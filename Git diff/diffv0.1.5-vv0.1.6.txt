diff --git a/CMakeLists.txt b/CMakeLists.txt
index d1ab1bf6..1c73a5ff 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -8,7 +8,7 @@ include(EthPolicy)
 eth_policy()
 
 # project name and version should be set after cmake_policy CMP0048
-set(PROJECT_VERSION "0.1.5")
+set(PROJECT_VERSION "0.1.6")
 project(solidity VERSION ${PROJECT_VERSION})
 
 # Let's find our dependencies
diff --git a/libsolidity/AST.cpp b/libsolidity/AST.cpp
index d55bc13c..062febb9 100644
--- a/libsolidity/AST.cpp
+++ b/libsolidity/AST.cpp
@@ -51,9 +51,9 @@ ASTAnnotation& ASTNode::annotation() const
 	return *m_annotation;
 }
 
-TypeError ASTNode::createTypeError(string const& _description) const
+Error ASTNode::createTypeError(string const& _description) const
 {
-	return TypeError() << errinfo_sourceLocation(location()) << errinfo_comment(_description);
+	return Error(Error::Type::TypeError) << errinfo_sourceLocation(location()) << errinfo_comment(_description);
 }
 
 map<FixedHash<4>, FunctionTypePointer> ContractDefinition::interfaceFunctions() const
@@ -115,29 +115,26 @@ vector<pair<FixedHash<4>, FunctionTypePointer>> const& ContractDefinition::inter
 		m_interfaceFunctionList.reset(new vector<pair<FixedHash<4>, FunctionTypePointer>>());
 		for (ContractDefinition const* contract: annotation().linearizedBaseContracts)
 		{
+			vector<FunctionTypePointer> functions;
 			for (ASTPointer<FunctionDefinition> const& f: contract->definedFunctions())
+				if (f->isPartOfExternalInterface())
+					functions.push_back(make_shared<FunctionType>(*f, false));
+			for (ASTPointer<VariableDeclaration> const& v: contract->stateVariables())
+				if (v->isPartOfExternalInterface())
+					functions.push_back(make_shared<FunctionType>(*v));
+			for (FunctionTypePointer const& fun: functions)
 			{
-				if (!f->isPartOfExternalInterface())
+				if (!fun->interfaceFunctionType())
+					// Fails hopefully because we already registered the error
 					continue;
-				string functionSignature = f->externalSignature();
+				string functionSignature = fun->externalSignature();
 				if (signaturesSeen.count(functionSignature) == 0)
 				{
-					functionsSeen.insert(f->name());
 					signaturesSeen.insert(functionSignature);
 					FixedHash<4> hash(dev::sha3(functionSignature));
-					m_interfaceFunctionList->push_back(make_pair(hash, make_shared<FunctionType>(*f, false)));
+					m_interfaceFunctionList->push_back(make_pair(hash, fun));
 				}
 			}
-
-			for (ASTPointer<VariableDeclaration> const& v: contract->stateVariables())
-				if (functionsSeen.count(v->name()) == 0 && v->isPartOfExternalInterface())
-				{
-					FunctionType ftype(*v);
-					solAssert(!!v->annotation().type.get(), "");
-					functionsSeen.insert(v->name());
-					FixedHash<4> hash(dev::sha3(ftype.externalSignature()));
-					m_interfaceFunctionList->push_back(make_pair(hash, make_shared<FunctionType>(*v)));
-				}
 		}
 	}
 	return *m_interfaceFunctionList;
@@ -325,6 +322,13 @@ ReturnAnnotation& Return::annotation() const
 	return static_cast<ReturnAnnotation&>(*m_annotation);
 }
 
+VariableDeclarationStatementAnnotation& VariableDeclarationStatement::annotation() const
+{
+	if (!m_annotation)
+		m_annotation = new VariableDeclarationStatementAnnotation();
+	return static_cast<VariableDeclarationStatementAnnotation&>(*m_annotation);
+}
+
 ExpressionAnnotation& Expression::annotation() const
 {
 	if (!m_annotation)
diff --git a/libsolidity/AST.h b/libsolidity/AST.h
index 075c1ff5..fc1db3f3 100644
--- a/libsolidity/AST.h
+++ b/libsolidity/AST.h
@@ -75,7 +75,7 @@ public:
 
 	/// Creates a @ref TypeError exception and decorates it with the location of the node and
 	/// the given description
-	TypeError createTypeError(std::string const& _description) const;
+	Error createTypeError(std::string const& _description) const;
 
 	///@todo make this const-safe by providing a different way to access the annotation
 	virtual ASTAnnotation& annotation() const;
@@ -558,7 +558,9 @@ protected:
 
 private:
 	ASTPointer<TypeName> m_typeName; ///< can be empty ("var")
-	ASTPointer<Expression> m_value; ///< the assigned value, can be missing
+	/// Initially assigned value, can be missing. For local variables, this is stored inside
+	/// VariableDeclarationStatement and not here.
+	ASTPointer<Expression> m_value;
 	bool m_isStateVariable; ///< Whether or not this is a contract state variable
 	bool m_isIndexed; ///< Whether this is an indexed variable (used by events).
 	bool m_isConstant; ///< Whether the variable is a compile-time constant.
@@ -658,10 +660,14 @@ class MagicVariableDeclaration: public Declaration
 public:
 	MagicVariableDeclaration(ASTString const& _name, std::shared_ptr<Type const> const& _type):
 		Declaration(SourceLocation(), std::make_shared<ASTString>(_name)), m_type(_type) {}
-	virtual void accept(ASTVisitor&) override { BOOST_THROW_EXCEPTION(InternalCompilerError()
-							<< errinfo_comment("MagicVariableDeclaration used inside real AST.")); }
-	virtual void accept(ASTConstVisitor&) const override { BOOST_THROW_EXCEPTION(InternalCompilerError()
-							<< errinfo_comment("MagicVariableDeclaration used inside real AST.")); }
+	virtual void accept(ASTVisitor&) override
+	{
+		BOOST_THROW_EXCEPTION(InternalCompilerError() << errinfo_comment("MagicVariableDeclaration used inside real AST."));
+	}
+	virtual void accept(ASTConstVisitor&) const override
+	{
+		BOOST_THROW_EXCEPTION(InternalCompilerError() << errinfo_comment("MagicVariableDeclaration used inside real AST."));
+	}
 
 	virtual TypePointer type(ContractDefinition const*) const override { return m_type; }
 
@@ -963,20 +969,33 @@ public:
  * Definition of a variable as a statement inside a function. It requires a type name (which can
  * also be "var") but the actual assignment can be missing.
  * Examples: var a = 2; uint256 a;
+ * As a second form, multiple variables can be declared, cannot have a type and must be assigned
+ * right away. If the first or last component is unnamed, it can "consume" an arbitrary number
+ * of components.
+ * Examples: var (a, b) = f(); var (a,,,c) = g(); var (a,) = d();
  */
 class VariableDeclarationStatement: public Statement
 {
 public:
-	VariableDeclarationStatement(SourceLocation const& _location, ASTPointer<VariableDeclaration> _variable):
-		Statement(_location), m_variable(_variable) {}
+	VariableDeclarationStatement(
+		SourceLocation const& _location,
+		std::vector<ASTPointer<VariableDeclaration>> const& _variables,
+		ASTPointer<Expression> const& _initialValue
+	):
+		Statement(_location), m_variables(_variables), m_initialValue(_initialValue) {}
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 
-	VariableDeclaration const& declaration() const { return *m_variable; }
-	Expression const* expression() const { return m_variable->value().get(); }
+	VariableDeclarationStatementAnnotation& annotation() const override;
+
+	std::vector<ASTPointer<VariableDeclaration>> const& declarations() const { return m_variables; }
+	Expression const* initialValue() const { return m_initialValue.get(); }
 
 private:
-	ASTPointer<VariableDeclaration> m_variable;
+	/// List of variables, some of which can be empty pointers (unnamed components).
+	std::vector<ASTPointer<VariableDeclaration>> m_variables;
+	/// The assigned expression / initial value.
+	ASTPointer<Expression> m_initialValue;
 };
 
 /**
@@ -1048,6 +1067,30 @@ private:
 	ASTPointer<Expression> m_rightHandSide;
 };
 
+/**
+ * Tuple or just parenthesized expression.
+ * Examples: (1, 2), (x,), (x), ()
+ * Individual components might be empty shared pointers (as in the second example).
+ * The respective types in lvalue context are: 2-tuple, 2-tuple (with wildcard), type of x, 0-tuple
+ * Not in lvalue context: 2-tuple, _1_-tuple, type of x, 0-tuple.
+ */
+class TupleExpression: public Expression
+{
+public:
+	TupleExpression(
+		SourceLocation const& _location,
+		std::vector<ASTPointer<Expression>> const& _components
+	):
+		Expression(_location), m_components(_components) {}
+	virtual void accept(ASTVisitor& _visitor) override;
+	virtual void accept(ASTConstVisitor& _visitor) const override;
+
+	std::vector<ASTPointer<Expression>> const& components() const { return m_components; }
+
+private:
+	std::vector<ASTPointer<Expression>> m_components;
+};
+
 /**
  * Operation involving a unary operator, pre- or postfix.
  * Examples: ++i, delete x or !true
diff --git a/libsolidity/ASTAnnotations.h b/libsolidity/ASTAnnotations.h
index be9b164c..1b772ffa 100644
--- a/libsolidity/ASTAnnotations.h
+++ b/libsolidity/ASTAnnotations.h
@@ -84,6 +84,13 @@ struct UserDefinedTypeNameAnnotation: TypeNameAnnotation
 	Declaration const* referencedDeclaration = nullptr;
 };
 
+struct VariableDeclarationStatementAnnotation: ASTAnnotation
+{
+	/// Information about which component of the value is assigned to which variable.
+	/// The pointer can be null to signify that the component is discarded.
+	std::vector<VariableDeclaration const*> assignments;
+};
+
 struct ExpressionAnnotation: ASTAnnotation
 {
 	/// Inferred type of the expression.
diff --git a/libsolidity/ASTForward.h b/libsolidity/ASTForward.h
index 396cf50a..02dd054a 100644
--- a/libsolidity/ASTForward.h
+++ b/libsolidity/ASTForward.h
@@ -69,6 +69,7 @@ class VariableDeclarationStatement;
 class ExpressionStatement;
 class Expression;
 class Assignment;
+class TupleExpression;
 class UnaryOperation;
 class BinaryOperation;
 class FunctionCall;
diff --git a/libsolidity/ASTJsonConverter.cpp b/libsolidity/ASTJsonConverter.cpp
index 4c14f2b2..34012c73 100644
--- a/libsolidity/ASTJsonConverter.cpp
+++ b/libsolidity/ASTJsonConverter.cpp
@@ -226,6 +226,12 @@ bool ASTJsonConverter::visit(Assignment const& _node)
 	return true;
 }
 
+bool ASTJsonConverter::visit(TupleExpression const&)
+{
+	addJsonNode("TupleExpression",{}, true);
+	return true;
+}
+
 bool ASTJsonConverter::visit(UnaryOperation const& _node)
 {
 	addJsonNode("UnaryOperation",
@@ -396,6 +402,11 @@ void ASTJsonConverter::endVisit(Assignment const&)
 	goUp();
 }
 
+void ASTJsonConverter::endVisit(TupleExpression const&)
+{
+	goUp();
+}
+
 void ASTJsonConverter::endVisit(UnaryOperation const&)
 {
 	goUp();
diff --git a/libsolidity/ASTJsonConverter.h b/libsolidity/ASTJsonConverter.h
index 61f87860..a62259e2 100644
--- a/libsolidity/ASTJsonConverter.h
+++ b/libsolidity/ASTJsonConverter.h
@@ -68,6 +68,7 @@ public:
 	bool visit(VariableDeclarationStatement const& _node) override;
 	bool visit(ExpressionStatement const& _node) override;
 	bool visit(Assignment const& _node) override;
+	bool visit(TupleExpression const& _node) override;
 	bool visit(UnaryOperation const& _node) override;
 	bool visit(BinaryOperation const& _node) override;
 	bool visit(FunctionCall const& _node) override;
@@ -99,6 +100,7 @@ public:
 	void endVisit(VariableDeclarationStatement const&) override;
 	void endVisit(ExpressionStatement const&) override;
 	void endVisit(Assignment const&) override;
+	void endVisit(TupleExpression const&) override;
 	void endVisit(UnaryOperation const&) override;
 	void endVisit(BinaryOperation const&) override;
 	void endVisit(FunctionCall const&) override;
diff --git a/libsolidity/ASTPrinter.cpp b/libsolidity/ASTPrinter.cpp
index 534f7c78..cb231842 100644
--- a/libsolidity/ASTPrinter.cpp
+++ b/libsolidity/ASTPrinter.cpp
@@ -256,6 +256,14 @@ bool ASTPrinter::visit(Assignment const& _node)
 	return goDeeper();
 }
 
+bool ASTPrinter::visit(TupleExpression const& _node)
+{
+	writeLine(string("TupleExpression"));
+	printType(_node);
+	printSourcePart(_node);
+	return goDeeper();
+}
+
 bool ASTPrinter::visit(UnaryOperation const& _node)
 {
 	writeLine(string("UnaryOperation (") + (_node.isPrefixOperation() ? "prefix" : "postfix") +
@@ -477,6 +485,11 @@ void ASTPrinter::endVisit(Assignment const&)
 	m_indentation--;
 }
 
+void ASTPrinter::endVisit(TupleExpression const&)
+{
+	m_indentation--;
+}
+
 void ASTPrinter::endVisit(UnaryOperation const&)
 {
 	m_indentation--;
diff --git a/libsolidity/ASTPrinter.h b/libsolidity/ASTPrinter.h
index a12ec0aa..95656436 100644
--- a/libsolidity/ASTPrinter.h
+++ b/libsolidity/ASTPrinter.h
@@ -76,6 +76,7 @@ public:
 	bool visit(VariableDeclarationStatement const& _node) override;
 	bool visit(ExpressionStatement const& _node) override;
 	bool visit(Assignment const& _node) override;
+	bool visit(TupleExpression const& _node) override;
 	bool visit(UnaryOperation const& _node) override;
 	bool visit(BinaryOperation const& _node) override;
 	bool visit(FunctionCall const& _node) override;
@@ -115,6 +116,7 @@ public:
 	void endVisit(VariableDeclarationStatement const&) override;
 	void endVisit(ExpressionStatement const&) override;
 	void endVisit(Assignment const&) override;
+	void endVisit(TupleExpression const&) override;
 	void endVisit(UnaryOperation const&) override;
 	void endVisit(BinaryOperation const&) override;
 	void endVisit(FunctionCall const&) override;
diff --git a/libsolidity/ASTVisitor.h b/libsolidity/ASTVisitor.h
index e665396c..3e50fb28 100644
--- a/libsolidity/ASTVisitor.h
+++ b/libsolidity/ASTVisitor.h
@@ -73,6 +73,7 @@ public:
 	virtual bool visit(VariableDeclarationStatement& _node) { return visitNode(_node); }
 	virtual bool visit(ExpressionStatement& _node) { return visitNode(_node); }
 	virtual bool visit(Assignment& _node) { return visitNode(_node); }
+	virtual bool visit(TupleExpression& _node) { return visitNode(_node); }
 	virtual bool visit(UnaryOperation& _node) { return visitNode(_node); }
 	virtual bool visit(BinaryOperation& _node) { return visitNode(_node); }
 	virtual bool visit(FunctionCall& _node) { return visitNode(_node); }
@@ -113,6 +114,7 @@ public:
 	virtual void endVisit(VariableDeclarationStatement& _node) { endVisitNode(_node); }
 	virtual void endVisit(ExpressionStatement& _node) { endVisitNode(_node); }
 	virtual void endVisit(Assignment& _node) { endVisitNode(_node); }
+	virtual void endVisit(TupleExpression& _node) { endVisitNode(_node); }
 	virtual void endVisit(UnaryOperation& _node) { endVisitNode(_node); }
 	virtual void endVisit(BinaryOperation& _node) { endVisitNode(_node); }
 	virtual void endVisit(FunctionCall& _node) { endVisitNode(_node); }
@@ -165,6 +167,7 @@ public:
 	virtual bool visit(VariableDeclarationStatement const& _node) { return visitNode(_node); }
 	virtual bool visit(ExpressionStatement const& _node) { return visitNode(_node); }
 	virtual bool visit(Assignment const& _node) { return visitNode(_node); }
+	virtual bool visit(TupleExpression const& _node) { return visitNode(_node); }
 	virtual bool visit(UnaryOperation const& _node) { return visitNode(_node); }
 	virtual bool visit(BinaryOperation const& _node) { return visitNode(_node); }
 	virtual bool visit(FunctionCall const& _node) { return visitNode(_node); }
@@ -205,6 +208,7 @@ public:
 	virtual void endVisit(VariableDeclarationStatement const& _node) { endVisitNode(_node); }
 	virtual void endVisit(ExpressionStatement const& _node) { endVisitNode(_node); }
 	virtual void endVisit(Assignment const& _node) { endVisitNode(_node); }
+	virtual void endVisit(TupleExpression const& _node) { endVisitNode(_node); }
 	virtual void endVisit(UnaryOperation const& _node) { endVisitNode(_node); }
 	virtual void endVisit(BinaryOperation const& _node) { endVisitNode(_node); }
 	virtual void endVisit(FunctionCall const& _node) { endVisitNode(_node); }
diff --git a/libsolidity/AST_accept.h b/libsolidity/AST_accept.h
index dfa9c425..eb1f6098 100644
--- a/libsolidity/AST_accept.h
+++ b/libsolidity/AST_accept.h
@@ -516,14 +516,26 @@ void ExpressionStatement::accept(ASTConstVisitor& _visitor) const
 void VariableDeclarationStatement::accept(ASTVisitor& _visitor)
 {
 	if (_visitor.visit(*this))
-		m_variable->accept(_visitor);
+	{
+		for (ASTPointer<VariableDeclaration> const& var: m_variables)
+			if (var)
+				var->accept(_visitor);
+		if (m_initialValue)
+			m_initialValue->accept(_visitor);
+	}
 	_visitor.endVisit(*this);
 }
 
 void VariableDeclarationStatement::accept(ASTConstVisitor& _visitor) const
 {
 	if (_visitor.visit(*this))
-		m_variable->accept(_visitor);
+	{
+		for (ASTPointer<VariableDeclaration> const& var: m_variables)
+			if (var)
+				var->accept(_visitor);
+		if (m_initialValue)
+			m_initialValue->accept(_visitor);
+	}
 	_visitor.endVisit(*this);
 }
 
@@ -547,6 +559,24 @@ void Assignment::accept(ASTConstVisitor& _visitor) const
 	_visitor.endVisit(*this);
 }
 
+void TupleExpression::accept(ASTVisitor& _visitor)
+{
+	if (_visitor.visit(*this))
+		for (auto const& component: m_components)
+			if (component)
+				component->accept(_visitor);
+	_visitor.endVisit(*this);
+}
+
+void TupleExpression::accept(ASTConstVisitor& _visitor) const
+{
+	if (_visitor.visit(*this))
+		for (auto const& component: m_components)
+			if (component)
+				component->accept(_visitor);
+	_visitor.endVisit(*this);
+}
+
 void UnaryOperation::accept(ASTVisitor& _visitor)
 {
 	if (_visitor.visit(*this))
diff --git a/libsolidity/Compiler.cpp b/libsolidity/Compiler.cpp
index 7ce2121e..679704ba 100644
--- a/libsolidity/Compiler.cpp
+++ b/libsolidity/Compiler.cpp
@@ -597,13 +597,20 @@ bool Compiler::visit(Break const& _breakStatement)
 bool Compiler::visit(Return const& _return)
 {
 	CompilerContext::LocationSetter locationSetter(m_context, _return);
-	//@todo modifications are needed to make this work with functions returning multiple values
 	if (Expression const* expression = _return.expression())
 	{
 		solAssert(_return.annotation().functionReturnParameters, "Invalid return parameters pointer.");
-		VariableDeclaration const& firstVariable = *_return.annotation().functionReturnParameters->parameters().front();
-		compileExpression(*expression, firstVariable.annotation().type);
-		CompilerUtils(m_context).moveToStackVariable(firstVariable);
+		vector<ASTPointer<VariableDeclaration>> const& returnParameters =
+			_return.annotation().functionReturnParameters->parameters();
+		TypePointers types;
+		for (auto const& retVariable: returnParameters)
+			types.push_back(retVariable->annotation().type);
+
+		TypePointer expectedType = types.size() == 1 ? types.front() : make_shared<TupleType>(types);
+		compileExpression(*expression, expectedType);
+
+		for (auto const& retVariable: boost::adaptors::reverse(returnParameters))
+			CompilerUtils(m_context).moveToStackVariable(*retVariable);
 	}
 	for (unsigned i = 0; i < m_stackCleanupForReturn; ++i)
 		m_context << eth::Instruction::POP;
@@ -623,10 +630,30 @@ bool Compiler::visit(VariableDeclarationStatement const& _variableDeclarationSta
 {
 	StackHeightChecker checker(m_context);
 	CompilerContext::LocationSetter locationSetter(m_context, _variableDeclarationStatement);
-	if (Expression const* expression = _variableDeclarationStatement.expression())
+	if (Expression const* expression = _variableDeclarationStatement.initialValue())
 	{
-		compileExpression(*expression, _variableDeclarationStatement.declaration().annotation().type);
-		CompilerUtils(m_context).moveToStackVariable(_variableDeclarationStatement.declaration());
+		CompilerUtils utils(m_context);
+		compileExpression(*expression);
+		TypePointers valueTypes;
+		if (auto tupleType = dynamic_cast<TupleType const*>(expression->annotation().type.get()))
+			valueTypes = tupleType->components();
+		else
+			valueTypes = TypePointers{expression->annotation().type};
+		auto const& assignments = _variableDeclarationStatement.annotation().assignments;
+		solAssert(assignments.size() == valueTypes.size(), "");
+		for (size_t i = 0; i < assignments.size(); ++i)
+		{
+			size_t j = assignments.size() - i - 1;
+			solAssert(!!valueTypes[j], "");
+			VariableDeclaration const* varDecl = assignments[j];
+			if (!varDecl)
+				utils.popStackElement(*valueTypes[j]);
+			else
+			{
+				utils.convertType(*valueTypes[j], *varDecl->annotation().type);
+				utils.moveToStackVariable(*varDecl);
+			}
+		}
 	}
 	checker.check();
 	return false;
diff --git a/libsolidity/CompilerContext.cpp b/libsolidity/CompilerContext.cpp
index fa7f9c77..0ba7af5b 100644
--- a/libsolidity/CompilerContext.cpp
+++ b/libsolidity/CompilerContext.cpp
@@ -137,7 +137,7 @@ ModifierDefinition const& CompilerContext::functionModifier(string const& _name)
 			if (modifier->name() == _name)
 				return *modifier.get();
 	BOOST_THROW_EXCEPTION(InternalCompilerError()
-						  << errinfo_comment("Function modifier " + _name + " not found."));
+		<< errinfo_comment("Function modifier " + _name + " not found."));
 }
 
 unsigned CompilerContext::baseStackOffsetOfVariable(Declaration const& _declaration) const
diff --git a/libsolidity/CompilerStack.cpp b/libsolidity/CompilerStack.cpp
index 8c1cd8cf..03120f66 100644
--- a/libsolidity/CompilerStack.cpp
+++ b/libsolidity/CompilerStack.cpp
@@ -97,27 +97,37 @@ void CompilerStack::setSource(string const& _sourceCode)
 
 bool CompilerStack::parse()
 {
+	//reset
 	m_errors.clear();
+	m_parseSuccessful = false;
 
 	for (auto& sourcePair: m_sources)
 	{
 		sourcePair.second.scanner->reset();
-		sourcePair.second.ast = Parser().parse(sourcePair.second.scanner);
+		sourcePair.second.ast = Parser(m_errors).parse(sourcePair.second.scanner);
+		if (!sourcePair.second.ast)
+			solAssert(!Error::containsOnlyWarnings(m_errors), "Parser returned null but did not report error.");
 	}
+	if (!Error::containsOnlyWarnings(m_errors))
+		// errors while parsing. sould stop before type checking
+		return false;
+
 	resolveImports();
 
 	m_globalContext = make_shared<GlobalContext>();
-	NameAndTypeResolver resolver(m_globalContext->declarations());
+	NameAndTypeResolver resolver(m_globalContext->declarations(), m_errors);
 	for (Source const* source: m_sourceOrder)
-		resolver.registerDeclarations(*source->ast);
+		if (!resolver.registerDeclarations(*source->ast))
+			return false;
+
 	for (Source const* source: m_sourceOrder)
 		for (ASTPointer<ASTNode> const& node: source->ast->nodes())
 			if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
 			{
 				m_globalContext->setCurrentContract(*contract);
-				resolver.updateDeclaration(*m_globalContext->currentThis());
-				resolver.updateDeclaration(*m_globalContext->currentSuper());
-				resolver.resolveNamesAndTypes(*contract);
+				if (!resolver.updateDeclaration(*m_globalContext->currentThis())) return false;
+				if (!resolver.updateDeclaration(*m_globalContext->currentSuper())) return false;
+				if (!resolver.resolveNamesAndTypes(*contract)) return false;
 				m_contracts[contract->name()].contract = contract;
 			}
 
@@ -129,7 +139,7 @@ bool CompilerStack::parse()
 			{
 				m_globalContext->setCurrentContract(*contract);
 				resolver.updateDeclaration(*m_globalContext->currentThis());
-				TypeChecker typeChecker;
+				TypeChecker typeChecker(m_errors);
 				if (typeChecker.checkTypeRequirements(*contract))
 				{
 					contract->setDevDocumentation(interfaceHandler.devDocumentation(*contract));
@@ -137,8 +147,8 @@ bool CompilerStack::parse()
 				}
 				else
 					typesFine = false;
+
 				m_contracts[contract->name()].contract = contract;
-				m_errors += typeChecker.errors();
 			}
 	m_parseSuccessful = typesFine;
 	return m_parseSuccessful;
@@ -253,9 +263,8 @@ string const& CompilerStack::metadata(string const& _contractName, Documentation
 	if (!m_parseSuccessful)
 		BOOST_THROW_EXCEPTION(CompilerError() << errinfo_comment("Parsing was not successful."));
 
-	Contract const& currentContract = contract(_contractName);
-
 	std::unique_ptr<string const>* doc;
+	Contract const& currentContract = contract(_contractName);
 
 	// checks wheather we already have the documentation
 	switch (_type)
@@ -345,10 +354,11 @@ void CompilerStack::resolveImports()
 				string const& id = import->identifier();
 				if (!m_sources.count(id))
 					BOOST_THROW_EXCEPTION(
-						ParserError()
-							  << errinfo_sourceLocation(import->location())
-							  << errinfo_comment("Source not found.")
+						Error(Error::Type::ParserError)
+							<< errinfo_sourceLocation(import->location())
+							<< errinfo_comment("Source not found.")
 					);
+
 				toposort(&m_sources[id]);
 			}
 		sourceOrder.push_back(_source);
@@ -414,10 +424,12 @@ CompilerStack::Source const& CompilerStack::source(string const& _sourceName) co
 	auto it = m_sources.find(_sourceName);
 	if (it == m_sources.end())
 		BOOST_THROW_EXCEPTION(CompilerError() << errinfo_comment("Given source file not found."));
+
 	return it->second;
 }
 
 CompilerStack::Contract::Contract(): interfaceHandler(make_shared<InterfaceHandler>()) {}
 
+
 }
 }
diff --git a/libsolidity/CompilerStack.h b/libsolidity/CompilerStack.h
index da26148d..de548bee 100644
--- a/libsolidity/CompilerStack.h
+++ b/libsolidity/CompilerStack.h
@@ -33,6 +33,7 @@
 #include <libdevcore/FixedHash.h>
 #include <libevmasm/SourceLocation.h>
 #include <libevmasm/LinkerObject.h>
+#include <libsolidity/Exceptions.h>
 
 namespace dev
 {
@@ -55,7 +56,7 @@ class SourceUnit;
 class Compiler;
 class GlobalContext;
 class InterfaceHandler;
-struct Error;
+class Error;
 
 enum class DocumentationType: uint8_t
 {
@@ -164,7 +165,8 @@ public:
 	std::tuple<int, int, int, int> positionFromSourceLocation(SourceLocation const& _sourceLocation) const;
 
 	/// @returns the list of errors that occured during parsing and type checking.
-	std::vector<std::shared_ptr<Error const>> const& errors() const { return m_errors; }
+	ErrorList const& errors() const { return m_errors; }
+
 
 private:
 	/**
@@ -212,7 +214,7 @@ private:
 	std::shared_ptr<GlobalContext> m_globalContext;
 	std::vector<Source const*> m_sourceOrder;
 	std::map<std::string const, Contract> m_contracts;
-	std::vector<std::shared_ptr<Error const>> m_errors;
+	ErrorList m_errors;
 };
 
 }
diff --git a/libsolidity/CompilerUtils.cpp b/libsolidity/CompilerUtils.cpp
index e1152202..f0dea708 100644
--- a/libsolidity/CompilerUtils.cpp
+++ b/libsolidity/CompilerUtils.cpp
@@ -550,6 +550,61 @@ void CompilerUtils::convertType(Type const& _typeOnStack, Type const& _targetTyp
 		}
 		break;
 	}
+	case Type::Category::Tuple:
+	{
+		TupleType const& sourceTuple = dynamic_cast<TupleType const&>(_typeOnStack);
+		TupleType const& targetTuple = dynamic_cast<TupleType const&>(_targetType);
+		// fillRight: remove excess values at right side, !fillRight: remove eccess values at left side
+		bool fillRight = !targetTuple.components().empty() && (
+			!targetTuple.components().back() ||
+			targetTuple.components().front()
+		);
+		unsigned depth = sourceTuple.sizeOnStack();
+		for (size_t i = 0; i < sourceTuple.components().size(); ++i)
+		{
+			TypePointer sourceType = sourceTuple.components()[i];
+			TypePointer targetType;
+			if (fillRight && i < targetTuple.components().size())
+				targetType = targetTuple.components()[i];
+			else if (!fillRight && targetTuple.components().size() + i >= sourceTuple.components().size())
+				targetType = targetTuple.components()[targetTuple.components().size() - (sourceTuple.components().size() - i)];
+			if (!sourceType)
+			{
+				solAssert(!targetType, "");
+				continue;
+			}
+			unsigned sourceSize = sourceType->sizeOnStack();
+			unsigned targetSize = targetType ? targetType->sizeOnStack() : 0;
+			if (!targetType || *sourceType != *targetType || _cleanupNeeded)
+			{
+				if (targetType)
+				{
+					if (sourceSize > 0)
+						copyToStackTop(depth, sourceSize);
+					convertType(*sourceType, *targetType, _cleanupNeeded);
+				}
+				if (sourceSize > 0 || targetSize > 0)
+				{
+					// Move it back into its place.
+					for (unsigned j = 0; j < min(sourceSize, targetSize); ++j)
+						m_context <<
+							eth::swapInstruction(depth + targetSize - sourceSize) <<
+							eth::Instruction::POP;
+					// Value shrank
+					for (unsigned j = targetSize; j < sourceSize; ++j)
+					{
+						moveToStackTop(depth - 1, 1);
+						m_context << eth::Instruction::POP;
+					}
+					// Value grew
+					if (targetSize > sourceSize)
+						moveIntoStack(depth + targetSize - sourceSize, targetSize - sourceSize);
+				}
+			}
+			depth -= sourceSize;
+		}
+		break;
+	}
 	default:
 		// All other types should not be convertible to non-equal types.
 		solAssert(_typeOnStack == _targetType, "Invalid type conversion requested.");
@@ -631,18 +686,20 @@ void CompilerUtils::copyToStackTop(unsigned _stackDepth, unsigned _itemSize)
 		m_context << eth::dupInstruction(_stackDepth);
 }
 
-void CompilerUtils::moveToStackTop(unsigned _stackDepth)
+void CompilerUtils::moveToStackTop(unsigned _stackDepth, unsigned _itemSize)
 {
 	solAssert(_stackDepth <= 15, "Stack too deep, try removing local variables.");
-	for (unsigned i = 0; i < _stackDepth; ++i)
-		m_context << eth::swapInstruction(1 + i);
+	for (unsigned j = 0; j < _itemSize; ++j)
+		for (unsigned i = 0; i < _stackDepth + _itemSize - 1; ++i)
+			m_context << eth::swapInstruction(1 + i);
 }
 
-void CompilerUtils::moveIntoStack(unsigned _stackDepth)
+void CompilerUtils::moveIntoStack(unsigned _stackDepth, unsigned _itemSize)
 {
 	solAssert(_stackDepth <= 16, "Stack too deep, try removing local variables.");
-	for (unsigned i = _stackDepth; i > 0; --i)
-		m_context << eth::swapInstruction(i);
+	for (unsigned j = 0; j < _itemSize; ++j)
+		for (unsigned i = _stackDepth; i > 0; --i)
+			m_context << eth::swapInstruction(i + _itemSize - 1);
 }
 
 void CompilerUtils::popStackElement(Type const& _type)
diff --git a/libsolidity/CompilerUtils.h b/libsolidity/CompilerUtils.h
index f335eed5..01b9f422 100644
--- a/libsolidity/CompilerUtils.h
+++ b/libsolidity/CompilerUtils.h
@@ -124,10 +124,11 @@ public:
 	/// Copies an item that occupies @a _itemSize stack slots from a stack depth of @a _stackDepth
 	/// to the top of the stack.
 	void copyToStackTop(unsigned _stackDepth, unsigned _itemSize);
-	/// Moves a single stack element (with _stackDepth items on top of it) to the top of the stack.
-	void moveToStackTop(unsigned _stackDepth);
-	/// Moves a single stack element past @a _stackDepth other stack elements
-	void moveIntoStack(unsigned _stackDepth);
+	/// Moves an item that occupies @a _itemSize stack slots and has items occupying @a _stackDepth
+	/// slots above it to the top of the stack.
+	void moveToStackTop(unsigned _stackDepth, unsigned _itemSize = 1);
+	/// Moves @a _itemSize elements past @a _stackDepth other stack elements
+	void moveIntoStack(unsigned _stackDepth, unsigned _itemSize = 1);
 	/// Removes the current value from the top of the stack.
 	void popStackElement(Type const& _type);
 	/// Removes element from the top of the stack _amount times.
diff --git a/libsolidity/Exceptions.cpp b/libsolidity/Exceptions.cpp
new file mode 100644
index 00000000..96bb2e37
--- /dev/null
+++ b/libsolidity/Exceptions.cpp
@@ -0,0 +1,52 @@
+/*
+	This file is part of cpp-ethereum.
+
+	cpp-ethereum is free software: you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
+
+	cpp-ethereum is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.
+*/
+/**
+ * @author Liana <liana@ethdev.com>
+ * @date 2015
+ * Solidity exception hierarchy.
+ */
+
+#include <libsolidity/Exceptions.h>
+#include <libsolidity/Utils.h>
+
+using namespace dev;
+using namespace dev::solidity;
+
+Error::Error(Type _type): m_type(_type)
+{
+	switch(m_type)
+	{
+		case Type::DeclarationError:
+			m_typeName = "Declaration Error";
+			break;
+		case Type::DocstringParsingError:
+			m_typeName = "Docstring Parsing Error";
+			break;
+		case Type::ParserError:
+			m_typeName = "Parser Error";
+			break;
+		case Type::TypeError:
+			m_typeName = "Type Error";
+			break;
+		case Type::Warning:
+			m_typeName = "Warning";
+			break;
+		default:
+			solAssert(false, "");
+			break;
+	}
+}
diff --git a/libsolidity/Exceptions.h b/libsolidity/Exceptions.h
index 8ab33999..cda6b97e 100644
--- a/libsolidity/Exceptions.h
+++ b/libsolidity/Exceptions.h
@@ -31,18 +31,55 @@ namespace dev
 {
 namespace solidity
 {
-struct Error: virtual Exception {};
-
-struct ParserError: virtual Error {};
-struct TypeError: virtual Error {};
-struct DeclarationError: virtual Error {};
-struct DocstringParsingError: virtual Error {};
-struct Warning: virtual Error {};
+class Error;
+using ErrorList = std::vector<std::shared_ptr<Error const>>;
 
 struct CompilerError: virtual Exception {};
 struct InternalCompilerError: virtual Exception {};
 struct FatalError: virtual Exception {};
 
+class Error: virtual public Exception
+{
+public:
+	enum class Type
+	{
+		DeclarationError,
+		DocstringParsingError,
+		ParserError,
+		TypeError,
+		Warning
+	};
+
+	explicit Error(Type _type);
+
+	Type type() const { return m_type; }
+	std::string const& typeName() const { return m_typeName; }
+
+	/// helper functions
+	static Error const* containsErrorOfType(ErrorList const& _list, Error::Type _type)
+	{
+		for (auto e: _list)
+		{
+			if (e->type() == _type)
+				return e.get();
+		}
+		return nullptr;
+	}
+	static bool containsOnlyWarnings(ErrorList const& _list)
+	{
+		for (auto e: _list)
+		{
+			if (e->type() != Type::Warning)
+				return false;
+		}
+		return true;
+	}
+private:
+	Type m_type;
+	std::string m_typeName;
+};
+
+
 using errorSourceLocationInfo = std::pair<std::string, SourceLocation>;
 
 class SecondarySourceLocation
@@ -56,6 +93,7 @@ public:
 	std::vector<errorSourceLocationInfo> infos;
 };
 
+
 using errinfo_sourceLocation = boost::error_info<struct tag_sourceLocation, SourceLocation>;
 using errinfo_secondarySourceLocation = boost::error_info<struct tag_secondarySourceLocation, SecondarySourceLocation>;
 
diff --git a/libsolidity/ExpressionCompiler.cpp b/libsolidity/ExpressionCompiler.cpp
index c11ef29e..112521f9 100644
--- a/libsolidity/ExpressionCompiler.cpp
+++ b/libsolidity/ExpressionCompiler.cpp
@@ -179,17 +179,12 @@ bool ExpressionCompiler::visit(Assignment const& _assignment)
 {
 	CompilerContext::LocationSetter locationSetter(m_context, _assignment);
 	_assignment.rightHandSide().accept(*this);
-	TypePointer type = _assignment.rightHandSide().annotation().type;
-	if (!_assignment.annotation().type->dataStoredIn(DataLocation::Storage))
-	{
-		utils().convertType(*type, *_assignment.annotation().type);
-		type = _assignment.annotation().type;
-	}
-	else
-	{
-		utils().convertType(*type, *type->mobileType());
-		type = type->mobileType();
-	}
+	// Perform some conversion already. This will convert storage types to memory and literals
+	// to their actual type, but will not convert e.g. memory to storage.
+	TypePointer type = _assignment.rightHandSide().annotation().type->closestTemporaryType(
+		_assignment.leftHandSide().annotation().type
+	);
+	utils().convertType(*_assignment.rightHandSide().annotation().type, *type);
 
 	_assignment.leftHandSide().accept(*this);
 	solAssert(!!m_currentLValue, "LValue not retrieved.");
@@ -221,6 +216,26 @@ bool ExpressionCompiler::visit(Assignment const& _assignment)
 	return false;
 }
 
+bool ExpressionCompiler::visit(TupleExpression const& _tuple)
+{
+	vector<unique_ptr<LValue>> lvalues;
+	for (auto const& component: _tuple.components())
+		if (component)
+		{
+			component->accept(*this);
+			if (_tuple.annotation().lValueRequested)
+			{
+				solAssert(!!m_currentLValue, "");
+				lvalues.push_back(move(m_currentLValue));
+			}
+		}
+		else if (_tuple.annotation().lValueRequested)
+			lvalues.push_back(unique_ptr<LValue>());
+	if (_tuple.annotation().lValueRequested)
+		m_currentLValue.reset(new TupleObject(m_context, move(lvalues)));
+	return false;
+}
+
 bool ExpressionCompiler::visit(UnaryOperation const& _unaryOperation)
 {
 	CompilerContext::LocationSetter locationSetter(m_context, _unaryOperation);
@@ -427,11 +442,6 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 			unsigned returnParametersSize = CompilerUtils::sizeOnStack(function.returnParameterTypes());
 			// callee adds return parameters, but removes arguments and return label
 			m_context.adjustStackOffset(returnParametersSize - CompilerUtils::sizeOnStack(function.parameterTypes()) - 1);
-
-			// @todo for now, the return value of a function is its first return value, so remove
-			// all others
-			for (unsigned i = 1; i < function.returnParameterTypes().size(); ++i)
-				utils().popStackElement(*function.returnParameterTypes()[i]);
 			break;
 		}
 		case Location::External:
@@ -628,6 +638,43 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 			appendExternalFunctionCall(function, arguments);
 			break;
 		}
+		case Location::ByteArrayPush:
+		case Location::ArrayPush:
+		{
+			_functionCall.expression().accept(*this);
+			solAssert(function.parameterTypes().size() == 1, "");
+			solAssert(!!function.parameterTypes()[0], "");
+			TypePointer const& paramType = function.parameterTypes()[0];
+			shared_ptr<ArrayType> arrayType =
+				function.location() == Location::ArrayPush ?
+				make_shared<ArrayType>(DataLocation::Storage, paramType) :
+				make_shared<ArrayType>(DataLocation::Storage);
+			// get the current length
+			ArrayUtils(m_context).retrieveLength(*arrayType);
+			m_context << eth::Instruction::DUP1;
+			// stack: ArrayReference currentLength currentLength
+			m_context << u256(1) << eth::Instruction::ADD;
+			// stack: ArrayReference currentLength newLength
+			m_context << eth::Instruction::DUP3 << eth::Instruction::DUP2;
+			ArrayUtils(m_context).resizeDynamicArray(*arrayType);
+			m_context << eth::Instruction::SWAP2 << eth::Instruction::SWAP1;
+			// stack: newLength ArrayReference oldLength
+			ArrayUtils(m_context).accessIndex(*arrayType, false);
+
+			// stack: newLength storageSlot slotOffset
+			arguments[0]->accept(*this);
+			// stack: newLength storageSlot slotOffset argValue
+			TypePointer type = arguments[0]->annotation().type->closestTemporaryType(arrayType->baseType());
+			utils().convertType(*arguments[0]->annotation().type, *type);
+			utils().moveToStackTop(1 + type->sizeOnStack());
+			utils().moveToStackTop(1 + type->sizeOnStack());
+			// stack: newLength argValue storageSlot slotOffset
+			if (function.location() == Location::ArrayPush)
+				StorageItem(m_context, *paramType).storeValue(*type, _functionCall.location(), true);
+			else
+				StorageByteArrayElement(m_context).storeValue(*type, _functionCall.location(), true);
+			break;
+		}
 		default:
 			BOOST_THROW_EXCEPTION(InternalCompilerError() << errinfo_comment("Invalid function type."));
 		}
@@ -789,26 +836,37 @@ void ExpressionCompiler::endVisit(MemberAccess const& _memberAccess)
 	}
 	case Type::Category::Array:
 	{
-		solAssert(member == "length", "Illegal array member.");
 		auto const& type = dynamic_cast<ArrayType const&>(*_memberAccess.expression().annotation().type);
-		if (!type.isDynamicallySized())
+		if (member == "length")
 		{
-			utils().popStackElement(type);
-			m_context << type.length();
-		}
-		else
-			switch (type.location())
+			if (!type.isDynamicallySized())
 			{
-			case DataLocation::CallData:
-				m_context << eth::Instruction::SWAP1 << eth::Instruction::POP;
-				break;
-			case DataLocation::Storage:
-				setLValue<StorageArrayLength>(_memberAccess, type);
-				break;
-			case DataLocation::Memory:
-				m_context << eth::Instruction::MLOAD;
-				break;
+				utils().popStackElement(type);
+				m_context << type.length();
 			}
+			else
+				switch (type.location())
+				{
+				case DataLocation::CallData:
+					m_context << eth::Instruction::SWAP1 << eth::Instruction::POP;
+					break;
+				case DataLocation::Storage:
+					setLValue<StorageArrayLength>(_memberAccess, type);
+					break;
+				case DataLocation::Memory:
+					m_context << eth::Instruction::MLOAD;
+					break;
+				}
+		}
+		else if (member == "push")
+		{
+			solAssert(
+				type.isDynamicallySized() && type.location() == DataLocation::Storage,
+				"Tried to use .push() on a non-dynamically sized array"
+			);
+		}
+		else
+			solAssert(false, "Illegal array member.");
 		break;
 	}
 	default:
@@ -892,6 +950,12 @@ bool ExpressionCompiler::visit(IndexAccess const& _indexAccess)
 			break;
 		}
 	}
+	else if (baseType.category() == Type::Category::TypeType)
+	{
+		solAssert(baseType.sizeOnStack() == 0, "");
+		solAssert(_indexAccess.annotation().type->sizeOnStack() == 0, "");
+		// no-op - this seems to be a lone array type (`structType[];`)
+	}
 	else
 		solAssert(false, "Index access only allowed for mappings or arrays.");
 
@@ -945,6 +1009,10 @@ void ExpressionCompiler::endVisit(Identifier const& _identifier)
 	{
 		// no-op
 	}
+	else if (dynamic_cast<StructDefinition const*>(declaration))
+	{
+		// no-op
+	}
 	else
 	{
 		BOOST_THROW_EXCEPTION(InternalCompilerError() << errinfo_comment("Identifier type not expected in expression context."));
@@ -1123,19 +1191,15 @@ void ExpressionCompiler::appendExternalFunctionCall(
 	bool returnSuccessCondition = funKind == FunctionKind::Bare || funKind == FunctionKind::BareCallCode;
 	bool isCallCode = funKind == FunctionKind::BareCallCode || funKind == FunctionKind::CallCode;
 
-	//@todo only return the first return value for now
-	Type const* firstReturnType =
-		_functionType.returnParameterTypes().empty() ?
-		nullptr :
-		_functionType.returnParameterTypes().front().get();
 	unsigned retSize = 0;
 	if (returnSuccessCondition)
 		retSize = 0; // return value actually is success condition
-	else if (firstReturnType)
-	{
-		retSize = firstReturnType->calldataEncodedSize();
-		solAssert(retSize > 0, "Unable to return dynamic type from external call.");
-	}
+	else
+		for (auto const& retType: _functionType.returnParameterTypes())
+		{
+			solAssert(retType->calldataEncodedSize() > 0, "Unable to return dynamic type from external call.");
+			retSize += retType->calldataEncodedSize();
+		}
 
 	// Evaluate arguments.
 	TypePointers argumentTypes;
@@ -1255,16 +1319,20 @@ void ExpressionCompiler::appendExternalFunctionCall(
 		utils().loadFromMemoryDynamic(IntegerType(160), false, true, false);
 		utils().convertType(IntegerType(160), FixedBytesType(20));
 	}
-	else if (firstReturnType)
+	else if (!_functionType.returnParameterTypes().empty())
 	{
 		utils().fetchFreeMemoryPointer();
-		if (dynamic_cast<ReferenceType const*>(firstReturnType))
+		bool memoryNeeded = false;
+		for (auto const& retType: _functionType.returnParameterTypes())
 		{
-			utils().loadFromMemoryDynamic(*firstReturnType, false, true, true);
-			utils().storeFreeMemoryPointer();
+			utils().loadFromMemoryDynamic(*retType, false, true, true);
+			if (dynamic_cast<ReferenceType const*>(retType.get()))
+				memoryNeeded = true;
 		}
+		if (memoryNeeded)
+			utils().storeFreeMemoryPointer();
 		else
-			utils().loadFromMemoryDynamic(*firstReturnType, false, true, false);
+			m_context << eth::Instruction::POP;
 	}
 }
 
diff --git a/libsolidity/ExpressionCompiler.h b/libsolidity/ExpressionCompiler.h
index d8fef5af..44d27ea2 100644
--- a/libsolidity/ExpressionCompiler.h
+++ b/libsolidity/ExpressionCompiler.h
@@ -72,6 +72,7 @@ public:
 
 private:
 	virtual bool visit(Assignment const& _assignment) override;
+	virtual bool visit(TupleExpression const& _tuple) override;
 	virtual bool visit(UnaryOperation const& _unaryOperation) override;
 	virtual bool visit(BinaryOperation const& _binaryOperation) override;
 	virtual bool visit(FunctionCall const& _functionCall) override;
diff --git a/libsolidity/InterfaceHandler.cpp b/libsolidity/InterfaceHandler.cpp
index be15ae58..17ca66b4 100644
--- a/libsolidity/InterfaceHandler.cpp
+++ b/libsolidity/InterfaceHandler.cpp
@@ -243,7 +243,7 @@ string InterfaceHandler::devDocumentation(ContractDefinition const& _contractDef
 				if (find(paramNames.begin(), paramNames.end(), pair.first) == paramNames.end())
 					// LTODO: mismatching parameter name, throw some form of warning and not just an exception
 					BOOST_THROW_EXCEPTION(
-						DocstringParsingError() <<
+						Error(Error::Type::DocstringParsingError) <<
 						errinfo_comment("documented parameter \"" + pair.first + "\" not found in the parameter list of the function.")
 					);					
 				params[pair.first] = pair.second;
@@ -310,7 +310,7 @@ string::const_iterator InterfaceHandler::parseDocTagParam(
 	// find param name
 	auto currPos = find(_pos, _end, ' ');
 	if (currPos == _end)
-		BOOST_THROW_EXCEPTION(DocstringParsingError() << errinfo_comment("End of param name not found" + string(_pos, _end)));
+		BOOST_THROW_EXCEPTION(Error(Error::Type::DocstringParsingError) << errinfo_comment("End of param name not found" + string(_pos, _end)));
 
 
 	auto paramName = string(_pos, currPos);
@@ -369,7 +369,7 @@ string::const_iterator InterfaceHandler::parseDocTag(
 				return parseDocTagLine(_pos, _end, m_author, DocTagType::Author, false);
 			else
 				// LTODO: for now this else makes no sense but later comments will go to more language constructs
-				BOOST_THROW_EXCEPTION(DocstringParsingError() << errinfo_comment("@author tag is legal only for contracts"));
+				BOOST_THROW_EXCEPTION(Error(Error::Type::DocstringParsingError) << errinfo_comment("@author tag is legal only for contracts"));
 		}
 		else if (_tag == "title")
 		{
@@ -377,13 +377,13 @@ string::const_iterator InterfaceHandler::parseDocTag(
 				return parseDocTagLine(_pos, _end, m_title, DocTagType::Title, false);
 			else
 				// LTODO: Unknown tag, throw some form of warning and not just an exception
-				BOOST_THROW_EXCEPTION(DocstringParsingError() << errinfo_comment("@title tag is legal only for contracts"));
+				BOOST_THROW_EXCEPTION(Error(Error::Type::DocstringParsingError) << errinfo_comment("@title tag is legal only for contracts"));
 		}
 		else if (_tag == "param")
 			return parseDocTagParam(_pos, _end);
 		else
 			// LTODO: Unknown tag, throw some form of warning and not just an exception
-			BOOST_THROW_EXCEPTION(DocstringParsingError() << errinfo_comment("Unknown tag " + _tag + " encountered"));
+			BOOST_THROW_EXCEPTION(Error(Error::Type::DocstringParsingError) << errinfo_comment("Unknown tag " + _tag + " encountered"));
 	}
 	else
 		return appendDocTag(_pos, _end, _owner);
@@ -410,13 +410,13 @@ string::const_iterator InterfaceHandler::appendDocTag(
 			return parseDocTagLine(_pos, _end, m_author, DocTagType::Author, true);
 		else
 			// LTODO: Unknown tag, throw some form of warning and not just an exception
-			BOOST_THROW_EXCEPTION(DocstringParsingError() << errinfo_comment("@author tag in illegal comment"));
+			BOOST_THROW_EXCEPTION(Error(Error::Type::DocstringParsingError) << errinfo_comment("@author tag in illegal comment"));
 	case DocTagType::Title:
 		if (_owner == CommentOwner::Contract)
 			return parseDocTagLine(_pos, _end, m_title, DocTagType::Title, true);
 		else
 			// LTODO: Unknown tag, throw some form of warning and not just an exception
-			BOOST_THROW_EXCEPTION(DocstringParsingError() << errinfo_comment("@title tag in illegal comment"));
+			BOOST_THROW_EXCEPTION(Error(Error::Type::DocstringParsingError) << errinfo_comment("@title tag in illegal comment"));
 	case DocTagType::Param:
 		return appendDocTagParam(_pos, _end);
 	default:
@@ -451,7 +451,7 @@ void InterfaceHandler::parseDocString(string const& _string, CommentOwner _owner
 			auto tagNameEndPos = firstSpaceOrNl(tagPos, end);
 			if (tagNameEndPos == end)
 				BOOST_THROW_EXCEPTION(
-					DocstringParsingError() <<
+					Error(Error::Type::DocstringParsingError) <<
 					errinfo_comment("End of tag " + string(tagPos, tagNameEndPos) + "not found"));
 
 			currPos = parseDocTag(tagNameEndPos + 1, end, string(tagPos + 1, tagNameEndPos), _owner);
diff --git a/libsolidity/LValue.cpp b/libsolidity/LValue.cpp
index 9f33e846..ac04ebef 100644
--- a/libsolidity/LValue.cpp
+++ b/libsolidity/LValue.cpp
@@ -32,9 +32,9 @@ using namespace solidity;
 
 
 StackVariable::StackVariable(CompilerContext& _compilerContext, VariableDeclaration const& _declaration):
-	LValue(_compilerContext, *_declaration.annotation().type),
+	LValue(_compilerContext, _declaration.annotation().type.get()),
 	m_baseStackOffset(m_context.baseStackOffsetOfVariable(_declaration)),
-	m_size(m_dataType.sizeOnStack())
+	m_size(m_dataType->sizeOnStack())
 {
 }
 
@@ -70,23 +70,23 @@ void StackVariable::storeValue(Type const&, SourceLocation const& _location, boo
 
 void StackVariable::setToZero(SourceLocation const& _location, bool) const
 {
-	CompilerUtils(m_context).pushZeroValue(m_dataType);
-	storeValue(m_dataType, _location, true);
+	CompilerUtils(m_context).pushZeroValue(*m_dataType);
+	storeValue(*m_dataType, _location, true);
 }
 
 MemoryItem::MemoryItem(CompilerContext& _compilerContext, Type const& _type, bool _padded):
-	LValue(_compilerContext, _type),
+	LValue(_compilerContext, &_type),
 	m_padded(_padded)
 {
 }
 
 void MemoryItem::retrieveValue(SourceLocation const&, bool _remove) const
 {
-	if (m_dataType.isValueType())
+	if (m_dataType->isValueType())
 	{
 		if (!_remove)
 			m_context << eth::Instruction::DUP1;
-		CompilerUtils(m_context).loadFromMemoryDynamic(m_dataType, false, m_padded, false);
+		CompilerUtils(m_context).loadFromMemoryDynamic(*m_dataType, false, m_padded, false);
 	}
 	else
 		m_context << eth::Instruction::MLOAD;
@@ -95,24 +95,24 @@ void MemoryItem::retrieveValue(SourceLocation const&, bool _remove) const
 void MemoryItem::storeValue(Type const& _sourceType, SourceLocation const&, bool _move) const
 {
 	CompilerUtils utils(m_context);
-	if (m_dataType.isValueType())
+	if (m_dataType->isValueType())
 	{
 		solAssert(_sourceType.isValueType(), "");
 		utils.moveIntoStack(_sourceType.sizeOnStack());
-		utils.convertType(_sourceType, m_dataType, true);
+		utils.convertType(_sourceType, *m_dataType, true);
 		if (!_move)
 		{
-			utils.moveToStackTop(m_dataType.sizeOnStack());
-			utils.copyToStackTop(2, m_dataType.sizeOnStack());
+			utils.moveToStackTop(m_dataType->sizeOnStack());
+			utils.copyToStackTop(2, m_dataType->sizeOnStack());
 		}
-		utils.storeInMemoryDynamic(m_dataType, m_padded);
+		utils.storeInMemoryDynamic(*m_dataType, m_padded);
 		m_context << eth::Instruction::POP;
 	}
 	else
 	{
-		solAssert(_sourceType == m_dataType, "Conversion not implemented for assignment to memory.");
+		solAssert(_sourceType == *m_dataType, "Conversion not implemented for assignment to memory.");
 
-		solAssert(m_dataType.sizeOnStack() == 1, "");
+		solAssert(m_dataType->sizeOnStack() == 1, "");
 		if (!_move)
 			m_context << eth::Instruction::DUP2 << eth::Instruction::SWAP1;
 		// stack: [value] value lvalue
@@ -126,8 +126,8 @@ void MemoryItem::setToZero(SourceLocation const&, bool _removeReference) const
 	CompilerUtils utils(m_context);
 	if (!_removeReference)
 		m_context << eth::Instruction::DUP1;
-	utils.pushZeroValue(m_dataType);
-	utils.storeInMemoryDynamic(m_dataType, m_padded);
+	utils.pushZeroValue(*m_dataType);
+	utils.storeInMemoryDynamic(*m_dataType, m_padded);
 	m_context << eth::Instruction::POP;
 }
 
@@ -139,21 +139,21 @@ StorageItem::StorageItem(CompilerContext& _compilerContext, VariableDeclaration
 }
 
 StorageItem::StorageItem(CompilerContext& _compilerContext, Type const& _type):
-	LValue(_compilerContext, _type)
+	LValue(_compilerContext, &_type)
 {
-	if (m_dataType.isValueType())
+	if (m_dataType->isValueType())
 	{
-		solAssert(m_dataType.storageSize() == m_dataType.sizeOnStack(), "");
-		solAssert(m_dataType.storageSize() == 1, "Invalid storage size.");
+		solAssert(m_dataType->storageSize() == m_dataType->sizeOnStack(), "");
+		solAssert(m_dataType->storageSize() == 1, "Invalid storage size.");
 	}
 }
 
 void StorageItem::retrieveValue(SourceLocation const&, bool _remove) const
 {
 	// stack: storage_key storage_offset
-	if (!m_dataType.isValueType())
+	if (!m_dataType->isValueType())
 	{
-		solAssert(m_dataType.sizeOnStack() == 1, "Invalid storage ref size.");
+		solAssert(m_dataType->sizeOnStack() == 1, "Invalid storage ref size.");
 		if (_remove)
 			m_context << eth::Instruction::POP; // remove byte offset
 		else
@@ -162,22 +162,22 @@ void StorageItem::retrieveValue(SourceLocation const&, bool _remove) const
 	}
 	if (!_remove)
 		CompilerUtils(m_context).copyToStackTop(sizeOnStack(), sizeOnStack());
-	if (m_dataType.storageBytes() == 32)
+	if (m_dataType->storageBytes() == 32)
 		m_context << eth::Instruction::POP << eth::Instruction::SLOAD;
 	else
 	{
 		m_context
 			<< eth::Instruction::SWAP1 << eth::Instruction::SLOAD << eth::Instruction::SWAP1
 			<< u256(0x100) << eth::Instruction::EXP << eth::Instruction::SWAP1 << eth::Instruction::DIV;
-		if (m_dataType.category() == Type::Category::FixedBytes)
-			m_context << (u256(0x1) << (256 - 8 * m_dataType.storageBytes())) << eth::Instruction::MUL;
+		if (m_dataType->category() == Type::Category::FixedBytes)
+			m_context << (u256(0x1) << (256 - 8 * m_dataType->storageBytes())) << eth::Instruction::MUL;
 		else if (
-			m_dataType.category() == Type::Category::Integer &&
-			dynamic_cast<IntegerType const&>(m_dataType).isSigned()
+			m_dataType->category() == Type::Category::Integer &&
+			dynamic_cast<IntegerType const&>(*m_dataType).isSigned()
 		)
-			m_context << u256(m_dataType.storageBytes() - 1) << eth::Instruction::SIGNEXTEND;
+			m_context << u256(m_dataType->storageBytes() - 1) << eth::Instruction::SIGNEXTEND;
 		else
-			m_context << ((u256(0x1) << (8 * m_dataType.storageBytes())) - 1) << eth::Instruction::AND;
+			m_context << ((u256(0x1) << (8 * m_dataType->storageBytes())) - 1) << eth::Instruction::AND;
 	}
 }
 
@@ -185,11 +185,11 @@ void StorageItem::storeValue(Type const& _sourceType, SourceLocation const& _loc
 {
 	CompilerUtils utils(m_context);
 	// stack: value storage_key storage_offset
-	if (m_dataType.isValueType())
+	if (m_dataType->isValueType())
 	{
-		solAssert(m_dataType.storageBytes() <= 32, "Invalid storage bytes size.");
-		solAssert(m_dataType.storageBytes() > 0, "Invalid storage bytes size.");
-		if (m_dataType.storageBytes() == 32)
+		solAssert(m_dataType->storageBytes() <= 32, "Invalid storage bytes size.");
+		solAssert(m_dataType->storageBytes() > 0, "Invalid storage bytes size.");
+		if (m_dataType->storageBytes() == 32)
 		{
 			// offset should be zero
 			m_context << eth::Instruction::POP;
@@ -207,24 +207,24 @@ void StorageItem::storeValue(Type const& _sourceType, SourceLocation const& _loc
 			// stack: value storege_ref multiplier old_full_value
 			// clear bytes in old value
 			m_context
-				<< eth::Instruction::DUP2 << ((u256(1) << (8 * m_dataType.storageBytes())) - 1)
+				<< eth::Instruction::DUP2 << ((u256(1) << (8 * m_dataType->storageBytes())) - 1)
 				<< eth::Instruction::MUL;
 			m_context << eth::Instruction::NOT << eth::Instruction::AND;
 			// stack: value storage_ref multiplier cleared_value
 			m_context
 				<< eth::Instruction::SWAP1 << eth::Instruction::DUP4;
 			// stack: value storage_ref cleared_value multiplier value
-			if (m_dataType.category() == Type::Category::FixedBytes)
+			if (m_dataType->category() == Type::Category::FixedBytes)
 				m_context
-					<< (u256(0x1) << (256 - 8 * dynamic_cast<FixedBytesType const&>(m_dataType).numBytes()))
+					<< (u256(0x1) << (256 - 8 * dynamic_cast<FixedBytesType const&>(*m_dataType).numBytes()))
 					<< eth::Instruction::SWAP1 << eth::Instruction::DIV;
 			else if (
-				m_dataType.category() == Type::Category::Integer &&
-				dynamic_cast<IntegerType const&>(m_dataType).isSigned()
+				m_dataType->category() == Type::Category::Integer &&
+				dynamic_cast<IntegerType const&>(*m_dataType).isSigned()
 			)
 				// remove the higher order bits
 				m_context
-					<< (u256(1) << (8 * (32 - m_dataType.storageBytes())))
+					<< (u256(1) << (8 * (32 - m_dataType->storageBytes())))
 					<< eth::Instruction::SWAP1
 					<< eth::Instruction::DUP2
 					<< eth::Instruction::MUL
@@ -239,23 +239,24 @@ void StorageItem::storeValue(Type const& _sourceType, SourceLocation const& _loc
 	else
 	{
 		solAssert(
-			_sourceType.category() == m_dataType.category(),
+			_sourceType.category() == m_dataType->category(),
 			"Wrong type conversation for assignment.");
-		if (m_dataType.category() == Type::Category::Array)
+		if (m_dataType->category() == Type::Category::Array)
 		{
 			m_context << eth::Instruction::POP; // remove byte offset
 			ArrayUtils(m_context).copyArrayToStorage(
-						dynamic_cast<ArrayType const&>(m_dataType),
-						dynamic_cast<ArrayType const&>(_sourceType));
+				dynamic_cast<ArrayType const&>(*m_dataType),
+				dynamic_cast<ArrayType const&>(_sourceType)
+			);
 			if (_move)
 				m_context << eth::Instruction::POP;
 		}
-		else if (m_dataType.category() == Type::Category::Struct)
+		else if (m_dataType->category() == Type::Category::Struct)
 		{
 			// stack layout: source_ref target_ref target_offset
 			// note that we have structs, so offset should be zero and are ignored
 			m_context << eth::Instruction::POP;
-			auto const& structType = dynamic_cast<StructType const&>(m_dataType);
+			auto const& structType = dynamic_cast<StructType const&>(*m_dataType);
 			auto const& sourceType = dynamic_cast<StructType const&>(_sourceType);
 			solAssert(
 				structType.structDefinition() == sourceType.structDefinition(),
@@ -313,18 +314,18 @@ void StorageItem::storeValue(Type const& _sourceType, SourceLocation const& _loc
 
 void StorageItem::setToZero(SourceLocation const&, bool _removeReference) const
 {
-	if (m_dataType.category() == Type::Category::Array)
+	if (m_dataType->category() == Type::Category::Array)
 	{
 		if (!_removeReference)
 			CompilerUtils(m_context).copyToStackTop(sizeOnStack(), sizeOnStack());
-		ArrayUtils(m_context).clearArray(dynamic_cast<ArrayType const&>(m_dataType));
+		ArrayUtils(m_context).clearArray(dynamic_cast<ArrayType const&>(*m_dataType));
 	}
-	else if (m_dataType.category() == Type::Category::Struct)
+	else if (m_dataType->category() == Type::Category::Struct)
 	{
 		// stack layout: storage_key storage_offset
 		// @todo this can be improved: use StorageItem for non-value types, and just store 0 in
 		// all slots that contain value types later.
-		auto const& structType = dynamic_cast<StructType const&>(m_dataType);
+		auto const& structType = dynamic_cast<StructType const&>(*m_dataType);
 		for (auto const& member: structType.members())
 		{
 			// zero each member that is not a mapping
@@ -342,10 +343,10 @@ void StorageItem::setToZero(SourceLocation const&, bool _removeReference) const
 	}
 	else
 	{
-		solAssert(m_dataType.isValueType(), "Clearing of unsupported type requested: " + m_dataType.toString());
+		solAssert(m_dataType->isValueType(), "Clearing of unsupported type requested: " + m_dataType->toString());
 		if (!_removeReference)
 			CompilerUtils(m_context).copyToStackTop(sizeOnStack(), sizeOnStack());
-		if (m_dataType.storageBytes() == 32)
+		if (m_dataType->storageBytes() == 32)
 		{
 			// offset should be zero
 			m_context
@@ -361,7 +362,7 @@ void StorageItem::setToZero(SourceLocation const&, bool _removeReference) const
 			// stack: storege_ref multiplier old_full_value
 			// clear bytes in old value
 			m_context
-				<< eth::Instruction::SWAP1 << ((u256(1) << (8 * m_dataType.storageBytes())) - 1)
+				<< eth::Instruction::SWAP1 << ((u256(1) << (8 * m_dataType->storageBytes())) - 1)
 				<< eth::Instruction::MUL;
 			m_context << eth::Instruction::NOT << eth::Instruction::AND;
 			// stack: storage_ref cleared_value
@@ -374,7 +375,7 @@ void StorageItem::setToZero(SourceLocation const&, bool _removeReference) const
 static FixedBytesType byteType(1);
 
 StorageByteArrayElement::StorageByteArrayElement(CompilerContext& _compilerContext):
-	LValue(_compilerContext, byteType)
+	LValue(_compilerContext, &byteType)
 {
 }
 
@@ -427,7 +428,7 @@ void StorageByteArrayElement::setToZero(SourceLocation const&, bool _removeRefer
 }
 
 StorageArrayLength::StorageArrayLength(CompilerContext& _compilerContext, const ArrayType& _arrayType):
-	LValue(_compilerContext, *_arrayType.memberType("length")),
+	LValue(_compilerContext, _arrayType.memberType("length").get()),
 	m_arrayType(_arrayType)
 {
 	solAssert(m_arrayType.isDynamicallySized(), "");
@@ -455,3 +456,91 @@ void StorageArrayLength::setToZero(SourceLocation const&, bool _removeReference)
 		m_context << eth::Instruction::DUP1;
 	ArrayUtils(m_context).clearDynamicArray(m_arrayType);
 }
+
+
+TupleObject::TupleObject(
+	CompilerContext& _compilerContext,
+	std::vector<std::unique_ptr<LValue>>&& _lvalues
+):
+	LValue(_compilerContext), m_lvalues(move(_lvalues))
+{
+}
+
+unsigned TupleObject::sizeOnStack() const
+{
+	unsigned size = 0;
+	for (auto const& lv: m_lvalues)
+		if (lv)
+			size += lv->sizeOnStack();
+	return size;
+}
+
+void TupleObject::retrieveValue(SourceLocation const& _location, bool _remove) const
+{
+	unsigned initialDepth = sizeOnStack();
+	unsigned initialStack = m_context.stackHeight();
+	for (auto const& lv: m_lvalues)
+		if (lv)
+		{
+			solAssert(initialDepth + m_context.stackHeight() >= initialStack, "");
+			unsigned depth = initialDepth + m_context.stackHeight() - initialStack;
+			if (lv->sizeOnStack() > 0)
+			{
+				if (_remove && depth > lv->sizeOnStack())
+					CompilerUtils(m_context).moveToStackTop(depth, depth - lv->sizeOnStack());
+				else if (!_remove && depth > 0)
+					CompilerUtils(m_context).copyToStackTop(depth, lv->sizeOnStack());
+			}
+			lv->retrieveValue(_location, true);
+		}
+}
+
+void TupleObject::storeValue(Type const& _sourceType, SourceLocation const& _location, bool) const
+{
+	// values are below the lvalue references
+	unsigned valuePos = sizeOnStack();
+	TypePointers const& valueTypes = dynamic_cast<TupleType const&>(_sourceType).components();
+	solAssert(valueTypes.size() == m_lvalues.size(), "");
+	// valuePos .... refPos ...
+	// We will assign from right to left to optimize stack layout.
+	for (size_t i = 0; i < m_lvalues.size(); ++i)
+	{
+		unique_ptr<LValue> const& lvalue = m_lvalues[m_lvalues.size() - i - 1];
+		TypePointer const& valType = valueTypes[valueTypes.size() - i - 1];
+		unsigned stackHeight = m_context.stackHeight();
+		solAssert(!valType == !lvalue, "");
+		if (!lvalue)
+			continue;
+		valuePos += valType->sizeOnStack();
+		// copy value to top
+		CompilerUtils(m_context).copyToStackTop(valuePos, valType->sizeOnStack());
+		// move lvalue ref above value
+		CompilerUtils(m_context).moveToStackTop(valType->sizeOnStack(), lvalue->sizeOnStack());
+		lvalue->storeValue(*valType, _location, true);
+		valuePos += m_context.stackHeight() - stackHeight;
+	}
+	// As the type of an assignment to a tuple type is the empty tuple, we always move.
+	CompilerUtils(m_context).popStackElement(_sourceType);
+}
+
+void TupleObject::setToZero(SourceLocation const& _location, bool _removeReference) const
+{
+	if (_removeReference)
+	{
+		for (size_t i = 0; i < m_lvalues.size(); ++i)
+			if (m_lvalues[m_lvalues.size() - i])
+				m_lvalues[m_lvalues.size() - i]->setToZero(_location, true);
+	}
+	else
+	{
+		unsigned depth = sizeOnStack();
+		for (auto const& val: m_lvalues)
+			if (val)
+			{
+				if (val->sizeOnStack() > 0)
+					CompilerUtils(m_context).copyToStackTop(depth, val->sizeOnStack());
+				val->setToZero(_location, false);
+				depth -= val->sizeOnStack();
+			}
+	}
+}
diff --git a/libsolidity/LValue.h b/libsolidity/LValue.h
index cbbfb102..94c8d3b8 100644
--- a/libsolidity/LValue.h
+++ b/libsolidity/LValue.h
@@ -23,6 +23,7 @@
 #pragma once
 
 #include <memory>
+#include <vector>
 #include <libevmasm/SourceLocation.h>
 #include <libsolidity/ArrayUtils.h>
 
@@ -33,6 +34,7 @@ namespace solidity
 
 class Declaration;
 class Type;
+class TupleType;
 class ArrayType;
 class CompilerContext;
 class VariableDeclaration;
@@ -43,7 +45,7 @@ class VariableDeclaration;
 class LValue
 {
 protected:
-	LValue(CompilerContext& _compilerContext, Type const& _dataType):
+	explicit LValue(CompilerContext& _compilerContext, Type const* _dataType = nullptr):
 		m_context(_compilerContext), m_dataType(_dataType) {}
 
 public:
@@ -68,7 +70,7 @@ public:
 
 protected:
 	CompilerContext& m_context;
-	Type const& m_dataType;
+	Type const* m_dataType;
 };
 
 /**
@@ -193,5 +195,30 @@ private:
 	ArrayType const& m_arrayType;
 };
 
+/**
+ * Tuple object that can itself hold several LValues.
+ */
+class TupleObject: public LValue
+{
+public:
+	/// Constructs the LValue assuming that the other LValues are present on the stack.
+	/// Empty unique_ptrs are possible if e.g. some values should be ignored during assignment.
+	TupleObject(CompilerContext& _compilerContext, std::vector<std::unique_ptr<LValue>>&& _lvalues);
+	virtual unsigned sizeOnStack() const;
+	virtual void retrieveValue(SourceLocation const& _location, bool _remove = false) const override;
+	virtual void storeValue(
+		Type const& _sourceType,
+		SourceLocation const& _location = SourceLocation(),
+		bool _move = false
+	) const override;
+	virtual void setToZero(
+		SourceLocation const& _location = SourceLocation(),
+		bool _removeReference = true
+	) const override;
+
+private:
+	std::vector<std::unique_ptr<LValue>> m_lvalues;
+};
+
 }
 }
diff --git a/libsolidity/NameAndTypeResolver.cpp b/libsolidity/NameAndTypeResolver.cpp
index 0ce20f3c..edd0704d 100644
--- a/libsolidity/NameAndTypeResolver.cpp
+++ b/libsolidity/NameAndTypeResolver.cpp
@@ -33,88 +33,120 @@ namespace solidity
 {
 
 NameAndTypeResolver::NameAndTypeResolver(
-	vector<Declaration const*> const& _globals
-)
+	vector<Declaration const*> const& _globals,
+	ErrorList& _errors
+) :
+	m_errors(_errors)
 {
 	for (Declaration const* declaration: _globals)
 		m_scopes[nullptr].registerDeclaration(*declaration);
 }
 
-void NameAndTypeResolver::registerDeclarations(SourceUnit& _sourceUnit)
+bool NameAndTypeResolver::registerDeclarations(SourceUnit& _sourceUnit)
 {
 	// The helper registers all declarations in m_scopes as a side-effect of its construction.
-	DeclarationRegistrationHelper registrar(m_scopes, _sourceUnit);
+	try
+	{
+		DeclarationRegistrationHelper registrar(m_scopes, _sourceUnit, m_errors);
+	}
+	catch (FatalError const& _e)
+	{
+		if (m_errors.empty())
+			throw; // Something is weird here, rather throw again.
+		return false;
+	}
+	return true;
 }
 
-void NameAndTypeResolver::resolveNamesAndTypes(ContractDefinition& _contract)
+bool NameAndTypeResolver::resolveNamesAndTypes(ContractDefinition& _contract)
 {
-	m_currentScope = &m_scopes[nullptr];
+	try
+	{
+		m_currentScope = &m_scopes[nullptr];
 
-	for (ASTPointer<InheritanceSpecifier> const& baseContract: _contract.baseContracts())
-		ReferencesResolver resolver(*baseContract, *this, &_contract, nullptr);
+		for (ASTPointer<InheritanceSpecifier> const& baseContract: _contract.baseContracts())
+			ReferencesResolver resolver(*baseContract, *this, &_contract, nullptr);
 
-	m_currentScope = &m_scopes[&_contract];
+		m_currentScope = &m_scopes[&_contract];
 
-	linearizeBaseContracts(_contract);
-	std::vector<ContractDefinition const*> properBases(
-		++_contract.annotation().linearizedBaseContracts.begin(),
-		_contract.annotation().linearizedBaseContracts.end()
-	);
+		linearizeBaseContracts(_contract);
+		std::vector<ContractDefinition const*> properBases(
+			++_contract.annotation().linearizedBaseContracts.begin(),
+			_contract.annotation().linearizedBaseContracts.end()
+		);
 
-	for (ContractDefinition const* base: properBases)
-		importInheritedScope(*base);
+		for (ContractDefinition const* base: properBases)
+			importInheritedScope(*base);
 
-	for (ASTPointer<StructDefinition> const& structDef: _contract.definedStructs())
-		ReferencesResolver resolver(*structDef, *this, &_contract, nullptr);
-	for (ASTPointer<EnumDefinition> const& enumDef: _contract.definedEnums())
-		ReferencesResolver resolver(*enumDef, *this, &_contract, nullptr);
-	for (ASTPointer<VariableDeclaration> const& variable: _contract.stateVariables())
-		ReferencesResolver resolver(*variable, *this, &_contract, nullptr);
-	for (ASTPointer<EventDefinition> const& event: _contract.events())
-		ReferencesResolver resolver(*event, *this, &_contract, nullptr);
+		for (ASTPointer<StructDefinition> const& structDef: _contract.definedStructs())
+			ReferencesResolver resolver(*structDef, *this, &_contract, nullptr);
+		for (ASTPointer<EnumDefinition> const& enumDef: _contract.definedEnums())
+			ReferencesResolver resolver(*enumDef, *this, &_contract, nullptr);
+		for (ASTPointer<VariableDeclaration> const& variable: _contract.stateVariables())
+			ReferencesResolver resolver(*variable, *this, &_contract, nullptr);
+		for (ASTPointer<EventDefinition> const& event: _contract.events())
+			ReferencesResolver resolver(*event, *this, &_contract, nullptr);
 
-	// these can contain code, only resolve parameters for now
-	for (ASTPointer<ModifierDefinition> const& modifier: _contract.functionModifiers())
-	{
-		m_currentScope = &m_scopes[modifier.get()];
-		ReferencesResolver resolver(*modifier, *this, &_contract, nullptr);
-	}
-	for (ASTPointer<FunctionDefinition> const& function: _contract.definedFunctions())
-	{
-		m_currentScope = &m_scopes[function.get()];
-		ReferencesResolver referencesResolver(
-			*function,
-			*this,
-			&_contract,
-			function->returnParameterList().get()
-		);
-	}
+		// these can contain code, only resolve parameters for now
+		for (ASTPointer<ModifierDefinition> const& modifier: _contract.functionModifiers())
+		{
+			m_currentScope = &m_scopes[modifier.get()];
+			ReferencesResolver resolver(*modifier, *this, &_contract, nullptr);
+		}
+		for (ASTPointer<FunctionDefinition> const& function: _contract.definedFunctions())
+		{
+			m_currentScope = &m_scopes[function.get()];
+			ReferencesResolver referencesResolver(
+				*function,
+				*this,
+				&_contract,
+				function->returnParameterList().get()
+			);
+		}
 
-	m_currentScope = &m_scopes[&_contract];
+		m_currentScope = &m_scopes[&_contract];
 
-	// now resolve references inside the code
-	for (ASTPointer<ModifierDefinition> const& modifier: _contract.functionModifiers())
-	{
-		m_currentScope = &m_scopes[modifier.get()];
-		ReferencesResolver resolver(*modifier, *this, &_contract, nullptr, true);
+		// now resolve references inside the code
+		for (ASTPointer<ModifierDefinition> const& modifier: _contract.functionModifiers())
+		{
+			m_currentScope = &m_scopes[modifier.get()];
+			ReferencesResolver resolver(*modifier, *this, &_contract, nullptr, true);
+		}
+		for (ASTPointer<FunctionDefinition> const& function: _contract.definedFunctions())
+		{
+			m_currentScope = &m_scopes[function.get()];
+			ReferencesResolver referencesResolver(
+				*function,
+				*this,
+				&_contract,
+				function->returnParameterList().get(),
+				true
+			);
+		}
 	}
-	for (ASTPointer<FunctionDefinition> const& function: _contract.definedFunctions())
+	catch (FatalError const& _e)
 	{
-		m_currentScope = &m_scopes[function.get()];
-		ReferencesResolver referencesResolver(
-			*function,
-			*this,
-			&_contract,
-			function->returnParameterList().get(),
-			true
-		);
+		if (m_errors.empty())
+			throw; // Something is weird here, rather throw again.
+		return false;
 	}
+	return true;
 }
 
-void NameAndTypeResolver::updateDeclaration(Declaration const& _declaration)
+bool NameAndTypeResolver::updateDeclaration(Declaration const& _declaration)
 {
-	m_scopes[nullptr].registerDeclaration(_declaration, false, true);
-	solAssert(_declaration.scope() == nullptr, "Updated declaration outside global scope.");
+	try
+	{
+		m_scopes[nullptr].registerDeclaration(_declaration, false, true);
+		solAssert(_declaration.scope() == nullptr, "Updated declaration outside global scope.");
+	}
+	catch (FatalError const& _error)
+	{
+		if (m_errors.empty())
+			throw; // Something is weird here, rather throw again.
+		return false;
+	}
+	return true;
 }
 
 vector<Declaration const*> NameAndTypeResolver::resolveName(ASTString const& _name, Declaration const* _scope) const
@@ -162,11 +194,8 @@ vector<Declaration const*> NameAndTypeResolver::cleanedDeclarations(
 		FunctionType functionType(functionDefinition);
 		for (auto parameter: functionType.parameterTypes() + functionType.returnParameterTypes())
 			if (!parameter)
-				BOOST_THROW_EXCEPTION(
-					DeclarationError() <<
-					errinfo_sourceLocation(_identifier.location()) <<
-					errinfo_comment("Function type can not be used in this context")
-				);
+				reportFatalDeclarationError(_identifier.location(), "Function type can not be used in this context");
+
 		if (uniqueFunctions.end() == find_if(
 			uniqueFunctions.begin(),
 			uniqueFunctions.end(),
@@ -192,7 +221,7 @@ void NameAndTypeResolver::importInheritedScope(ContractDefinition const& _base)
 				m_currentScope->registerDeclaration(*declaration);
 }
 
-void NameAndTypeResolver::linearizeBaseContracts(ContractDefinition& _contract) const
+void NameAndTypeResolver::linearizeBaseContracts(ContractDefinition& _contract)
 {
 	// order in the lists is from derived to base
 	// list of lists to linearize, the last element is the list of direct bases
@@ -202,19 +231,19 @@ void NameAndTypeResolver::linearizeBaseContracts(ContractDefinition& _contract)
 		Identifier const& baseName = baseSpecifier->name();
 		auto base = dynamic_cast<ContractDefinition const*>(baseName.annotation().referencedDeclaration);
 		if (!base)
-			BOOST_THROW_EXCEPTION(baseName.createTypeError("Contract expected."));
+			reportFatalTypeError(baseName.createTypeError("Contract expected."));
 		// "push_front" has the effect that bases mentioned later can overwrite members of bases
 		// mentioned earlier
 		input.back().push_front(base);
 		vector<ContractDefinition const*> const& basesBases = base->annotation().linearizedBaseContracts;
 		if (basesBases.empty())
-			BOOST_THROW_EXCEPTION(baseName.createTypeError("Definition of base has to precede definition of derived contract"));
+			reportFatalTypeError(baseName.createTypeError("Definition of base has to precede definition of derived contract"));
 		input.push_front(list<ContractDefinition const*>(basesBases.begin(), basesBases.end()));
 	}
 	input.back().push_front(&_contract);
 	vector<ContractDefinition const*> result = cThreeMerge(input);
 	if (result.empty())
-		BOOST_THROW_EXCEPTION(_contract.createTypeError("Linearization of inheritance graph impossible"));
+		reportFatalTypeError(_contract.createTypeError("Linearization of inheritance graph impossible"));
 	_contract.annotation().linearizedBaseContracts = result;
 	_contract.annotation().contractDependencies.insert(result.begin() + 1, result.end());
 }
@@ -270,9 +299,60 @@ vector<_T const*> NameAndTypeResolver::cThreeMerge(list<list<_T const*>>& _toMer
 	return result;
 }
 
-DeclarationRegistrationHelper::DeclarationRegistrationHelper(map<ASTNode const*, DeclarationContainer>& _scopes,
-															 ASTNode& _astRoot):
-	m_scopes(_scopes), m_currentScope(nullptr)
+void NameAndTypeResolver::reportDeclarationError(
+	SourceLocation _sourceLoction,
+	string const& _description,
+	SourceLocation _secondarySourceLocation,
+	string const& _secondaryDescription
+)
+{
+	auto err = make_shared<Error>(Error::Type::DeclarationError); // todo remove Error?
+	*err <<
+		errinfo_sourceLocation(_sourceLoction) <<
+		errinfo_comment(_description) <<
+		errinfo_secondarySourceLocation(
+			SecondarySourceLocation().append(_secondaryDescription, _secondarySourceLocation)
+		);
+
+	m_errors.push_back(err);
+}
+
+void NameAndTypeResolver::reportDeclarationError(SourceLocation _sourceLocation, string const& _description)
+{
+	auto err = make_shared<Error>(Error::Type::DeclarationError); // todo remove Error?
+	*err <<	errinfo_sourceLocation(_sourceLocation) << errinfo_comment(_description);
+
+	m_errors.push_back(err);
+}
+
+void NameAndTypeResolver::reportFatalDeclarationError(
+	SourceLocation _sourceLocation,
+	string const& _description
+)
+{
+	reportDeclarationError(_sourceLocation, _description);
+	BOOST_THROW_EXCEPTION(FatalError());
+}
+
+void NameAndTypeResolver::reportTypeError(Error const& _e)
+{
+	m_errors.push_back(make_shared<Error>(_e));
+}
+
+void NameAndTypeResolver::reportFatalTypeError(Error const& _e)
+{
+	reportTypeError(_e);
+	BOOST_THROW_EXCEPTION(FatalError());
+}
+
+DeclarationRegistrationHelper::DeclarationRegistrationHelper(
+	map<ASTNode const*, DeclarationContainer>& _scopes,
+	ASTNode& _astRoot,
+	ErrorList& _errors
+):
+	m_scopes(_scopes),
+	m_currentScope(nullptr),
+	m_errors(_errors)
 {
 	_astRoot.accept(*this);
 }
@@ -350,7 +430,9 @@ void DeclarationRegistrationHelper::endVisit(VariableDeclarationStatement& _vari
 	// Register the local variables with the function
 	// This does not fit here perfectly, but it saves us another AST visit.
 	solAssert(m_currentFunction, "Variable declaration without function.");
-	m_currentFunction->addLocalVariable(_variableDeclarationStatement.declaration());
+	for (ASTPointer<VariableDeclaration> const& var: _variableDeclarationStatement.declarations())
+		if (var)
+			m_currentFunction->addLocalVariable(*var);
 }
 
 bool DeclarationRegistrationHelper::visit(VariableDeclaration& _declaration)
@@ -405,13 +487,11 @@ void DeclarationRegistrationHelper::registerDeclaration(Declaration& _declaratio
 			secondDeclarationLocation = _declaration.location();
 		}
 
-		BOOST_THROW_EXCEPTION(
-			DeclarationError() <<
-			errinfo_sourceLocation(secondDeclarationLocation) <<
-			errinfo_comment("Identifier already declared.") <<
-			errinfo_secondarySourceLocation(
-				SecondarySourceLocation().append("The previous declaration is here:", firstDeclarationLocation)
-			)
+		declarationError(
+			secondDeclarationLocation,
+			"Identifier already declared.",
+			firstDeclarationLocation,
+			"The previous declaration is here:"
 		);
 	}
 
@@ -436,5 +516,40 @@ string DeclarationRegistrationHelper::currentCanonicalName() const
 	return ret;
 }
 
+void DeclarationRegistrationHelper::declarationError(
+	SourceLocation _sourceLocation,
+	string const& _description,
+	SourceLocation _secondarySourceLocation,
+	string const& _secondaryDescription
+)
+{
+	auto err = make_shared<Error>(Error::Type::DeclarationError);
+	*err <<
+		errinfo_sourceLocation(_sourceLocation) <<
+		errinfo_comment(_description) <<
+		errinfo_secondarySourceLocation(
+			SecondarySourceLocation().append(_secondaryDescription, _secondarySourceLocation)
+		);
+
+	m_errors.push_back(err);
+}
+
+void DeclarationRegistrationHelper::declarationError(SourceLocation _sourceLocation, string const& _description)
+{
+	auto err = make_shared<Error>(Error::Type::DeclarationError);
+	*err <<	errinfo_sourceLocation(_sourceLocation) << errinfo_comment(_description);
+
+	m_errors.push_back(err);
+}
+
+void DeclarationRegistrationHelper::fatalDeclarationError(
+	SourceLocation _sourceLocation,
+	string const& _description
+)
+{
+	declarationError(_sourceLocation, _description);
+	BOOST_THROW_EXCEPTION(FatalError());
+}
+
 }
 }
diff --git a/libsolidity/NameAndTypeResolver.h b/libsolidity/NameAndTypeResolver.h
index f5f4c6ce..7169f302 100644
--- a/libsolidity/NameAndTypeResolver.h
+++ b/libsolidity/NameAndTypeResolver.h
@@ -42,14 +42,17 @@ namespace solidity
 class NameAndTypeResolver: private boost::noncopyable
 {
 public:
-	NameAndTypeResolver(std::vector<Declaration const*> const& _globals);
+	NameAndTypeResolver(std::vector<Declaration const*> const& _globals, ErrorList& _errors);
 	/// Registers all declarations found in the source unit.
-	void registerDeclarations(SourceUnit& _sourceUnit);
+	/// @returns false in case of error.
+	bool registerDeclarations(SourceUnit& _sourceUnit);
 	/// Resolves all names and types referenced from the given contract.
-	void resolveNamesAndTypes(ContractDefinition& _contract);
+	/// @returns false in case of error.
+	bool resolveNamesAndTypes(ContractDefinition& _contract);
 	/// Updates the given global declaration (used for "this"). Not to be used with declarations
 	/// that create their own scope.
-	void updateDeclaration(Declaration const& _declaration);
+	/// @returns false in case of error.
+	bool updateDeclaration(Declaration const& _declaration);
 
 	/// Resolves the given @a _name inside the scope @a _scope. If @a _scope is omitted,
 	/// the global scope is used (i.e. the one containing only the contract).
@@ -66,7 +69,7 @@ public:
 	Declaration const* pathFromCurrentScope(std::vector<ASTString> const& _path, bool _recursive = true) const;
 
 	/// returns the vector of declarations without repetitions
-	static std::vector<Declaration const*> cleanedDeclarations(
+	std::vector<Declaration const*> cleanedDeclarations(
 		Identifier const& _identifier,
 		std::vector<Declaration const*> const& _declarations
 	);
@@ -78,8 +81,8 @@ private:
 	/// into the current scope if they are not present already.
 	void importInheritedScope(ContractDefinition const& _base);
 
-	/// Computes "C3-Linearization" of base contracts and stores it inside the contract.
-	void linearizeBaseContracts(ContractDefinition& _contract) const;
+	/// Computes "C3-Linearization" of base contracts and stores it inside the contract. Reports errors if any
+	void linearizeBaseContracts(ContractDefinition& _contract);
 	/// Computes the C3-merge of the given list of lists of bases.
 	/// @returns the linearized vector or an empty vector if linearization is not possible.
 	template <class _T>
@@ -90,7 +93,25 @@ private:
 	/// not contain code.
 	std::map<ASTNode const*, DeclarationContainer> m_scopes;
 
+	// creates the Declaration error and adds it in the errors list
+	void reportDeclarationError(
+		SourceLocation _sourceLoction,
+		std::string const& _description,
+		SourceLocation _secondarySourceLocation,
+		std::string const& _secondaryDescription
+	);
+	// creates the Declaration error and adds it in the errors list
+	void reportDeclarationError(SourceLocation _sourceLocation, std::string const& _description);
+	// creates the Declaration error and adds it in the errors list and throws FatalError
+	void reportFatalDeclarationError(SourceLocation _sourceLocation, std::string const& _description);
+
+	// creates the Declaration error and adds it in the errors list
+	void reportTypeError(Error const& _e);
+	// creates the Declaration error and adds it in the errors list and throws FatalError
+	void reportFatalTypeError(Error const& _e);
+
 	DeclarationContainer* m_currentScope = nullptr;
+	ErrorList& m_errors;
 };
 
 /**
@@ -100,7 +121,7 @@ private:
 class DeclarationRegistrationHelper: private ASTVisitor
 {
 public:
-	DeclarationRegistrationHelper(std::map<ASTNode const*, DeclarationContainer>& _scopes, ASTNode& _astRoot);
+	DeclarationRegistrationHelper(std::map<ASTNode const*, DeclarationContainer>& _scopes, ASTNode& _astRoot, ErrorList& _errors);
 
 private:
 	bool visit(ContractDefinition& _contract) override;
@@ -125,10 +146,23 @@ private:
 
 	/// @returns the canonical name of the current scope.
 	std::string currentCanonicalName() const;
+	// creates the Declaration error and adds it in the errors list
+	void declarationError(
+		SourceLocation _sourceLocation,
+		std::string const& _description,
+		SourceLocation _secondarySourceLocation,
+		std::string const& _secondaryDescription
+	);
+
+	// creates the Declaration error and adds it in the errors list
+	void declarationError(SourceLocation _sourceLocation, std::string const& _description);
+	// creates the Declaration error and adds it in the errors list and throws FatalError
+	void fatalDeclarationError(SourceLocation _sourceLocation, std::string const& _description);
 
 	std::map<ASTNode const*, DeclarationContainer>& m_scopes;
 	Declaration const* m_currentScope;
 	VariableScope* m_currentFunction;
+	ErrorList& m_errors;
 };
 
 }
diff --git a/libsolidity/Parser.cpp b/libsolidity/Parser.cpp
index 94e9c0ea..4fdfd2e4 100644
--- a/libsolidity/Parser.cpp
+++ b/libsolidity/Parser.cpp
@@ -66,25 +66,34 @@ private:
 
 ASTPointer<SourceUnit> Parser::parse(shared_ptr<Scanner> const& _scanner)
 {
-	m_scanner = _scanner;
-	ASTNodeFactory nodeFactory(*this);
-	vector<ASTPointer<ASTNode>> nodes;
-	while (m_scanner->currentToken() != Token::EOS)
+	try
 	{
-		switch (auto token = m_scanner->currentToken())
+		m_scanner = _scanner;
+		ASTNodeFactory nodeFactory(*this);
+		vector<ASTPointer<ASTNode>> nodes;
+		while (m_scanner->currentToken() != Token::EOS)
 		{
-		case Token::Import:
-			nodes.push_back(parseImportDirective());
-			break;
-		case Token::Contract:
-		case Token::Library:
-			nodes.push_back(parseContractDefinition(token == Token::Library));
-			break;
-		default:
-			BOOST_THROW_EXCEPTION(createParserError(std::string("Expected import directive or contract definition.")));
+			switch (auto token = m_scanner->currentToken())
+			{
+			case Token::Import:
+				nodes.push_back(parseImportDirective());
+				break;
+			case Token::Contract:
+			case Token::Library:
+				nodes.push_back(parseContractDefinition(token == Token::Library));
+				break;
+			default:
+				fatalParserError(std::string("Expected import directive or contract definition."));
+			}
 		}
+		return nodeFactory.createNode<SourceUnit>(nodes);
+	}
+	catch (FatalError const& _error)
+	{
+		if (m_errors.empty())
+			throw; // Something is weird here, rather throw again.
+		return nullptr;
 	}
-	return nodeFactory.createNode<SourceUnit>(nodes);
 }
 
 std::shared_ptr<const string> const& Parser::sourceName() const
@@ -107,7 +116,7 @@ ASTPointer<ImportDirective> Parser::parseImportDirective()
 	ASTNodeFactory nodeFactory(*this);
 	expectToken(Token::Import);
 	if (m_scanner->currentToken() != Token::StringLiteral)
-		BOOST_THROW_EXCEPTION(createParserError("Expected string literal (URL)."));
+		fatalParserError(std::string("Expected string literal (URL)."));
 	ASTPointer<ASTString> url = getLiteralAndAdvance();
 	nodeFactory.markEndPosition();
 	expectToken(Token::Semicolon);
@@ -165,7 +174,7 @@ ASTPointer<ContractDefinition> Parser::parseContractDefinition(bool _isLibrary)
 		else if (currentTokenValue == Token::Event)
 			events.push_back(parseEventDefinition());
 		else
-			BOOST_THROW_EXCEPTION(createParserError("Function, variable, struct or modifier declaration expected."));
+			fatalParserError(std::string("Function, variable, struct or modifier declaration expected."));
 	}
 	nodeFactory.markEndPosition();
 	expectToken(Token::RBrace);
@@ -249,7 +258,7 @@ ASTPointer<FunctionDefinition> Parser::parseFunctionDefinition(ASTString const*
 		else if (Token::isVisibilitySpecifier(token))
 		{
 			if (visibility != Declaration::Visibility::Default)
-				BOOST_THROW_EXCEPTION(createParserError("Multiple visibility specifiers."));
+				fatalParserError(std::string("Multiple visibility specifiers."));
 			visibility = parseVisibilitySpecifier(token);
 		}
 		else
@@ -326,7 +335,7 @@ ASTPointer<EnumDefinition> Parser::parseEnumDefinition()
 			break;
 		expectToken(Token::Comma);
 		if (m_scanner->currentToken() != Token::Identifier)
-			BOOST_THROW_EXCEPTION(createParserError("Expected Identifier after ','"));
+			fatalParserError(std::string("Expected Identifier after ','"));
 	}
 
 	nodeFactory.markEndPosition();
@@ -362,7 +371,7 @@ ASTPointer<VariableDeclaration> Parser::parseVariableDeclaration(
 		if (_options.isStateVariable && Token::isVariableVisibilitySpecifier(token))
 		{
 			if (visibility != Declaration::Visibility::Default)
-				BOOST_THROW_EXCEPTION(createParserError("Visibility already specified."));
+				fatalParserError(std::string("Visibility already specified."));
 			visibility = parseVisibilitySpecifier(token);
 		}
 		else
@@ -374,9 +383,9 @@ ASTPointer<VariableDeclaration> Parser::parseVariableDeclaration(
 			else if (_options.allowLocationSpecifier && Token::isLocationSpecifier(token))
 			{
 				if (location != VariableDeclaration::Location::Default)
-					BOOST_THROW_EXCEPTION(createParserError("Location already specified."));
+					fatalParserError(std::string("Location already specified."));
 				if (!type)
-					BOOST_THROW_EXCEPTION(createParserError("Location specifier needs explicit type name."));
+					fatalParserError(std::string("Location specifier needs explicit type name."));
 				location = (
 					token == Token::Memory ?
 					VariableDeclaration::Location::Memory :
@@ -513,7 +522,7 @@ ASTPointer<TypeName> Parser::parseTypeName(bool _allowVar)
 	else if (token == Token::Var)
 	{
 		if (!_allowVar)
-			BOOST_THROW_EXCEPTION(createParserError("Expected explicit type name."));
+			fatalParserError(std::string("Expected explicit type name."));
 		m_scanner->next();
 	}
 	else if (token == Token::Mapping)
@@ -532,7 +541,7 @@ ASTPointer<TypeName> Parser::parseTypeName(bool _allowVar)
 		type = nodeFactory.createNode<UserDefinedTypeName>(identifierPath);
 	}
 	else
-		BOOST_THROW_EXCEPTION(createParserError("Expected type name"));
+		fatalParserError(std::string("Expected type name"));
 
 	if (type)
 		// Parse "[...]" postfixes for arrays.
@@ -555,7 +564,7 @@ ASTPointer<Mapping> Parser::parseMapping()
 	expectToken(Token::Mapping);
 	expectToken(Token::LParen);
 	if (!Token::isElementaryTypeName(m_scanner->currentToken()))
-		BOOST_THROW_EXCEPTION(createParserError("Expected elementary type name for mapping key type"));
+		fatalParserError(std::string("Expected elementary type name for mapping key type"));
 	ASTPointer<ElementaryTypeName> keyType;
 	keyType = ASTNodeFactory(*this).createNode<ElementaryTypeName>(m_scanner->currentToken());
 	m_scanner->next();
@@ -725,6 +734,9 @@ ASTPointer<Statement> Parser::parseSimpleStatement()
 	// These two cases are very hard to distinguish:
 	// x[7 * 20 + 3] a;  -  x[7 * 20 + 3] = 9;
 	// In the first case, x is a type name, in the second it is the name of a variable.
+	// As an extension, we can even have:
+	// `x.y.z[1][2] a;` and `x.y.z[1][2] = 10;`
+	// Where in the first, x.y.z leads to a type name where in the second, it accesses structs.
 	switch (peekStatementType())
 	{
 	case LookAheadInfo::VariableDeclarationStatement:
@@ -735,49 +747,105 @@ ASTPointer<Statement> Parser::parseSimpleStatement()
 		break;
 	}
 
-	// At this point, we have '(Identifier|ElementaryTypeName) "["'.
-	// We parse '(Identifier|ElementaryTypeName) ( "[" Expression "]" )+' and then decide whether to hand this over
-	// to ExpressionStatement or create a VariableDeclarationStatement out of it.
-	ASTPointer<PrimaryExpression> primary;
+	// At this point, we have 'Identifier "["' or 'Identifier "." Identifier' or 'ElementoryTypeName "["'.
+	// We parse '(Identifier ("." Identifier)* |ElementaryTypeName) ( "[" Expression "]" )+'
+	// until we can decide whether to hand this over to ExpressionStatement or create a
+	// VariableDeclarationStatement out of it.
+
+	vector<ASTPointer<PrimaryExpression>> path;
+	bool startedWithElementary = false;
 	if (m_scanner->currentToken() == Token::Identifier)
-		primary = parseIdentifier();
+		path.push_back(parseIdentifier());
 	else
 	{
-		primary = ASTNodeFactory(*this).createNode<ElementaryTypeNameExpression>(m_scanner->currentToken());
+		startedWithElementary = true;
+		path.push_back(ASTNodeFactory(*this).createNode<ElementaryTypeNameExpression>(m_scanner->currentToken()));
+		m_scanner->next();
+	}
+	while (!startedWithElementary && m_scanner->currentToken() == Token::Period)
+	{
 		m_scanner->next();
+		path.push_back(parseIdentifier());
 	}
 	vector<pair<ASTPointer<Expression>, SourceLocation>> indices;
-	solAssert(m_scanner->currentToken() == Token::LBrack, "");
-	SourceLocation indexLocation = primary->location();
-	do
+	while (m_scanner->currentToken() == Token::LBrack)
 	{
 		expectToken(Token::LBrack);
 		ASTPointer<Expression> index;
 		if (m_scanner->currentToken() != Token::RBrack)
 			index = parseExpression();
+		SourceLocation indexLocation = path.front()->location();
 		indexLocation.end = endPosition();
 		indices.push_back(make_pair(index, indexLocation));
 		expectToken(Token::RBrack);
 	}
-	while (m_scanner->currentToken() == Token::LBrack);
 
 	if (m_scanner->currentToken() == Token::Identifier || Token::isLocationSpecifier(m_scanner->currentToken()))
-		return parseVariableDeclarationStatement(typeNameIndexAccessStructure(primary, indices));
+		return parseVariableDeclarationStatement(typeNameIndexAccessStructure(path, indices));
 	else
-		return parseExpressionStatement(expressionFromIndexAccessStructure(primary, indices));
+		return parseExpressionStatement(expressionFromIndexAccessStructure(path, indices));
 }
 
 ASTPointer<VariableDeclarationStatement> Parser::parseVariableDeclarationStatement(
 	ASTPointer<TypeName> const& _lookAheadArrayType
 )
 {
-	VarDeclParserOptions options;
-	options.allowVar = true;
-	options.allowInitialValue = true;
-	options.allowLocationSpecifier = true;
-	ASTPointer<VariableDeclaration> variable = parseVariableDeclaration(options, _lookAheadArrayType);
-	ASTNodeFactory nodeFactory(*this, variable);
-	return nodeFactory.createNode<VariableDeclarationStatement>(variable);
+	ASTNodeFactory nodeFactory(*this);
+	if (_lookAheadArrayType)
+		nodeFactory.setLocation(_lookAheadArrayType->location());
+	vector<ASTPointer<VariableDeclaration>> variables;
+	ASTPointer<Expression> value;
+	if (
+		!_lookAheadArrayType &&
+		m_scanner->currentToken() == Token::Var &&
+		m_scanner->peekNextToken() == Token::LParen
+	)
+	{
+		// Parse `var (a, b, ,, c) = ...` into a single VariableDeclarationStatement with multiple variables.
+		m_scanner->next();
+		m_scanner->next();
+		if (m_scanner->currentToken() != Token::RParen)
+			while (true)
+			{
+				ASTPointer<VariableDeclaration> var;
+				if (
+					m_scanner->currentToken() != Token::Comma &&
+					m_scanner->currentToken() != Token::RParen
+				)
+				{
+					ASTNodeFactory varDeclNodeFactory(*this);
+					varDeclNodeFactory.markEndPosition();
+					ASTPointer<ASTString> name = expectIdentifierToken();
+					var = varDeclNodeFactory.createNode<VariableDeclaration>(
+						ASTPointer<TypeName>(),
+						name,
+						ASTPointer<Expression>(),
+						VariableDeclaration::Visibility::Default
+					);
+				}
+				variables.push_back(var);
+				if (m_scanner->currentToken() == Token::RParen)
+					break;
+				else
+					expectToken(Token::Comma);
+			}
+		nodeFactory.markEndPosition();
+		m_scanner->next();
+	}
+	else
+	{
+		VarDeclParserOptions options;
+		options.allowVar = true;
+		options.allowLocationSpecifier = true;
+		variables.push_back(parseVariableDeclaration(options, _lookAheadArrayType));
+	}
+	if (m_scanner->currentToken() == Token::Assign)
+	{
+		m_scanner->next();
+		value = parseExpression();
+		nodeFactory.setEndPositionFromNode(value);
+	}
+	return nodeFactory.createNode<VariableDeclarationStatement>(variables, value);
 }
 
 ASTPointer<ExpressionStatement> Parser::parseExpressionStatement(
@@ -950,10 +1018,25 @@ ASTPointer<Expression> Parser::parsePrimaryExpression()
 		break;
 	case Token::LParen:
 	{
+		// Tuple or parenthesized expression.
+		// Special cases: () is empty tuple type, (x) is not a real tuple, (x,) is one-dimensional tuple
 		m_scanner->next();
-		ASTPointer<Expression> expression = parseExpression();
+		vector<ASTPointer<Expression>> components;
+		if (m_scanner->currentToken() != Token::RParen)
+			while (true)
+			{
+				if (m_scanner->currentToken() != Token::Comma && m_scanner->currentToken() != Token::RParen)
+					components.push_back(parseExpression());
+				else
+					components.push_back(ASTPointer<Expression>());
+				if (m_scanner->currentToken() == Token::RParen)
+					break;
+				else if (m_scanner->currentToken() == Token::Comma)
+					m_scanner->next();
+			}
+		nodeFactory.markEndPosition();
 		expectToken(Token::RParen);
-		return expression;
+		return nodeFactory.createNode<TupleExpression>(components);
 	}
 	default:
 		if (Token::isElementaryTypeName(token))
@@ -963,7 +1046,7 @@ ASTPointer<Expression> Parser::parsePrimaryExpression()
 			m_scanner->next();
 		}
 		else
-			BOOST_THROW_EXCEPTION(createParserError("Expected primary expression."));
+			fatalParserError(std::string("Expected primary expression."));
 		break;
 	}
 	return expression;
@@ -1017,7 +1100,7 @@ Parser::LookAheadInfo Parser::peekStatementType() const
 	// We have a variable declaration if we get a keyword that specifies a type name.
 	// If it is an identifier or an elementary type name followed by an identifier, we also have
 	// a variable declaration.
-	// If we get an identifier followed by a "[", it can be both ("type[9] a;" or "arr[9] = 7;").
+	// If we get an identifier followed by a "[" or ".", it can be both ("lib.type[9] a;" or "variable.el[9] = 7;").
 	// In all other cases, we have an expression statement.
 	Token::Value token(m_scanner->currentToken());
 	bool mightBeTypeName = (Token::isElementaryTypeName(token) || token == Token::Identifier);
@@ -1029,25 +1112,36 @@ Parser::LookAheadInfo Parser::peekStatementType() const
 		Token::Value next = m_scanner->peekNextToken();
 		if (next == Token::Identifier || Token::isLocationSpecifier(next))
 			return LookAheadInfo::VariableDeclarationStatement;
-		if (m_scanner->peekNextToken() == Token::LBrack)
+		if (next == Token::LBrack || next == Token::Period)
 			return LookAheadInfo::IndexAccessStructure;
 	}
 	return LookAheadInfo::ExpressionStatement;
 }
 
 ASTPointer<TypeName> Parser::typeNameIndexAccessStructure(
-	ASTPointer<PrimaryExpression> const& _primary,
+	vector<ASTPointer<PrimaryExpression>> const& _path,
 	vector<pair<ASTPointer<Expression>, SourceLocation>> const& _indices
 )
 {
-	ASTNodeFactory nodeFactory(*this, _primary);
+	solAssert(!_path.empty(), "");
+	ASTNodeFactory nodeFactory(*this);
+	SourceLocation location = _path.front()->location();
+	location.end = _path.back()->location().end;
+	nodeFactory.setLocation(location);
+
 	ASTPointer<TypeName> type;
-	if (auto identifier = dynamic_cast<Identifier const*>(_primary.get()))
-		type = nodeFactory.createNode<UserDefinedTypeName>(vector<ASTString>{identifier->name()});
-	else if (auto typeName = dynamic_cast<ElementaryTypeNameExpression const*>(_primary.get()))
+	if (auto typeName = dynamic_cast<ElementaryTypeNameExpression const*>(_path.front().get()))
+	{
+		solAssert(_path.size() == 1, "");
 		type = nodeFactory.createNode<ElementaryTypeName>(typeName->typeToken());
+	}
 	else
-		solAssert(false, "Invalid type name for array look-ahead.");
+	{
+		vector<ASTString> path;
+		for (auto const& el: _path)
+			path.push_back(dynamic_cast<Identifier const&>(*el).name());
+		type = nodeFactory.createNode<UserDefinedTypeName>(path);
+	}
 	for (auto const& lengthExpression: _indices)
 	{
 		nodeFactory.setLocation(lengthExpression.second);
@@ -1057,12 +1151,24 @@ ASTPointer<TypeName> Parser::typeNameIndexAccessStructure(
 }
 
 ASTPointer<Expression> Parser::expressionFromIndexAccessStructure(
-	ASTPointer<PrimaryExpression> const& _primary,
+	vector<ASTPointer<PrimaryExpression>> const& _path,
 	vector<pair<ASTPointer<Expression>, SourceLocation>> const& _indices
 )
 {
-	ASTNodeFactory nodeFactory(*this, _primary);
-	ASTPointer<Expression> expression(_primary);
+	solAssert(!_path.empty(), "");
+	ASTNodeFactory nodeFactory(*this, _path.front());
+	ASTPointer<Expression> expression(_path.front());
+	for (size_t i = 1; i < _path.size(); ++i)
+	{
+		SourceLocation location(_path.front()->location());
+		location.end = _path[i]->location().end;
+		nodeFactory.setLocation(location);
+		Identifier const& identifier = dynamic_cast<Identifier const&>(*_path[i]);
+		expression = nodeFactory.createNode<MemberAccess>(
+			expression,
+			make_shared<ASTString>(identifier.name())
+		);
+	}
 	for (auto const& index: _indices)
 	{
 		nodeFactory.setLocation(index.second);
@@ -1074,7 +1180,7 @@ ASTPointer<Expression> Parser::expressionFromIndexAccessStructure(
 void Parser::expectToken(Token::Value _value)
 {
 	if (m_scanner->currentToken() != _value)
-		BOOST_THROW_EXCEPTION(createParserError(string("Expected token ") + string(Token::name(_value))));
+		fatalParserError(std::string(string("Expected token ") + string(Token::name(_value))));
 	m_scanner->next();
 }
 
@@ -1082,7 +1188,7 @@ Token::Value Parser::expectAssignmentOperator()
 {
 	Token::Value op = m_scanner->currentToken();
 	if (!Token::isAssignmentOp(op))
-		BOOST_THROW_EXCEPTION(createParserError("Expected assignment operator"));
+		fatalParserError(std::string("Expected assignment operator"));
 	m_scanner->next();
 	return op;
 }
@@ -1090,7 +1196,7 @@ Token::Value Parser::expectAssignmentOperator()
 ASTPointer<ASTString> Parser::expectIdentifierToken()
 {
 	if (m_scanner->currentToken() != Token::Identifier)
-		BOOST_THROW_EXCEPTION(createParserError("Expected identifier"));
+		fatalParserError(std::string("Expected identifier"));
 	return getLiteralAndAdvance();
 }
 
@@ -1108,13 +1214,21 @@ ASTPointer<ParameterList> Parser::createEmptyParameterList()
 	return nodeFactory.createNode<ParameterList>(vector<ASTPointer<VariableDeclaration>>());
 }
 
-ParserError Parser::createParserError(string const& _description) const
+void Parser::parserError(string const& _description)
 {
-	return ParserError() <<
+	auto err = make_shared<Error>(Error::Type::ParserError);
+	*err <<
 		errinfo_sourceLocation(SourceLocation(position(), position(), sourceName())) <<
 		errinfo_comment(_description);
+
+	m_errors.push_back(err);
 }
 
+void Parser::fatalParserError(string const& _description)
+{
+	parserError(_description);
+	BOOST_THROW_EXCEPTION(FatalError());
+}
 
 }
 }
diff --git a/libsolidity/Parser.h b/libsolidity/Parser.h
index 043d022b..bd483e09 100644
--- a/libsolidity/Parser.h
+++ b/libsolidity/Parser.h
@@ -34,7 +34,7 @@ class Scanner;
 class Parser
 {
 public:
-	Parser() {}
+	Parser(ErrorList& errors): m_errors(errors){};
 
 	ASTPointer<SourceUnit> parse(std::shared_ptr<Scanner> const& _scanner);
 	std::shared_ptr<std::string const> const& sourceName() const;
@@ -125,14 +125,14 @@ private:
 	/// For source code of the form "a[][8]" ("IndexAccessStructure"), this is not possible to
 	/// decide with constant look-ahead.
 	LookAheadInfo peekStatementType() const;
-	/// Returns a typename parsed in look-ahead fashion from something like "a[8][2**70]".
+	/// Returns a typename parsed in look-ahead fashion from something like "a.b[8][2**70]".
 	ASTPointer<TypeName> typeNameIndexAccessStructure(
-		ASTPointer<PrimaryExpression> const& _primary,
+		std::vector<ASTPointer<PrimaryExpression>> const& _path,
 		std::vector<std::pair<ASTPointer<Expression>, SourceLocation>> const& _indices
 	);
-	/// Returns an expression parsed in look-ahead fashion from something like "a[8][2**70]".
+	/// Returns an expression parsed in look-ahead fashion from something like "a.b[8][2**70]".
 	ASTPointer<Expression> expressionFromIndexAccessStructure(
-		ASTPointer<PrimaryExpression> const& _primary,
+		std::vector<ASTPointer<PrimaryExpression>> const& _path,
 		std::vector<std::pair<ASTPointer<Expression>, SourceLocation>> const& _indices
 	);
 	/// If current token value is not _value, throw exception otherwise advance token.
@@ -145,13 +145,19 @@ private:
 	/// Creates an empty ParameterList at the current location (used if parameters can be omitted).
 	ASTPointer<ParameterList> createEmptyParameterList();
 
-	/// Creates a @ref ParserError exception and annotates it with the current position and the
+	/// Creates a @ref ParserError and annotates it with the current position and the
 	/// given @a _description.
-	ParserError createParserError(std::string const& _description) const;
+	void parserError(std::string const& _description);
+
+	/// Creates a @ref ParserError and annotates it with the current position and the
+	/// given @a _description. Throws the FatalError.
+	void fatalParserError(std::string const& _description);
 
 	std::shared_ptr<Scanner> m_scanner;
 	/// Flag that signifies whether '_' is parsed as a PlaceholderStatement or a regular identifier.
 	bool m_insideModifier = false;
+	/// The reference to the list of errors and warning to add errors/warnings during parsing
+	ErrorList& m_errors;
 };
 
 }
diff --git a/libsolidity/ReferencesResolver.cpp b/libsolidity/ReferencesResolver.cpp
index 32c1728f..b1112dd9 100644
--- a/libsolidity/ReferencesResolver.cpp
+++ b/libsolidity/ReferencesResolver.cpp
@@ -57,7 +57,7 @@ bool ReferencesResolver::visit(UserDefinedTypeName const& _typeName)
 	Declaration const* declaration = m_resolver.pathFromCurrentScope(_typeName.namePath());
 	if (!declaration)
 		BOOST_THROW_EXCEPTION(
-			DeclarationError() <<
+			Error(Error::Type::DeclarationError) <<
 			errinfo_sourceLocation(_typeName.location()) <<
 			errinfo_comment("Identifier not found or not unique.")
 		);
@@ -70,7 +70,7 @@ bool ReferencesResolver::visit(Identifier const& _identifier)
 	auto declarations = m_resolver.nameFromCurrentScope(_identifier.name());
 	if (declarations.empty())
 		BOOST_THROW_EXCEPTION(
-			DeclarationError() <<
+			Error(Error::Type::DeclarationError) <<
 			errinfo_sourceLocation(_identifier.location()) <<
 			errinfo_comment("Undeclared identifier.")
 		);
diff --git a/libsolidity/TypeChecker.cpp b/libsolidity/TypeChecker.cpp
index 5bbbd072..5ea5825d 100644
--- a/libsolidity/TypeChecker.cpp
+++ b/libsolidity/TypeChecker.cpp
@@ -43,14 +43,7 @@ bool TypeChecker::checkTypeRequirements(const ContractDefinition& _contract)
 		if (m_errors.empty())
 			throw; // Something is weird here, rather throw again.
 	}
-	bool success = true;
-	for (auto const& it: m_errors)
-		if (!dynamic_cast<Warning const*>(it.get()))
-		{
-			success = false;
-			break;
-		}
-	return success;
+	return Error::containsOnlyWarnings(m_errors);
 }
 
 TypePointer const& TypeChecker::type(Expression const& _expression) const
@@ -87,7 +80,7 @@ bool TypeChecker::visit(ContractDefinition const& _contract)
 		{
 			if (fallbackFunction)
 			{
-				auto err = make_shared<DeclarationError>();
+				auto err = make_shared<Error>(Error::Type::DeclarationError);
 				*err << errinfo_comment("Only one fallback function is allowed.");
 				m_errors.push_back(err);
 			}
@@ -143,7 +136,7 @@ void TypeChecker::checkContractDuplicateFunctions(ContractDefinition const& _con
 		for (; it != functions[_contract.name()].end(); ++it)
 			ssl.append("Another declaration is here:", (*it)->location());
 
-		auto err = make_shared<DeclarationError>();
+		auto err = make_shared<Error>(Error(Error::Type::DeclarationError));
 		*err <<
 			errinfo_sourceLocation(functions[_contract.name()].front()->location()) <<
 			errinfo_comment("More than one constructor defined.") <<
@@ -157,7 +150,7 @@ void TypeChecker::checkContractDuplicateFunctions(ContractDefinition const& _con
 			for (size_t j = i + 1; j < overloads.size(); ++j)
 				if (FunctionType(*overloads[i]).hasEqualArgumentTypes(FunctionType(*overloads[j])))
 				{
-					auto err = make_shared<DeclarationError>();
+					auto err = make_shared<Error>(Error(Error::Type::DeclarationError));
 					*err <<
 						errinfo_sourceLocation(overloads[j]->location()) <<
 						errinfo_comment("Function with same name and arguments defined twice.") <<
@@ -424,16 +417,17 @@ bool TypeChecker::visit(VariableDeclaration const& _variable)
 	// Note that assignments before the first declaration are legal because of the special scoping
 	// rules inherited from JavaScript.
 
-	// This only infers the type from its type name.
-	// If an explicit type is required, it throws, otherwise it returns TypePointer();
+	// type is filled either by ReferencesResolver directly from the type name or by
+	// TypeChecker at the VariableDeclarationStatement level.
 	TypePointer varType = _variable.annotation().type;
+	solAssert(!!varType, "Failed to infer variable type.");
 	if (_variable.isConstant())
 	{
 		if (!dynamic_cast<ContractDefinition const*>(_variable.scope()))
 			typeError(_variable, "Illegal use of \"constant\" specifier.");
 		if (!_variable.value())
 			typeError(_variable, "Uninitialized \"constant\" variable.");
-		if (varType && !varType->isValueType())
+		if (!varType->isValueType())
 		{
 			bool constImplemented = false;
 			if (auto arrayType = dynamic_cast<ArrayType const*>(varType.get()))
@@ -446,43 +440,8 @@ bool TypeChecker::visit(VariableDeclaration const& _variable)
 				);
 		}
 	}
-	if (varType)
-	{
-		if (_variable.value())
-			expectType(*_variable.value(), *varType);
-		else
-		{
-			if (auto ref = dynamic_cast<ReferenceType const *>(varType.get()))
-				if (ref->dataStoredIn(DataLocation::Storage) && _variable.isLocalVariable() && !_variable.isCallableParameter())
-				{
-					auto err = make_shared<Warning>();
-					*err <<
-						errinfo_sourceLocation(_variable.location()) <<
-						errinfo_comment("Uninitialized storage pointer. Did you mean '<type> memory " + _variable.name() + "'?");
-					m_errors.push_back(err);
-				}
-		}
-	}
-	else
-	{
-		// Infer type from value.
-		if (!_variable.value())
-			fatalTypeError(_variable, "Assignment necessary for type detection.");
-		_variable.value()->accept(*this);
-
-		TypePointer const& valueType = type(*_variable.value());
-		solAssert(!!valueType, "");
-		if (
-			valueType->category() == Type::Category::IntegerConstant &&
-			!dynamic_pointer_cast<IntegerConstantType const>(valueType)->integerType()
-		)
-			fatalTypeError(*_variable.value(), "Invalid integer constant " + valueType->toString() + ".");
-		else if (valueType->category() == Type::Category::Void)
-			fatalTypeError(_variable, "Variable cannot have void type.");
-		varType = valueType->mobileType();
-	}
-	solAssert(!!varType, "");
-	_variable.annotation().type = varType;
+	if (_variable.value())
+		expectType(*_variable.value(), *varType);
 	if (!_variable.isStateVariable())
 	{
 		if (varType->dataStoredIn(DataLocation::Memory) || varType->dataStoredIn(DataLocation::CallData))
@@ -601,13 +560,31 @@ void TypeChecker::endVisit(Return const& _return)
 		return;
 	ParameterList const* params = _return.annotation().functionReturnParameters;
 	if (!params)
+	{
 		typeError(_return, "Return arguments not allowed.");
+		return;
+	}
+	TypePointers returnTypes;
+	for (auto const& var: params->parameters())
+		returnTypes.push_back(type(*var));
+	if (auto tupleType = dynamic_cast<TupleType const*>(type(*_return.expression()).get()))
+	{
+		if (tupleType->components().size() != params->parameters().size())
+			typeError(_return, "Different number of arguments in return statement than in returns declaration.");
+		else if (!tupleType->isImplicitlyConvertibleTo(TupleType(returnTypes)))
+			typeError(
+				*_return.expression(),
+				"Return argument type " +
+				type(*_return.expression())->toString() +
+				" is not implicitly convertible to expected type " +
+				TupleType(returnTypes).toString(false) +
+				"."
+			);
+	}
 	else if (params->parameters().size() != 1)
 		typeError(_return, "Different number of arguments in return statement than in returns declaration.");
 	else
 	{
-		// this could later be changed such that the paramaters type is an anonymous struct type,
-		// but for now, we only allow one return parameter
 		TypePointer const& expected = type(*params->parameters().front());
 		if (!type(*_return.expression())->isImplicitlyConvertibleTo(*expected))
 			typeError(
@@ -621,6 +598,126 @@ void TypeChecker::endVisit(Return const& _return)
 	}
 }
 
+bool TypeChecker::visit(VariableDeclarationStatement const& _statement)
+{
+	if (!_statement.initialValue())
+	{
+		// No initial value is only permitted for single variables with specified type.
+		if (_statement.declarations().size() != 1 || !_statement.declarations().front())
+			fatalTypeError(_statement, "Assignment necessary for type detection.");
+		VariableDeclaration const& varDecl = *_statement.declarations().front();
+		if (!varDecl.annotation().type)
+			fatalTypeError(_statement, "Assignment necessary for type detection.");
+		if (auto ref = dynamic_cast<ReferenceType const*>(type(varDecl).get()))
+		{
+			if (ref->dataStoredIn(DataLocation::Storage))
+			{
+				auto err = make_shared<Error>(Error::Type::Warning);
+				*err <<
+					errinfo_sourceLocation(varDecl.location()) <<
+					errinfo_comment("Uninitialized storage pointer. Did you mean '<type> memory " + varDecl.name() + "'?");
+				m_errors.push_back(err);
+			}
+		}
+		varDecl.accept(*this);
+		return false;
+	}
+
+	// Here we have an initial value and might have to derive some types before we can visit
+	// the variable declaration(s).
+
+	_statement.initialValue()->accept(*this);
+	TypePointers valueTypes;
+	if (auto tupleType = dynamic_cast<TupleType const*>(type(*_statement.initialValue()).get()))
+		valueTypes = tupleType->components();
+	else
+		valueTypes = TypePointers{type(*_statement.initialValue())};
+
+	// Determine which component is assigned to which variable.
+	// If numbers do not match, fill up if variables begin or end empty (not both).
+	vector<VariableDeclaration const*>& assignments = _statement.annotation().assignments;
+	assignments.resize(valueTypes.size(), nullptr);
+	vector<ASTPointer<VariableDeclaration>> const& variables = _statement.declarations();
+	if (variables.empty())
+	{
+		if (!valueTypes.empty())
+			fatalTypeError(
+				_statement,
+				"Too many components (" +
+				toString(valueTypes.size()) +
+				") in value for variable assignment (0) needed"
+			);
+	}
+	else if (valueTypes.size() != variables.size() && !variables.front() && !variables.back())
+		fatalTypeError(
+			_statement,
+			"Wildcard both at beginning and end of variable declaration list is only allowed "
+			"if the number of components is equal."
+		);
+	size_t minNumValues = variables.size();
+	if (!variables.empty() && (!variables.back() || !variables.front()))
+		--minNumValues;
+	if (valueTypes.size() < minNumValues)
+		fatalTypeError(
+			_statement,
+			"Not enough components (" +
+			toString(valueTypes.size()) +
+			") in value to assign all variables (" +
+			toString(minNumValues) + ")."
+		);
+	if (valueTypes.size() > variables.size() && variables.front() && variables.back())
+		fatalTypeError(
+			_statement,
+			"Too many components (" +
+			toString(valueTypes.size()) +
+			") in value for variable assignment (" +
+			toString(minNumValues) +
+			" needed)."
+		);
+	bool fillRight = !variables.empty() && (!variables.back() || variables.front());
+	for (size_t i = 0; i < min(variables.size(), valueTypes.size()); ++i)
+		if (fillRight)
+			assignments[i] = variables[i].get();
+		else
+			assignments[assignments.size() - i - 1] = variables[variables.size() - i - 1].get();
+
+	for (size_t i = 0; i < assignments.size(); ++i)
+	{
+		if (!assignments[i])
+			continue;
+		VariableDeclaration const& var = *assignments[i];
+		solAssert(!var.value(), "Value has to be tied to statement.");
+		TypePointer const& valueComponentType = valueTypes[i];
+		solAssert(!!valueComponentType, "");
+		if (!var.annotation().type)
+		{
+			// Infer type from value.
+			solAssert(!var.typeName(), "");
+			if (
+				valueComponentType->category() == Type::Category::IntegerConstant &&
+				!dynamic_pointer_cast<IntegerConstantType const>(valueComponentType)->integerType()
+			)
+				fatalTypeError(*_statement.initialValue(), "Invalid integer constant " + valueComponentType->toString() + ".");
+			var.annotation().type = valueComponentType->mobileType();
+			var.accept(*this);
+		}
+		else
+		{
+			var.accept(*this);
+			if (!valueComponentType->isImplicitlyConvertibleTo(*var.annotation().type))
+				typeError(
+					_statement,
+					"Type " +
+					valueComponentType->toString() +
+					" is not implicitly convertible to expected type " +
+					var.annotation().type->toString() +
+					"."
+				);
+		}
+	}
+	return false;
+}
+
 void TypeChecker::endVisit(ExpressionStatement const& _statement)
 {
 	if (type(_statement.expression())->category() == Type::Category::IntegerConstant)
@@ -633,7 +730,13 @@ bool TypeChecker::visit(Assignment const& _assignment)
 	requireLValue(_assignment.leftHandSide());
 	TypePointer t = type(_assignment.leftHandSide());
 	_assignment.annotation().type = t;
-	if (t->category() == Type::Category::Mapping)
+	if (TupleType const* tupleType = dynamic_cast<TupleType const*>(t.get()))
+	{
+		// Sequenced assignments of tuples is not valid, make the result a "void" type.
+		_assignment.annotation().type = make_shared<TupleType>();
+		expectType(_assignment.rightHandSide(), *tupleType);
+	}
+	else if (t->category() == Type::Category::Mapping)
 	{
 		typeError(_assignment, "Mappings cannot be assigned to.");
 		_assignment.rightHandSide().accept(*this);
@@ -662,6 +765,51 @@ bool TypeChecker::visit(Assignment const& _assignment)
 	return false;
 }
 
+bool TypeChecker::visit(TupleExpression const& _tuple)
+{
+	vector<ASTPointer<Expression>> const& components = _tuple.components();
+	TypePointers types;
+	if (_tuple.annotation().lValueRequested)
+	{
+		for (auto const& component: components)
+			if (component)
+			{
+				requireLValue(*component);
+				types.push_back(type(*component));
+			}
+			else
+				types.push_back(TypePointer());
+		_tuple.annotation().type = make_shared<TupleType>(types);
+		// If some of the components are not LValues, the error is reported above.
+		_tuple.annotation().isLValue = true;
+	}
+	else
+	{
+		for (size_t i = 0; i < components.size(); ++i)
+		{
+			// Outside of an lvalue-context, the only situation where a component can be empty is (x,).
+			if (!components[i] && !(i == 1 && components.size() == 2))
+				fatalTypeError(_tuple, "Tuple component cannot be empty.");
+			else if (components[i])
+			{
+				components[i]->accept(*this);
+				types.push_back(type(*components[i]));
+			}
+			else
+				types.push_back(TypePointer());
+		}
+		if (components.size() == 1)
+			_tuple.annotation().type = type(*components[0]);
+		else
+		{
+			if (components.size() == 2 && !components[1])
+				types.pop_back();
+			_tuple.annotation().type = make_shared<TupleType>(types);
+		}
+	}
+	return false;
+}
+
 bool TypeChecker::visit(UnaryOperation const& _operation)
 {
 	// Inc, Dec, Add, Sub, Not, BitNot, Delete
@@ -785,23 +933,14 @@ bool TypeChecker::visit(FunctionCall const& _functionCall)
 	if (!functionType)
 	{
 		typeError(_functionCall, "Type is not callable");
-		_functionCall.annotation().type = make_shared<VoidType>();
+		_functionCall.annotation().type = make_shared<TupleType>();
 		return false;
 	}
+	else if (functionType->returnParameterTypes().size() == 1)
+		_functionCall.annotation().type = functionType->returnParameterTypes().front();
 	else
-	{
-		// @todo actually the return type should be an anonymous struct,
-		// but we change it to the type of the first return value until we have anonymous
-		// structs and tuples
-		if (functionType->returnParameterTypes().empty())
-			_functionCall.annotation().type = make_shared<VoidType>();
-		else
-			_functionCall.annotation().type = functionType->returnParameterTypes().front();
-	}
+		_functionCall.annotation().type = make_shared<TupleType>(functionType->returnParameterTypes());
 
-	//@todo would be nice to create a struct type from the arguments
-	// and then ask if that is implicitly convertible to the struct represented by the
-	// function parameters
 	TypePointers const& parameterTypes = functionType->parameterTypes();
 	if (!functionType->takesArbitraryParameters() && parameterTypes.size() != arguments.size())
 	{
@@ -1166,15 +1305,15 @@ void TypeChecker::expectType(Expression const& _expression, Type const& _expecte
 
 void TypeChecker::requireLValue(Expression const& _expression)
 {
+	_expression.annotation().lValueRequested = true;
 	_expression.accept(*this);
 	if (!_expression.annotation().isLValue)
 		typeError(_expression, "Expression has to be an lvalue.");
-	_expression.annotation().lValueRequested = true;
 }
 
 void TypeChecker::typeError(ASTNode const& _node, string const& _description)
 {
-	auto err = make_shared<TypeError>();
+	auto err = make_shared<Error>(Error::Type::TypeError);
 	*err <<
 		errinfo_sourceLocation(_node.location()) <<
 		errinfo_comment(_description);
diff --git a/libsolidity/TypeChecker.h b/libsolidity/TypeChecker.h
index 97262ed0..7af5473b 100644
--- a/libsolidity/TypeChecker.h
+++ b/libsolidity/TypeChecker.h
@@ -42,26 +42,26 @@ namespace solidity
 class TypeChecker: private ASTConstVisitor
 {
 public:
+	/// @param _errors the reference to the list of errors and warnings to add them found during type checking.
+	TypeChecker(ErrorList& _errors): m_errors(_errors) {}
+
 	/// Performs type checking on the given contract and all of its sub-nodes.
 	/// @returns true iff all checks passed. Note even if all checks passed, errors() can still contain warnings
 	bool checkTypeRequirements(ContractDefinition const& _contract);
 
-	/// @returns the list of errors and warnings found during type checking.
-	std::vector<std::shared_ptr<Error const>> const& errors() const { return m_errors; }
-
 	/// @returns the type of an expression and asserts that it is present.
 	TypePointer const& type(Expression const& _expression) const;
 	/// @returns the type of the given variable and throws if the type is not present
 	/// (this can happen for variables with non-explicit types before their types are resolved)
 	TypePointer const& type(VariableDeclaration const& _variable) const;
 
+private:
 	/// Adds a new error to the list of errors.
 	void typeError(ASTNode const& _node, std::string const& _description);
 
 	/// Adds a new error to the list of errors and throws to abort type checking.
 	void fatalTypeError(ASTNode const& _node, std::string const& _description);
 
-private:
 	virtual bool visit(ContractDefinition const& _contract) override;
 	/// Checks that two functions defined in this contract with the same name have different
 	/// arguments and that there is at most one constructor.
@@ -87,8 +87,10 @@ private:
 	virtual bool visit(WhileStatement const& _whileStatement) override;
 	virtual bool visit(ForStatement const& _forStatement) override;
 	virtual void endVisit(Return const& _return) override;
+	virtual bool visit(VariableDeclarationStatement const& _variable) override;
 	virtual void endVisit(ExpressionStatement const& _statement) override;
 	virtual bool visit(Assignment const& _assignment) override;
+	virtual bool visit(TupleExpression const& _tuple) override;
 	virtual void endVisit(BinaryOperation const& _operation) override;
 	virtual bool visit(UnaryOperation const& _operation) override;
 	virtual bool visit(FunctionCall const& _functionCall) override;
@@ -113,7 +115,7 @@ private:
 	/// Runs type checks on @a _expression to infer its type and then checks that it is an LValue.
 	void requireLValue(Expression const& _expression);
 
-	std::vector<std::shared_ptr<Error const>> m_errors;
+	ErrorList& m_errors;
 };
 
 }
diff --git a/libsolidity/Types.cpp b/libsolidity/Types.cpp
index f0c67bba..02b86a7f 100644
--- a/libsolidity/Types.cpp
+++ b/libsolidity/Types.cpp
@@ -50,7 +50,7 @@ void StorageOffsets::computeOffsets(TypePointers const& _types)
 			byteOffset = 0;
 		}
 		if (slotOffset >= bigint(1) << 256)
-			BOOST_THROW_EXCEPTION(TypeError() << errinfo_comment("Object too large for storage."));
+			BOOST_THROW_EXCEPTION(Error(Error::Type::TypeError) << errinfo_comment("Object too large for storage."));
 		offsets[i] = make_pair(u256(slotOffset), byteOffset);
 		solAssert(type->storageSize() >= 1, "Invalid storage size.");
 		if (type->storageSize() == 1 && byteOffset + type->storageBytes() <= 32)
@@ -64,7 +64,7 @@ void StorageOffsets::computeOffsets(TypePointers const& _types)
 	if (byteOffset > 0)
 		++slotOffset;
 	if (slotOffset >= bigint(1) << 256)
-		BOOST_THROW_EXCEPTION(TypeError() << errinfo_comment("Object too large for storage."));
+		BOOST_THROW_EXCEPTION(Error(Error::Type::TypeError) << errinfo_comment("Object too large for storage."));
 	m_storageSize = u256(slotOffset);
 	swap(m_offsets, offsets);
 }
@@ -223,7 +223,7 @@ TypePointer IntegerType::unaryOperatorResult(Token::Value _operator) const
 {
 	// "delete" is ok for all integer types
 	if (_operator == Token::Delete)
-		return make_shared<VoidType>();
+		return make_shared<TupleType>();
 	// no further unary operators for addresses
 	else if (isAddress())
 		return TypePointer();
@@ -562,7 +562,7 @@ TypePointer FixedBytesType::unaryOperatorResult(Token::Value _operator) const
 {
 	// "delete" and "~" is okay for FixedBytesType
 	if (_operator == Token::Delete)
-		return make_shared<VoidType>();
+		return make_shared<TupleType>();
 	else if (_operator == Token::BitNot)
 		return shared_from_this();
 
@@ -617,7 +617,7 @@ u256 BoolType::literalValue(Literal const* _literal) const
 TypePointer BoolType::unaryOperatorResult(Token::Value _operator) const
 {
 	if (_operator == Token::Delete)
-		return make_shared<VoidType>();
+		return make_shared<TupleType>();
 	return (_operator == Token::Not) ? shared_from_this() : TypePointer();
 }
 
@@ -658,7 +658,7 @@ bool ContractType::isExplicitlyConvertibleTo(Type const& _convertTo) const
 
 TypePointer ContractType::unaryOperatorResult(Token::Value _operator) const
 {
-	return _operator == Token::Delete ? make_shared<VoidType>() : TypePointer();
+	return _operator == Token::Delete ? make_shared<TupleType>() : TypePointer();
 }
 
 TypePointer ReferenceType::unaryOperatorResult(Token::Value _operator) const
@@ -672,9 +672,9 @@ TypePointer ReferenceType::unaryOperatorResult(Token::Value _operator) const
 	case DataLocation::CallData:
 		return TypePointer();
 	case DataLocation::Memory:
-		return make_shared<VoidType>();
+		return make_shared<TupleType>();
 	case DataLocation::Storage:
-		return m_isPointer ? TypePointer() : make_shared<VoidType>();
+		return m_isPointer ? TypePointer() : make_shared<TupleType>();
 	default:
 		solAssert(false, "");
 	}
@@ -805,7 +805,7 @@ u256 ArrayType::storageSize() const
 	else
 		size = bigint(length()) * baseType()->storageSize();
 	if (size >= bigint(1) << 256)
-		BOOST_THROW_EXCEPTION(TypeError() << errinfo_comment("Array too large for storage."));
+		BOOST_THROW_EXCEPTION(Error(Error::Type::TypeError) << errinfo_comment("Array too large for storage."));
 	return max<u256>(1, u256(size));
 }
 
@@ -858,6 +858,28 @@ string ArrayType::canonicalName(bool _addDataLocation) const
 	return ret;
 }
 
+MemberList const& ArrayType::members() const
+{
+	if (!m_members)
+	{
+		MemberList::MemberMap members;
+		if (!isString())
+		{
+			members.push_back({"length", make_shared<IntegerType>(256)});
+			if (isDynamicallySized() && location() == DataLocation::Storage)
+				members.push_back({"push", make_shared<FunctionType>(
+					TypePointers{baseType()},
+					TypePointers{make_shared<IntegerType>(256)},
+					strings{string()},
+					strings{string()},
+					isByteArray() ? FunctionType::Location::ByteArrayPush : FunctionType::Location::ArrayPush
+				)});
+		}
+		m_members.reset(new MemberList(members));
+	}
+	return *m_members;
+}
+
 TypePointer ArrayType::encodingType() const
 {
 	if (location() == DataLocation::Storage)
@@ -913,8 +935,6 @@ TypePointer ArrayType::copyForLocation(DataLocation _location, bool _isPointer)
 	return copy;
 }
 
-const MemberList ArrayType::s_arrayTypeMemberList({{"length", make_shared<IntegerType>(256)}});
-
 bool ContractType::operator==(Type const& _other) const
 {
 	if (_other.category() != category())
@@ -1175,7 +1195,7 @@ set<string> StructType::membersMissingInMemory() const
 
 TypePointer EnumType::unaryOperatorResult(Token::Value _operator) const
 {
-	return _operator == Token::Delete ? make_shared<VoidType>() : TypePointer();
+	return _operator == Token::Delete ? make_shared<TupleType>() : TypePointer();
 }
 
 bool EnumType::operator==(Type const& _other) const
@@ -1222,6 +1242,97 @@ unsigned int EnumType::memberValue(ASTString const& _member) const
 	BOOST_THROW_EXCEPTION(m_enum.createTypeError("Requested unknown enum value ." + _member));
 }
 
+bool TupleType::isImplicitlyConvertibleTo(Type const& _other) const
+{
+	if (auto tupleType = dynamic_cast<TupleType const*>(&_other))
+	{
+		TypePointers const& targets = tupleType->components();
+		if (targets.empty())
+			return components().empty();
+		if (components().size() != targets.size() && !targets.front() && !targets.back())
+			return false; // (,a,) = (1,2,3,4) - unable to position `a` in the tuple.
+		size_t minNumValues = targets.size();
+		if (!targets.back() || !targets.front())
+			--minNumValues; // wildcards can also match 0 components
+		if (components().size() < minNumValues)
+			return false;
+		if (components().size() > targets.size() && targets.front() && targets.back())
+			return false; // larger source and no wildcard
+		bool fillRight = !targets.back() || targets.front();
+		for (size_t i = 0; i < min(targets.size(), components().size()); ++i)
+		{
+			auto const& s = components()[fillRight ? i : components().size() - i - 1];
+			auto const& t = targets[fillRight ? i : targets.size() - i - 1];
+			if (!s && t)
+				return false;
+			else if (s && t && !s->isImplicitlyConvertibleTo(*t))
+				return false;
+		}
+		return true;
+	}
+	else
+		return false;
+}
+
+bool TupleType::operator==(Type const& _other) const
+{
+	if (auto tupleType = dynamic_cast<TupleType const*>(&_other))
+		return components() == tupleType->components();
+	else
+		return false;
+}
+
+string TupleType::toString(bool _short) const
+{
+	if (components().empty())
+		return "tuple()";
+	string str = "tuple(";
+	for (auto const& t: components())
+		str += (t ? t->toString(_short) : "") + ",";
+	str.pop_back();
+	return str + ")";
+}
+
+u256 TupleType::storageSize() const
+{
+	BOOST_THROW_EXCEPTION(
+		InternalCompilerError() <<
+		errinfo_comment("Storage size of non-storable tuple type requested.")
+	);
+}
+
+unsigned TupleType::sizeOnStack() const
+{
+	unsigned size = 0;
+	for (auto const& t: components())
+		size += t ? t->sizeOnStack() : 0;
+	return size;
+}
+
+TypePointer TupleType::mobileType() const
+{
+	TypePointers mobiles;
+	for (auto const& c: components())
+		mobiles.push_back(c ? c->mobileType() : TypePointer());
+	return make_shared<TupleType>(mobiles);
+}
+
+TypePointer TupleType::closestTemporaryType(TypePointer const& _targetType) const
+{
+	solAssert(!!_targetType, "");
+	TypePointers const& targetComponents = dynamic_cast<TupleType const&>(*_targetType).components();
+	bool fillRight = !targetComponents.empty() && (!targetComponents.back() || targetComponents.front());
+	TypePointers tempComponents(targetComponents.size());
+	for (size_t i = 0; i < min(targetComponents.size(), components().size()); ++i)
+	{
+		size_t si = fillRight ? i : components().size() - i - 1;
+		size_t ti = fillRight ? i : targetComponents.size() - i - 1;
+		if (components()[si] && targetComponents[ti])
+			tempComponents[ti] = components()[si]->closestTemporaryType(targetComponents[ti]);
+	}
+	return make_shared<TupleType>(tempComponents);
+}
+
 FunctionType::FunctionType(FunctionDefinition const& _function, bool _isInternal):
 	m_location(_isInternal ? Location::Internal : Location::External),
 	m_isConstant(_function.isDeclaredConst()),
@@ -1387,6 +1498,8 @@ unsigned FunctionType::sizeOnStack() const
 		size = 1;
 	else if (location == Location::Internal)
 		size = 1;
+	else if (location == Location::ArrayPush || location == Location::ByteArrayPush)
+		size = 1;
 	if (m_gasSet)
 		size++;
 	if (m_valueSet)
@@ -1581,14 +1694,15 @@ FunctionTypePointer FunctionType::asMemberFunction(bool _inLibrary) const
 			parameterTypes.push_back(t);
 	}
 
-	//@todo make this more intelligent once we support destructuring assignments
+	// Removes dynamic types.
 	TypePointers returnParameterTypes;
 	vector<string> returnParameterNames;
-	if (!m_returnParameterTypes.empty() && m_returnParameterTypes.front()->calldataEncodedSize() > 0)
-	{
-		returnParameterTypes.push_back(m_returnParameterTypes.front());
-		returnParameterNames.push_back(m_returnParameterNames.front());
-	}
+	for (size_t i = 0; i < m_returnParameterTypes.size(); ++i)
+		if (m_returnParameterTypes[i]->calldataEncodedSize() > 0)
+		{
+			returnParameterTypes.push_back(m_returnParameterTypes[i]);
+			returnParameterNames.push_back(m_returnParameterNames[i]);
+		}
 	return make_shared<FunctionType>(
 		parameterTypes,
 		returnParameterTypes,
@@ -1647,13 +1761,6 @@ string MappingType::canonicalName(bool) const
 	return "mapping(" + keyType()->canonicalName(false) + " => " + valueType()->canonicalName(false) + ")";
 }
 
-u256 VoidType::storageSize() const
-{
-	BOOST_THROW_EXCEPTION(
-		InternalCompilerError()
-			<< errinfo_comment("Storage size of non-storable void type requested."));
-}
-
 bool TypeType::operator==(Type const& _other) const
 {
 	if (_other.category() != category())
diff --git a/libsolidity/Types.h b/libsolidity/Types.h
index 7a65ca92..626ebbe4 100644
--- a/libsolidity/Types.h
+++ b/libsolidity/Types.h
@@ -132,8 +132,8 @@ public:
 	enum class Category
 	{
 		Integer, IntegerConstant, StringLiteral, Bool, Real, Array,
-		FixedBytes, Contract, Struct, Function, Enum,
-		Mapping, Void, TypeType, Modifier, Magic
+		FixedBytes, Contract, Struct, Function, Enum, Tuple,
+		Mapping, TypeType, Modifier, Magic
 	};
 
 	/// @{
@@ -210,6 +210,13 @@ public:
 	/// @returns true if this is a non-value type and the data of this type is stored at the
 	/// given location.
 	virtual bool dataStoredIn(DataLocation) const { return false; }
+	/// @returns the type of a temporary during assignment to a variable of the given type.
+	/// Specifically, returns the requested itself if it can be dynamically allocated (or is a value type)
+	/// and the mobile type otherwise.
+	virtual TypePointer closestTemporaryType(TypePointer const& _targetType) const
+	{
+		return _targetType->dataStoredIn(DataLocation::Storage) ? mobileType() : _targetType;
+	}
 
 	/// Returns the list of all members of this type. Default implementation: no members.
 	virtual MemberList const& members() const { return EmptyMemberList; }
@@ -505,10 +512,7 @@ public:
 	virtual unsigned sizeOnStack() const override;
 	virtual std::string toString(bool _short) const override;
 	virtual std::string canonicalName(bool _addDataLocation) const override;
-	virtual MemberList const& members() const override
-	{
-		return isString() ? EmptyMemberList : s_arrayTypeMemberList;
-	}
+	virtual MemberList const& members() const override;
 	virtual TypePointer encodingType() const override;
 	virtual TypePointer decodingType() const override;
 	virtual TypePointer interfaceType(bool _inLibrary) const override;
@@ -532,7 +536,8 @@ private:
 	TypePointer m_baseType;
 	bool m_hasDynamicLength = true;
 	u256 m_length;
-	static const MemberList s_arrayTypeMemberList;
+	/// List of member types, will be lazy-initialized because of recursive references.
+	mutable std::unique_ptr<MemberList> m_members;
 };
 
 /**
@@ -682,6 +687,33 @@ private:
 	mutable std::unique_ptr<MemberList> m_members;
 };
 
+/**
+ * Type that can hold a finite sequence of values of different types.
+ * In some cases, the components are empty pointers (when used as placeholders).
+ */
+class TupleType: public Type
+{
+public:
+	virtual Category category() const override { return Category::Tuple; }
+	explicit TupleType(std::vector<TypePointer> const& _types = std::vector<TypePointer>()): m_components(_types) {}
+	virtual bool isImplicitlyConvertibleTo(Type const& _other) const override;
+	virtual bool operator==(Type const& _other) const override;
+	virtual TypePointer binaryOperatorResult(Token::Value, TypePointer const&) const override { return TypePointer(); }
+	virtual std::string toString(bool) const override;
+	virtual bool canBeStored() const override { return false; }
+	virtual u256 storageSize() const override;
+	virtual bool canLiveOutsideStorage() const override { return false; }
+	virtual unsigned sizeOnStack() const override;
+	virtual TypePointer mobileType() const override;
+	/// Converts components to their temporary types and performs some wildcard matching.
+	virtual TypePointer closestTemporaryType(TypePointer const& _targetType) const override;
+
+	std::vector<TypePointer> const& components() const { return m_components; }
+
+private:
+	std::vector<TypePointer> const m_components;
+};
+
 /**
  * The type of a function, identified by its (return) parameter types.
  * @todo the return parameters should also have names, i.e. return parameters should be a struct
@@ -714,7 +746,9 @@ public:
 		Event, ///< syntactic sugar for LOG*
 		SetGas, ///< modify the default gas value for the function call
 		SetValue, ///< modify the default value transfer for the function call
-		BlockHash ///< BLOCKHASH
+		BlockHash, ///< BLOCKHASH
+		ArrayPush, ///< .push() to a dynamically sized array in storage
+		ByteArrayPush ///< .push() to a dynamically sized byte array in storage
 	};
 
 	virtual Category category() const override { return Category::Function; }
@@ -874,24 +908,6 @@ private:
 	TypePointer m_valueType;
 };
 
-/**
- * The void type, can only be implicitly used as the type that is returned by functions without
- * return parameters.
- */
-class VoidType: public Type
-{
-public:
-	virtual Category category() const override { return Category::Void; }
-	VoidType() {}
-
-	virtual TypePointer binaryOperatorResult(Token::Value, TypePointer const&) const override { return TypePointer(); }
-	virtual std::string toString(bool) const override { return "void"; }
-	virtual bool canBeStored() const override { return false; }
-	virtual u256 storageSize() const override;
-	virtual bool canLiveOutsideStorage() const override { return false; }
-	virtual unsigned sizeOnStack() const override { return 0; }
-};
-
 /**
  * The type of a type reference. The type of "uint32" when used in "a = uint32(2)" is an example
  * of a TypeType.
diff --git a/libsolidity/Utils.h b/libsolidity/Utils.h
index 6c8e3b33..48bb1e47 100644
--- a/libsolidity/Utils.h
+++ b/libsolidity/Utils.h
@@ -25,6 +25,14 @@
 #include <libdevcore/Assertions.h>
 #include <libsolidity/Exceptions.h>
 
+namespace dev
+{
+namespace solidity
+{
+struct InternalCompilerError;
+}
+}
+
 /// Assertion that throws an InternalCompilerError containing the given description if it is not met.
 #define solAssert(CONDITION, DESCRIPTION) \
 	assertThrow(CONDITION, ::dev::solidity::InternalCompilerError, DESCRIPTION)
diff --git a/solc/CMakeLists.txt b/solc/CMakeLists.txt
index 40ab0e21..7dd24627 100644
--- a/solc/CMakeLists.txt
+++ b/solc/CMakeLists.txt
@@ -18,7 +18,7 @@ else()
 endif()
 
 if (EMSCRIPTEN)
-	set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -s EXPORTED_FUNCTIONS='[\"_compileJSON\",\"_version\"]'")
+	set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -s EXPORTED_FUNCTIONS='[\"_compileJSON\",\"_version\",\"_compileJSONMulti\"]'")
 	add_executable(soljson jsonCompiler.cpp ${HEADERS})
 	eth_use(soljson REQUIRED Solidity)
 else()
diff --git a/solc/CommandLineInterface.cpp b/solc/CommandLineInterface.cpp
index be10faa8..deae5928 100644
--- a/solc/CommandLineInterface.cpp
+++ b/solc/CommandLineInterface.cpp
@@ -496,27 +496,12 @@ bool CommandLineInterface::processInput()
 			SourceReferenceFormatter::printExceptionInformation(
 				cerr,
 				*error,
-				(dynamic_pointer_cast<Warning const>(error)) ? "Warning" : "Error", *m_compiler
+				(error->type() == Error::Type::Warning) ? "Warning" : "Error", *m_compiler
 			);
 		if (!successful)
 			return false;
 		m_compiler->link(m_libraries);
 	}
-	catch (ParserError const& _exception)
-	{
-		SourceReferenceFormatter::printExceptionInformation(cerr, _exception, "Parser error", *m_compiler);
-		return false;
-	}
-	catch (DeclarationError const& _exception)
-	{
-		SourceReferenceFormatter::printExceptionInformation(cerr, _exception, "Declaration error", *m_compiler);
-		return false;
-	}
-	catch (TypeError const& _exception)
-	{
-		SourceReferenceFormatter::printExceptionInformation(cerr, _exception, "Type error", *m_compiler);
-		return false;
-	}
 	catch (CompilerError const& _exception)
 	{
 		SourceReferenceFormatter::printExceptionInformation(cerr, _exception, "Compiler error", *m_compiler);
@@ -528,9 +513,13 @@ bool CommandLineInterface::processInput()
 			 << boost::diagnostic_information(_exception);
 		return false;
 	}
-	catch (DocstringParsingError const& _exception)
+	catch (Error const& _error)
 	{
-		cerr << "Documentation parsing error: " << *boost::get_error_info<errinfo_comment>(_exception) << endl;
+		if (_error.type() == Error::Type::DocstringParsingError)
+			cerr << "Documentation parsing error: " << *boost::get_error_info<errinfo_comment>(_error) << endl;
+		else
+			SourceReferenceFormatter::printExceptionInformation(cerr, _error, _error.typeName(), *m_compiler);
+
 		return false;
 	}
 	catch (Exception const& _exception)
diff --git a/solc/jsonCompiler.cpp b/solc/jsonCompiler.cpp
index 00fd0370..1690fadb 100644
--- a/solc/jsonCompiler.cpp
+++ b/solc/jsonCompiler.cpp
@@ -114,37 +114,30 @@ Json::Value estimateGas(CompilerStack const& _compiler, string const& _contract)
 	return gasEstimates;
 }
 
-string compile(string _input, bool _optimize)
+string compile(StringMap const& _sources, bool _optimize)
 {
-	StringMap sources;
-	sources[""] = _input;
-
 	Json::Value output(Json::objectValue);
 	Json::Value errors(Json::arrayValue);
 	CompilerStack compiler;
 	bool success = false;
 	try
 	{
-		bool succ = compiler.compile(_input, _optimize);
+		compiler.addSources(_sources);
+		bool succ = compiler.compile(_optimize);
 		for (auto const& error: compiler.errors())
+		{
+			auto err = dynamic_pointer_cast<Error const>(error);
 			errors.append(formatError(
 				*error,
-				(dynamic_pointer_cast<Warning const>(error)) ? "Warning" : "Error",
+				(err->type() == Error::Type::Warning) ? "Warning" : "Error",
 				compiler
 			));
+		}
 		success = succ; // keep success false on exception
 	}
-	catch (ParserError const& exception)
-	{
-		errors.append(formatError(exception, "Parser error", compiler));
-	}
-	catch (DeclarationError const& exception)
+	catch (Error const& error)
 	{
-		errors.append(formatError(exception, "Declaration error", compiler));
-	}
-	catch (TypeError const& exception)
-	{
-		errors.append(formatError(exception, "Type error", compiler));
+		errors.append(formatError(error, error.typeName(), compiler));
 	}
 	catch (CompilerError const& exception)
 	{
@@ -154,10 +147,6 @@ string compile(string _input, bool _optimize)
 	{
 		errors.append(formatError(exception, "Internal compiler error", compiler));
 	}
-	catch (DocstringParsingError const& exception)
-	{
-		errors.append(formatError(exception, "Documentation parsing error", compiler));
-	}
 	catch (Exception const& exception)
 	{
 		errors.append("Exception during compilation: " + boost::diagnostic_information(exception));
@@ -184,19 +173,52 @@ string compile(string _input, bool _optimize)
 			contractData["functionHashes"] = functionHashes(compiler.contractDefinition(contractName));
 			contractData["gasEstimates"] = estimateGas(compiler, contractName);
 			ostringstream unused;
-			contractData["assembly"] = compiler.streamAssembly(unused, contractName, sources, true);
+			contractData["assembly"] = compiler.streamAssembly(unused, contractName, _sources, true);
 			output["contracts"][contractName] = contractData;
 		}
 
 		output["sources"] = Json::Value(Json::objectValue);
-		output["sources"][""] = Json::Value(Json::objectValue);
-		output["sources"][""]["AST"] = ASTJsonConverter(compiler.ast("")).json();
+		for (auto const& source: _sources)
+		{
+			output["sources"][source.first] = Json::Value(Json::objectValue);
+			output["sources"][source.first]["AST"] = ASTJsonConverter(compiler.ast(source.first)).json();
+		}
 	}
 
 	return Json::FastWriter().write(output);
 }
 
-static string outputBuffer;
+string compileMulti(string const& _input, bool _optimize)
+{
+	Json::Reader reader;
+	Json::Value input;
+	if (!reader.parse(_input, input, false))
+	{
+		Json::Value errors(Json::arrayValue);
+		errors.append("Error parsing input JSON: " + reader.getFormattedErrorMessages());
+		Json::Value output(Json::objectValue);
+		output["errors"] = errors;
+		return Json::FastWriter().write(output);
+	}
+	else
+	{
+		StringMap sources;
+		Json::Value jsonSources = input["sources"];
+		if (jsonSources.isObject())
+			for (auto const& sourceName: jsonSources.getMemberNames())
+				sources[sourceName] = jsonSources[sourceName].asString();
+		return compile(sources, _optimize);
+	}
+}
+
+string compileSingle(string const& _input, bool _optimize)
+{
+	StringMap sources;
+	sources[""] = _input;
+	return compile(sources, _optimize);
+}
+
+static string s_outputBuffer;
 
 extern "C"
 {
@@ -206,7 +228,12 @@ extern char const* version()
 }
 extern char const* compileJSON(char const* _input, bool _optimize)
 {
-	outputBuffer = compile(_input, _optimize);
-	return outputBuffer.c_str();
+	s_outputBuffer = compileSingle(_input, _optimize);
+	return s_outputBuffer.c_str();
+}
+extern char const* compileJSONMulti(char const* _input, bool _optimize)
+{
+	s_outputBuffer = compileMulti(_input, _optimize);
+	return s_outputBuffer.c_str();
 }
 }
diff --git a/test/libsolidity/Assembly.cpp b/test/libsolidity/Assembly.cpp
index ca1e8980..f69ae680 100644
--- a/test/libsolidity/Assembly.cpp
+++ b/test/libsolidity/Assembly.cpp
@@ -48,21 +48,29 @@ namespace
 
 eth::AssemblyItems compileContract(const string& _sourceCode)
 {
-	Parser parser;
+	ErrorList errors;
+	Parser parser(errors);
 	ASTPointer<SourceUnit> sourceUnit;
 	BOOST_REQUIRE_NO_THROW(sourceUnit = parser.parse(make_shared<Scanner>(CharStream(_sourceCode))));
-	NameAndTypeResolver resolver({});
+	BOOST_CHECK(!!sourceUnit);
+
+	NameAndTypeResolver resolver({}, errors);
+	solAssert(Error::containsOnlyWarnings(errors), "");
 	resolver.registerDeclarations(*sourceUnit);
 	for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
 		if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
 		{
 			BOOST_REQUIRE_NO_THROW(resolver.resolveNamesAndTypes(*contract));
+			if (!Error::containsOnlyWarnings(errors))
+				return AssemblyItems();
 		}
 	for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
 		if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
 		{
-			TypeChecker checker;
+			TypeChecker checker(errors);
 			BOOST_REQUIRE_NO_THROW(checker.checkTypeRequirements(*contract));
+			if (!Error::containsOnlyWarnings(errors))
+				return AssemblyItems();
 		}
 	for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
 		if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
diff --git a/test/libsolidity/SolidityABIJSON.cpp b/test/libsolidity/SolidityABIJSON.cpp
index f3004b5f..68f5a64a 100644
--- a/test/libsolidity/SolidityABIJSON.cpp
+++ b/test/libsolidity/SolidityABIJSON.cpp
@@ -45,9 +45,10 @@ public:
 		m_reader.parse(generatedInterfaceString, generatedInterface);
 		Json::Value expectedInterface;
 		m_reader.parse(_expectedInterfaceString, expectedInterface);
-		BOOST_CHECK_MESSAGE(expectedInterface == generatedInterface,
-							"Expected:\n" << expectedInterface.toStyledString() <<
-							"\n but got:\n" << generatedInterface.toStyledString());
+		BOOST_CHECK_MESSAGE(
+			expectedInterface == generatedInterface,
+			"Expected:\n" << expectedInterface.toStyledString() << "\n but got:\n" << generatedInterface.toStyledString()
+		);
 	}
 
 private:
diff --git a/test/libsolidity/SolidityEndToEndTest.cpp b/test/libsolidity/SolidityEndToEndTest.cpp
index 3126c1cc..27c511f2 100644
--- a/test/libsolidity/SolidityEndToEndTest.cpp
+++ b/test/libsolidity/SolidityEndToEndTest.cpp
@@ -3452,6 +3452,7 @@ BOOST_AUTO_TEST_CASE(array_copy_target_leftover2)
 		asString(fromHex("0000000000000000"))
 	));
 }
+
 BOOST_AUTO_TEST_CASE(array_copy_storage_storage_struct)
 {
 	char const* sourceCode = R"(
@@ -3476,6 +3477,45 @@ BOOST_AUTO_TEST_CASE(array_copy_storage_storage_struct)
 	BOOST_CHECK(m_state.storage(m_contractAddress).empty());
 }
 
+BOOST_AUTO_TEST_CASE(array_push)
+{
+	char const* sourceCode = R"(
+		contract c {
+			uint[] data;
+			function test() returns (uint x, uint y, uint z, uint l) {
+				data.push(5);
+				x = data[0];
+				data.push(4);
+				y = data[1];
+				l = data.push(3);
+				z = data[2];
+			}
+		}
+	)";
+	compileAndRun(sourceCode);
+	BOOST_CHECK(callContractFunction("test()") == encodeArgs(5, 4, 3, 3));
+}
+
+BOOST_AUTO_TEST_CASE(byte_array_push)
+{
+	char const* sourceCode = R"(
+		contract c {
+			bytes data;
+			function test() returns (bool x) {
+				if (data.push(5) != 1)  return true;
+				if (data[0] != 5) return true;
+				data.push(4);
+				if (data[1] != 4) return true;
+				uint l = data.push(3);
+				if (data[2] != 3) return true;
+				if (l != 3) return true;
+			}
+		}
+	)";
+	compileAndRun(sourceCode);
+	BOOST_CHECK(callContractFunction("test()") == encodeArgs(false));
+}
+
 BOOST_AUTO_TEST_CASE(external_array_args)
 {
 	char const* sourceCode = R"(
@@ -4705,7 +4745,7 @@ BOOST_AUTO_TEST_CASE(dev_title_at_function_error)
 	"  function mul(uint a, uint second) returns(uint d) { return a * 7 + second; }\n"
 	"}\n";
 
-	compileRequireThrow<DocstringParsingError>(sourceCode);
+	compileRequireError(sourceCode, Error::Type::DocstringParsingError);
 }
 
 BOOST_AUTO_TEST_CASE(dev_documenting_nonexistant_param)
@@ -4717,7 +4757,7 @@ BOOST_AUTO_TEST_CASE(dev_documenting_nonexistant_param)
 	"  function mul(uint a, uint second) returns(uint d) { return a * 7 + second; }\n"
 	"}\n";
 
-	compileRequireThrow<DocstringParsingError>(sourceCode);
+	compileRequireError(sourceCode, Error::Type::DocstringParsingError);
 }
 
 
@@ -5613,6 +5653,140 @@ BOOST_AUTO_TEST_CASE(reject_ether_sent_to_library)
 	BOOST_CHECK_EQUAL(m_state.balance(libraryAddress), 0);
 }
 
+BOOST_AUTO_TEST_CASE(multi_variable_declaration)
+{
+	char const* sourceCode = R"(
+		contract C {
+			function g() returns (uint a, uint b, uint c) {
+				a = 1; b = 2; c = 3;
+			}
+			function f() returns (bool) {
+				var (x, y, z) = g();
+				if (x != 1 || y != 2 || z != 3) return false;
+				var (, a,) = g();
+				if (a != 2) return false;
+				var (b,) = g();
+				if (b != 1) return false;
+				var (,c) = g();
+				if (c != 3) return false;
+				return true;
+			}
+		}
+	)";
+	compileAndRun(sourceCode);
+	BOOST_CHECK(callContractFunction("f()", encodeArgs()) == encodeArgs(true));
+}
+
+BOOST_AUTO_TEST_CASE(tuples)
+{
+	char const* sourceCode = R"(
+		contract C {
+			uint[] data;
+			function g() internal returns (uint a, uint b, uint[] storage c) {
+				return (1, 2, data);
+			}
+			function h() external returns (uint a, uint b) {
+				return (5, 6);
+			}
+			function f() returns (uint) {
+				data.length = 1;
+				data[0] = 3;
+				uint a; uint b;
+				(a, b) = this.h();
+				if (a != 5 || b != 6) return 1;
+				uint[] storage c;
+				(a, b, c) = g();
+				if (a != 1 || b != 2 || c[0] != 3) return 2;
+				(a, b) = (b, a);
+				if (a != 2 || b != 1) return 3;
+				(a, , b, ) = (8, 9, 10, 11, 12);
+				if (a != 8 || b != 10) return 4;
+			}
+		}
+	)";
+	compileAndRun(sourceCode);
+	BOOST_CHECK(callContractFunction("f()") == encodeArgs(u256(0)));
+}
+
+BOOST_AUTO_TEST_CASE(destructuring_assignment)
+{
+	char const* sourceCode = R"(
+		contract C {
+			uint x = 7;
+			bytes data;
+			uint[] y;
+			uint[] arrayData;
+			function returnsArray() returns (uint[]) {
+				arrayData.length = 9;
+				arrayData[2] = 5;
+				arrayData[7] = 4;
+				return arrayData;
+			}
+			function f(bytes s) returns (uint) {
+				uint loc;
+				uint[] memory memArray;
+				(loc, x, y, data, arrayData[3]) = (8, 4, returnsArray(), s, 2);
+				if (loc != 8) return 1;
+				if (x != 4) return 2;
+				if (y.length != 9) return 3;
+				if (y[2] != 5) return 4;
+				if (y[7] != 4) return 5;
+				if (data.length != s.length) return 6;
+				if (data[3] != s[3]) return 7;
+				if (arrayData[3] != 2) return 8;
+				(memArray, loc) = (arrayData, 3);
+				if (loc != 3) return 9;
+				if (memArray.length != arrayData.length) return 10;
+				bytes memory memBytes;
+				(x, memBytes, y[2], ) = (456, s, 789, 101112, 131415);
+				if (x != 456 || memBytes.length != s.length || y[2] != 789) return 11;
+			}
+		}
+	)";
+	compileAndRun(sourceCode);
+	BOOST_CHECK(callContractFunction("f(bytes)", u256(0x20), u256(5), string("abcde")) == encodeArgs(u256(0)));
+}
+
+BOOST_AUTO_TEST_CASE(destructuring_assignment_wildcard)
+{
+	char const* sourceCode = R"(
+		contract C {
+			function f() returns (uint) {
+				uint a;
+				uint b;
+				uint c;
+				(a,) = (1,);
+				if (a != 1) return 1;
+				(,b) = (2,3,4);
+				if (b != 4) return 2;
+				(, c,) = (5,6,7);
+				if (c != 6) return 3;
+				(a, b,) = (11, 12, 13);
+				if (a != 11 || b != 12) return 4;
+				(, a, b) = (11, 12, 13);
+				if (a != 12 || b != 13) return 5;
+			}
+		}
+	)";
+	compileAndRun(sourceCode);
+	BOOST_CHECK(callContractFunction("f()") == encodeArgs(u256(0)));
+}
+
+BOOST_AUTO_TEST_CASE(lone_struct_array_type)
+{
+	char const* sourceCode = R"(
+		contract C {
+			struct s { uint a; uint b;}
+			function f() returns (uint) {
+				s[7][]; // This is only the type, should not have any effect
+				return 3;
+			}
+		}
+	)";
+	compileAndRun(sourceCode);
+	BOOST_CHECK(callContractFunction("f()") == encodeArgs(u256(3)));
+}
+
 BOOST_AUTO_TEST_SUITE_END()
 
 }
diff --git a/test/libsolidity/SolidityExpressionCompiler.cpp b/test/libsolidity/SolidityExpressionCompiler.cpp
index 545775ee..4013581d 100644
--- a/test/libsolidity/SolidityExpressionCompiler.cpp
+++ b/test/libsolidity/SolidityExpressionCompiler.cpp
@@ -85,15 +85,20 @@ Declaration const& resolveDeclaration(
 	return *declaration;
 }
 
-bytes compileFirstExpression(const string& _sourceCode, vector<vector<string>> _functions = {},
-							 vector<vector<string>> _localVariables = {},
-							 vector<shared_ptr<MagicVariableDeclaration const>> _globalDeclarations = {})
+bytes compileFirstExpression(
+	const string& _sourceCode,
+	vector<vector<string>> _functions = {},
+	vector<vector<string>> _localVariables = {},
+	vector<shared_ptr<MagicVariableDeclaration const>> _globalDeclarations = {}
+)
 {
-	Parser parser;
 	ASTPointer<SourceUnit> sourceUnit;
 	try
 	{
-		sourceUnit = parser.parse(make_shared<Scanner>(CharStream(_sourceCode)));
+		ErrorList errors;
+		sourceUnit = Parser(errors).parse(make_shared<Scanner>(CharStream(_sourceCode)));
+		if (!sourceUnit)
+			return bytes();
 	}
 	catch(boost::exception const& _e)
 	{
@@ -105,7 +110,9 @@ bytes compileFirstExpression(const string& _sourceCode, vector<vector<string>> _
 	declarations.reserve(_globalDeclarations.size() + 1);
 	for (ASTPointer<Declaration const> const& variable: _globalDeclarations)
 		declarations.push_back(variable.get());
-	NameAndTypeResolver resolver(declarations);
+
+	ErrorList errors;
+	NameAndTypeResolver resolver(declarations, errors);
 	resolver.registerDeclarations(*sourceUnit);
 
 	vector<ContractDefinition const*> inheritanceHierarchy;
@@ -118,7 +125,7 @@ bytes compileFirstExpression(const string& _sourceCode, vector<vector<string>> _
 	for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
 		if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
 		{
-			TypeChecker typeChecker;
+			TypeChecker typeChecker(errors);
 			BOOST_REQUIRE(typeChecker.checkTypeRequirements(*contract));
 		}
 	for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
diff --git a/test/libsolidity/SolidityNameAndTypeResolution.cpp b/test/libsolidity/SolidityNameAndTypeResolution.cpp
index b55c92f0..4f0b70bd 100644
--- a/test/libsolidity/SolidityNameAndTypeResolution.cpp
+++ b/test/libsolidity/SolidityNameAndTypeResolution.cpp
@@ -44,18 +44,22 @@ namespace test
 namespace
 {
 
-pair<ASTPointer<SourceUnit>, shared_ptr<Exception const>>
+pair<ASTPointer<SourceUnit>, std::shared_ptr<Error::Type const>>
 parseAnalyseAndReturnError(string const& _source, bool _reportWarnings = false)
 {
-	Parser parser;
+	ErrorList errors;
+	Parser parser(errors);
 	ASTPointer<SourceUnit> sourceUnit;
-	shared_ptr<Exception const> err;
 	// catch exceptions for a transition period
 	try
 	{
 		sourceUnit = parser.parse(std::make_shared<Scanner>(CharStream(_source)));
+		if(!sourceUnit)
+			return make_pair(sourceUnit, nullptr);
+
 		std::shared_ptr<GlobalContext> globalContext = make_shared<GlobalContext>();
-		NameAndTypeResolver resolver(globalContext->declarations());
+		NameAndTypeResolver resolver(globalContext->declarations(), errors);
+		solAssert(Error::containsOnlyWarnings(errors), "");
 		resolver.registerDeclarations(*sourceUnit);
 
 		for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
@@ -71,51 +75,51 @@ parseAnalyseAndReturnError(string const& _source, bool _reportWarnings = false)
 			{
 				globalContext->setCurrentContract(*contract);
 				resolver.updateDeclaration(*globalContext->currentThis());
-				TypeChecker typeChecker;
+
+				TypeChecker typeChecker(errors);
 				bool success = typeChecker.checkTypeRequirements(*contract);
-				BOOST_CHECK(success || !typeChecker.errors().empty());
-				for (auto const& firstError: typeChecker.errors())
+				BOOST_CHECK(success || !errors.empty());
+
+				for (auto const& currentError: errors)
 				{
-					if (_reportWarnings || !dynamic_pointer_cast<Warning const>(firstError))
-					{
-						err = firstError;
-						break;
-					}
-					else if (_reportWarnings)
-					{
-						err = firstError;
-						break;
-					}
+					if (
+						(_reportWarnings && currentError->type() == Error::Type::Warning) ||
+						(!_reportWarnings && currentError->type() != Error::Type::Warning)
+					)
+						return make_pair(sourceUnit, std::make_shared<Error::Type const>(currentError->type()));
 				}
 			}
 	}
-	catch (ParserError const& _exception)
+	catch(Error const& _e)
 	{
-		return make_pair(sourceUnit, make_shared<ParserError>(_exception));
+		return make_pair(sourceUnit, std::make_shared<Error::Type const>(_e.type()));
 	}
-	catch (DeclarationError const& _exception)
+	catch (Exception const& _exception)
 	{
-		return make_pair(sourceUnit, make_shared<DeclarationError>(_exception));
+		return make_pair(sourceUnit, nullptr);
 	}
-	catch (TypeError const& _exception)
-	{
-		return make_pair(sourceUnit, make_shared<TypeError>(_exception));
-	}
-	return make_pair(sourceUnit, err);
+	return make_pair(sourceUnit, nullptr);
 }
 
 ASTPointer<SourceUnit> parseAndAnalyse(string const& _source)
 {
 	auto sourceAndError = parseAnalyseAndReturnError(_source);
+	BOOST_REQUIRE(!!sourceAndError.first);
 	BOOST_REQUIRE(!sourceAndError.second);
 	return sourceAndError.first;
 }
 
-shared_ptr<Exception const> parseAndAnalyseReturnError(std::string const& _source, bool _warning = false)
+bool success(string const& _source)
+{
+	return !parseAnalyseAndReturnError(_source).second;
+}
+
+Error::Type expectError(std::string const& _source, bool _warning = false)
 {
 	auto sourceAndError = parseAnalyseAndReturnError(_source, _warning);
 	BOOST_REQUIRE(!!sourceAndError.second);
-	return sourceAndError.second;
+	BOOST_REQUIRE(!!sourceAndError.first);
+	return *sourceAndError.second;
 }
 
 static ContractDefinition const* retrieveContract(ASTPointer<SourceUnit> _source, unsigned index)
@@ -140,10 +144,6 @@ static FunctionTypePointer const& retrieveFunctionBySignature(
 
 }
 
-#define SOLIDITY_CHECK_ERROR_TYPE(_statement, _ErrorType)				\
-	BOOST_CHECK(!!dynamic_cast<_ErrorType const*>(_statement.get()))
-
-
 BOOST_AUTO_TEST_SUITE(SolidityNameAndTypeResolution)
 
 BOOST_AUTO_TEST_CASE(smoke_test)
@@ -152,7 +152,7 @@ BOOST_AUTO_TEST_CASE(smoke_test)
 					   "  uint256 stateVariable1;\n"
 					   "  function fun(uint256 arg1) { uint256 y; }"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(double_stateVariable_declaration)
@@ -161,7 +161,7 @@ BOOST_AUTO_TEST_CASE(double_stateVariable_declaration)
 					   "  uint256 variable;\n"
 					   "  uint128 variable;\n"
 					   "}\n";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), DeclarationError);
+	BOOST_CHECK(expectError(text) == Error::Type::DeclarationError);
 }
 
 BOOST_AUTO_TEST_CASE(double_function_declaration)
@@ -170,7 +170,7 @@ BOOST_AUTO_TEST_CASE(double_function_declaration)
 					   "  function fun() { uint x; }\n"
 					   "  function fun() { uint x; }\n"
 					   "}\n";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), DeclarationError);
+	BOOST_CHECK(expectError(text) == Error::Type::DeclarationError);
 }
 
 BOOST_AUTO_TEST_CASE(double_variable_declaration)
@@ -178,7 +178,7 @@ BOOST_AUTO_TEST_CASE(double_variable_declaration)
 	char const* text = "contract test {\n"
 					   "  function f() { uint256 x; if (true)  { uint256 x; } }\n"
 					   "}\n";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), DeclarationError);
+	BOOST_CHECK(expectError(text) == Error::Type::DeclarationError);
 }
 
 BOOST_AUTO_TEST_CASE(name_shadowing)
@@ -187,7 +187,7 @@ BOOST_AUTO_TEST_CASE(name_shadowing)
 					   "  uint256 variable;\n"
 					   "  function f() { uint32 variable ; }"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(name_references)
@@ -196,7 +196,7 @@ BOOST_AUTO_TEST_CASE(name_references)
 					   "  uint256 variable;\n"
 					   "  function f(uint256 arg) returns (uint out) { f(variable); test; out; }"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(undeclared_name)
@@ -205,7 +205,7 @@ BOOST_AUTO_TEST_CASE(undeclared_name)
 					   "  uint256 variable;\n"
 					   "  function f(uint256 arg) { f(notfound); }"
 					   "}\n";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), DeclarationError);
+	BOOST_CHECK(expectError(text) == Error::Type::DeclarationError);
 }
 
 BOOST_AUTO_TEST_CASE(reference_to_later_declaration)
@@ -214,7 +214,7 @@ BOOST_AUTO_TEST_CASE(reference_to_later_declaration)
 					   "  function g() { f(); }"
 					   "  function f() {  }"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(struct_definition_directly_recursive)
@@ -225,7 +225,7 @@ BOOST_AUTO_TEST_CASE(struct_definition_directly_recursive)
 					   "    MyStructName x;\n"
 					   "  }\n"
 					   "}\n";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(struct_definition_indirectly_recursive)
@@ -240,7 +240,7 @@ BOOST_AUTO_TEST_CASE(struct_definition_indirectly_recursive)
 					   "    MyStructName1 x;\n"
 					   "  }\n"
 					   "}\n";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(struct_definition_not_really_recursive)
@@ -251,7 +251,7 @@ BOOST_AUTO_TEST_CASE(struct_definition_not_really_recursive)
 			struct s2 { s1 x; s1 y; }
 		}
 	)";
-	BOOST_CHECK_NO_THROW(parseAndAnalyse(text));
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(struct_definition_recursion_via_mapping)
@@ -263,7 +263,7 @@ BOOST_AUTO_TEST_CASE(struct_definition_recursion_via_mapping)
 					   "    mapping(uint => MyStructName1) x;\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(type_inference_smoke_test)
@@ -271,7 +271,7 @@ BOOST_AUTO_TEST_CASE(type_inference_smoke_test)
 	char const* text = "contract test {\n"
 					   "  function f(uint256 arg1, uint32 arg2) returns (bool ret) { var x = arg1 + arg2 == 8; ret = x; }"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(type_checking_return)
@@ -279,7 +279,7 @@ BOOST_AUTO_TEST_CASE(type_checking_return)
 	char const* text = "contract test {\n"
 					   "  function f() returns (bool r) { return 1 >= 2; }"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(type_checking_return_wrong_number)
@@ -287,7 +287,7 @@ BOOST_AUTO_TEST_CASE(type_checking_return_wrong_number)
 	char const* text = "contract test {\n"
 					   "  function f() returns (bool r1, bool r2) { return 1 >= 2; }"
 					   "}\n";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(type_checking_return_wrong_type)
@@ -295,7 +295,7 @@ BOOST_AUTO_TEST_CASE(type_checking_return_wrong_type)
 	char const* text = "contract test {\n"
 					   "  function f() returns (uint256 r) { return 1 >= 2; }"
 					   "}\n";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(type_checking_function_call)
@@ -304,7 +304,7 @@ BOOST_AUTO_TEST_CASE(type_checking_function_call)
 					   "  function f() returns (bool r) { return g(12, true) == 3; }\n"
 					   "  function g(uint256 a, bool b) returns (uint256 r) { }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(type_conversion_for_comparison)
@@ -312,7 +312,7 @@ BOOST_AUTO_TEST_CASE(type_conversion_for_comparison)
 	char const* text = "contract test {\n"
 					   "  function f() { uint32(2) == int64(2); }"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(type_conversion_for_comparison_invalid)
@@ -320,7 +320,7 @@ BOOST_AUTO_TEST_CASE(type_conversion_for_comparison_invalid)
 	char const* text = "contract test {\n"
 					   "  function f() { int32(2) == uint64(2); }"
 					   "}\n";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(type_inference_explicit_conversion)
@@ -328,7 +328,7 @@ BOOST_AUTO_TEST_CASE(type_inference_explicit_conversion)
 	char const* text = "contract test {\n"
 					   "  function f() returns (int256 r) { var x = int256(uint32(2)); return x; }"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(large_string_literal)
@@ -336,7 +336,7 @@ BOOST_AUTO_TEST_CASE(large_string_literal)
 	char const* text = "contract test {\n"
 					   "  function f() { var x = \"123456789012345678901234567890123\"; }"
 					   "}\n";
-	BOOST_CHECK_NO_THROW(parseAndAnalyse(text));
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(balance)
@@ -346,7 +346,7 @@ BOOST_AUTO_TEST_CASE(balance)
 					   "    uint256 x = address(0).balance;\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(balance_invalid)
@@ -356,7 +356,7 @@ BOOST_AUTO_TEST_CASE(balance_invalid)
 					   "    address(0).balance = 7;\n"
 					   "  }\n"
 					   "}\n";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(assignment_to_mapping)
@@ -371,7 +371,7 @@ BOOST_AUTO_TEST_CASE(assignment_to_mapping)
 					   "    data.map = a;\n"
 					   "  }\n"
 					   "}\n";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(assignment_to_struct)
@@ -386,7 +386,7 @@ BOOST_AUTO_TEST_CASE(assignment_to_struct)
 					   "    data = a;\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(returns_in_constructor)
@@ -395,7 +395,7 @@ BOOST_AUTO_TEST_CASE(returns_in_constructor)
 					   "  function test() returns (uint a) {\n"
 					   "  }\n"
 					   "}\n";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(forward_function_reference)
@@ -410,7 +410,7 @@ BOOST_AUTO_TEST_CASE(forward_function_reference)
 					   "    if (First(2).fun() == true) return 1;\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(comparison_bitop_precedence)
@@ -420,7 +420,7 @@ BOOST_AUTO_TEST_CASE(comparison_bitop_precedence)
 					   "    return 1 & 2 == 8 & 9 && 1 ^ 2 < 4 | 6;\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(function_no_implementation)
@@ -483,7 +483,7 @@ BOOST_AUTO_TEST_CASE(create_abstract_contract)
 			function foo() { b = new base();}
 			}
 		)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(abstract_contract_constructor_args_optional)
@@ -527,7 +527,7 @@ BOOST_AUTO_TEST_CASE(redeclare_implemented_abstract_function_as_abstract)
 		contract derived is base { function foo() {} }
 		contract wrong is derived { function foo(); }
 		)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(function_canonical_signature)
@@ -622,7 +622,7 @@ BOOST_AUTO_TEST_CASE(function_external_call_allowed_conversion)
 			}
 			function g (C c) external {}
 	})";
-	BOOST_CHECK_NO_THROW(parseAndAnalyse(text));
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(function_external_call_not_allowed_conversion)
@@ -636,7 +636,7 @@ BOOST_AUTO_TEST_CASE(function_external_call_not_allowed_conversion)
 			}
 			function g (C c) external {}
 	})";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(function_internal_allowed_conversion)
@@ -652,7 +652,7 @@ BOOST_AUTO_TEST_CASE(function_internal_allowed_conversion)
 				g(a);
 			}
 	})";
-	BOOST_CHECK_NO_THROW(parseAndAnalyse(text));
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(function_internal_not_allowed_conversion)
@@ -668,7 +668,7 @@ BOOST_AUTO_TEST_CASE(function_internal_not_allowed_conversion)
 				g(a);
 			}
 	})";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(hash_collision_in_interface)
@@ -679,7 +679,7 @@ BOOST_AUTO_TEST_CASE(hash_collision_in_interface)
 					   "  function tgeo() {\n"
 					   "  }\n"
 					   "}\n";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(inheritance_basic)
@@ -691,7 +691,7 @@ BOOST_AUTO_TEST_CASE(inheritance_basic)
 			function f() { baseMember = 7; }
 		}
 	)";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(inheritance_diamond_basic)
@@ -704,7 +704,7 @@ BOOST_AUTO_TEST_CASE(inheritance_diamond_basic)
 			function g() { f(); rootFunction(); }
 		}
 	)";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(cyclic_inheritance)
@@ -713,7 +713,7 @@ BOOST_AUTO_TEST_CASE(cyclic_inheritance)
 		contract A is B { }
 		contract B is A { }
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(legal_override_direct)
@@ -722,7 +722,7 @@ BOOST_AUTO_TEST_CASE(legal_override_direct)
 		contract B { function f() {} }
 		contract C is B { function f(uint i) {} }
 	)";
-	BOOST_CHECK_NO_THROW(parseAndAnalyse(text));
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(legal_override_indirect)
@@ -732,7 +732,7 @@ BOOST_AUTO_TEST_CASE(legal_override_indirect)
 		contract B { function f() {} }
 		contract C is A, B { }
 	)";
-	BOOST_CHECK_NO_THROW(parseAndAnalyse(text));
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(illegal_override_visibility)
@@ -741,7 +741,7 @@ BOOST_AUTO_TEST_CASE(illegal_override_visibility)
 		contract B { function f() internal {} }
 		contract C is B { function f() public {} }
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(illegal_override_constness)
@@ -750,7 +750,7 @@ BOOST_AUTO_TEST_CASE(illegal_override_constness)
 		contract B { function f() constant {} }
 		contract C is B { function f() {} }
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(complex_inheritance)
@@ -760,7 +760,7 @@ BOOST_AUTO_TEST_CASE(complex_inheritance)
 		contract B { function f() {} function g() returns (uint8 r) {} }
 		contract C is A, B { }
 	)";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(constructor_visibility)
@@ -770,7 +770,7 @@ BOOST_AUTO_TEST_CASE(constructor_visibility)
 		contract A { function A() { } }
 		contract B is A { function f() { A x = A(0); } }
 	)";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(overriding_constructor)
@@ -780,7 +780,7 @@ BOOST_AUTO_TEST_CASE(overriding_constructor)
 		contract A { function A() { } }
 		contract B is A { function A() returns (uint8 r) {} }
 	)";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(missing_base_constructor_arguments)
@@ -789,7 +789,7 @@ BOOST_AUTO_TEST_CASE(missing_base_constructor_arguments)
 		contract A { function A(uint a) { } }
 		contract B is A { }
 	)";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(base_constructor_arguments_override)
@@ -798,7 +798,7 @@ BOOST_AUTO_TEST_CASE(base_constructor_arguments_override)
 		contract A { function A(uint a) { } }
 		contract B is A { }
 	)";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(implicit_derived_to_base_conversion)
@@ -809,7 +809,7 @@ BOOST_AUTO_TEST_CASE(implicit_derived_to_base_conversion)
 			function f() { A a = B(1); }
 		}
 	)";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(implicit_base_to_derived_conversion)
@@ -820,7 +820,7 @@ BOOST_AUTO_TEST_CASE(implicit_base_to_derived_conversion)
 			function f() { B b = A(1); }
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(function_modifier_invocation)
@@ -832,7 +832,7 @@ BOOST_AUTO_TEST_CASE(function_modifier_invocation)
 			modifier mod2(bytes7 a) { while (a == "1234567") _ }
 		}
 	)";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(invalid_function_modifier_type)
@@ -843,7 +843,7 @@ BOOST_AUTO_TEST_CASE(invalid_function_modifier_type)
 			modifier mod1(uint a) { if (a > 0) _ }
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(function_modifier_invocation_parameters)
@@ -855,7 +855,7 @@ BOOST_AUTO_TEST_CASE(function_modifier_invocation_parameters)
 			modifier mod2(bytes7 a) { while (a == "1234567") _ }
 		}
 	)";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(function_modifier_invocation_local_variables)
@@ -866,7 +866,7 @@ BOOST_AUTO_TEST_CASE(function_modifier_invocation_local_variables)
 			modifier mod(uint a) { if (a > 0) _ }
 		}
 	)";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(legal_modifier_override)
@@ -875,7 +875,7 @@ BOOST_AUTO_TEST_CASE(legal_modifier_override)
 		contract A { modifier mod(uint a) {} }
 		contract B is A { modifier mod(uint a) {} }
 	)";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(illegal_modifier_override)
@@ -884,7 +884,7 @@ BOOST_AUTO_TEST_CASE(illegal_modifier_override)
 		contract A { modifier mod(uint a) {} }
 		contract B is A { modifier mod(uint8 a) {} }
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(modifier_overrides_function)
@@ -893,7 +893,7 @@ BOOST_AUTO_TEST_CASE(modifier_overrides_function)
 		contract A { modifier mod(uint a) {} }
 		contract B is A { function mod(uint a) {} }
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(function_overrides_modifier)
@@ -902,7 +902,7 @@ BOOST_AUTO_TEST_CASE(function_overrides_modifier)
 		contract A { function mod(uint a) {} }
 		contract B is A { modifier mod(uint a) {} }
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(modifier_returns_value)
@@ -913,7 +913,7 @@ BOOST_AUTO_TEST_CASE(modifier_returns_value)
 			modifier mod(uint a) { return 7; }
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(state_variable_accessors)
@@ -964,7 +964,7 @@ BOOST_AUTO_TEST_CASE(function_clash_with_state_variable_accessor)
 					   "uint256 foo;\n"
 					   "   function foo() {}\n"
 					   "}\n";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), DeclarationError);
+	BOOST_CHECK(expectError(text) == Error::Type::DeclarationError);
 }
 
 BOOST_AUTO_TEST_CASE(private_state_variable)
@@ -997,7 +997,7 @@ BOOST_AUTO_TEST_CASE(base_class_state_variable_accessor)
 					   "contract Child is Parent{\n"
 					   "    function foo() returns (uint256) { return Parent.m_aMember; }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(base_class_state_variable_internal_member)
@@ -1008,7 +1008,7 @@ BOOST_AUTO_TEST_CASE(base_class_state_variable_internal_member)
 					   "contract Child is Parent{\n"
 					   "    function foo() returns (uint256) { return Parent.m_aMember; }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(state_variable_member_of_wrong_class1)
@@ -1022,7 +1022,7 @@ BOOST_AUTO_TEST_CASE(state_variable_member_of_wrong_class1)
 					   "contract Child is Parent2{\n"
 					   "    function foo() returns (uint256) { return Parent2.m_aMember1; }\n"
 					   "}\n";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(state_variable_member_of_wrong_class2)
@@ -1037,7 +1037,7 @@ BOOST_AUTO_TEST_CASE(state_variable_member_of_wrong_class2)
 					   "    function foo() returns (uint256) { return Child.m_aMember2; }\n"
 					   "    uint256 public m_aMember3;\n"
 					   "}\n";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(fallback_function)
@@ -1048,7 +1048,7 @@ BOOST_AUTO_TEST_CASE(fallback_function)
 			function() { x = 2; }
 		}
 	)";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(fallback_function_with_arguments)
@@ -1059,7 +1059,7 @@ BOOST_AUTO_TEST_CASE(fallback_function_with_arguments)
 			function(uint a) { x = 2; }
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(fallback_function_twice)
@@ -1071,7 +1071,7 @@ BOOST_AUTO_TEST_CASE(fallback_function_twice)
 			function() { x = 3; }
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), DeclarationError);
+	BOOST_CHECK(expectError(text) == Error::Type::DeclarationError);
 }
 
 BOOST_AUTO_TEST_CASE(fallback_function_inheritance)
@@ -1085,7 +1085,7 @@ BOOST_AUTO_TEST_CASE(fallback_function_inheritance)
 			function() { x = 2; }
 		}
 	)";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(event)
@@ -1095,7 +1095,7 @@ BOOST_AUTO_TEST_CASE(event)
 			event e(uint indexed a, bytes3 indexed s, bool indexed b);
 			function f() { e(2, "abc", true); }
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(event_too_many_indexed)
@@ -1104,7 +1104,7 @@ BOOST_AUTO_TEST_CASE(event_too_many_indexed)
 		contract c {
 			event e(uint indexed a, bytes3 indexed b, bool indexed c, uint indexed d);
 		})";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(anonymous_event_four_indexed)
@@ -1113,7 +1113,7 @@ BOOST_AUTO_TEST_CASE(anonymous_event_four_indexed)
 		contract c {
 			event e(uint indexed a, bytes3 indexed b, bool indexed c, uint indexed d) anonymous;
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(anonymous_event_too_many_indexed)
@@ -1122,7 +1122,7 @@ BOOST_AUTO_TEST_CASE(anonymous_event_too_many_indexed)
 		contract c {
 			event e(uint indexed a, bytes3 indexed b, bool indexed c, uint indexed d, uint indexed e) anonymous;
 		})";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(event_call)
@@ -1132,7 +1132,7 @@ BOOST_AUTO_TEST_CASE(event_call)
 			event e(uint a, bytes3 indexed s, bool indexed b);
 			function f() { e(2, "abc", true); }
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(event_inheritance)
@@ -1144,7 +1144,7 @@ BOOST_AUTO_TEST_CASE(event_inheritance)
 		contract c is base {
 			function f() { e(2, "abc", true); }
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(multiple_events_argument_clash)
@@ -1154,7 +1154,7 @@ BOOST_AUTO_TEST_CASE(multiple_events_argument_clash)
 			event e1(uint a, uint e1, uint e2);
 			event e2(uint a, uint e1, uint e2);
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(access_to_default_function_visibility)
@@ -1166,7 +1166,7 @@ BOOST_AUTO_TEST_CASE(access_to_default_function_visibility)
 		contract d {
 			function g() { c(0).f(); }
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(access_to_internal_function)
@@ -1178,7 +1178,7 @@ BOOST_AUTO_TEST_CASE(access_to_internal_function)
 		contract d {
 			function g() { c(0).f(); }
 		})";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(access_to_default_state_variable_visibility)
@@ -1190,7 +1190,7 @@ BOOST_AUTO_TEST_CASE(access_to_default_state_variable_visibility)
 		contract d {
 			function g() { c(0).a(); }
 		})";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(access_to_internal_state_variable)
@@ -1202,7 +1202,7 @@ BOOST_AUTO_TEST_CASE(access_to_internal_state_variable)
 		contract d {
 			function g() { c(0).a(); }
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(error_count_in_named_args)
@@ -1211,7 +1211,7 @@ BOOST_AUTO_TEST_CASE(error_count_in_named_args)
 							 "  function a(uint a, uint b) returns (uint r) { r = a + b; }\n"
 							 "  function b() returns (uint r) { r = a({a: 1}); }\n"
 							 "}\n";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(empty_in_named_args)
@@ -1220,7 +1220,7 @@ BOOST_AUTO_TEST_CASE(empty_in_named_args)
 							 "  function a(uint a, uint b) returns (uint r) { r = a + b; }\n"
 							 "  function b() returns (uint r) { r = a({}); }\n"
 							 "}\n";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(duplicate_parameter_names_in_named_args)
@@ -1229,7 +1229,7 @@ BOOST_AUTO_TEST_CASE(duplicate_parameter_names_in_named_args)
 							 "  function a(uint a, uint b) returns (uint r) { r = a + b; }\n"
 							 "  function b() returns (uint r) { r = a({a: 1, a: 2}); }\n"
 							 "}\n";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(invalid_parameter_names_in_named_args)
@@ -1238,7 +1238,7 @@ BOOST_AUTO_TEST_CASE(invalid_parameter_names_in_named_args)
 							 "  function a(uint a, uint b) returns (uint r) { r = a + b; }\n"
 							 "  function b() returns (uint r) { r = a({a: 1, c: 2}); }\n"
 							 "}\n";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(empty_name_input_parameter)
@@ -1248,7 +1248,7 @@ BOOST_AUTO_TEST_CASE(empty_name_input_parameter)
 			function f(uint){
 		}
 	})";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(empty_name_return_parameter)
@@ -1258,7 +1258,7 @@ BOOST_AUTO_TEST_CASE(empty_name_return_parameter)
 			function f() returns(bool){
 		}
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(empty_name_input_parameter_with_named_one)
@@ -1269,7 +1269,7 @@ BOOST_AUTO_TEST_CASE(empty_name_input_parameter_with_named_one)
 				return k;
 		}
 	})";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(empty_name_return_parameter_with_named_one)
@@ -1280,13 +1280,13 @@ BOOST_AUTO_TEST_CASE(empty_name_return_parameter_with_named_one)
 				return 5;
 		}
 		})";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(disallow_declaration_of_void_type)
 {
-	char const* sourceCode = "contract c { function f() { var x = f(); } }";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	char const* sourceCode = "contract c { function f() { var (x) = f(); } }";
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(overflow_caused_by_ether_units)
@@ -1309,7 +1309,7 @@ BOOST_AUTO_TEST_CASE(overflow_caused_by_ether_units)
 			}
 			uint256 a;
 		})";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(exp_operator_negative_exponent)
@@ -1318,7 +1318,7 @@ BOOST_AUTO_TEST_CASE(exp_operator_negative_exponent)
 		contract test {
 			function f() returns(uint d) { return 2 ** -3; }
 		})";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(exp_operator_exponent_too_big)
@@ -1327,7 +1327,7 @@ BOOST_AUTO_TEST_CASE(exp_operator_exponent_too_big)
 		contract test {
 			function f() returns(uint d) { return 2 ** 10000000000; }
 		})";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(enum_member_access)
@@ -1342,7 +1342,7 @@ BOOST_AUTO_TEST_CASE(enum_member_access)
 				ActionChoices choices;
 			}
 	)";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(enum_invalid_member_access)
@@ -1357,7 +1357,7 @@ BOOST_AUTO_TEST_CASE(enum_invalid_member_access)
 				ActionChoices choices;
 			}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(enum_explicit_conversion_is_okay)
@@ -1374,7 +1374,7 @@ BOOST_AUTO_TEST_CASE(enum_explicit_conversion_is_okay)
 				uint64 b;
 			}
 	)";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(int_to_enum_explicit_conversion_is_okay)
@@ -1391,7 +1391,7 @@ BOOST_AUTO_TEST_CASE(int_to_enum_explicit_conversion_is_okay)
 				ActionChoices b;
 			}
 	)";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(enum_implicit_conversion_is_not_okay)
@@ -1408,7 +1408,7 @@ BOOST_AUTO_TEST_CASE(enum_implicit_conversion_is_not_okay)
 				uint64 b;
 			}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(enum_duplicate_values)
@@ -1418,7 +1418,7 @@ BOOST_AUTO_TEST_CASE(enum_duplicate_values)
 				enum ActionChoices { GoLeft, GoRight, GoLeft, Sit }
 			}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), DeclarationError);
+	BOOST_CHECK(expectError(text) == Error::Type::DeclarationError);
 }
 
 BOOST_AUTO_TEST_CASE(private_visibility)
@@ -1431,7 +1431,7 @@ BOOST_AUTO_TEST_CASE(private_visibility)
 			function g() { f(); }
 		}
 		)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), DeclarationError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::DeclarationError);
 }
 
 BOOST_AUTO_TEST_CASE(private_visibility_via_explicit_base_access)
@@ -1444,7 +1444,7 @@ BOOST_AUTO_TEST_CASE(private_visibility_via_explicit_base_access)
 			function g() { base.f(); }
 		}
 		)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(external_visibility)
@@ -1455,7 +1455,7 @@ BOOST_AUTO_TEST_CASE(external_visibility)
 			function g() { f(); }
 		}
 		)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), DeclarationError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::DeclarationError);
 }
 
 BOOST_AUTO_TEST_CASE(external_base_visibility)
@@ -1468,7 +1468,7 @@ BOOST_AUTO_TEST_CASE(external_base_visibility)
 			function g() { base.f(); }
 		}
 		)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(external_argument_assign)
@@ -1478,7 +1478,7 @@ BOOST_AUTO_TEST_CASE(external_argument_assign)
 			function f(uint a) external { a = 1; }
 		}
 		)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(external_argument_increment)
@@ -1488,7 +1488,7 @@ BOOST_AUTO_TEST_CASE(external_argument_increment)
 			function f(uint a) external { a++; }
 		}
 		)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(external_argument_delete)
@@ -1498,7 +1498,7 @@ BOOST_AUTO_TEST_CASE(external_argument_delete)
 			function f(uint a) external { delete a; }
 		}
 		)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(test_for_bug_override_function_with_bytearray_type)
@@ -1520,7 +1520,7 @@ BOOST_AUTO_TEST_CASE(array_with_nonconstant_length)
 		contract c {
 			function f(uint a) { uint8[a] x; }
 		})";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(array_copy_with_different_types1)
@@ -1531,7 +1531,7 @@ BOOST_AUTO_TEST_CASE(array_copy_with_different_types1)
 			uint[] b;
 			function f() { b = a; }
 		})";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(array_copy_with_different_types2)
@@ -1542,7 +1542,7 @@ BOOST_AUTO_TEST_CASE(array_copy_with_different_types2)
 			uint8[] b;
 			function f() { b = a; }
 		})";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(array_copy_with_different_types_conversion_possible)
@@ -1553,7 +1553,7 @@ BOOST_AUTO_TEST_CASE(array_copy_with_different_types_conversion_possible)
 			uint8[] b;
 			function f() { a = b; }
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(array_copy_with_different_types_static_dynamic)
@@ -1564,7 +1564,7 @@ BOOST_AUTO_TEST_CASE(array_copy_with_different_types_static_dynamic)
 			uint8[80] b;
 			function f() { a = b; }
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseAndAnalyse(text), "Parsing and Name Resolving Failed");
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(array_copy_with_different_types_dynamic_static)
@@ -1575,7 +1575,7 @@ BOOST_AUTO_TEST_CASE(array_copy_with_different_types_dynamic_static)
 			uint[80] b;
 			function f() { b = a; }
 		})";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(storage_variable_initialization_with_incorrect_type_int)
@@ -1584,7 +1584,7 @@ BOOST_AUTO_TEST_CASE(storage_variable_initialization_with_incorrect_type_int)
 		contract c {
 			uint8 a = 1000;
 		})";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(storage_variable_initialization_with_incorrect_type_string)
@@ -1593,7 +1593,7 @@ BOOST_AUTO_TEST_CASE(storage_variable_initialization_with_incorrect_type_string)
 		contract c {
 			uint a = "abc";
 		})";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(test_fromElementaryTypeName)
@@ -1718,7 +1718,7 @@ BOOST_AUTO_TEST_CASE(assigning_value_to_const_variable)
 			function changeIt() { x = 9; }
 			uint constant x = 56;
 	})";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(complex_const_variable)
@@ -1728,7 +1728,7 @@ BOOST_AUTO_TEST_CASE(complex_const_variable)
 		contract Foo {
 			mapping(uint => bool) constant mapVar;
 	})";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(uninitialized_const_variable)
@@ -1737,20 +1737,7 @@ BOOST_AUTO_TEST_CASE(uninitialized_const_variable)
 		contract Foo {
 			uint constant y;
 	})";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
-}
-
-BOOST_AUTO_TEST_CASE(local_const_variable)
-{
-	char const* text = R"(
-		contract Foo {
-			function localConst() returns (uint ret)
-			{
-				uint constant local = 4;
-				return local;
-			}
-	})";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), ParserError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(overloaded_function_cannot_resolve)
@@ -1762,7 +1749,7 @@ BOOST_AUTO_TEST_CASE(overloaded_function_cannot_resolve)
 			function g() returns(uint) { return f(3, 5); }
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(ambiguous_overloaded_function)
@@ -1775,7 +1762,7 @@ BOOST_AUTO_TEST_CASE(ambiguous_overloaded_function)
 			function g() returns(uint) { return f(1); }
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(assignment_of_nonoverloaded_function)
@@ -1798,7 +1785,7 @@ BOOST_AUTO_TEST_CASE(assignment_of_overloaded_function)
 			function g() returns(uint) { var x = f; return x(7); }
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(external_types_clash)
@@ -1812,7 +1799,7 @@ BOOST_AUTO_TEST_CASE(external_types_clash)
 			function f(uint8 a) { }
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(override_changes_return_types)
@@ -1825,7 +1812,7 @@ BOOST_AUTO_TEST_CASE(override_changes_return_types)
 			function f(uint a) returns (uint8) { }
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(multiple_constructors)
@@ -1836,7 +1823,7 @@ BOOST_AUTO_TEST_CASE(multiple_constructors)
 			function test() {}
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), DeclarationError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::DeclarationError);
 }
 
 BOOST_AUTO_TEST_CASE(equal_overload)
@@ -1847,7 +1834,7 @@ BOOST_AUTO_TEST_CASE(equal_overload)
 			function test(uint a) external {}
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), DeclarationError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::DeclarationError);
 }
 
 BOOST_AUTO_TEST_CASE(uninitialized_var)
@@ -1857,7 +1844,7 @@ BOOST_AUTO_TEST_CASE(uninitialized_var)
 			function f() returns (uint) { var x; return 2; }
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(string)
@@ -1879,7 +1866,7 @@ BOOST_AUTO_TEST_CASE(string_index)
 			function f() { var a = s[2]; }
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(string_length)
@@ -1890,7 +1877,7 @@ BOOST_AUTO_TEST_CASE(string_length)
 			function f() { var a = s.length; }
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(negative_integers_to_signed_out_of_bound)
@@ -1900,7 +1887,7 @@ BOOST_AUTO_TEST_CASE(negative_integers_to_signed_out_of_bound)
 			int8 public i = -129;
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(negative_integers_to_signed_min)
@@ -1920,7 +1907,7 @@ BOOST_AUTO_TEST_CASE(positive_integers_to_signed_out_of_bound)
 			int8 public j = 128;
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(positive_integers_to_signed_out_of_bound_max)
@@ -1940,7 +1927,7 @@ BOOST_AUTO_TEST_CASE(negative_integers_to_unsigned)
 			uint8 public x = -1;
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(positive_integers_to_unsigned_out_of_bound)
@@ -1950,7 +1937,7 @@ BOOST_AUTO_TEST_CASE(positive_integers_to_unsigned_out_of_bound)
 			uint8 public x = 700;
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(integer_boolean_operators)
@@ -1958,15 +1945,15 @@ BOOST_AUTO_TEST_CASE(integer_boolean_operators)
 	char const* sourceCode1 = R"(
 		contract test { function() { uint x = 1; uint y = 2; x || y; } }
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode1), TypeError);
+	BOOST_CHECK(expectError(sourceCode1) == Error::Type::TypeError);
 	char const* sourceCode2 = R"(
 		contract test { function() { uint x = 1; uint y = 2; x && y; } }
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode2), TypeError);
+	BOOST_CHECK(expectError(sourceCode2) == Error::Type::TypeError);
 	char const* sourceCode3 = R"(
 		contract test { function() { uint x = 1; !x; } }
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode3), TypeError);
+	BOOST_CHECK(expectError(sourceCode3) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(reference_compare_operators)
@@ -1974,11 +1961,11 @@ BOOST_AUTO_TEST_CASE(reference_compare_operators)
 	char const* sourceCode1 = R"(
 		contract test { bytes a; bytes b; function() { a == b; } }
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode1), TypeError);
+	BOOST_CHECK(expectError(sourceCode1) == Error::Type::TypeError);
 	char const* sourceCode2 = R"(
 		contract test { struct s {uint a;} s x; s y; function() { x == y; } }
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode2), TypeError);
+	BOOST_CHECK(expectError(sourceCode2) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(overwrite_memory_location_external)
@@ -1988,7 +1975,7 @@ BOOST_AUTO_TEST_CASE(overwrite_memory_location_external)
 			function f(uint[] memory a) external {}
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(overwrite_storage_location_external)
@@ -1998,7 +1985,7 @@ BOOST_AUTO_TEST_CASE(overwrite_storage_location_external)
 			function f(uint[] storage a) external {}
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(storage_location_local_variables)
@@ -2024,7 +2011,7 @@ BOOST_AUTO_TEST_CASE(no_mappings_in_memory_array)
 			}
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(assignment_mem_to_local_storage_variable)
@@ -2038,7 +2025,7 @@ BOOST_AUTO_TEST_CASE(assignment_mem_to_local_storage_variable)
 			}
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(storage_assign_to_different_local_variable)
@@ -2055,7 +2042,7 @@ BOOST_AUTO_TEST_CASE(storage_assign_to_different_local_variable)
 			}
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(no_delete_on_storage_pointers)
@@ -2069,7 +2056,7 @@ BOOST_AUTO_TEST_CASE(no_delete_on_storage_pointers)
 			}
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(assignment_mem_storage_variable_directly)
@@ -2096,7 +2083,7 @@ BOOST_AUTO_TEST_CASE(function_argument_mem_to_storage)
 			}
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(function_argument_storage_to_mem)
@@ -2125,7 +2112,7 @@ BOOST_AUTO_TEST_CASE(mem_array_assignment_changes_base_type)
 			}
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(dynamic_return_types_not_possible)
@@ -2134,11 +2121,11 @@ BOOST_AUTO_TEST_CASE(dynamic_return_types_not_possible)
 		contract C {
 			function f(uint) returns (string);
 			function g() {
-				var x = this.f(2);
+				var (x,) = this.f(2);
 			}
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(memory_arrays_not_resizeable)
@@ -2151,7 +2138,7 @@ BOOST_AUTO_TEST_CASE(memory_arrays_not_resizeable)
 			}
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(struct_constructor)
@@ -2205,7 +2192,7 @@ BOOST_AUTO_TEST_CASE(literal_strings)
 			}
 		}
 	)";
-	BOOST_CHECK_NO_THROW(parseAndAnalyse(text));
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(invalid_integer_literal_fraction)
@@ -2217,7 +2204,7 @@ BOOST_AUTO_TEST_CASE(invalid_integer_literal_fraction)
 			}
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(invalid_integer_literal_exp)
@@ -2229,7 +2216,7 @@ BOOST_AUTO_TEST_CASE(invalid_integer_literal_exp)
 			}
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(memory_structs_with_mappings)
@@ -2244,7 +2231,7 @@ BOOST_AUTO_TEST_CASE(memory_structs_with_mappings)
 			}
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(string_bytes_conversion)
@@ -2261,7 +2248,7 @@ BOOST_AUTO_TEST_CASE(string_bytes_conversion)
 			function m() internal { string(b); }
 		}
 	)";
-	BOOST_CHECK_NO_THROW(parseAndAnalyse(text));
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(inheriting_from_library)
@@ -2270,7 +2257,7 @@ BOOST_AUTO_TEST_CASE(inheriting_from_library)
 		library Lib {}
 		contract Test is Lib {}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(inheriting_library)
@@ -2279,7 +2266,7 @@ BOOST_AUTO_TEST_CASE(inheriting_library)
 		contract Test {}
 		library Lib is Test {}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(library_having_variables)
@@ -2287,7 +2274,7 @@ BOOST_AUTO_TEST_CASE(library_having_variables)
 	char const* text = R"(
 		library Lib { uint x; }
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(valid_library)
@@ -2295,7 +2282,7 @@ BOOST_AUTO_TEST_CASE(valid_library)
 	char const* text = R"(
 		library Lib { uint constant x = 9; }
 	)";
-	BOOST_CHECK_NO_THROW(parseAndAnalyse(text));
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(call_to_library_function)
@@ -2311,7 +2298,7 @@ BOOST_AUTO_TEST_CASE(call_to_library_function)
 			}
 		}
 	)";
-	BOOST_CHECK_NO_THROW(parseAndAnalyse(text));
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_CASE(creating_contract_within_the_contract)
@@ -2321,7 +2308,7 @@ BOOST_AUTO_TEST_CASE(creating_contract_within_the_contract)
 			function f() { var x = new Test(); }
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(sourceCode), TypeError);
+	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(array_out_of_bound_access)
@@ -2335,7 +2322,7 @@ BOOST_AUTO_TEST_CASE(array_out_of_bound_access)
 			}
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(literal_string_to_storage_pointer)
@@ -2345,7 +2332,7 @@ BOOST_AUTO_TEST_CASE(literal_string_to_storage_pointer)
 			function f() { string x = "abc"; }
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(non_initialized_references)
@@ -2363,7 +2350,8 @@ BOOST_AUTO_TEST_CASE(non_initialized_references)
 			}
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text, true), Warning);
+
+	BOOST_CHECK(expectError(text, true) == Error::Type::Warning);
 }
 
 BOOST_AUTO_TEST_CASE(sha3_with_large_integer_constant)
@@ -2374,7 +2362,7 @@ BOOST_AUTO_TEST_CASE(sha3_with_large_integer_constant)
 			function f() { sha3(2**500); }
 		}
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(cyclic_binary_dependency)
@@ -2384,7 +2372,7 @@ BOOST_AUTO_TEST_CASE(cyclic_binary_dependency)
 		contract B { function f() { new C(); } }
 		contract C { function f() { new A(); } }
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
 BOOST_AUTO_TEST_CASE(cyclic_binary_dependency_via_inheritance)
@@ -2394,7 +2382,148 @@ BOOST_AUTO_TEST_CASE(cyclic_binary_dependency_via_inheritance)
 		contract B { function f() { new C(); } }
 		contract C { function f() { new A(); } }
 	)";
-	SOLIDITY_CHECK_ERROR_TYPE(parseAndAnalyseReturnError(text), TypeError);
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(multi_variable_declaration_fail)
+{
+	char const* text = R"(
+		contract C { function f() { var (x,y); } }
+	)";
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(multi_variable_declaration_wildcards_fine)
+{
+	char const* text = R"(
+		contract C {
+			function three() returns (uint, uint, uint);
+			function two() returns (uint, uint);
+			function none();
+			function f() {
+				var (a,) = three();
+				var (b,c,) = two();
+				var (,d) = three();
+				var (,e,g) = two();
+				var (,,) = three();
+				var () = none();
+			}
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(multi_variable_declaration_wildcards_fail_1)
+{
+	char const* text = R"(
+		contract C {
+			function one() returns (uint);
+			function f() { var (a, b, ) = one(); }
+		}
+	)";
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
+}
+BOOST_AUTO_TEST_CASE(multi_variable_declaration_wildcards_fail_2)
+{
+	char const* text = R"(
+		contract C {
+			function one() returns (uint);
+			function f() { var (a, , ) = one(); }
+		}
+	)";
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(multi_variable_declaration_wildcards_fail_3)
+{
+	char const* text = R"(
+		contract C {
+			function one() returns (uint);
+			function f() { var (, , a) = one(); }
+		}
+	)";
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(multi_variable_declaration_wildcards_fail_4)
+{
+	char const* text = R"(
+		contract C {
+			function one() returns (uint);
+			function f() { var (, a, b) = one(); }
+		}
+	)";
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(tuples)
+{
+	char const* text = R"(
+		contract C {
+			function f() {
+				uint a = (1);
+				var (b,) = (1,);
+				var (c,d) = (1, 2 + a);
+				var (e,) = (1, 2, b);
+			}
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(tuples_empty_components)
+{
+	char const* text = R"(
+		contract C {
+			function f() {
+				(1,,2);
+			}
+		}
+	)";
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(multi_variable_declaration_wildcards_fail_5)
+{
+	char const* text = R"(
+		contract C {
+			function one() returns (uint);
+			function f() { var (,) = one(); }
+		}
+	)";
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(multi_variable_declaration_wildcards_fail_6)
+{
+	char const* text = R"(
+		contract C {
+			function two() returns (uint, uint);
+			function f() { var (a, b, c) = two(); }
+		}
+	)";
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(member_access_parser_ambiguity)
+{
+	char const* text = R"(
+		contract C {
+			struct R { uint[10][10] y; }
+			struct S { uint a; uint b; uint[20][20][20] c; R d; }
+			S data;
+			function f() {
+				C.S x = data;
+				C.S memory y;
+				C.S[10] memory z;
+				C.S[10];
+				y.a = 2;
+				x.c[1][2][3] = 9;
+				x.d.y[2][2] = 3;
+			}
+		}
+	)";
+	BOOST_CHECK(success(text));
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/test/libsolidity/SolidityParser.cpp b/test/libsolidity/SolidityParser.cpp
index 1e034863..77582a2a 100644
--- a/test/libsolidity/SolidityParser.cpp
+++ b/test/libsolidity/SolidityParser.cpp
@@ -39,10 +39,11 @@ namespace test
 
 namespace
 {
-ASTPointer<ContractDefinition> parseText(std::string const& _source)
+ASTPointer<ContractDefinition> parseText(std::string const& _source, ErrorList& _errors)
 {
-	Parser parser;
-	ASTPointer<SourceUnit> sourceUnit = parser.parse(std::make_shared<Scanner>(CharStream(_source)));
+	ASTPointer<SourceUnit> sourceUnit = Parser(_errors).parse(std::make_shared<Scanner>(CharStream(_source)));
+	if (!sourceUnit)
+		return ASTPointer<ContractDefinition>();
 	for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
 		if (ASTPointer<ContractDefinition> contract = dynamic_pointer_cast<ContractDefinition>(node))
 			return contract;
@@ -50,8 +51,31 @@ ASTPointer<ContractDefinition> parseText(std::string const& _source)
 	return ASTPointer<ContractDefinition>();
 }
 
-static void checkFunctionNatspec(ASTPointer<FunctionDefinition> _function,
-								 std::string const& _expectedDoc)
+bool successParse(std::string const& _source)
+{
+	ErrorList errors;
+	try
+	{
+		auto sourceUnit = parseText(_source, errors);
+		if (!sourceUnit)
+			return false;
+	}
+	catch (FatalError const& _exception)
+	{
+		if (Error::containsErrorOfType(errors, Error::Type::ParserError))
+			return false;
+	}
+	if (Error::containsErrorOfType(errors, Error::Type::ParserError))
+		return false;
+
+	BOOST_CHECK(Error::containsOnlyWarnings(errors));
+	return true;
+}
+
+void checkFunctionNatspec(
+	ASTPointer<FunctionDefinition> _function,
+	std::string const& _expectedDoc
+)
 {
 	auto doc = _function->documentation();
 	BOOST_CHECK_MESSAGE(doc != nullptr, "Function does not have Natspec Doc as expected");
@@ -68,7 +92,7 @@ BOOST_AUTO_TEST_CASE(smoke_test)
 	char const* text = "contract test {\n"
 					   "  uint256 stateVariable1;\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed.");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(missing_variable_name_in_declaration)
@@ -76,7 +100,7 @@ BOOST_AUTO_TEST_CASE(missing_variable_name_in_declaration)
 	char const* text = "contract test {\n"
 					   "  uint256 ;\n"
 					   "}\n";
-	BOOST_CHECK_THROW(parseText(text), ParserError);
+	BOOST_CHECK(!successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(empty_function)
@@ -87,7 +111,7 @@ BOOST_AUTO_TEST_CASE(empty_function)
 					   "    returns (int id)\n"
 					   "  { }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed.");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(no_function_params)
@@ -96,7 +120,7 @@ BOOST_AUTO_TEST_CASE(no_function_params)
 					   "  uint256 stateVar;\n"
 					   "  function functionName() {}\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed.");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(single_function_param)
@@ -105,7 +129,7 @@ BOOST_AUTO_TEST_CASE(single_function_param)
 					   "  uint256 stateVar;\n"
 					   "  function functionName(bytes32 input) returns (bytes32 out) {}\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed.");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(function_no_body)
@@ -113,7 +137,7 @@ BOOST_AUTO_TEST_CASE(function_no_body)
 	char const* text = "contract test {\n"
 					   "  function functionName(bytes32 input) returns (bytes32 out);\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed.");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(missing_parameter_name_in_named_args)
@@ -122,7 +146,7 @@ BOOST_AUTO_TEST_CASE(missing_parameter_name_in_named_args)
 					   "  function a(uint a, uint b, uint c) returns (uint r) { r = a * 100 + b * 10 + c * 1; }\n"
 					   "  function b() returns (uint r) { r = a({: 1, : 2, : 3}); }\n"
 					   "}\n";
-	BOOST_CHECK_THROW(parseText(text), ParserError);
+	BOOST_CHECK(!successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(missing_argument_in_named_args)
@@ -131,7 +155,7 @@ BOOST_AUTO_TEST_CASE(missing_argument_in_named_args)
 					   "  function a(uint a, uint b, uint c) returns (uint r) { r = a * 100 + b * 10 + c * 1; }\n"
 					   "  function b() returns (uint r) { r = a({a: , b: , c: }); }\n"
 					   "}\n";
-	BOOST_CHECK_THROW(parseText(text), ParserError);
+	BOOST_CHECK(!successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(two_exact_functions)
@@ -145,7 +169,7 @@ BOOST_AUTO_TEST_CASE(two_exact_functions)
 	// with support of overloaded functions, during parsing,
 	// we can't determine whether they match exactly, however
 	// it will throw DeclarationError in following stage.
-	BOOST_CHECK_NO_THROW(parseText(text));
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(overloaded_functions)
@@ -156,20 +180,23 @@ BOOST_AUTO_TEST_CASE(overloaded_functions)
 			function fun(uint a, uint b) returns(uint r) { return a + b; }
 		}
 	)";
-	BOOST_CHECK_NO_THROW(parseText(text));
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(function_natspec_documentation)
 {
-	ASTPointer<ContractDefinition> contract;
-	ASTPointer<FunctionDefinition> function;
 	char const* text = "contract test {\n"
 					   "  uint256 stateVar;\n"
 					   "  /// This is a test function\n"
 					   "  function functionName(bytes32 input) returns (bytes32 out) {}\n"
 					   "}\n";
-	ETH_TEST_REQUIRE_NO_THROW(contract = parseText(text), "Parsing failed");
-	auto functions = contract->definedFunctions();
+	BOOST_CHECK(successParse(text));
+	ErrorList e;
+	ASTPointer<ContractDefinition> contract = parseText(text, e);
+	ASTPointer<FunctionDefinition> function;
+
+	ErrorList errors;
+	auto functions = parseText(text, errors)->definedFunctions();
 	ETH_TEST_REQUIRE_NO_THROW(function = functions.at(0), "Failed to retrieve function");
 	checkFunctionNatspec(function, "This is a test function");
 }
@@ -183,8 +210,9 @@ BOOST_AUTO_TEST_CASE(function_normal_comments)
 					   "  // We won't see this comment\n"
 					   "  function functionName(bytes32 input) returns (bytes32 out) {}\n"
 					   "}\n";
-	ETH_TEST_REQUIRE_NO_THROW(contract = parseText(text), "Parsing failed");
-	auto functions = contract->definedFunctions();
+	BOOST_CHECK(successParse(text));
+	ErrorList errors;
+	auto functions = parseText(text, errors)->definedFunctions();
 	ETH_TEST_REQUIRE_NO_THROW(function = functions.at(0), "Failed to retrieve function");
 	BOOST_CHECK_MESSAGE(function->documentation() == nullptr,
 						"Should not have gotten a Natspecc comment for this function");
@@ -205,8 +233,9 @@ BOOST_AUTO_TEST_CASE(multiple_functions_natspec_documentation)
 					   "  /// This is test function 4\n"
 					   "  function functionName4(bytes32 input) returns (bytes32 out) {}\n"
 					   "}\n";
-	ETH_TEST_REQUIRE_NO_THROW(contract = parseText(text), "Parsing failed");
-	auto functions = contract->definedFunctions();
+	BOOST_CHECK(successParse(text));
+	ErrorList errors;
+	auto functions = parseText(text, errors)->definedFunctions();
 
 	ETH_TEST_REQUIRE_NO_THROW(function = functions.at(0), "Failed to retrieve function");
 	checkFunctionNatspec(function, "This is test function 1");
@@ -232,9 +261,9 @@ BOOST_AUTO_TEST_CASE(multiline_function_documentation)
 					   "  /// and it has 2 lines\n"
 					   "  function functionName1(bytes32 input) returns (bytes32 out) {}\n"
 					   "}\n";
-	ETH_TEST_REQUIRE_NO_THROW(contract = parseText(text), "Parsing failed");
-	auto functions = contract->definedFunctions();
-
+	BOOST_CHECK(successParse(text));
+	ErrorList errors;
+	auto functions = parseText(text, errors)->definedFunctions();
 	ETH_TEST_REQUIRE_NO_THROW(function = functions.at(0), "Failed to retrieve function");
 	checkFunctionNatspec(function, "This is a test function\n"
 						 " and it has 2 lines");
@@ -257,8 +286,9 @@ BOOST_AUTO_TEST_CASE(natspec_comment_in_function_body)
 					   "  /// and it has 2 lines\n"
 					   "  function fun(bytes32 input) returns (bytes32 out) {}\n"
 					   "}\n";
-	ETH_TEST_REQUIRE_NO_THROW(contract = parseText(text), "Parsing failed");
-	auto functions = contract->definedFunctions();
+	BOOST_CHECK(successParse(text));
+	ErrorList errors;
+	auto functions = parseText(text, errors)->definedFunctions();
 
 	ETH_TEST_REQUIRE_NO_THROW(function = functions.at(0), "Failed to retrieve function");
 	checkFunctionNatspec(function, "fun1 description");
@@ -283,8 +313,9 @@ BOOST_AUTO_TEST_CASE(natspec_docstring_between_keyword_and_signature)
 					   "    bytes7 name = \"Solidity\";"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_REQUIRE_NO_THROW(contract = parseText(text), "Parsing failed");
-	auto functions = contract->definedFunctions();
+	BOOST_CHECK(successParse(text));
+	ErrorList errors;
+	auto functions = parseText(text, errors)->definedFunctions();
 
 	ETH_TEST_REQUIRE_NO_THROW(function = functions.at(0), "Failed to retrieve function");
 	BOOST_CHECK_MESSAGE(!function->documentation(),
@@ -306,8 +337,9 @@ BOOST_AUTO_TEST_CASE(natspec_docstring_after_signature)
 					   "    bytes7 name = \"Solidity\";"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_REQUIRE_NO_THROW(contract = parseText(text), "Parsing failed");
-	auto functions = contract->definedFunctions();
+	BOOST_CHECK(successParse(text));
+	ErrorList errors;
+	auto functions = parseText(text, errors)->definedFunctions();
 
 	ETH_TEST_REQUIRE_NO_THROW(function = functions.at(0), "Failed to retrieve function");
 	BOOST_CHECK_MESSAGE(!function->documentation(),
@@ -323,7 +355,7 @@ BOOST_AUTO_TEST_CASE(struct_definition)
 					   "    uint256 count;\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(mapping)
@@ -331,7 +363,7 @@ BOOST_AUTO_TEST_CASE(mapping)
 	char const* text = "contract test {\n"
 					   "  mapping(address => bytes32) names;\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(mapping_in_struct)
@@ -343,7 +375,7 @@ BOOST_AUTO_TEST_CASE(mapping_in_struct)
 					   "    mapping(bytes32 => test_struct) self_reference;\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(mapping_to_mapping_in_struct)
@@ -354,7 +386,7 @@ BOOST_AUTO_TEST_CASE(mapping_to_mapping_in_struct)
 					   "    mapping (uint64 => mapping (bytes32 => uint)) complex_mapping;\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(variable_definition)
@@ -367,7 +399,7 @@ BOOST_AUTO_TEST_CASE(variable_definition)
 					   "    customtype varname;\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(variable_definition_with_initialization)
@@ -381,7 +413,7 @@ BOOST_AUTO_TEST_CASE(variable_definition_with_initialization)
 					   "    customtype varname;\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(variable_definition_in_function_parameter)
@@ -391,7 +423,7 @@ BOOST_AUTO_TEST_CASE(variable_definition_in_function_parameter)
 			function fun(var a) {}
 		}
 	)";
-	BOOST_CHECK_THROW(parseText(text), ParserError);
+	BOOST_CHECK(!successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(variable_definition_in_mapping)
@@ -403,7 +435,7 @@ BOOST_AUTO_TEST_CASE(variable_definition_in_mapping)
 			}
 		}
 	)";
-	BOOST_CHECK_THROW(parseText(text), ParserError);
+	BOOST_CHECK(!successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(variable_definition_in_function_return)
@@ -415,7 +447,7 @@ BOOST_AUTO_TEST_CASE(variable_definition_in_function_return)
 			}
 		}
 	)";
-	BOOST_CHECK_THROW(parseText(text), ParserError);
+	BOOST_CHECK(!successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(operator_expression)
@@ -425,7 +457,7 @@ BOOST_AUTO_TEST_CASE(operator_expression)
 					   "    uint256 x = (1 + 4) || false && (1 - 12) + -9;\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(complex_expression)
@@ -435,7 +467,7 @@ BOOST_AUTO_TEST_CASE(complex_expression)
 					   "    uint256 x = (1 + 4).member(++67)[a/=9] || true;\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(exp_expression)
@@ -446,7 +478,7 @@ BOOST_AUTO_TEST_CASE(exp_expression)
 				uint256 x = 3 ** a;
 			}
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(while_loop)
@@ -456,7 +488,7 @@ BOOST_AUTO_TEST_CASE(while_loop)
 					   "    while (true) { uint256 x = 1; break; continue; } x = 9;\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(for_loop_vardef_initexpr)
@@ -467,7 +499,7 @@ BOOST_AUTO_TEST_CASE(for_loop_vardef_initexpr)
 					   "    { uint256 x = i; break; continue; }\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(for_loop_simple_initexpr)
@@ -479,7 +511,7 @@ BOOST_AUTO_TEST_CASE(for_loop_simple_initexpr)
 					   "    { uint256 x = i; break; continue; }\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(for_loop_simple_noexpr)
@@ -491,7 +523,7 @@ BOOST_AUTO_TEST_CASE(for_loop_simple_noexpr)
 					   "    { uint256 x = i; break; continue; }\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(for_loop_single_stmt_body)
@@ -503,7 +535,7 @@ BOOST_AUTO_TEST_CASE(for_loop_single_stmt_body)
 					   "        continue;\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(if_statement)
@@ -513,7 +545,7 @@ BOOST_AUTO_TEST_CASE(if_statement)
 					   "    if (a >= 8) return 2; else { var b = 7; }\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(else_if_statement)
@@ -523,7 +555,7 @@ BOOST_AUTO_TEST_CASE(else_if_statement)
 					   "    if (a < 0) b = 0x67; else if (a == 0) b = 0x12; else b = 0x78;\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(statement_starting_with_type_conversion)
@@ -535,7 +567,7 @@ BOOST_AUTO_TEST_CASE(statement_starting_with_type_conversion)
 					   "    uint64[](3);\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(type_conversion_to_dynamic_array)
@@ -545,7 +577,7 @@ BOOST_AUTO_TEST_CASE(type_conversion_to_dynamic_array)
 					   "    var x = uint64[](3);\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(import_directive)
@@ -556,7 +588,7 @@ BOOST_AUTO_TEST_CASE(import_directive)
 					   "    uint64(2);\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(multiple_contracts)
@@ -571,7 +603,7 @@ BOOST_AUTO_TEST_CASE(multiple_contracts)
 					   "    uint64(2);\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(multiple_contracts_and_imports)
@@ -589,7 +621,7 @@ BOOST_AUTO_TEST_CASE(multiple_contracts_and_imports)
 					   "  }\n"
 					   "}\n"
 					   "import \"ghi\";\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(contract_inheritance)
@@ -604,7 +636,7 @@ BOOST_AUTO_TEST_CASE(contract_inheritance)
 					   "    uint64(2);\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(contract_multiple_inheritance)
@@ -619,7 +651,7 @@ BOOST_AUTO_TEST_CASE(contract_multiple_inheritance)
 					   "    uint64(2);\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(contract_multiple_inheritance_with_arguments)
@@ -634,7 +666,7 @@ BOOST_AUTO_TEST_CASE(contract_multiple_inheritance_with_arguments)
 					   "    uint64(2);\n"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(placeholder_in_function_context)
@@ -645,7 +677,7 @@ BOOST_AUTO_TEST_CASE(placeholder_in_function_context)
 					   "    return _ + 1;"
 					   "  }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(modifier)
@@ -653,7 +685,7 @@ BOOST_AUTO_TEST_CASE(modifier)
 	char const* text = "contract c {\n"
 					   "  modifier mod { if (msg.sender == 0) _ }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(modifier_arguments)
@@ -661,7 +693,7 @@ BOOST_AUTO_TEST_CASE(modifier_arguments)
 	char const* text = "contract c {\n"
 					   "  modifier mod(uint a) { if (msg.sender == a) _ }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(modifier_invocation)
@@ -671,7 +703,7 @@ BOOST_AUTO_TEST_CASE(modifier_invocation)
 					   "  modifier mod2 { if (msg.sender == 2) _ }\n"
 					   "  function f() mod1(7) mod2 { }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(fallback_function)
@@ -679,7 +711,7 @@ BOOST_AUTO_TEST_CASE(fallback_function)
 	char const* text = "contract c {\n"
 					   "  function() { }\n"
 					   "}\n";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(event)
@@ -688,7 +720,7 @@ BOOST_AUTO_TEST_CASE(event)
 		contract c {
 			event e();
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(event_arguments)
@@ -697,7 +729,7 @@ BOOST_AUTO_TEST_CASE(event_arguments)
 		contract c {
 			event e(uint a, bytes32 s);
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(event_arguments_indexed)
@@ -706,7 +738,7 @@ BOOST_AUTO_TEST_CASE(event_arguments_indexed)
 		contract c {
 			event e(uint a, bytes32 indexed s, bool indexed b);
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(visibility_specifiers)
@@ -722,7 +754,7 @@ BOOST_AUTO_TEST_CASE(visibility_specifiers)
 			function f_public() public {}
 			function f_internal() internal {}
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(multiple_visibility_specifiers)
@@ -731,7 +763,7 @@ BOOST_AUTO_TEST_CASE(multiple_visibility_specifiers)
 		contract c {
 			uint private internal a;
 		})";
-	BOOST_CHECK_THROW(parseText(text), ParserError);
+	BOOST_CHECK(!successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(literal_constants_with_ether_subdenominations)
@@ -750,7 +782,7 @@ BOOST_AUTO_TEST_CASE(literal_constants_with_ether_subdenominations)
 			uint256 c;
 			uint256 d;
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(literal_constants_with_ether_subdenominations_in_expressions)
@@ -763,7 +795,7 @@ BOOST_AUTO_TEST_CASE(literal_constants_with_ether_subdenominations_in_expression
 			}
 			uint256 a;
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(enum_valid_declaration)
@@ -777,7 +809,7 @@ BOOST_AUTO_TEST_CASE(enum_valid_declaration)
 			}
 			uint256 a;
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(empty_enum_declaration)
@@ -786,7 +818,7 @@ BOOST_AUTO_TEST_CASE(empty_enum_declaration)
 		contract c {
 			enum foo { }
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(malformed_enum_declaration)
@@ -795,7 +827,7 @@ BOOST_AUTO_TEST_CASE(malformed_enum_declaration)
 		contract c {
 			enum foo { WARNING,}
 		})";
-	BOOST_CHECK_THROW(parseText(text), ParserError);
+	BOOST_CHECK(!successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(external_function)
@@ -804,7 +836,7 @@ BOOST_AUTO_TEST_CASE(external_function)
 		contract c {
 			function x() external {}
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(external_variable)
@@ -813,7 +845,7 @@ BOOST_AUTO_TEST_CASE(external_variable)
 		contract c {
 			uint external x;
 		})";
-	BOOST_CHECK_THROW(parseText(text), ParserError);
+	BOOST_CHECK(!successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(arrays_in_storage)
@@ -825,7 +857,7 @@ BOOST_AUTO_TEST_CASE(arrays_in_storage)
 			struct x { uint[2**20] b; y[0] c; }
 			struct y { uint d; mapping(uint=>x)[] e; }
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(arrays_in_events)
@@ -834,7 +866,7 @@ BOOST_AUTO_TEST_CASE(arrays_in_events)
 		contract c {
 			event e(uint[10] a, bytes7[8] indexed b, c[3] x);
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(arrays_in_expressions)
@@ -843,7 +875,7 @@ BOOST_AUTO_TEST_CASE(arrays_in_expressions)
 		contract c {
 			function f() { c[10] a = 7; uint8[10 * 2] x; }
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(multi_arrays)
@@ -852,7 +884,7 @@ BOOST_AUTO_TEST_CASE(multi_arrays)
 		contract c {
 			mapping(uint => mapping(uint => int8)[8][][9])[] x;
 		})";
-	ETH_TEST_CHECK_NO_THROW(parseText(text), "Parsing failed");
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(constant_is_keyword)
@@ -861,7 +893,7 @@ BOOST_AUTO_TEST_CASE(constant_is_keyword)
 		contract Foo {
 			uint constant = 4;
 	})";
-	BOOST_CHECK_THROW(parseText(text), ParserError);
+	BOOST_CHECK(!successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(var_array)
@@ -870,7 +902,7 @@ BOOST_AUTO_TEST_CASE(var_array)
 		contract Foo {
 			function f() { var[] a; }
 	})";
-	BOOST_CHECK_THROW(parseText(text), ParserError);
+	BOOST_CHECK(!successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(location_specifiers_for_params)
@@ -880,7 +912,7 @@ BOOST_AUTO_TEST_CASE(location_specifiers_for_params)
 			function f(uint[] storage constant x, uint[] memory y) { }
 		}
 	)";
-	BOOST_CHECK_NO_THROW(parseText(text));
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(location_specifiers_for_locals)
@@ -893,7 +925,7 @@ BOOST_AUTO_TEST_CASE(location_specifiers_for_locals)
 			}
 		}
 	)";
-	BOOST_CHECK_NO_THROW(parseText(text));
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(location_specifiers_for_state)
@@ -902,7 +934,7 @@ BOOST_AUTO_TEST_CASE(location_specifiers_for_state)
 		contract Foo {
 			uint[] memory x;
 	})";
-	BOOST_CHECK_THROW(parseText(text), ParserError);
+	BOOST_CHECK(!successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(location_specifiers_with_var)
@@ -911,7 +943,7 @@ BOOST_AUTO_TEST_CASE(location_specifiers_with_var)
 		contract Foo {
 			function f() { var memory x; }
 	})";
-	BOOST_CHECK_THROW(parseText(text), ParserError);
+	BOOST_CHECK(!successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(empty_comment)
@@ -921,7 +953,7 @@ BOOST_AUTO_TEST_CASE(empty_comment)
 		contract test
 		{}
 	)";
-	BOOST_CHECK_NO_THROW(parseText(text));
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_CASE(library_simple)
@@ -931,7 +963,74 @@ BOOST_AUTO_TEST_CASE(library_simple)
 			function f() { }
 		}
 	)";
-	BOOST_CHECK_NO_THROW(parseText(text));
+	BOOST_CHECK(successParse(text));
+}
+
+
+BOOST_AUTO_TEST_CASE(local_const_variable)
+{
+	char const* text = R"(
+		contract Foo {
+			function localConst() returns (uint ret)
+			{
+				uint constant local = 4;
+				return local;
+			}
+	})";
+	BOOST_CHECK(!successParse(text));
+}
+
+BOOST_AUTO_TEST_CASE(multi_variable_declaration)
+{
+	char const* text = R"(
+		contract C {
+			function f() {
+				var (a,b,c) = g();
+				var (d) = 2;
+				var (,e) = 3;
+				var (f,) = 4;
+				var (x,,) = g();
+				var (,y,) = g();
+				var () = g();
+				var (,,) = g();
+			}
+			function g() returns (uint, uint, uint) {}
+		}
+	)";
+	BOOST_CHECK(successParse(text));
+}
+
+BOOST_AUTO_TEST_CASE(tuples)
+{
+	char const* text = R"(
+		contract C {
+			function f() {
+				uint a = (1);
+				var (b,) = (1,);
+				var (c,d) = (1, 2 + a);
+				var (e,) = (1, 2, b);
+			}
+		}
+	)";
+	BOOST_CHECK(successParse(text));
+}
+
+BOOST_AUTO_TEST_CASE(member_access_parser_ambiguity)
+{
+	char const* text = R"(
+		contract C {
+			struct S { uint a; uint b; uint[][][] c; }
+			function f() {
+				C.S x;
+				C.S memory y;
+				C.S[10] memory z;
+				C.S[10](x);
+				x.a = 2;
+				x.c[1][2][3] = 9;
+			}
+		}
+	)";
+	BOOST_CHECK(successParse(text));
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/test/libsolidity/solidityExecutionFramework.h b/test/libsolidity/solidityExecutionFramework.h
index 3370044c..82fede84 100644
--- a/test/libsolidity/solidityExecutionFramework.h
+++ b/test/libsolidity/solidityExecutionFramework.h
@@ -67,12 +67,26 @@ public:
 		return m_output;
 	}
 
-	template <class Exceptiontype>
-	void compileRequireThrow(std::string const& _sourceCode)
+	void compileRequireError(std::string const& _sourceCode, Error::Type _type)
 	{
 		m_compiler.reset(false, m_addStandardSources);
 		m_compiler.addSource("", _sourceCode);
-		BOOST_REQUIRE_THROW(m_compiler.compile(m_optimize, m_optimizeRuns), Exceptiontype);
+		bool foundError = false;
+		try
+		{
+			m_compiler.compile(m_optimize, m_optimizeRuns);
+			BOOST_REQUIRE(Error::containsErrorOfType(m_compiler.errors(), _type));
+		}
+		catch (Error const& _e)
+		{
+			BOOST_REQUIRE(_e.type() == _type);
+			foundError = true;
+		}
+		catch (Exception const& _exception)
+		{
+			BOOST_REQUIRE(false);
+		}
+		BOOST_REQUIRE(foundError);
 	}
 
 	bytes const& compileAndRun(
