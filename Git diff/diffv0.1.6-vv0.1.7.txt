diff --git a/CMakeLists.txt b/CMakeLists.txt
index 1c73a5ff..4b887365 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -8,7 +8,7 @@ include(EthPolicy)
 eth_policy()
 
 # project name and version should be set after cmake_policy CMP0048
-set(PROJECT_VERSION "0.1.6")
+set(PROJECT_VERSION "0.1.7")
 project(solidity VERSION ${PROJECT_VERSION})
 
 # Let's find our dependencies
diff --git a/README.md b/README.md
index cd6b48de..5b40e1a8 100644
--- a/README.md
+++ b/README.md
@@ -2,7 +2,7 @@
 [![Join the chat at https://gitter.im/ethereum/solidity](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/ethereum/solidity?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
 ## Useful links
 
-To get started you can find a basic introduction to the language in [Solidity Tutorial](https://github.com/ethereum/wiki/wiki/Solidity-Tutorial).
+To get started you can find a basic introduction to the language in [Solidity Tutorial](https://ethereum.github.io/solidity/docs/home/).
 
 You can start using [Solidity in your browser](https://chriseth.github.io/browser-solidity/) with no need to download or compile anything. This application only supports compilation - if you want to inject it into the blockchain, you have to use a client like [Geth](https://github.com/ethereum/go-ethereum/wiki) or [AlethZero](https://github.com/ethereum/alethzero).
 
diff --git a/libsolidity/CMakeLists.txt b/libsolidity/CMakeLists.txt
index 9fa35e3b..d59afc2d 100644
--- a/libsolidity/CMakeLists.txt
+++ b/libsolidity/CMakeLists.txt
@@ -1,10 +1,15 @@
 set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DSTATICLIB")
 
-aux_source_directory(. SRC_LIST)
+aux_source_directory(analysis SRC_LIST)
+aux_source_directory(ast SRC_LIST)
+aux_source_directory(codegen SRC_LIST)
+aux_source_directory(formal SRC_LIST)
+aux_source_directory(interface SRC_LIST)
+aux_source_directory(parsing SRC_LIST)
 
 set(EXECUTABLE solidity)
 
-file(GLOB HEADERS "*.h") 
+file(GLOB HEADERS "*/*.h") 
 
 include_directories(BEFORE ..)
 add_library(${EXECUTABLE} ${SRC_LIST} ${HEADERS})
diff --git a/libsolidity/InterfaceHandler.cpp b/libsolidity/InterfaceHandler.cpp
deleted file mode 100644
index 17ca66b4..00000000
--- a/libsolidity/InterfaceHandler.cpp
+++ /dev/null
@@ -1,478 +0,0 @@
-
-#include <libsolidity/InterfaceHandler.h>
-#include <boost/range/irange.hpp>
-#include <libsolidity/AST.h>
-#include <libsolidity/CompilerStack.h>
-using namespace std;
-
-namespace dev
-{
-namespace solidity
-{
-
-/* -- public -- */
-
-InterfaceHandler::InterfaceHandler()
-{
-	m_lastTag = DocTagType::None;
-}
-
-string InterfaceHandler::documentation(
-	ContractDefinition const& _contractDef,
-	DocumentationType _type
-)
-{
-	switch(_type)
-	{
-	case DocumentationType::NatspecUser:
-		return userDocumentation(_contractDef);
-	case DocumentationType::NatspecDev:
-		return devDocumentation(_contractDef);
-	case DocumentationType::ABIInterface:
-		return abiInterface(_contractDef);
-	case DocumentationType::ABISolidityInterface:
-		return ABISolidityInterface(_contractDef);
-	}
-
-	BOOST_THROW_EXCEPTION(InternalCompilerError() << errinfo_comment("Unknown documentation type"));
-	return "";
-}
-
-string InterfaceHandler::abiInterface(ContractDefinition const& _contractDef)
-{
-	Json::Value abi(Json::arrayValue);
-
-	auto populateParameters = [](vector<string> const& _paramNames, vector<string> const& _paramTypes)
-	{
-		Json::Value params(Json::arrayValue);
-		solAssert(_paramNames.size() == _paramTypes.size(), "Names and types vector size does not match");
-		for (unsigned i = 0; i < _paramNames.size(); ++i)
-		{
-			Json::Value param;
-			param["name"] = _paramNames[i];
-			param["type"] = _paramTypes[i];
-			params.append(param);
-		}
-		return params;
-	};
-
-	for (auto it: _contractDef.interfaceFunctions())
-	{
-		auto externalFunctionType = it.second->interfaceFunctionType();
-		Json::Value method;
-		method["type"] = "function";
-		method["name"] = it.second->declaration().name();
-		method["constant"] = it.second->isConstant();
-		method["inputs"] = populateParameters(
-			externalFunctionType->parameterNames(),
-			externalFunctionType->parameterTypeNames(_contractDef.isLibrary())
-		);
-		method["outputs"] = populateParameters(
-			externalFunctionType->returnParameterNames(),
-			externalFunctionType->returnParameterTypeNames(_contractDef.isLibrary())
-		);
-		abi.append(method);
-	}
-	if (_contractDef.constructor())
-	{
-		Json::Value method;
-		method["type"] = "constructor";
-		auto externalFunction = FunctionType(*_contractDef.constructor()).interfaceFunctionType();
-		solAssert(!!externalFunction, "");
-		method["inputs"] = populateParameters(
-			externalFunction->parameterNames(),
-			externalFunction->parameterTypeNames(_contractDef.isLibrary())
-		);
-		abi.append(method);
-	}
-
-	for (auto const& it: _contractDef.interfaceEvents())
-	{
-		Json::Value event;
-		event["type"] = "event";
-		event["name"] = it->name();
-		event["anonymous"] = it->isAnonymous();
-		Json::Value params(Json::arrayValue);
-		for (auto const& p: it->parameters())
-		{
-			Json::Value input;
-			input["name"] = p->name();
-			input["type"] = p->annotation().type->canonicalName(false);
-			input["indexed"] = p->isIndexed();
-			params.append(input);
-		}
-		event["inputs"] = params;
-		abi.append(event);
-	}
-	return Json::FastWriter().write(abi);
-}
-
-string InterfaceHandler::ABISolidityInterface(ContractDefinition const& _contractDef)
-{
-	string ret = (_contractDef.isLibrary() ? "library " : "contract ") + _contractDef.name() + "{";
-
-	auto populateParameters = [](vector<string> const& _paramNames, vector<string> const& _paramTypes)
-	{
-		string ret = "(";
-		for (size_t i = 0; i < _paramNames.size(); ++i)
-			ret += _paramTypes[i] + " " + _paramNames[i] + ",";
-		if (ret.size() != 1)
-			ret.pop_back();
-		return ret + ")";
-	};
-	// If this is a library, include all its enum and struct types. Should be more intelligent
-	// in the future and check what is actually used (it might even use types from other libraries
-	// or contracts or in the global scope).
-	if (_contractDef.isLibrary())
-	{
-		for (auto const& stru: _contractDef.definedStructs())
-		{
-			ret += "struct " + stru->name() + "{";
-			for (ASTPointer<VariableDeclaration> const& _member: stru->members())
-				ret += _member->type(nullptr)->canonicalName(false) + " " + _member->name() + ";";
-			ret += "}";
-		}
-		for (auto const& enu: _contractDef.definedEnums())
-		{
-			ret += "enum " + enu->name() + "{";
-			for (ASTPointer<EnumValue> const& val: enu->members())
-				ret += val->name() + ",";
-			if (ret.back() == ',')
-				ret.pop_back();
-			ret += "}";
-		}
-	}
-	if (_contractDef.constructor())
-	{
-		auto externalFunction = FunctionType(*_contractDef.constructor()).interfaceFunctionType();
-		solAssert(!!externalFunction, "");
-		ret +=
-			"function " +
-			_contractDef.name() +
-			populateParameters(
-				externalFunction->parameterNames(),
-				externalFunction->parameterTypeNames(_contractDef.isLibrary())
-			) +
-			";";
-	}
-	for (auto const& it: _contractDef.interfaceFunctions())
-	{
-		ret += "function " + it.second->declaration().name() +
-			populateParameters(
-				it.second->parameterNames(),
-				it.second->parameterTypeNames(_contractDef.isLibrary())
-			) + (it.second->isConstant() ? "constant " : "");
-		if (it.second->returnParameterTypes().size())
-			ret += "returns" + populateParameters(
-				it.second->returnParameterNames(),
-				it.second->returnParameterTypeNames(_contractDef.isLibrary())
-			);
-		else if (ret.back() == ' ')
-			ret.pop_back();
-		ret += ";";
-	}
-
-	return ret + "}";
-}
-
-string InterfaceHandler::userDocumentation(ContractDefinition const& _contractDef)
-{
-	Json::Value doc;
-	Json::Value methods(Json::objectValue);
-
-	for (auto const& it: _contractDef.interfaceFunctions())
-	{
-		Json::Value user;
-		auto strPtr = it.second->documentation();
-		if (strPtr)
-		{
-			resetUser();
-			parseDocString(*strPtr, CommentOwner::Function);
-			if (!m_notice.empty())
-			{// since @notice is the only user tag if missing function should not appear
-				user["notice"] = Json::Value(m_notice);
-				methods[it.second->externalSignature()] = user;
-			}
-		}
-	}
-	doc["methods"] = methods;
-
-	return Json::StyledWriter().write(doc);
-}
-
-string InterfaceHandler::devDocumentation(ContractDefinition const& _contractDef)
-{
-	// LTODO: Somewhere in this function warnings for mismatch of param names
-	// should be thrown
-	Json::Value doc;
-	Json::Value methods(Json::objectValue);
-
-	auto contractDoc = _contractDef.documentation();
-	if (contractDoc)
-	{
-		m_contractAuthor.clear();
-		m_title.clear();
-		parseDocString(*contractDoc, CommentOwner::Contract);
-
-		if (!m_contractAuthor.empty())
-			doc["author"] = m_contractAuthor;
-
-		if (!m_title.empty())
-			doc["title"] = m_title;
-	}
-
-	for (auto const& it: _contractDef.interfaceFunctions())
-	{
-		Json::Value method;
-		auto strPtr = it.second->documentation();
-		if (strPtr)
-		{
-			resetDev();
-			parseDocString(*strPtr, CommentOwner::Function);
-
-			if (!m_dev.empty())
-				method["details"] = Json::Value(m_dev);
-
-			if (!m_author.empty())
-				method["author"] = m_author;
-
-			Json::Value params(Json::objectValue);
-			vector<string> paramNames = it.second->parameterNames();
-			for (auto const& pair: m_params)
-			{
-				if (find(paramNames.begin(), paramNames.end(), pair.first) == paramNames.end())
-					// LTODO: mismatching parameter name, throw some form of warning and not just an exception
-					BOOST_THROW_EXCEPTION(
-						Error(Error::Type::DocstringParsingError) <<
-						errinfo_comment("documented parameter \"" + pair.first + "\" not found in the parameter list of the function.")
-					);					
-				params[pair.first] = pair.second;
-			}
-
-			if (!m_params.empty())
-				method["params"] = params;
-
-			if (!m_return.empty())
-				method["return"] = m_return;
-
-			if (!method.empty()) // add the function, only if we have any documentation to add
-				methods[it.second->externalSignature()] = method;
-		}
-	}
-	doc["methods"] = methods;
-
-	return Json::StyledWriter().write(doc);
-}
-
-/* -- private -- */
-void InterfaceHandler::resetUser()
-{
-	m_notice.clear();
-}
-
-void InterfaceHandler::resetDev()
-{
-	m_dev.clear();
-	m_author.clear();
-	m_return.clear();
-	m_params.clear();
-}
-
-static inline string::const_iterator skipLineOrEOS(
-	string::const_iterator _nlPos,
-	string::const_iterator _end
-)
-{
-	return (_nlPos == _end) ? _end : ++_nlPos;
-}
-
-string::const_iterator InterfaceHandler::parseDocTagLine(
-	string::const_iterator _pos,
-	string::const_iterator _end,
-	string& _tagString,
-	DocTagType _tagType,
-	bool _appending
-)
-{
-	auto nlPos = find(_pos, _end, '\n');
-	if (_appending && _pos < _end && *_pos != ' ')
-		_tagString += " ";
-	copy(_pos, nlPos, back_inserter(_tagString));
-	m_lastTag = _tagType;
-	return skipLineOrEOS(nlPos, _end);
-}
-
-string::const_iterator InterfaceHandler::parseDocTagParam(
-	string::const_iterator _pos,
-	string::const_iterator _end
-)
-{
-	// find param name
-	auto currPos = find(_pos, _end, ' ');
-	if (currPos == _end)
-		BOOST_THROW_EXCEPTION(Error(Error::Type::DocstringParsingError) << errinfo_comment("End of param name not found" + string(_pos, _end)));
-
-
-	auto paramName = string(_pos, currPos);
-
-	currPos += 1;
-	auto nlPos = find(currPos, _end, '\n');
-	auto paramDesc = string(currPos, nlPos);
-	m_params.push_back(make_pair(paramName, paramDesc));
-
-	m_lastTag = DocTagType::Param;
-	return skipLineOrEOS(nlPos, _end);
-}
-
-string::const_iterator InterfaceHandler::appendDocTagParam(
-	string::const_iterator _pos,
-	string::const_iterator _end
-)
-{
-	// Should never be called with an empty vector
-	solAssert(!m_params.empty(), "Internal: Tried to append to empty parameter");
-
-	auto pair = m_params.back();
-	if (_pos < _end && *_pos != ' ')
-		pair.second += " ";
-	auto nlPos = find(_pos, _end, '\n');
-	copy(_pos, nlPos, back_inserter(pair.second));
-
-	m_params.at(m_params.size() - 1) = pair;
-
-	return skipLineOrEOS(nlPos, _end);
-}
-
-string::const_iterator InterfaceHandler::parseDocTag(
-	string::const_iterator _pos,
-	string::const_iterator _end,
-	string const& _tag,
-	CommentOwner _owner
-)
-{
-	// LTODO: need to check for @(start of a tag) between here and the end of line
-	// for all cases. Also somehow automate list of acceptable tags for each
-	// language construct since current way does not scale well.
-	if (m_lastTag == DocTagType::None || _tag != "")
-	{
-		if (_tag == "dev")
-			return parseDocTagLine(_pos, _end, m_dev, DocTagType::Dev, false);
-		else if (_tag == "notice")
-			return parseDocTagLine(_pos, _end, m_notice, DocTagType::Notice, false);
-		else if (_tag == "return")
-			return parseDocTagLine(_pos, _end, m_return, DocTagType::Return, false);
-		else if (_tag == "author")
-		{
-			if (_owner == CommentOwner::Contract)
-				return parseDocTagLine(_pos, _end, m_contractAuthor, DocTagType::Author, false);
-			else if (_owner == CommentOwner::Function)
-				return parseDocTagLine(_pos, _end, m_author, DocTagType::Author, false);
-			else
-				// LTODO: for now this else makes no sense but later comments will go to more language constructs
-				BOOST_THROW_EXCEPTION(Error(Error::Type::DocstringParsingError) << errinfo_comment("@author tag is legal only for contracts"));
-		}
-		else if (_tag == "title")
-		{
-			if (_owner == CommentOwner::Contract)
-				return parseDocTagLine(_pos, _end, m_title, DocTagType::Title, false);
-			else
-				// LTODO: Unknown tag, throw some form of warning and not just an exception
-				BOOST_THROW_EXCEPTION(Error(Error::Type::DocstringParsingError) << errinfo_comment("@title tag is legal only for contracts"));
-		}
-		else if (_tag == "param")
-			return parseDocTagParam(_pos, _end);
-		else
-			// LTODO: Unknown tag, throw some form of warning and not just an exception
-			BOOST_THROW_EXCEPTION(Error(Error::Type::DocstringParsingError) << errinfo_comment("Unknown tag " + _tag + " encountered"));
-	}
-	else
-		return appendDocTag(_pos, _end, _owner);
-}
-
-string::const_iterator InterfaceHandler::appendDocTag(
-	string::const_iterator _pos,
-	string::const_iterator _end,
-	CommentOwner _owner
-)
-{
-	switch (m_lastTag)
-	{
-	case DocTagType::Dev:
-		return parseDocTagLine(_pos, _end, m_dev, DocTagType::Dev, true);
-	case DocTagType::Notice:
-		return parseDocTagLine(_pos, _end, m_notice, DocTagType::Notice, true);
-	case DocTagType::Return:
-		return parseDocTagLine(_pos, _end, m_return, DocTagType::Return, true);
-	case DocTagType::Author:
-		if (_owner == CommentOwner::Contract)
-			return parseDocTagLine(_pos, _end, m_contractAuthor, DocTagType::Author, true);
-		else if (_owner == CommentOwner::Function)
-			return parseDocTagLine(_pos, _end, m_author, DocTagType::Author, true);
-		else
-			// LTODO: Unknown tag, throw some form of warning and not just an exception
-			BOOST_THROW_EXCEPTION(Error(Error::Type::DocstringParsingError) << errinfo_comment("@author tag in illegal comment"));
-	case DocTagType::Title:
-		if (_owner == CommentOwner::Contract)
-			return parseDocTagLine(_pos, _end, m_title, DocTagType::Title, true);
-		else
-			// LTODO: Unknown tag, throw some form of warning and not just an exception
-			BOOST_THROW_EXCEPTION(Error(Error::Type::DocstringParsingError) << errinfo_comment("@title tag in illegal comment"));
-	case DocTagType::Param:
-		return appendDocTagParam(_pos, _end);
-	default:
-		BOOST_THROW_EXCEPTION(InternalCompilerError() << errinfo_comment("Internal: Illegal documentation tag type"));
-		break;
-	}
-}
-
-static inline string::const_iterator firstSpaceOrNl(
-	string::const_iterator _pos,
-	string::const_iterator _end
-)
-{
-	auto spacePos = find(_pos, _end, ' ');
-	auto nlPos = find(_pos, _end, '\n');
-	return (spacePos < nlPos) ? spacePos : nlPos;
-}
-
-void InterfaceHandler::parseDocString(string const& _string, CommentOwner _owner)
-{
-	auto currPos = _string.begin();
-	auto end = _string.end();
-
-	while (currPos != end)
-	{
-		auto tagPos = find(currPos, end, '@');
-		auto nlPos = find(currPos, end, '\n');
-
-		if (tagPos != end && tagPos < nlPos)
-		{
-			// we found a tag
-			auto tagNameEndPos = firstSpaceOrNl(tagPos, end);
-			if (tagNameEndPos == end)
-				BOOST_THROW_EXCEPTION(
-					Error(Error::Type::DocstringParsingError) <<
-					errinfo_comment("End of tag " + string(tagPos, tagNameEndPos) + "not found"));
-
-			currPos = parseDocTag(tagNameEndPos + 1, end, string(tagPos + 1, tagNameEndPos), _owner);
-		}
-		else if (m_lastTag != DocTagType::None) // continuation of the previous tag
-			currPos = appendDocTag(currPos, end, _owner);
-		else if (currPos != end)
-		{
-			// if it begins without a tag then consider it as @notice
-			if (currPos == _string.begin())
-			{
-				currPos = parseDocTag(currPos, end, "notice", CommentOwner::Function);
-				continue;
-			}
-			else if (nlPos == end) //end of text
-				return;
-			// else skip the line if a newline was found and we get here
-			currPos = nlPos + 1;
-		}
-	}
-}
-
-} //solidity NS
-} // dev NS
diff --git a/libsolidity/ConstantEvaluator.cpp b/libsolidity/analysis/ConstantEvaluator.cpp
similarity index 96%
rename from libsolidity/ConstantEvaluator.cpp
rename to libsolidity/analysis/ConstantEvaluator.cpp
index 5936b3d4..6beb655e 100644
--- a/libsolidity/ConstantEvaluator.cpp
+++ b/libsolidity/analysis/ConstantEvaluator.cpp
@@ -20,8 +20,8 @@
  * Evaluator for types of constant expressions.
  */
 
-#include <libsolidity/ConstantEvaluator.h>
-#include <libsolidity/AST.h>
+#include <libsolidity/analysis/ConstantEvaluator.h>
+#include <libsolidity/ast/AST.h>
 
 using namespace std;
 using namespace dev;
diff --git a/libsolidity/ConstantEvaluator.h b/libsolidity/analysis/ConstantEvaluator.h
similarity index 96%
rename from libsolidity/ConstantEvaluator.h
rename to libsolidity/analysis/ConstantEvaluator.h
index cf3d2094..f311efbf 100644
--- a/libsolidity/ConstantEvaluator.h
+++ b/libsolidity/analysis/ConstantEvaluator.h
@@ -22,7 +22,7 @@
 
 #pragma once
 
-#include <libsolidity/ASTVisitor.h>
+#include <libsolidity/ast/ASTVisitor.h>
 
 namespace dev
 {
diff --git a/libsolidity/DeclarationContainer.cpp b/libsolidity/analysis/DeclarationContainer.cpp
similarity index 95%
rename from libsolidity/DeclarationContainer.cpp
rename to libsolidity/analysis/DeclarationContainer.cpp
index dbe9715d..7339ad5d 100644
--- a/libsolidity/DeclarationContainer.cpp
+++ b/libsolidity/analysis/DeclarationContainer.cpp
@@ -20,9 +20,9 @@
  * Scope - object that holds declaration of names.
  */
 
-#include <libsolidity/DeclarationContainer.h>
-#include <libsolidity/AST.h>
-#include <libsolidity/Types.h>
+#include <libsolidity/analysis/DeclarationContainer.h>
+#include <libsolidity/ast/AST.h>
+#include <libsolidity/ast/Types.h>
 
 using namespace std;
 using namespace dev;
diff --git a/libsolidity/DeclarationContainer.h b/libsolidity/analysis/DeclarationContainer.h
similarity index 98%
rename from libsolidity/DeclarationContainer.h
rename to libsolidity/analysis/DeclarationContainer.h
index 3d6ed2cc..064724d1 100644
--- a/libsolidity/DeclarationContainer.h
+++ b/libsolidity/analysis/DeclarationContainer.h
@@ -26,7 +26,7 @@
 #include <set>
 #include <boost/noncopyable.hpp>
 
-#include <libsolidity/ASTForward.h>
+#include <libsolidity/ast/ASTForward.h>
 
 namespace dev
 {
diff --git a/libsolidity/analysis/DocStringAnalyser.cpp b/libsolidity/analysis/DocStringAnalyser.cpp
new file mode 100644
index 00000000..4f75f03d
--- /dev/null
+++ b/libsolidity/analysis/DocStringAnalyser.cpp
@@ -0,0 +1,128 @@
+/*
+    This file is part of cpp-ethereum.
+
+    cpp-ethereum is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    cpp-ethereum is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.
+*/
+/**
+ * @author Christian <c@ethdev.com>
+ * @date 2015
+ * Parses and analyses the doc strings.
+ * Stores the parsing results in the AST annotations and reports errors.
+ */
+
+#include <libsolidity/analysis/DocStringAnalyser.h>
+#include <libsolidity/ast/AST.h>
+#include <libsolidity/parsing/DocStringParser.h>
+
+using namespace std;
+using namespace dev;
+using namespace dev::solidity;
+
+bool DocStringAnalyser::analyseDocStrings(SourceUnit const& _sourceUnit)
+{
+	m_errorOccured = false;
+	_sourceUnit.accept(*this);
+
+	return !m_errorOccured;
+}
+
+bool DocStringAnalyser::visit(ContractDefinition const& _node)
+{
+	static const set<string> validTags = set<string>{"author", "title", "dev", "notice", "why3"};
+	parseDocStrings(_node, _node.annotation(), validTags, "contracts");
+
+	return true;
+}
+
+bool DocStringAnalyser::visit(FunctionDefinition const& _node)
+{
+	handleCallable(_node, _node, _node.annotation());
+	return true;
+}
+
+bool DocStringAnalyser::visit(ModifierDefinition const& _node)
+{
+	handleCallable(_node, _node, _node.annotation());
+
+	return true;
+}
+
+bool DocStringAnalyser::visit(EventDefinition const& _node)
+{
+	handleCallable(_node, _node, _node.annotation());
+
+	return true;
+}
+
+bool DocStringAnalyser::visitNode(ASTNode const& _node)
+{
+	if (auto node = dynamic_cast<Statement const*>(&_node))
+	{
+		static const set<string> validTags = {"why3"};
+		parseDocStrings(*node, node->annotation(), validTags, "statements");
+	}
+	return true;
+}
+
+void DocStringAnalyser::handleCallable(
+	CallableDeclaration const& _callable,
+	Documented const& _node,
+	DocumentedAnnotation& _annotation
+)
+{
+	static const set<string> validTags = set<string>{"author", "dev", "notice", "return", "param", "why3"};
+	parseDocStrings(_node, _annotation, validTags, "functions");
+
+	set<string> validParams;
+	for (auto const& p: _callable.parameters())
+		validParams.insert(p->name());
+	if (_callable.returnParameterList())
+		for (auto const& p: _callable.returnParameterList()->parameters())
+			validParams.insert(p->name());
+	auto paramRange = _annotation.docTags.equal_range("param");
+	for (auto i = paramRange.first; i != paramRange.second; ++i)
+		if (!validParams.count(i->second.paramName))
+			appendError(
+				"Documented parameter \"" +
+				i->second.paramName +
+				"\" not found in the parameter list of the function."
+			);
+}
+
+void DocStringAnalyser::parseDocStrings(
+	Documented const& _node,
+	DocumentedAnnotation& _annotation,
+	set<string> const& _validTags,
+	string const& _nodeName
+)
+{
+	DocStringParser parser;
+	if (_node.documentation() && !_node.documentation()->empty())
+	{
+		if (!parser.parse(*_node.documentation(), m_errors))
+			m_errorOccured = true;
+		_annotation.docTags = parser.tags();
+	}
+	for (auto const& docTag: _annotation.docTags)
+		if (!_validTags.count(docTag.first))
+			appendError("Doc tag @" + docTag.first + " not valid for " + _nodeName + ".");
+}
+
+void DocStringAnalyser::appendError(string const& _description)
+{
+	auto err = make_shared<Error>(Error::Type::DocstringParsingError);
+	*err << errinfo_comment(_description);
+	m_errors.push_back(err);
+	m_errorOccured = true;
+}
diff --git a/libsolidity/analysis/DocStringAnalyser.h b/libsolidity/analysis/DocStringAnalyser.h
new file mode 100644
index 00000000..cdf297e3
--- /dev/null
+++ b/libsolidity/analysis/DocStringAnalyser.h
@@ -0,0 +1,71 @@
+/*
+    This file is part of cpp-ethereum.
+
+    cpp-ethereum is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    cpp-ethereum is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.
+*/
+/**
+ * @author Christian <c@ethdev.com>
+ * @date 2015
+ * Parses and analyses the doc strings.
+ * Stores the parsing results in the AST annotations and reports errors.
+ */
+
+#pragma once
+
+#include <libsolidity/ast/ASTVisitor.h>
+
+namespace dev
+{
+namespace solidity
+{
+
+/**
+ * Parses and analyses the doc strings.
+ * Stores the parsing results in the AST annotations and reports errors.
+ */
+class DocStringAnalyser: private ASTConstVisitor
+{
+public:
+	DocStringAnalyser(ErrorList& _errors): m_errors(_errors) {}
+	bool analyseDocStrings(SourceUnit const& _sourceUnit);
+
+private:
+	virtual bool visit(ContractDefinition const& _contract) override;
+	virtual bool visit(FunctionDefinition const& _function) override;
+	virtual bool visit(ModifierDefinition const& _modifier) override;
+	virtual bool visit(EventDefinition const& _event) override;
+
+	virtual bool visitNode(ASTNode const&) override;
+
+	void handleCallable(
+		CallableDeclaration const& _callable,
+		Documented const& _node,
+		DocumentedAnnotation& _annotation
+	);
+
+	void parseDocStrings(
+		Documented const& _node,
+		DocumentedAnnotation& _annotation,
+		std::set<std::string> const& _validTags,
+		std::string const& _nodeName
+	);
+
+	void appendError(std::string const& _description);
+
+	bool m_errorOccured = false;
+	ErrorList& m_errors;
+};
+
+}
+}
diff --git a/libsolidity/GlobalContext.cpp b/libsolidity/analysis/GlobalContext.cpp
similarity index 97%
rename from libsolidity/GlobalContext.cpp
rename to libsolidity/analysis/GlobalContext.cpp
index a0f5396f..20f8272f 100644
--- a/libsolidity/GlobalContext.cpp
+++ b/libsolidity/analysis/GlobalContext.cpp
@@ -22,9 +22,9 @@
  */
 
 #include <memory>
-#include <libsolidity/GlobalContext.h>
-#include <libsolidity/AST.h>
-#include <libsolidity/Types.h>
+#include <libsolidity/analysis/GlobalContext.h>
+#include <libsolidity/ast/AST.h>
+#include <libsolidity/ast/Types.h>
 
 using namespace std;
 
diff --git a/libsolidity/GlobalContext.h b/libsolidity/analysis/GlobalContext.h
similarity index 98%
rename from libsolidity/GlobalContext.h
rename to libsolidity/analysis/GlobalContext.h
index 20ffecb4..482391d3 100644
--- a/libsolidity/GlobalContext.h
+++ b/libsolidity/analysis/GlobalContext.h
@@ -27,7 +27,7 @@
 #include <map>
 #include <memory>
 #include <boost/noncopyable.hpp>
-#include <libsolidity/ASTForward.h>
+#include <libsolidity/ast/ASTForward.h>
 
 namespace dev
 {
diff --git a/libsolidity/NameAndTypeResolver.cpp b/libsolidity/analysis/NameAndTypeResolver.cpp
similarity index 91%
rename from libsolidity/NameAndTypeResolver.cpp
rename to libsolidity/analysis/NameAndTypeResolver.cpp
index edd0704d..806f1322 100644
--- a/libsolidity/NameAndTypeResolver.cpp
+++ b/libsolidity/analysis/NameAndTypeResolver.cpp
@@ -20,10 +20,10 @@
  * Parser part that determines the declarations corresponding to names and the types of expressions.
  */
 
-#include <libsolidity/NameAndTypeResolver.h>
-#include <libsolidity/AST.h>
-#include <libsolidity/TypeChecker.h>
-#include <libsolidity/Exceptions.h>
+#include <libsolidity/analysis/NameAndTypeResolver.h>
+#include <libsolidity/ast/AST.h>
+#include <libsolidity/analysis/TypeChecker.h>
+#include <libsolidity/interface/Exceptions.h>
 
 using namespace std;
 
@@ -64,65 +64,87 @@ bool NameAndTypeResolver::resolveNamesAndTypes(ContractDefinition& _contract)
 	{
 		m_currentScope = &m_scopes[nullptr];
 
+		ReferencesResolver resolver(m_errors, *this, &_contract, nullptr);
+		bool success = true;
 		for (ASTPointer<InheritanceSpecifier> const& baseContract: _contract.baseContracts())
-			ReferencesResolver resolver(*baseContract, *this, &_contract, nullptr);
+			if (!resolver.resolve(*baseContract))
+				success = false;
 
 		m_currentScope = &m_scopes[&_contract];
 
-		linearizeBaseContracts(_contract);
-		std::vector<ContractDefinition const*> properBases(
-			++_contract.annotation().linearizedBaseContracts.begin(),
-			_contract.annotation().linearizedBaseContracts.end()
-		);
+		if (success)
+		{
+			linearizeBaseContracts(_contract);
+			std::vector<ContractDefinition const*> properBases(
+				++_contract.annotation().linearizedBaseContracts.begin(),
+				_contract.annotation().linearizedBaseContracts.end()
+			);
 
-		for (ContractDefinition const* base: properBases)
-			importInheritedScope(*base);
+			for (ContractDefinition const* base: properBases)
+				importInheritedScope(*base);
+		}
 
 		for (ASTPointer<StructDefinition> const& structDef: _contract.definedStructs())
-			ReferencesResolver resolver(*structDef, *this, &_contract, nullptr);
+			if (!resolver.resolve(*structDef))
+				success = false;
 		for (ASTPointer<EnumDefinition> const& enumDef: _contract.definedEnums())
-			ReferencesResolver resolver(*enumDef, *this, &_contract, nullptr);
+			if (!resolver.resolve(*enumDef))
+				success = false;
 		for (ASTPointer<VariableDeclaration> const& variable: _contract.stateVariables())
-			ReferencesResolver resolver(*variable, *this, &_contract, nullptr);
+			if (!resolver.resolve(*variable))
+				success = false;
 		for (ASTPointer<EventDefinition> const& event: _contract.events())
-			ReferencesResolver resolver(*event, *this, &_contract, nullptr);
-
+			if (!resolver.resolve(*event))
+				success = false;
 		// these can contain code, only resolve parameters for now
 		for (ASTPointer<ModifierDefinition> const& modifier: _contract.functionModifiers())
 		{
 			m_currentScope = &m_scopes[modifier.get()];
-			ReferencesResolver resolver(*modifier, *this, &_contract, nullptr);
+			ReferencesResolver resolver(m_errors, *this, &_contract, nullptr);
+			if (!resolver.resolve(*modifier))
+				success = false;
 		}
+
 		for (ASTPointer<FunctionDefinition> const& function: _contract.definedFunctions())
 		{
 			m_currentScope = &m_scopes[function.get()];
-			ReferencesResolver referencesResolver(
-				*function,
+			if (!ReferencesResolver(
+				m_errors,
 				*this,
 				&_contract,
 				function->returnParameterList().get()
-			);
+			).resolve(*function))
+				success = false;
 		}
 
+		if (!success)
+			return false;
+
 		m_currentScope = &m_scopes[&_contract];
 
 		// now resolve references inside the code
 		for (ASTPointer<ModifierDefinition> const& modifier: _contract.functionModifiers())
 		{
 			m_currentScope = &m_scopes[modifier.get()];
-			ReferencesResolver resolver(*modifier, *this, &_contract, nullptr, true);
+			ReferencesResolver resolver(m_errors, *this, &_contract, nullptr, true);
+			if (!resolver.resolve(*modifier))
+				success = false;
 		}
+
 		for (ASTPointer<FunctionDefinition> const& function: _contract.definedFunctions())
 		{
 			m_currentScope = &m_scopes[function.get()];
-			ReferencesResolver referencesResolver(
-				*function,
+			if (!ReferencesResolver(
+				m_errors,
 				*this,
 				&_contract,
 				function->returnParameterList().get(),
 				true
-			);
+			).resolve(*function))
+				success = false;
 		}
+		if (!success)
+			return false;
 	}
 	catch (FatalError const& _e)
 	{
diff --git a/libsolidity/NameAndTypeResolver.h b/libsolidity/analysis/NameAndTypeResolver.h
similarity index 97%
rename from libsolidity/NameAndTypeResolver.h
rename to libsolidity/analysis/NameAndTypeResolver.h
index 7169f302..0d9b2477 100644
--- a/libsolidity/NameAndTypeResolver.h
+++ b/libsolidity/analysis/NameAndTypeResolver.h
@@ -25,10 +25,10 @@
 #include <map>
 #include <list>
 #include <boost/noncopyable.hpp>
-#include <libsolidity/DeclarationContainer.h>
-#include <libsolidity/ReferencesResolver.h>
-#include <libsolidity/ASTVisitor.h>
-#include <libsolidity/ASTAnnotations.h>
+#include <libsolidity/analysis/DeclarationContainer.h>
+#include <libsolidity/analysis/ReferencesResolver.h>
+#include <libsolidity/ast/ASTVisitor.h>
+#include <libsolidity/ast/ASTAnnotations.h>
 
 namespace dev
 {
diff --git a/libsolidity/ReferencesResolver.cpp b/libsolidity/analysis/ReferencesResolver.cpp
similarity index 73%
rename from libsolidity/ReferencesResolver.cpp
rename to libsolidity/analysis/ReferencesResolver.cpp
index b1112dd9..95643578 100644
--- a/libsolidity/ReferencesResolver.cpp
+++ b/libsolidity/analysis/ReferencesResolver.cpp
@@ -20,32 +20,17 @@
  * Component that resolves type names to types and annotates the AST accordingly.
  */
 
-#include <libsolidity/ReferencesResolver.h>
-#include <libsolidity/AST.h>
-#include <libsolidity/NameAndTypeResolver.h>
-#include <libsolidity/Exceptions.h>
-#include <libsolidity/ConstantEvaluator.h>
+#include <libsolidity/analysis/ReferencesResolver.h>
+#include <libsolidity/ast/AST.h>
+#include <libsolidity/analysis/NameAndTypeResolver.h>
+#include <libsolidity/interface/Exceptions.h>
+#include <libsolidity/analysis/ConstantEvaluator.h>
 
 using namespace std;
 using namespace dev;
 using namespace dev::solidity;
 
 
-ReferencesResolver::ReferencesResolver(
-	ASTNode& _root,
-	NameAndTypeResolver& _resolver,
-	ContractDefinition const* _currentContract,
-	ParameterList const* _returnParameters,
-	bool _resolveInsideCode
-):
-	m_resolver(_resolver),
-	m_currentContract(_currentContract),
-	m_returnParameters(_returnParameters),
-	m_resolveInsideCode(_resolveInsideCode)
-{
-	_root.accept(*this);
-}
-
 bool ReferencesResolver::visit(Return const& _return)
 {
 	_return.annotation().functionReturnParameters = m_returnParameters;
@@ -56,24 +41,30 @@ bool ReferencesResolver::visit(UserDefinedTypeName const& _typeName)
 {
 	Declaration const* declaration = m_resolver.pathFromCurrentScope(_typeName.namePath());
 	if (!declaration)
-		BOOST_THROW_EXCEPTION(
-			Error(Error::Type::DeclarationError) <<
-			errinfo_sourceLocation(_typeName.location()) <<
-			errinfo_comment("Identifier not found or not unique.")
-		);
+		fatalDeclarationError(_typeName.location(), "Identifier not found or not unique.");
+
 	_typeName.annotation().referencedDeclaration = declaration;
 	return true;
 }
 
+bool ReferencesResolver::resolve(ASTNode& _root)
+{
+	try
+	{
+		_root.accept(*this);
+	}
+	catch (FatalError const& e)
+	{
+		solAssert(m_errorOccurred, "");
+	}
+	return !m_errorOccurred;
+}
+
 bool ReferencesResolver::visit(Identifier const& _identifier)
 {
 	auto declarations = m_resolver.nameFromCurrentScope(_identifier.name());
 	if (declarations.empty())
-		BOOST_THROW_EXCEPTION(
-			Error(Error::Type::DeclarationError) <<
-			errinfo_sourceLocation(_identifier.location()) <<
-			errinfo_comment("Undeclared identifier.")
-		);
+		fatalDeclarationError(_identifier.location(), "Undeclared identifier.");
 	else if (declarations.size() == 1)
 	{
 		_identifier.annotation().referencedDeclaration = declarations.front();
@@ -108,19 +99,19 @@ void ReferencesResolver::endVisit(VariableDeclaration const& _variable)
 				if (contract.isLibrary())
 				{
 					if (loc == Location::Memory)
-						BOOST_THROW_EXCEPTION(_variable.createTypeError(
+						fatalTypeError(_variable.location(),
 							"Location has to be calldata or storage for external "
 							"library functions (remove the \"memory\" keyword)."
-						));
+						);
 				}
 				else
 				{
 					// force location of external function parameters (not return) to calldata
 					if (loc != Location::Default)
-						BOOST_THROW_EXCEPTION(_variable.createTypeError(
+						fatalTypeError(_variable.location(),
 							"Location has to be calldata for external functions "
 							"(remove the \"memory\" or \"storage\" keyword)."
-						));
+						);
 				}
 				if (loc == Location::Default)
 					type = ref->copyForLocation(DataLocation::CallData, true);
@@ -130,10 +121,10 @@ void ReferencesResolver::endVisit(VariableDeclaration const& _variable)
 				auto const& contract = dynamic_cast<ContractDefinition const&>(*_variable.scope()->scope());
 				// force locations of public or external function (return) parameters to memory
 				if (loc == Location::Storage && !contract.isLibrary())
-					BOOST_THROW_EXCEPTION(_variable.createTypeError(
+					fatalTypeError(_variable.location(),
 						"Location has to be memory for publicly visible functions "
 						"(remove the \"storage\" keyword)."
-					));
+					);
 				if (loc == Location::Default || !contract.isLibrary())
 					type = ref->copyForLocation(DataLocation::Memory, true);
 			}
@@ -142,9 +133,10 @@ void ReferencesResolver::endVisit(VariableDeclaration const& _variable)
 				if (_variable.isConstant())
 				{
 					if (loc != Location::Default && loc != Location::Memory)
-						BOOST_THROW_EXCEPTION(_variable.createTypeError(
+						fatalTypeError(
+							_variable.location(),
 							"Storage location has to be \"memory\" (or unspecified) for constants."
-						));
+						);
 					loc = Location::Memory;
 				}
 				if (loc == Location::Default)
@@ -159,16 +151,14 @@ void ReferencesResolver::endVisit(VariableDeclaration const& _variable)
 			}
 		}
 		else if (loc != Location::Default && !ref)
-			BOOST_THROW_EXCEPTION(_variable.createTypeError(
-				"Storage location can only be given for array or struct types."
-			));
+			fatalTypeError(_variable.location(), "Storage location can only be given for array or struct types.");
 
 		if (!type)
-			BOOST_THROW_EXCEPTION(_variable.typeName()->createTypeError("Invalid type name."));
+			fatalTypeError(_variable.location(), "Invalid type name.");
 
 	}
 	else if (!_variable.canHaveAutoType())
-		BOOST_THROW_EXCEPTION(_variable.createTypeError("Explicit type needed."));
+		fatalTypeError(_variable.location(), "Explicit type needed.");
 	// otherwise we have a "var"-declaration whose type is resolved by the first assignment
 
 	_variable.annotation().type = type;
@@ -194,9 +184,7 @@ TypePointer ReferencesResolver::typeFor(TypeName const& _typeName)
 		else if (ContractDefinition const* contract = dynamic_cast<ContractDefinition const*>(declaration))
 			type = make_shared<ContractType>(*contract);
 		else
-			BOOST_THROW_EXCEPTION(typeName->createTypeError(
-				"Name has to refer to a struct, enum or contract."
-			));
+			fatalTypeError(typeName->location(), "Name has to refer to a struct, enum or contract.");
 	}
 	else if (auto mapping = dynamic_cast<Mapping const*>(&_typeName))
 	{
@@ -212,9 +200,7 @@ TypePointer ReferencesResolver::typeFor(TypeName const& _typeName)
 	{
 		TypePointer baseType = typeFor(arrayType->baseType());
 		if (baseType->storageBytes() == 0)
-			BOOST_THROW_EXCEPTION(arrayType->baseType().createTypeError(
-				"Illegal base type of storage size zero for array."
-			));
+			fatalTypeError(arrayType->baseType().location(), "Illegal base type of storage size zero for array.");
 		if (Expression const* length = arrayType->length())
 		{
 			if (!length->annotation().type)
@@ -222,8 +208,9 @@ TypePointer ReferencesResolver::typeFor(TypeName const& _typeName)
 
 			auto const* lengthType = dynamic_cast<IntegerConstantType const*>(length->annotation().type.get());
 			if (!lengthType)
-				BOOST_THROW_EXCEPTION(length->createTypeError("Invalid array length."));
-			type = make_shared<ArrayType>(DataLocation::Storage, baseType, lengthType->literalValue(nullptr));
+				fatalTypeError(length->location(), "Invalid array length.");
+			else
+				type = make_shared<ArrayType>(DataLocation::Storage, baseType, lengthType->literalValue(nullptr));
 		}
 		else
 			type = make_shared<ArrayType>(DataLocation::Storage, baseType);
@@ -232,3 +219,31 @@ TypePointer ReferencesResolver::typeFor(TypeName const& _typeName)
 	return _typeName.annotation().type = move(type);
 }
 
+void ReferencesResolver::typeError(SourceLocation const& _location, string const& _description)
+{
+	auto err = make_shared<Error>(Error::Type::TypeError);
+	*err <<	errinfo_sourceLocation(_location) << errinfo_comment(_description);
+	m_errorOccurred = true;
+	m_errors.push_back(err);
+}
+
+void ReferencesResolver::fatalTypeError(SourceLocation const& _location, string const& _description)
+{
+	typeError(_location, _description);
+	BOOST_THROW_EXCEPTION(FatalError());
+}
+
+void ReferencesResolver::declarationError(SourceLocation const& _location, string const& _description)
+{
+	auto err = make_shared<Error>(Error::Type::DeclarationError);
+	*err <<	errinfo_sourceLocation(_location) << errinfo_comment(_description);
+	m_errorOccurred = true;
+	m_errors.push_back(err);
+}
+
+void ReferencesResolver::fatalDeclarationError(SourceLocation const& _location, string const& _description)
+{
+	declarationError(_location, _description);
+	BOOST_THROW_EXCEPTION(FatalError());
+}
+
diff --git a/libsolidity/ReferencesResolver.h b/libsolidity/analysis/ReferencesResolver.h
similarity index 64%
rename from libsolidity/ReferencesResolver.h
rename to libsolidity/analysis/ReferencesResolver.h
index b8a55dc2..21cb1d35 100644
--- a/libsolidity/ReferencesResolver.h
+++ b/libsolidity/analysis/ReferencesResolver.h
@@ -25,8 +25,8 @@
 #include <map>
 #include <list>
 #include <boost/noncopyable.hpp>
-#include <libsolidity/ASTVisitor.h>
-#include <libsolidity/ASTAnnotations.h>
+#include <libsolidity/ast/ASTVisitor.h>
+#include <libsolidity/ast/ASTAnnotations.h>
 
 namespace dev
 {
@@ -43,12 +43,21 @@ class ReferencesResolver: private ASTConstVisitor
 {
 public:
 	ReferencesResolver(
-		ASTNode& _root,
+		ErrorList& _errors,
 		NameAndTypeResolver& _resolver,
 		ContractDefinition const* _currentContract,
 		ParameterList const* _returnParameters,
 		bool _resolveInsideCode = false
-	);
+	):
+		m_errors(_errors),
+		m_resolver(_resolver),
+		m_currentContract(_currentContract),
+		m_returnParameters(_returnParameters),
+		m_resolveInsideCode(_resolveInsideCode)
+	{}
+
+	/// @returns true if no errors during resolving
+	bool resolve(ASTNode& _root);
 
 private:
 	virtual bool visit(Block const&) override { return m_resolveInsideCode; }
@@ -59,10 +68,24 @@ private:
 
 	TypePointer typeFor(TypeName const& _typeName);
 
+	/// Adds a new error to the list of errors.
+	void typeError(SourceLocation const& _location, std::string const& _description);
+
+	/// Adds a new error to the list of errors and throws to abort type checking.
+	void fatalTypeError(SourceLocation const& _location, std::string const& _description);
+
+	/// Adds a new error to the list of errors.
+	void declarationError(const SourceLocation& _location, std::string const& _description);
+
+	/// Adds a new error to the list of errors and throws to abort type checking.
+	void fatalDeclarationError(const SourceLocation& _location, std::string const& _description);
+
+	ErrorList& m_errors;
 	NameAndTypeResolver& m_resolver;
 	ContractDefinition const* m_currentContract;
 	ParameterList const* m_returnParameters;
-	bool m_resolveInsideCode;
+	bool const m_resolveInsideCode;
+	bool m_errorOccurred = false;
 };
 
 }
diff --git a/libsolidity/TypeChecker.cpp b/libsolidity/analysis/TypeChecker.cpp
similarity index 87%
rename from libsolidity/TypeChecker.cpp
rename to libsolidity/analysis/TypeChecker.cpp
index 5ea5825d..0990a9e4 100644
--- a/libsolidity/TypeChecker.cpp
+++ b/libsolidity/analysis/TypeChecker.cpp
@@ -20,10 +20,10 @@
  * Type analyzer and checker.
  */
 
-#include <libsolidity/TypeChecker.h>
+#include <libsolidity/analysis/TypeChecker.h>
 #include <memory>
 #include <boost/range/adaptor/reversed.hpp>
-#include <libsolidity/AST.h>
+#include <libsolidity/ast/AST.h>
 
 using namespace std;
 using namespace dev;
@@ -71,7 +71,7 @@ bool TypeChecker::visit(ContractDefinition const& _contract)
 
 	FunctionDefinition const* function = _contract.constructor();
 	if (function && !function->returnParameters().empty())
-		typeError(*function->returnParameterList(), "Non-empty \"returns\" directive for constructor.");
+		typeError(function->returnParameterList()->location(), "Non-empty \"returns\" directive for constructor.");
 
 	FunctionDefinition const* fallbackFunction = nullptr;
 	for (ASTPointer<FunctionDefinition> const& function: _contract.definedFunctions())
@@ -88,7 +88,7 @@ bool TypeChecker::visit(ContractDefinition const& _contract)
 			{
 				fallbackFunction = function.get();
 				if (!fallbackFunction->parameters().empty())
-					typeError(fallbackFunction->parameterList(), "Fallback function cannot take parameters.");
+					typeError(fallbackFunction->parameterList().location(), "Fallback function cannot take parameters.");
 			}
 		}
 		if (!function->isImplemented())
@@ -108,7 +108,7 @@ bool TypeChecker::visit(ContractDefinition const& _contract)
 		FixedHash<4> const& hash = it.first;
 		if (hashes.count(hash))
 			typeError(
-				_contract,
+				_contract.location(),
 				string("Function signature hash collision for ") + it.second->externalSignature()
 			);
 		hashes.insert(hash);
@@ -183,7 +183,7 @@ void TypeChecker::checkContractAbstractFunctions(ContractDefinition const& _cont
 			else if (it->second)
 			{
 				if (!function->isImplemented())
-					typeError(*function, "Redeclaring an already implemented function as abstract");
+					typeError(function->location(), "Redeclaring an already implemented function as abstract");
 			}
 			else if (function->isImplemented())
 				it->second = true;
@@ -252,7 +252,7 @@ void TypeChecker::checkContractIllegalOverrides(ContractDefinition const& _contr
 				continue; // constructors can neither be overridden nor override anything
 			string const& name = function->name();
 			if (modifiers.count(name))
-				typeError(*modifiers[name], "Override changes function to modifier.");
+				typeError(modifiers[name]->location(), "Override changes function to modifier.");
 			FunctionType functionType(*function);
 			// function should not change the return type
 			for (FunctionDefinition const* overriding: functions[name])
@@ -265,7 +265,7 @@ void TypeChecker::checkContractIllegalOverrides(ContractDefinition const& _contr
 					overriding->isDeclaredConst() != function->isDeclaredConst() ||
 					overridingType != functionType
 				)
-					typeError(*overriding, "Override changes extended function signature.");
+					typeError(overriding->location(), "Override changes extended function signature.");
 			}
 			functions[name].push_back(function.get());
 		}
@@ -276,9 +276,9 @@ void TypeChecker::checkContractIllegalOverrides(ContractDefinition const& _contr
 			if (!override)
 				override = modifier.get();
 			else if (ModifierType(*override) != ModifierType(*modifier))
-				typeError(*override, "Override changes modifier signature.");
+				typeError(override->location(), "Override changes modifier signature.");
 			if (!functions[name].empty())
-				typeError(*override, "Override changes modifier to function.");
+				typeError(override->location(), "Override changes modifier to function.");
 		}
 	}
 }
@@ -310,7 +310,7 @@ void TypeChecker::checkContractExternalTypeClashes(ContractDefinition const& _co
 			for (size_t j = i + 1; j < it.second.size(); ++j)
 				if (!it.second[i].second->hasEqualArgumentTypes(*it.second[j].second))
 					typeError(
-						*it.second[j].first,
+						it.second[j].first->location(),
 						"Function overload clash during conversion to external types for arguments."
 					);
 }
@@ -319,11 +319,11 @@ void TypeChecker::checkLibraryRequirements(ContractDefinition const& _contract)
 {
 	solAssert(_contract.isLibrary(), "");
 	if (!_contract.baseContracts().empty())
-		typeError(_contract, "Library is not allowed to inherit.");
+		typeError(_contract.location(), "Library is not allowed to inherit.");
 
 	for (auto const& var: _contract.stateVariables())
 		if (!var->isConstant())
-			typeError(*var, "Library cannot have non-constant state variables");
+			typeError(var->location(), "Library cannot have non-constant state variables");
 }
 
 void TypeChecker::endVisit(InheritanceSpecifier const& _inheritance)
@@ -332,13 +332,13 @@ void TypeChecker::endVisit(InheritanceSpecifier const& _inheritance)
 	solAssert(base, "Base contract not available.");
 
 	if (base->isLibrary())
-		typeError(_inheritance, "Libraries cannot be inherited from.");
+		typeError(_inheritance.location(), "Libraries cannot be inherited from.");
 
 	auto const& arguments = _inheritance.arguments();
 	TypePointers parameterTypes = ContractType(*base).constructorType()->parameterTypes();
 	if (!arguments.empty() && parameterTypes.size() != arguments.size())
 		typeError(
-			_inheritance,
+			_inheritance.location(),
 			"Wrong argument count for constructor call: " +
 			toString(arguments.size()) +
 			" arguments given but expected " +
@@ -349,7 +349,7 @@ void TypeChecker::endVisit(InheritanceSpecifier const& _inheritance)
 	for (size_t i = 0; i < arguments.size(); ++i)
 		if (!type(*arguments[i])->isImplicitlyConvertibleTo(*parameterTypes[i]))
 			typeError(
-				*arguments[i],
+				arguments[i]->location(),
 				"Invalid type for argument in constructor call. "
 				"Invalid implicit conversion from " +
 				type(*arguments[i])->toString() +
@@ -363,7 +363,7 @@ bool TypeChecker::visit(StructDefinition const& _struct)
 {
 	for (ASTPointer<VariableDeclaration> const& member: _struct.members())
 		if (!type(*member)->canBeStored())
-			typeError(*member, "Type cannot be used in struct.");
+			typeError(member->location(), "Type cannot be used in struct.");
 
 	// Check recursion, fatal error if detected.
 	using StructPointer = StructDefinition const*;
@@ -371,7 +371,7 @@ bool TypeChecker::visit(StructDefinition const& _struct)
 	function<void(StructPointer,StructPointersSet const&)> check = [&](StructPointer _struct, StructPointersSet const& _parents)
 	{
 		if (_parents.count(_struct))
-			fatalTypeError(*_struct, "Recursive struct definition.");
+			fatalTypeError(_struct->location(), "Recursive struct definition.");
 		StructPointersSet parents = _parents;
 		parents.insert(_struct);
 		for (ASTPointer<VariableDeclaration> const& member: _struct->members())
@@ -394,9 +394,9 @@ bool TypeChecker::visit(FunctionDefinition const& _function)
 	for (ASTPointer<VariableDeclaration> const& var: _function.parameters() + _function.returnParameters())
 	{
 		if (!type(*var)->canLiveOutsideStorage())
-			typeError(*var, "Type is required to live outside storage.");
+			typeError(var->location(), "Type is required to live outside storage.");
 		if (_function.visibility() >= FunctionDefinition::Visibility::Public && !(type(*var)->interfaceType(isLibraryFunction)))
-			fatalTypeError(*var, "Internal type is not allowed for public or external functions.");
+			fatalTypeError(var->location(), "Internal type is not allowed for public or external functions.");
 	}
 	for (ASTPointer<ModifierInvocation> const& modifier: _function.modifiers())
 		visitManually(
@@ -424,9 +424,9 @@ bool TypeChecker::visit(VariableDeclaration const& _variable)
 	if (_variable.isConstant())
 	{
 		if (!dynamic_cast<ContractDefinition const*>(_variable.scope()))
-			typeError(_variable, "Illegal use of \"constant\" specifier.");
+			typeError(_variable.location(), "Illegal use of \"constant\" specifier.");
 		if (!_variable.value())
-			typeError(_variable, "Uninitialized \"constant\" variable.");
+			typeError(_variable.location(), "Uninitialized \"constant\" variable.");
 		if (!varType->isValueType())
 		{
 			bool constImplemented = false;
@@ -434,7 +434,7 @@ bool TypeChecker::visit(VariableDeclaration const& _variable)
 				constImplemented = arrayType->isByteArray();
 			if (!constImplemented)
 				typeError(
-					_variable,
+					_variable.location(),
 					"Illegal use of \"constant\" specifier. \"constant\" "
 					"is not yet implemented for this type."
 				);
@@ -446,13 +446,13 @@ bool TypeChecker::visit(VariableDeclaration const& _variable)
 	{
 		if (varType->dataStoredIn(DataLocation::Memory) || varType->dataStoredIn(DataLocation::CallData))
 			if (!varType->canLiveOutsideStorage())
-				typeError(_variable, "Type " + varType->toString() + " is only valid in storage.");
+				typeError(_variable.location(), "Type " + varType->toString() + " is only valid in storage.");
 	}
 	else if (
 		_variable.visibility() >= VariableDeclaration::Visibility::Public &&
 		!FunctionType(_variable).interfaceFunctionType()
 	)
-		typeError(_variable, "Internal type is not allowed for public state variables.");
+		typeError(_variable.location(), "Internal type is not allowed for public state variables.");
 	return false;
 }
 
@@ -483,10 +483,10 @@ void TypeChecker::visitManually(
 				break;
 			}
 	if (!parameters)
-		typeError(_modifier, "Referenced declaration is neither modifier nor base class.");
+		typeError(_modifier.location(), "Referenced declaration is neither modifier nor base class.");
 	if (parameters->size() != arguments.size())
 		typeError(
-			_modifier,
+			_modifier.location(),
 			"Wrong argument count for modifier invocation: " +
 			toString(arguments.size()) +
 			" arguments given but expected " +
@@ -496,7 +496,7 @@ void TypeChecker::visitManually(
 	for (size_t i = 0; i < _modifier.arguments().size(); ++i)
 		if (!type(*arguments[i])->isImplicitlyConvertibleTo(*type(*(*parameters)[i])))
 			typeError(
-				*arguments[i],
+				arguments[i]->location(),
 				"Invalid type for argument in modifier invocation. "
 				"Invalid implicit conversion from " +
 				type(*arguments[i])->toString() +
@@ -514,13 +514,13 @@ bool TypeChecker::visit(EventDefinition const& _eventDef)
 		if (var->isIndexed())
 			numIndexed++;
 		if (_eventDef.isAnonymous() && numIndexed > 4)
-			typeError(_eventDef, "More than 4 indexed arguments for anonymous event.");
+			typeError(_eventDef.location(), "More than 4 indexed arguments for anonymous event.");
 		else if (!_eventDef.isAnonymous() && numIndexed > 3)
-			typeError(_eventDef, "More than 3 indexed arguments for event.");
+			typeError(_eventDef.location(), "More than 3 indexed arguments for event.");
 		if (!type(*var)->canLiveOutsideStorage())
-			typeError(*var, "Type is required to live outside storage.");
+			typeError(var->location(), "Type is required to live outside storage.");
 		if (!type(*var)->interfaceType(false))
-			typeError(*var, "Internal type is not allowed as event parameter type.");
+			typeError(var->location(), "Internal type is not allowed as event parameter type.");
 	}
 	return false;
 }
@@ -561,7 +561,7 @@ void TypeChecker::endVisit(Return const& _return)
 	ParameterList const* params = _return.annotation().functionReturnParameters;
 	if (!params)
 	{
-		typeError(_return, "Return arguments not allowed.");
+		typeError(_return.location(), "Return arguments not allowed.");
 		return;
 	}
 	TypePointers returnTypes;
@@ -570,10 +570,10 @@ void TypeChecker::endVisit(Return const& _return)
 	if (auto tupleType = dynamic_cast<TupleType const*>(type(*_return.expression()).get()))
 	{
 		if (tupleType->components().size() != params->parameters().size())
-			typeError(_return, "Different number of arguments in return statement than in returns declaration.");
+			typeError(_return.location(), "Different number of arguments in return statement than in returns declaration.");
 		else if (!tupleType->isImplicitlyConvertibleTo(TupleType(returnTypes)))
 			typeError(
-				*_return.expression(),
+				_return.expression()->location(),
 				"Return argument type " +
 				type(*_return.expression())->toString() +
 				" is not implicitly convertible to expected type " +
@@ -582,13 +582,13 @@ void TypeChecker::endVisit(Return const& _return)
 			);
 	}
 	else if (params->parameters().size() != 1)
-		typeError(_return, "Different number of arguments in return statement than in returns declaration.");
+		typeError(_return.location(), "Different number of arguments in return statement than in returns declaration.");
 	else
 	{
 		TypePointer const& expected = type(*params->parameters().front());
 		if (!type(*_return.expression())->isImplicitlyConvertibleTo(*expected))
 			typeError(
-				*_return.expression(),
+				_return.expression()->location(),
 				"Return argument type " +
 				type(*_return.expression())->toString() +
 				" is not implicitly convertible to expected type (type of first return variable) " +
@@ -604,10 +604,10 @@ bool TypeChecker::visit(VariableDeclarationStatement const& _statement)
 	{
 		// No initial value is only permitted for single variables with specified type.
 		if (_statement.declarations().size() != 1 || !_statement.declarations().front())
-			fatalTypeError(_statement, "Assignment necessary for type detection.");
+			fatalTypeError(_statement.location(), "Assignment necessary for type detection.");
 		VariableDeclaration const& varDecl = *_statement.declarations().front();
 		if (!varDecl.annotation().type)
-			fatalTypeError(_statement, "Assignment necessary for type detection.");
+			fatalTypeError(_statement.location(), "Assignment necessary for type detection.");
 		if (auto ref = dynamic_cast<ReferenceType const*>(type(varDecl).get()))
 		{
 			if (ref->dataStoredIn(DataLocation::Storage))
@@ -642,7 +642,7 @@ bool TypeChecker::visit(VariableDeclarationStatement const& _statement)
 	{
 		if (!valueTypes.empty())
 			fatalTypeError(
-				_statement,
+				_statement.location(),
 				"Too many components (" +
 				toString(valueTypes.size()) +
 				") in value for variable assignment (0) needed"
@@ -650,7 +650,7 @@ bool TypeChecker::visit(VariableDeclarationStatement const& _statement)
 	}
 	else if (valueTypes.size() != variables.size() && !variables.front() && !variables.back())
 		fatalTypeError(
-			_statement,
+			_statement.location(),
 			"Wildcard both at beginning and end of variable declaration list is only allowed "
 			"if the number of components is equal."
 		);
@@ -659,7 +659,7 @@ bool TypeChecker::visit(VariableDeclarationStatement const& _statement)
 		--minNumValues;
 	if (valueTypes.size() < minNumValues)
 		fatalTypeError(
-			_statement,
+			_statement.location(),
 			"Not enough components (" +
 			toString(valueTypes.size()) +
 			") in value to assign all variables (" +
@@ -667,7 +667,7 @@ bool TypeChecker::visit(VariableDeclarationStatement const& _statement)
 		);
 	if (valueTypes.size() > variables.size() && variables.front() && variables.back())
 		fatalTypeError(
-			_statement,
+			_statement.location(),
 			"Too many components (" +
 			toString(valueTypes.size()) +
 			") in value for variable assignment (" +
@@ -697,7 +697,7 @@ bool TypeChecker::visit(VariableDeclarationStatement const& _statement)
 				valueComponentType->category() == Type::Category::IntegerConstant &&
 				!dynamic_pointer_cast<IntegerConstantType const>(valueComponentType)->integerType()
 			)
-				fatalTypeError(*_statement.initialValue(), "Invalid integer constant " + valueComponentType->toString() + ".");
+				fatalTypeError(_statement.initialValue()->location(), "Invalid integer constant " + valueComponentType->toString() + ".");
 			var.annotation().type = valueComponentType->mobileType();
 			var.accept(*this);
 		}
@@ -706,7 +706,7 @@ bool TypeChecker::visit(VariableDeclarationStatement const& _statement)
 			var.accept(*this);
 			if (!valueComponentType->isImplicitlyConvertibleTo(*var.annotation().type))
 				typeError(
-					_statement,
+					_statement.location(),
 					"Type " +
 					valueComponentType->toString() +
 					" is not implicitly convertible to expected type " +
@@ -722,7 +722,7 @@ void TypeChecker::endVisit(ExpressionStatement const& _statement)
 {
 	if (type(_statement.expression())->category() == Type::Category::IntegerConstant)
 		if (!dynamic_pointer_cast<IntegerConstantType const>(type(_statement.expression()))->integerType())
-			typeError(_statement.expression(), "Invalid integer constant.");
+			typeError(_statement.expression().location(), "Invalid integer constant.");
 }
 
 bool TypeChecker::visit(Assignment const& _assignment)
@@ -738,7 +738,7 @@ bool TypeChecker::visit(Assignment const& _assignment)
 	}
 	else if (t->category() == Type::Category::Mapping)
 	{
-		typeError(_assignment, "Mappings cannot be assigned to.");
+		typeError(_assignment.location(), "Mappings cannot be assigned to.");
 		_assignment.rightHandSide().accept(*this);
 	}
 	else if (_assignment.assignmentOperator() == Token::Assign)
@@ -753,7 +753,7 @@ bool TypeChecker::visit(Assignment const& _assignment)
 		);
 		if (!resultType || *resultType != *t)
 			typeError(
-				_assignment,
+				_assignment.location(),
 				"Operator " +
 				string(Token::toString(_assignment.assignmentOperator())) +
 				" not compatible with types " +
@@ -789,7 +789,7 @@ bool TypeChecker::visit(TupleExpression const& _tuple)
 		{
 			// Outside of an lvalue-context, the only situation where a component can be empty is (x,).
 			if (!components[i] && !(i == 1 && components.size() == 2))
-				fatalTypeError(_tuple, "Tuple component cannot be empty.");
+				fatalTypeError(_tuple.location(), "Tuple component cannot be empty.");
 			else if (components[i])
 			{
 				components[i]->accept(*this);
@@ -823,7 +823,7 @@ bool TypeChecker::visit(UnaryOperation const& _operation)
 	if (!t)
 	{
 		typeError(
-			_operation,
+			_operation.location(),
 			"Unary operator " +
 			string(Token::toString(op)) +
 			" cannot be applied to type " +
@@ -843,7 +843,7 @@ void TypeChecker::endVisit(BinaryOperation const& _operation)
 	if (!commonType)
 	{
 		typeError(
-			_operation,
+			_operation.location(),
 			"Operator " +
 			string(Token::toString(_operation.getOperator())) +
 			" not compatible with types " +
@@ -896,9 +896,9 @@ bool TypeChecker::visit(FunctionCall const& _functionCall)
 		TypeType const& t = dynamic_cast<TypeType const&>(*expressionType);
 		TypePointer resultType = t.actualType();
 		if (arguments.size() != 1)
-			typeError(_functionCall, "Exactly one argument expected for explicit type conversion.");
+			typeError(_functionCall.location(), "Exactly one argument expected for explicit type conversion.");
 		else if (!isPositionalCall)
-			typeError(_functionCall, "Type conversion cannot allow named arguments.");
+			typeError(_functionCall.location(), "Type conversion cannot allow named arguments.");
 		else
 		{
 			TypePointer const& argType = type(*arguments.front());
@@ -907,7 +907,7 @@ bool TypeChecker::visit(FunctionCall const& _functionCall)
 				// (data location cannot yet be specified for type conversions)
 				resultType = ReferenceType::copyForLocationIfReference(argRefType->location(), resultType);
 			if (!argType->isExplicitlyConvertibleTo(*resultType))
-				typeError(_functionCall, "Explicit type conversion not allowed.");
+				typeError(_functionCall.location(), "Explicit type conversion not allowed.");
 		}
 		_functionCall.annotation().type = resultType;
 
@@ -932,7 +932,7 @@ bool TypeChecker::visit(FunctionCall const& _functionCall)
 
 	if (!functionType)
 	{
-		typeError(_functionCall, "Type is not callable");
+		typeError(_functionCall.location(), "Type is not callable");
 		_functionCall.annotation().type = make_shared<TupleType>();
 		return false;
 	}
@@ -957,7 +957,7 @@ bool TypeChecker::visit(FunctionCall const& _functionCall)
 			for (auto const& member: membersRemovedForStructConstructor)
 				msg += " " + member;
 		}
-		typeError(_functionCall, msg);
+		typeError(_functionCall.location(), msg);
 	}
 	else if (isPositionalCall)
 	{
@@ -969,11 +969,11 @@ bool TypeChecker::visit(FunctionCall const& _functionCall)
 			{
 				if (auto t = dynamic_cast<IntegerConstantType const*>(argType.get()))
 					if (!t->integerType())
-						typeError(*arguments[i], "Integer constant too large.");
+						typeError(arguments[i]->location(), "Integer constant too large.");
 			}
 			else if (!type(*arguments[i])->isImplicitlyConvertibleTo(*parameterTypes[i]))
 				typeError(
-					*arguments[i],
+					arguments[i]->location(),
 					"Invalid type for argument in function call. "
 					"Invalid implicit conversion from " +
 					type(*arguments[i])->toString() +
@@ -989,13 +989,13 @@ bool TypeChecker::visit(FunctionCall const& _functionCall)
 		auto const& parameterNames = functionType->parameterNames();
 		if (functionType->takesArbitraryParameters())
 			typeError(
-				_functionCall,
+				_functionCall.location(),
 				"Named arguments cannnot be used for functions that take arbitrary parameters."
 			);
 		else if (parameterNames.size() > argumentNames.size())
-			typeError(_functionCall, "Some argument names are missing.");
+			typeError(_functionCall.location(), "Some argument names are missing.");
 		else if (parameterNames.size() < argumentNames.size())
-			typeError(_functionCall, "Too many arguments.");
+			typeError(_functionCall.location(), "Too many arguments.");
 		else
 		{
 			// check duplicate names
@@ -1005,7 +1005,7 @@ bool TypeChecker::visit(FunctionCall const& _functionCall)
 					if (*argumentNames[i] == *argumentNames[j])
 					{
 						duplication = true;
-						typeError(*arguments[i], "Duplicate named argument.");
+						typeError(arguments[i]->location(), "Duplicate named argument.");
 					}
 
 			// check actual types
@@ -1020,7 +1020,7 @@ bool TypeChecker::visit(FunctionCall const& _functionCall)
 							// check type convertible
 							if (!type(*arguments[i])->isImplicitlyConvertibleTo(*parameterTypes[j]))
 								typeError(
-									*arguments[i],
+									arguments[i]->location(),
 									"Invalid type for argument in function call. "
 									"Invalid implicit conversion from " +
 									type(*arguments[i])->toString() +
@@ -1033,7 +1033,7 @@ bool TypeChecker::visit(FunctionCall const& _functionCall)
 
 					if (!found)
 						typeError(
-							_functionCall,
+							_functionCall.location(),
 							"Named argument does not match function declaration."
 						);
 				}
@@ -1048,9 +1048,9 @@ void TypeChecker::endVisit(NewExpression const& _newExpression)
 	auto contract = dynamic_cast<ContractDefinition const*>(&dereference(_newExpression.contractName()));
 
 	if (!contract)
-		fatalTypeError(_newExpression, "Identifier is not a contract.");
+		fatalTypeError(_newExpression.location(), "Identifier is not a contract.");
 	if (!contract->annotation().isFullyImplemented)
-		typeError(_newExpression, "Trying to create an instance of an abstract contract.");
+		typeError(_newExpression.location(), "Trying to create an instance of an abstract contract.");
 
 	auto scopeContract = _newExpression.contractName().annotation().contractScope;
 	scopeContract->annotation().contractDependencies.insert(contract);
@@ -1060,7 +1060,7 @@ void TypeChecker::endVisit(NewExpression const& _newExpression)
 	);
 	if (contractDependenciesAreCyclic(*scopeContract))
 		typeError(
-			_newExpression,
+			_newExpression.location(),
 			"Circular reference for contract creation (cannot create instance of derived or same contract)."
 		);
 
@@ -1104,20 +1104,20 @@ bool TypeChecker::visit(MemberAccess const& _memberAccess)
 		);
 		if (!storageType->members().membersByName(memberName).empty())
 			fatalTypeError(
-				_memberAccess,
+				_memberAccess.location(),
 				"Member \"" + memberName + "\" is not available in " +
 				exprType->toString() +
 				" outside of storage."
 			);
 		fatalTypeError(
-			_memberAccess,
+			_memberAccess.location(),
 			"Member \"" + memberName + "\" not found or not visible "
 			"after argument-dependent lookup in " + exprType->toString()
 		);
 	}
 	else if (possibleMembers.size() > 1)
 		fatalTypeError(
-			_memberAccess,
+			_memberAccess.location(),
 			"Member \"" + memberName + "\" not unique "
 			"after argument-dependent lookup in " + exprType->toString()
 		);
@@ -1153,10 +1153,10 @@ bool TypeChecker::visit(IndexAccess const& _access)
 	{
 		ArrayType const& actualType = dynamic_cast<ArrayType const&>(*baseType);
 		if (!index)
-			typeError(_access, "Index expression cannot be omitted.");
+			typeError(_access.location(), "Index expression cannot be omitted.");
 		else if (actualType.isString())
 		{
-			typeError(_access, "Index access for string is not possible.");
+			typeError(_access.location(), "Index access for string is not possible.");
 			index->accept(*this);
 		}
 		else
@@ -1164,7 +1164,7 @@ bool TypeChecker::visit(IndexAccess const& _access)
 			expectType(*index, IntegerType(256));
 			if (auto integerType = dynamic_cast<IntegerConstantType const*>(type(*index).get()))
 				if (!actualType.isDynamicallySized() && actualType.length() <= integerType->literalValue(nullptr))
-					typeError(_access, "Out of bounds array access.");
+					typeError(_access.location(), "Out of bounds array access.");
 		}
 		resultType = actualType.baseType();
 		isLValue = actualType.location() != DataLocation::CallData;
@@ -1174,7 +1174,7 @@ bool TypeChecker::visit(IndexAccess const& _access)
 	{
 		MappingType const& actualType = dynamic_cast<MappingType const&>(*baseType);
 		if (!index)
-			typeError(_access, "Index expression cannot be omitted.");
+			typeError(_access.location(), "Index expression cannot be omitted.");
 		else
 			expectType(*index, *actualType.keyType());
 		resultType = actualType.valueType();
@@ -1196,13 +1196,13 @@ bool TypeChecker::visit(IndexAccess const& _access)
 					length->literalValue(nullptr)
 				));
 			else
-				typeError(*index, "Integer constant expected.");
+				typeError(index->location(), "Integer constant expected.");
 		}
 		break;
 	}
 	default:
 		fatalTypeError(
-			_access.baseExpression(),
+			_access.baseExpression().location(),
 			"Indexed expression has to be a type, mapping or array (is " + baseType->toString() + ")"
 		);
 	}
@@ -1218,9 +1218,9 @@ bool TypeChecker::visit(Identifier const& _identifier)
 	if (!annotation.referencedDeclaration)
 	{
 		if (!annotation.argumentTypes)
-			fatalTypeError(_identifier, "Unable to determine overloaded type.");
+			fatalTypeError(_identifier.location(), "Unable to determine overloaded type.");
 		if (annotation.overloadedDeclarations.empty())
-			fatalTypeError(_identifier, "No candidates for overload resolution found.");
+			fatalTypeError(_identifier.location(), "No candidates for overload resolution found.");
 		else if (annotation.overloadedDeclarations.size() == 1)
 			annotation.referencedDeclaration = *annotation.overloadedDeclarations.begin();
 		else
@@ -1236,11 +1236,11 @@ bool TypeChecker::visit(Identifier const& _identifier)
 					candidates.push_back(declaration);
 			}
 			if (candidates.empty())
-				fatalTypeError(_identifier, "No matching declaration found after argument-dependent lookup.");
+				fatalTypeError(_identifier.location(), "No matching declaration found after argument-dependent lookup.");
 			else if (candidates.size() == 1)
 				annotation.referencedDeclaration = candidates.front();
 			else
-				fatalTypeError(_identifier, "No unique declaration found after argument-dependent lookup.");
+				fatalTypeError(_identifier.location(), "No unique declaration found after argument-dependent lookup.");
 		}
 	}
 	solAssert(
@@ -1250,7 +1250,7 @@ bool TypeChecker::visit(Identifier const& _identifier)
 	annotation.isLValue = annotation.referencedDeclaration->isLValue();
 	annotation.type = annotation.referencedDeclaration->type(_identifier.annotation().contractScope);
 	if (!annotation.type)
-		fatalTypeError(_identifier, "Declaration referenced before type could be determined.");
+		fatalTypeError(_identifier.location(), "Declaration referenced before type could be determined.");
 	return false;
 }
 
@@ -1263,7 +1263,7 @@ void TypeChecker::endVisit(Literal const& _literal)
 {
 	_literal.annotation().type = Type::forLiteral(_literal);
 	if (!_literal.annotation().type)
-		fatalTypeError(_literal, "Invalid literal value.");
+		fatalTypeError(_literal.location(), "Invalid literal value.");
 }
 
 bool TypeChecker::contractDependenciesAreCyclic(
@@ -1294,7 +1294,7 @@ void TypeChecker::expectType(Expression const& _expression, Type const& _expecte
 
 	if (!type(_expression)->isImplicitlyConvertibleTo(_expectedType))
 		typeError(
-			_expression,
+			_expression.location(),
 			"Type " +
 			type(_expression)->toString() +
 			" is not implicitly convertible to expected type " +
@@ -1308,21 +1308,21 @@ void TypeChecker::requireLValue(Expression const& _expression)
 	_expression.annotation().lValueRequested = true;
 	_expression.accept(*this);
 	if (!_expression.annotation().isLValue)
-		typeError(_expression, "Expression has to be an lvalue.");
+		typeError(_expression.location(), "Expression has to be an lvalue.");
 }
 
-void TypeChecker::typeError(ASTNode const& _node, string const& _description)
+void TypeChecker::typeError(SourceLocation const& _location, string const& _description)
 {
 	auto err = make_shared<Error>(Error::Type::TypeError);
 	*err <<
-		errinfo_sourceLocation(_node.location()) <<
+		errinfo_sourceLocation(_location) <<
 		errinfo_comment(_description);
 
 	m_errors.push_back(err);
 }
 
-void TypeChecker::fatalTypeError(ASTNode const& _node, string const& _description)
+void TypeChecker::fatalTypeError(SourceLocation const& _location, string const& _description)
 {
-	typeError(_node, _description);
+	typeError(_location, _description);
 	BOOST_THROW_EXCEPTION(FatalError());
 }
diff --git a/libsolidity/TypeChecker.h b/libsolidity/analysis/TypeChecker.h
similarity index 93%
rename from libsolidity/TypeChecker.h
rename to libsolidity/analysis/TypeChecker.h
index 7af5473b..f163f47c 100644
--- a/libsolidity/TypeChecker.h
+++ b/libsolidity/analysis/TypeChecker.h
@@ -22,11 +22,11 @@
 
 #pragma once
 
-#include <libsolidity/TypeChecker.h>
-#include <libsolidity/Types.h>
-#include <libsolidity/ASTAnnotations.h>
-#include <libsolidity/ASTForward.h>
-#include <libsolidity/ASTVisitor.h>
+#include <libsolidity/analysis/TypeChecker.h>
+#include <libsolidity/ast/Types.h>
+#include <libsolidity/ast/ASTAnnotations.h>
+#include <libsolidity/ast/ASTForward.h>
+#include <libsolidity/ast/ASTVisitor.h>
 
 namespace dev
 {
@@ -57,10 +57,10 @@ public:
 
 private:
 	/// Adds a new error to the list of errors.
-	void typeError(ASTNode const& _node, std::string const& _description);
+	void typeError(SourceLocation const& _location, std::string const& _description);
 
 	/// Adds a new error to the list of errors and throws to abort type checking.
-	void fatalTypeError(ASTNode const& _node, std::string const& _description);
+	void fatalTypeError(SourceLocation const& _location, std::string const& _description);
 
 	virtual bool visit(ContractDefinition const& _contract) override;
 	/// Checks that two functions defined in this contract with the same name have different
diff --git a/libsolidity/AST.cpp b/libsolidity/ast/AST.cpp
similarity index 91%
rename from libsolidity/AST.cpp
rename to libsolidity/ast/AST.cpp
index 062febb9..41a4d182 100644
--- a/libsolidity/AST.cpp
+++ b/libsolidity/ast/AST.cpp
@@ -22,11 +22,11 @@
 
 #include <algorithm>
 #include <functional>
-#include <libsolidity/Utils.h>
-#include <libsolidity/AST.h>
-#include <libsolidity/ASTVisitor.h>
-#include <libsolidity/Exceptions.h>
-#include <libsolidity/AST_accept.h>
+#include <libsolidity/interface/Utils.h>
+#include <libsolidity/ast/AST.h>
+#include <libsolidity/ast/ASTVisitor.h>
+#include <libsolidity/interface/Exceptions.h>
+#include <libsolidity/ast/AST_accept.h>
 
 #include <libdevcore/SHA3.h>
 
@@ -248,16 +248,37 @@ string FunctionDefinition::externalSignature() const
 	return FunctionType(*this).externalSignature();
 }
 
+FunctionDefinitionAnnotation& FunctionDefinition::annotation() const
+{
+	if (!m_annotation)
+		m_annotation = new FunctionDefinitionAnnotation();
+	return static_cast<FunctionDefinitionAnnotation&>(*m_annotation);
+}
+
 TypePointer ModifierDefinition::type(ContractDefinition const*) const
 {
 	return make_shared<ModifierType>(*this);
 }
 
+ModifierDefinitionAnnotation& ModifierDefinition::annotation() const
+{
+	if (!m_annotation)
+		m_annotation = new ModifierDefinitionAnnotation();
+	return static_cast<ModifierDefinitionAnnotation&>(*m_annotation);
+}
+
 TypePointer EventDefinition::type(ContractDefinition const*) const
 {
 	return make_shared<FunctionType>(*this);
 }
 
+EventDefinitionAnnotation& EventDefinition::annotation() const
+{
+	if (!m_annotation)
+		m_annotation = new EventDefinitionAnnotation();
+	return static_cast<EventDefinitionAnnotation&>(*m_annotation);
+}
+
 UserDefinedTypeNameAnnotation& UserDefinedTypeName::annotation() const
 {
 	if (!m_annotation)
@@ -315,6 +336,13 @@ VariableDeclarationAnnotation& VariableDeclaration::annotation() const
 	return static_cast<VariableDeclarationAnnotation&>(*m_annotation);
 }
 
+StatementAnnotation& Statement::annotation() const
+{
+	if (!m_annotation)
+		m_annotation = new StatementAnnotation();
+	return static_cast<StatementAnnotation&>(*m_annotation);
+}
+
 ReturnAnnotation& Return::annotation() const
 {
 	if (!m_annotation)
diff --git a/libsolidity/AST.h b/libsolidity/ast/AST.h
similarity index 94%
rename from libsolidity/AST.h
rename to libsolidity/ast/AST.h
index fc1db3f3..69186cb7 100644
--- a/libsolidity/AST.h
+++ b/libsolidity/ast/AST.h
@@ -28,12 +28,12 @@
 #include <memory>
 #include <boost/noncopyable.hpp>
 #include <libevmasm/SourceLocation.h>
-#include <libsolidity/Utils.h>
-#include <libsolidity/ASTForward.h>
-#include <libsolidity/Token.h>
-#include <libsolidity/Types.h>
-#include <libsolidity/Exceptions.h>
-#include <libsolidity/ASTAnnotations.h>
+#include <libsolidity/interface/Utils.h>
+#include <libsolidity/ast/ASTForward.h>
+#include <libsolidity/parsing/Token.h>
+#include <libsolidity/ast/Types.h>
+#include <libsolidity/interface/Exceptions.h>
+#include <libsolidity/ast/ASTAnnotations.h>
 
 namespace dev
 {
@@ -492,6 +492,8 @@ public:
 
 	virtual TypePointer type(ContractDefinition const* m_currentContract) const override;
 
+	virtual FunctionDefinitionAnnotation& annotation() const override;
+
 private:
 	bool m_isConstructor;
 	bool m_isDeclaredConst;
@@ -593,6 +595,8 @@ public:
 
 	virtual TypePointer type(ContractDefinition const* m_currentContract) const override;
 
+	virtual ModifierDefinitionAnnotation& annotation() const override;
+
 private:
 	ASTPointer<Block> m_body;
 };
@@ -647,6 +651,8 @@ public:
 
 	virtual TypePointer type(ContractDefinition const* m_currentContract) const override;
 
+	virtual EventDefinitionAnnotation& annotation() const override;
+
 private:
 	bool m_anonymous = false;
 };
@@ -786,10 +792,15 @@ private:
 /**
  * Abstract base class for statements.
  */
-class Statement: public ASTNode
+class Statement: public ASTNode, public Documented
 {
 public:
-	explicit Statement(SourceLocation const& _location): ASTNode(_location) {}
+	explicit Statement(
+		SourceLocation const& _location,
+		ASTPointer<ASTString> const& _docString
+	): ASTNode(_location), Documented(_docString) {}
+
+	virtual StatementAnnotation& annotation() const override;
 };
 
 /**
@@ -800,12 +811,15 @@ class Block: public Statement
 public:
 	Block(
 		SourceLocation const& _location,
+		ASTPointer<ASTString> const& _docString,
 		std::vector<ASTPointer<Statement>> const& _statements
 	):
-		Statement(_location), m_statements(_statements) {}
+		Statement(_location, _docString), m_statements(_statements) {}
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 
+	std::vector<ASTPointer<Statement>> const& statements() const { return m_statements; }
+
 private:
 	std::vector<ASTPointer<Statement>> m_statements;
 };
@@ -817,7 +831,10 @@ private:
 class PlaceholderStatement: public Statement
 {
 public:
-	explicit PlaceholderStatement(SourceLocation const& _location): Statement(_location) {}
+	explicit PlaceholderStatement(
+		SourceLocation const& _location,
+		ASTPointer<ASTString> const& _docString
+	): Statement(_location, _docString) {}
 
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
@@ -832,11 +849,12 @@ class IfStatement: public Statement
 public:
 	IfStatement(
 		SourceLocation const& _location,
+		ASTPointer<ASTString> const& _docString,
 		ASTPointer<Expression> const& _condition,
 		ASTPointer<Statement> const& _trueBody,
 		ASTPointer<Statement> const& _falseBody
 	):
-		Statement(_location),
+		Statement(_location, _docString),
 		m_condition(_condition),
 		m_trueBody(_trueBody),
 		m_falseBody(_falseBody)
@@ -861,7 +879,10 @@ private:
 class BreakableStatement: public Statement
 {
 public:
-	explicit BreakableStatement(SourceLocation const& _location): Statement(_location) {}
+	explicit BreakableStatement(
+		SourceLocation const& _location,
+		ASTPointer<ASTString> const& _docString
+	): Statement(_location, _docString) {}
 };
 
 class WhileStatement: public BreakableStatement
@@ -869,10 +890,11 @@ class WhileStatement: public BreakableStatement
 public:
 	WhileStatement(
 		SourceLocation const& _location,
+		ASTPointer<ASTString> const& _docString,
 		ASTPointer<Expression> const& _condition,
 		ASTPointer<Statement> const& _body
 	):
-		BreakableStatement(_location), m_condition(_condition), m_body(_body) {}
+		BreakableStatement(_location, _docString), m_condition(_condition), m_body(_body) {}
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 
@@ -892,12 +914,13 @@ class ForStatement: public BreakableStatement
 public:
 	ForStatement(
 		SourceLocation const& _location,
+		ASTPointer<ASTString> const& _docString,
 		ASTPointer<Statement> const& _initExpression,
 		ASTPointer<Expression> const& _conditionExpression,
 		ASTPointer<ExpressionStatement> const& _loopExpression,
 		ASTPointer<Statement> const& _body
 	):
-		BreakableStatement(_location),
+		BreakableStatement(_location, _docString),
 		m_initExpression(_initExpression),
 		m_condExpression(_conditionExpression),
 		m_loopExpression(_loopExpression),
@@ -925,7 +948,8 @@ private:
 class Continue: public Statement
 {
 public:
-	explicit Continue(SourceLocation const& _location): Statement(_location) {}
+	explicit Continue(SourceLocation const& _location, 	ASTPointer<ASTString> const& _docString):
+		Statement(_location, _docString) {}
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 };
@@ -933,7 +957,8 @@ public:
 class Break: public Statement
 {
 public:
-	explicit Break(SourceLocation const& _location): Statement(_location) {}
+	explicit Break(SourceLocation const& _location, ASTPointer<ASTString> const& _docString):
+		Statement(_location, _docString) {}
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 };
@@ -941,8 +966,11 @@ public:
 class Return: public Statement
 {
 public:
-	Return(SourceLocation const& _location, ASTPointer<Expression> _expression):
-		Statement(_location), m_expression(_expression) {}
+	Return(
+		SourceLocation const& _location,
+		ASTPointer<ASTString> const& _docString,
+		ASTPointer<Expression> _expression
+	): Statement(_location, _docString), m_expression(_expression) {}
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 
@@ -960,7 +988,8 @@ private:
 class Throw: public Statement
 {
 public:
-	explicit Throw(SourceLocation const& _location): Statement(_location) {}
+	explicit Throw(SourceLocation const& _location, ASTPointer<ASTString> const& _docString):
+		Statement(_location, _docString) {}
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 };
@@ -979,10 +1008,11 @@ class VariableDeclarationStatement: public Statement
 public:
 	VariableDeclarationStatement(
 		SourceLocation const& _location,
+		ASTPointer<ASTString> const& _docString,
 		std::vector<ASTPointer<VariableDeclaration>> const& _variables,
 		ASTPointer<Expression> const& _initialValue
 	):
-		Statement(_location), m_variables(_variables), m_initialValue(_initialValue) {}
+		Statement(_location, _docString), m_variables(_variables), m_initialValue(_initialValue) {}
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 
@@ -1006,9 +1036,10 @@ class ExpressionStatement: public Statement
 public:
 	ExpressionStatement(
 		SourceLocation const& _location,
+		ASTPointer<ASTString> const& _docString,
 		ASTPointer<Expression> _expression
 	):
-		Statement(_location), m_expression(_expression) {}
+		Statement(_location, _docString), m_expression(_expression) {}
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 
diff --git a/libsolidity/ASTAnnotations.cpp b/libsolidity/ast/ASTAnnotations.cpp
similarity index 95%
rename from libsolidity/ASTAnnotations.cpp
rename to libsolidity/ast/ASTAnnotations.cpp
index 4253e16d..416e6b44 100644
--- a/libsolidity/ASTAnnotations.cpp
+++ b/libsolidity/ast/ASTAnnotations.cpp
@@ -20,7 +20,7 @@
  * Object containing the type and other annotations for the AST nodes.
  */
 
-#include <libsolidity/ASTAnnotations.h>
+#include <libsolidity/ast/ASTAnnotations.h>
 
 using namespace std;
 using namespace dev;
diff --git a/libsolidity/ASTAnnotations.h b/libsolidity/ast/ASTAnnotations.h
similarity index 82%
rename from libsolidity/ASTAnnotations.h
rename to libsolidity/ast/ASTAnnotations.h
index 1b772ffa..bb59ceae 100644
--- a/libsolidity/ASTAnnotations.h
+++ b/libsolidity/ast/ASTAnnotations.h
@@ -26,7 +26,7 @@
 #include <memory>
 #include <vector>
 #include <set>
-#include <libsolidity/ASTForward.h>
+#include <libsolidity/ast/ASTForward.h>
 
 namespace dev
 {
@@ -41,13 +41,26 @@ struct ASTAnnotation
 	virtual ~ASTAnnotation() {}
 };
 
+struct DocTag
+{
+	std::string content;	///< The text content of the tag.
+	std::string paramName;	///< Only used for @param, stores the parameter name.
+};
+
+struct DocumentedAnnotation
+{
+	virtual ~DocumentedAnnotation() {}
+	/// Mapping docstring tag name -> content.
+	std::multimap<std::string, DocTag> docTags;
+};
+
 struct TypeDeclarationAnnotation: ASTAnnotation
 {
 	/// The name of this type, prefixed by proper namespaces if globally accessible.
 	std::string canonicalName;
 };
 
-struct ContractDefinitionAnnotation: TypeDeclarationAnnotation
+struct ContractDefinitionAnnotation: TypeDeclarationAnnotation, DocumentedAnnotation
 {
 	/// Whether all functions are implemented.
 	bool isFullyImplemented = true;
@@ -59,13 +72,29 @@ struct ContractDefinitionAnnotation: TypeDeclarationAnnotation
 	std::set<ContractDefinition const*> contractDependencies;
 };
 
+struct FunctionDefinitionAnnotation: ASTAnnotation, DocumentedAnnotation
+{
+};
+
+struct EventDefinitionAnnotation: ASTAnnotation, DocumentedAnnotation
+{
+};
+
+struct ModifierDefinitionAnnotation: ASTAnnotation, DocumentedAnnotation
+{
+};
+
 struct VariableDeclarationAnnotation: ASTAnnotation
 {
 	/// Type of variable (type of identifier referencing this variable).
 	TypePointer type;
 };
 
-struct ReturnAnnotation: ASTAnnotation
+struct StatementAnnotation: ASTAnnotation, DocumentedAnnotation
+{
+};
+
+struct ReturnAnnotation: StatementAnnotation
 {
 	/// Reference to the return parameters of the function.
 	ParameterList const* functionReturnParameters = nullptr;
@@ -84,7 +113,7 @@ struct UserDefinedTypeNameAnnotation: TypeNameAnnotation
 	Declaration const* referencedDeclaration = nullptr;
 };
 
-struct VariableDeclarationStatementAnnotation: ASTAnnotation
+struct VariableDeclarationStatementAnnotation: StatementAnnotation
 {
 	/// Information about which component of the value is assigned to which variable.
 	/// The pointer can be null to signify that the component is discarded.
diff --git a/libsolidity/ASTForward.h b/libsolidity/ast/ASTForward.h
similarity index 100%
rename from libsolidity/ASTForward.h
rename to libsolidity/ast/ASTForward.h
diff --git a/libsolidity/ASTJsonConverter.cpp b/libsolidity/ast/ASTJsonConverter.cpp
similarity index 99%
rename from libsolidity/ASTJsonConverter.cpp
rename to libsolidity/ast/ASTJsonConverter.cpp
index 34012c73..f208c3c9 100644
--- a/libsolidity/ASTJsonConverter.cpp
+++ b/libsolidity/ast/ASTJsonConverter.cpp
@@ -20,9 +20,9 @@
  * Converts the AST into json format
  */
 
-#include <libsolidity/ASTJsonConverter.h>
+#include <libsolidity/ast/ASTJsonConverter.h>
 #include <boost/algorithm/string/join.hpp>
-#include <libsolidity/AST.h>
+#include <libsolidity/ast/AST.h>
 
 using namespace std;
 
diff --git a/libsolidity/ASTJsonConverter.h b/libsolidity/ast/ASTJsonConverter.h
similarity index 96%
rename from libsolidity/ASTJsonConverter.h
rename to libsolidity/ast/ASTJsonConverter.h
index a62259e2..de891cc6 100644
--- a/libsolidity/ASTJsonConverter.h
+++ b/libsolidity/ast/ASTJsonConverter.h
@@ -24,10 +24,10 @@
 
 #include <ostream>
 #include <stack>
-#include <libsolidity/ASTVisitor.h>
-#include <libsolidity/Exceptions.h>
-#include <libsolidity/Utils.h>
-#include <libsolidity/ASTAnnotations.h>
+#include <libsolidity/ast/ASTVisitor.h>
+#include <libsolidity/interface/Exceptions.h>
+#include <libsolidity/interface/Utils.h>
+#include <libsolidity/ast/ASTAnnotations.h>
 #include <json/json.h>
 
 namespace dev
diff --git a/libsolidity/ASTPrinter.cpp b/libsolidity/ast/ASTPrinter.cpp
similarity index 99%
rename from libsolidity/ASTPrinter.cpp
rename to libsolidity/ast/ASTPrinter.cpp
index cb231842..9253e0bf 100644
--- a/libsolidity/ASTPrinter.cpp
+++ b/libsolidity/ast/ASTPrinter.cpp
@@ -20,9 +20,9 @@
  * Pretty-printer for the abstract syntax tree (the "pretty" is arguable), used for debugging.
  */
 
-#include <libsolidity/ASTPrinter.h>
+#include <libsolidity/ast/ASTPrinter.h>
 #include <boost/algorithm/string/join.hpp>
-#include <libsolidity/AST.h>
+#include <libsolidity/ast/AST.h>
 
 using namespace std;
 
diff --git a/libsolidity/ASTPrinter.h b/libsolidity/ast/ASTPrinter.h
similarity index 98%
rename from libsolidity/ASTPrinter.h
rename to libsolidity/ast/ASTPrinter.h
index 95656436..d9b5e252 100644
--- a/libsolidity/ASTPrinter.h
+++ b/libsolidity/ast/ASTPrinter.h
@@ -23,8 +23,8 @@
 #pragma once
 
 #include <ostream>
-#include <libsolidity/ASTVisitor.h>
-#include <libsolidity/GasEstimator.h>
+#include <libsolidity/ast/ASTVisitor.h>
+#include <libsolidity/interface/GasEstimator.h>
 
 namespace dev
 {
diff --git a/libsolidity/ASTUtils.cpp b/libsolidity/ast/ASTUtils.cpp
similarity index 96%
rename from libsolidity/ASTUtils.cpp
rename to libsolidity/ast/ASTUtils.cpp
index a617bf94..e9b70b62 100644
--- a/libsolidity/ASTUtils.cpp
+++ b/libsolidity/ast/ASTUtils.cpp
@@ -20,7 +20,7 @@
  * Utilities to work with the AST.
  */
 
-#include <libsolidity/ASTUtils.h>
+#include <libsolidity/ast/ASTUtils.h>
 
 using namespace std;
 using namespace dev;
diff --git a/libsolidity/ASTUtils.h b/libsolidity/ast/ASTUtils.h
similarity index 97%
rename from libsolidity/ASTUtils.h
rename to libsolidity/ast/ASTUtils.h
index b24a3404..237537ec 100644
--- a/libsolidity/ASTUtils.h
+++ b/libsolidity/ast/ASTUtils.h
@@ -23,7 +23,7 @@
 #pragma once
 
 #include <libevmasm/SourceLocation.h>
-#include <libsolidity/ASTVisitor.h>
+#include <libsolidity/ast/ASTVisitor.h>
 
 namespace dev
 {
diff --git a/libsolidity/ASTVisitor.h b/libsolidity/ast/ASTVisitor.h
similarity index 99%
rename from libsolidity/ASTVisitor.h
rename to libsolidity/ast/ASTVisitor.h
index 3e50fb28..14c09fb4 100644
--- a/libsolidity/ASTVisitor.h
+++ b/libsolidity/ast/ASTVisitor.h
@@ -25,7 +25,7 @@
 #include <string>
 #include <functional>
 #include <vector>
-#include <libsolidity/AST.h>
+#include <libsolidity/ast/AST.h>
 
 namespace dev
 {
diff --git a/libsolidity/AST_accept.h b/libsolidity/ast/AST_accept.h
similarity index 99%
rename from libsolidity/AST_accept.h
rename to libsolidity/ast/AST_accept.h
index eb1f6098..12a26ea7 100644
--- a/libsolidity/AST_accept.h
+++ b/libsolidity/ast/AST_accept.h
@@ -23,8 +23,8 @@
 
 #pragma once
 
-#include <libsolidity/AST.h>
-#include <libsolidity/ASTVisitor.h>
+#include <libsolidity/ast/AST.h>
+#include <libsolidity/ast/ASTVisitor.h>
 
 namespace dev
 {
diff --git a/libsolidity/Types.cpp b/libsolidity/ast/Types.cpp
similarity index 99%
rename from libsolidity/Types.cpp
rename to libsolidity/ast/Types.cpp
index 02b86a7f..0253e843 100644
--- a/libsolidity/Types.cpp
+++ b/libsolidity/ast/Types.cpp
@@ -20,14 +20,14 @@
  * Solidity data types
  */
 
-#include <libsolidity/Types.h>
+#include <libsolidity/ast/Types.h>
 #include <limits>
 #include <boost/range/adaptor/reversed.hpp>
 #include <libdevcore/CommonIO.h>
 #include <libdevcore/CommonData.h>
 #include <libdevcore/SHA3.h>
-#include <libsolidity/Utils.h>
-#include <libsolidity/AST.h>
+#include <libsolidity/interface/Utils.h>
+#include <libsolidity/ast/AST.h>
 
 using namespace std;
 using namespace dev;
diff --git a/libsolidity/Types.h b/libsolidity/ast/Types.h
similarity index 99%
rename from libsolidity/Types.h
rename to libsolidity/ast/Types.h
index 626ebbe4..2f75975f 100644
--- a/libsolidity/Types.h
+++ b/libsolidity/ast/Types.h
@@ -27,9 +27,9 @@
 #include <map>
 #include <boost/noncopyable.hpp>
 #include <libdevcore/Common.h>
-#include <libsolidity/Exceptions.h>
-#include <libsolidity/ASTForward.h>
-#include <libsolidity/Token.h>
+#include <libsolidity/interface/Exceptions.h>
+#include <libsolidity/ast/ASTForward.h>
+#include <libsolidity/parsing/Token.h>
 #include <libdevcore/UndefMacros.h>
 
 namespace dev
diff --git a/libsolidity/ArrayUtils.cpp b/libsolidity/codegen/ArrayUtils.cpp
similarity index 99%
rename from libsolidity/ArrayUtils.cpp
rename to libsolidity/codegen/ArrayUtils.cpp
index 1999eb77..ba26caa6 100644
--- a/libsolidity/ArrayUtils.cpp
+++ b/libsolidity/codegen/ArrayUtils.cpp
@@ -20,13 +20,13 @@
  * Code generation utils that handle arrays.
  */
 
-#include <libsolidity/ArrayUtils.h>
+#include <libsolidity/codegen/ArrayUtils.h>
 #include <libevmcore/Instruction.h>
-#include <libsolidity/CompilerContext.h>
-#include <libsolidity/CompilerUtils.h>
-#include <libsolidity/Types.h>
-#include <libsolidity/Utils.h>
-#include <libsolidity/LValue.h>
+#include <libsolidity/codegen/CompilerContext.h>
+#include <libsolidity/codegen/CompilerUtils.h>
+#include <libsolidity/ast/Types.h>
+#include <libsolidity/interface/Utils.h>
+#include <libsolidity/codegen/LValue.h>
 
 using namespace std;
 using namespace dev;
diff --git a/libsolidity/ArrayUtils.h b/libsolidity/codegen/ArrayUtils.h
similarity index 100%
rename from libsolidity/ArrayUtils.h
rename to libsolidity/codegen/ArrayUtils.h
diff --git a/libsolidity/Compiler.cpp b/libsolidity/codegen/Compiler.cpp
similarity index 98%
rename from libsolidity/Compiler.cpp
rename to libsolidity/codegen/Compiler.cpp
index 679704ba..5daa37de 100644
--- a/libsolidity/Compiler.cpp
+++ b/libsolidity/codegen/Compiler.cpp
@@ -20,15 +20,15 @@
  * Solidity compiler.
  */
 
-#include <libsolidity/Compiler.h>
+#include <libsolidity/codegen/Compiler.h>
 #include <algorithm>
 #include <boost/range/adaptor/reversed.hpp>
 #include <libevmcore/Instruction.h>
 #include <libevmasm/Assembly.h>
 #include <libevmcore/Params.h>
-#include <libsolidity/AST.h>
-#include <libsolidity/ExpressionCompiler.h>
-#include <libsolidity/CompilerUtils.h>
+#include <libsolidity/ast/AST.h>
+#include <libsolidity/codegen/ExpressionCompiler.h>
+#include <libsolidity/codegen/CompilerUtils.h>
 
 using namespace std;
 using namespace dev;
@@ -606,7 +606,11 @@ bool Compiler::visit(Return const& _return)
 		for (auto const& retVariable: returnParameters)
 			types.push_back(retVariable->annotation().type);
 
-		TypePointer expectedType = types.size() == 1 ? types.front() : make_shared<TupleType>(types);
+		TypePointer expectedType;
+		if (expression->annotation().type->category() == Type::Category::Tuple || types.size() != 1)
+			expectedType = make_shared<TupleType>(types);
+		else
+			expectedType = types.front();
 		compileExpression(*expression, expectedType);
 
 		for (auto const& retVariable: boost::adaptors::reverse(returnParameters))
diff --git a/libsolidity/Compiler.h b/libsolidity/codegen/Compiler.h
similarity index 98%
rename from libsolidity/Compiler.h
rename to libsolidity/codegen/Compiler.h
index 3cf1004a..14314434 100644
--- a/libsolidity/Compiler.h
+++ b/libsolidity/codegen/Compiler.h
@@ -24,8 +24,8 @@
 
 #include <ostream>
 #include <functional>
-#include <libsolidity/ASTVisitor.h>
-#include <libsolidity/CompilerContext.h>
+#include <libsolidity/ast/ASTVisitor.h>
+#include <libsolidity/codegen/CompilerContext.h>
 #include <libevmasm/Assembly.h>
 
 namespace dev {
diff --git a/libsolidity/CompilerContext.cpp b/libsolidity/codegen/CompilerContext.cpp
similarity index 97%
rename from libsolidity/CompilerContext.cpp
rename to libsolidity/codegen/CompilerContext.cpp
index 0ba7af5b..00b9d87c 100644
--- a/libsolidity/CompilerContext.cpp
+++ b/libsolidity/codegen/CompilerContext.cpp
@@ -20,12 +20,12 @@
  * Utilities for the solidity compiler.
  */
 
-#include <libsolidity/CompilerContext.h>
+#include <libsolidity/codegen/CompilerContext.h>
 #include <utility>
 #include <numeric>
-#include <libsolidity/AST.h>
-#include <libsolidity/Compiler.h>
-#include <libsolidity/Version.h>
+#include <libsolidity/ast/AST.h>
+#include <libsolidity/codegen/Compiler.h>
+#include <libsolidity/interface/Version.h>
 
 using namespace std;
 
diff --git a/libsolidity/CompilerContext.h b/libsolidity/codegen/CompilerContext.h
similarity index 98%
rename from libsolidity/CompilerContext.h
rename to libsolidity/codegen/CompilerContext.h
index 18865091..5287088a 100644
--- a/libsolidity/CompilerContext.h
+++ b/libsolidity/codegen/CompilerContext.h
@@ -27,9 +27,9 @@
 #include <utility>
 #include <libevmcore/Instruction.h>
 #include <libevmasm/Assembly.h>
-#include <libsolidity/ASTForward.h>
-#include <libsolidity/Types.h>
-#include <libsolidity/ASTAnnotations.h>
+#include <libsolidity/ast/ASTForward.h>
+#include <libsolidity/ast/Types.h>
+#include <libsolidity/ast/ASTAnnotations.h>
 #include <libdevcore/Common.h>
 
 namespace dev {
diff --git a/libsolidity/CompilerUtils.cpp b/libsolidity/codegen/CompilerUtils.cpp
similarity index 99%
rename from libsolidity/CompilerUtils.cpp
rename to libsolidity/codegen/CompilerUtils.cpp
index f0dea708..dd38ef97 100644
--- a/libsolidity/CompilerUtils.cpp
+++ b/libsolidity/codegen/CompilerUtils.cpp
@@ -20,12 +20,12 @@
  * Routines used by both the compiler and the expression compiler.
  */
 
-#include <libsolidity/CompilerUtils.h>
-#include <libsolidity/AST.h>
+#include <libsolidity/codegen/CompilerUtils.h>
+#include <libsolidity/ast/AST.h>
 #include <libevmcore/Instruction.h>
 #include <libevmcore/Params.h>
-#include <libsolidity/ArrayUtils.h>
-#include <libsolidity/LValue.h>
+#include <libsolidity/codegen/ArrayUtils.h>
+#include <libsolidity/codegen/LValue.h>
 
 using namespace std;
 
@@ -598,7 +598,7 @@ void CompilerUtils::convertType(Type const& _typeOnStack, Type const& _targetTyp
 					}
 					// Value grew
 					if (targetSize > sourceSize)
-						moveIntoStack(depth + targetSize - sourceSize, targetSize - sourceSize);
+						moveIntoStack(depth + targetSize - sourceSize - 1, targetSize - sourceSize);
 				}
 			}
 			depth -= sourceSize;
diff --git a/libsolidity/CompilerUtils.h b/libsolidity/codegen/CompilerUtils.h
similarity index 98%
rename from libsolidity/CompilerUtils.h
rename to libsolidity/codegen/CompilerUtils.h
index 01b9f422..6292e5c7 100644
--- a/libsolidity/CompilerUtils.h
+++ b/libsolidity/codegen/CompilerUtils.h
@@ -22,8 +22,8 @@
 
 #pragma once
 
-#include <libsolidity/CompilerContext.h>
-#include <libsolidity/ASTForward.h>
+#include <libsolidity/codegen/CompilerContext.h>
+#include <libsolidity/ast/ASTForward.h>
 
 namespace dev {
 namespace solidity {
diff --git a/libsolidity/ExpressionCompiler.cpp b/libsolidity/codegen/ExpressionCompiler.cpp
similarity index 98%
rename from libsolidity/ExpressionCompiler.cpp
rename to libsolidity/codegen/ExpressionCompiler.cpp
index 112521f9..3906a897 100644
--- a/libsolidity/ExpressionCompiler.cpp
+++ b/libsolidity/codegen/ExpressionCompiler.cpp
@@ -26,11 +26,11 @@
 #include <libevmcore/Params.h>
 #include <libdevcore/Common.h>
 #include <libdevcore/SHA3.h>
-#include <libsolidity/AST.h>
-#include <libsolidity/ExpressionCompiler.h>
-#include <libsolidity/CompilerContext.h>
-#include <libsolidity/CompilerUtils.h>
-#include <libsolidity/LValue.h>
+#include <libsolidity/ast/AST.h>
+#include <libsolidity/codegen/ExpressionCompiler.h>
+#include <libsolidity/codegen/CompilerContext.h>
+#include <libsolidity/codegen/CompilerUtils.h>
+#include <libsolidity/codegen/LValue.h>
 
 using namespace std;
 
@@ -587,11 +587,24 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 				{
 					++numIndexed;
 					arguments[arg - 1]->accept(*this);
-					utils().convertType(
-						*arguments[arg - 1]->annotation().type,
-						*function.parameterTypes()[arg - 1],
-						true
-					);
+					if (auto const& arrayType = dynamic_pointer_cast<ArrayType const>(function.parameterTypes()[arg - 1]))
+					{
+						utils().fetchFreeMemoryPointer();
+						utils().encodeToMemory(
+							{arguments[arg - 1]->annotation().type},
+							{arrayType},
+							false,
+							true
+						);
+						utils().toSizeAfterFreeMemoryPointer();
+						m_context << eth::Instruction::SHA3;
+					}
+					else
+						utils().convertType(
+							*arguments[arg - 1]->annotation().type,
+							*function.parameterTypes()[arg - 1],
+							true
+						);
 				}
 			if (!event.isAnonymous())
 			{
diff --git a/libsolidity/ExpressionCompiler.h b/libsolidity/codegen/ExpressionCompiler.h
similarity index 97%
rename from libsolidity/ExpressionCompiler.h
rename to libsolidity/codegen/ExpressionCompiler.h
index 44d27ea2..379aa65a 100644
--- a/libsolidity/ExpressionCompiler.h
+++ b/libsolidity/codegen/ExpressionCompiler.h
@@ -26,9 +26,9 @@
 #include <boost/noncopyable.hpp>
 #include <libdevcore/Common.h>
 #include <libevmasm/SourceLocation.h>
-#include <libsolidity/ASTVisitor.h>
-#include <libsolidity/LValue.h>
-#include <libsolidity/Utils.h>
+#include <libsolidity/ast/ASTVisitor.h>
+#include <libsolidity/codegen/LValue.h>
+#include <libsolidity/interface/Utils.h>
 
 namespace dev {
 namespace eth
diff --git a/libsolidity/LValue.cpp b/libsolidity/codegen/LValue.cpp
similarity index 96%
rename from libsolidity/LValue.cpp
rename to libsolidity/codegen/LValue.cpp
index ac04ebef..864f28d0 100644
--- a/libsolidity/LValue.cpp
+++ b/libsolidity/codegen/LValue.cpp
@@ -20,11 +20,11 @@
  * LValues for use in the expresison compiler.
  */
 
-#include <libsolidity/LValue.h>
+#include <libsolidity/codegen/LValue.h>
 #include <libevmcore/Instruction.h>
-#include <libsolidity/Types.h>
-#include <libsolidity/AST.h>
-#include <libsolidity/CompilerUtils.h>
+#include <libsolidity/ast/Types.h>
+#include <libsolidity/ast/AST.h>
+#include <libsolidity/codegen/CompilerUtils.h>
 
 using namespace std;
 using namespace dev;
@@ -103,10 +103,20 @@ void MemoryItem::storeValue(Type const& _sourceType, SourceLocation const&, bool
 		if (!_move)
 		{
 			utils.moveToStackTop(m_dataType->sizeOnStack());
-			utils.copyToStackTop(2, m_dataType->sizeOnStack());
+			utils.copyToStackTop(1 + m_dataType->sizeOnStack(), m_dataType->sizeOnStack());
+		}
+		if (!m_padded)
+		{
+			solAssert(m_dataType->calldataEncodedSize(false) == 1, "Invalid non-padded type.");
+			if (m_dataType->category() == Type::Category::FixedBytes)
+				m_context << u256(0) << eth::Instruction::BYTE;
+			m_context << eth::Instruction::SWAP1 << eth::Instruction::MSTORE8;
+		}
+		else
+		{
+			utils.storeInMemoryDynamic(*m_dataType, m_padded);
+			m_context << eth::Instruction::POP;
 		}
-		utils.storeInMemoryDynamic(*m_dataType, m_padded);
-		m_context << eth::Instruction::POP;
 	}
 	else
 	{
diff --git a/libsolidity/LValue.h b/libsolidity/codegen/LValue.h
similarity index 98%
rename from libsolidity/LValue.h
rename to libsolidity/codegen/LValue.h
index 94c8d3b8..e8c3aa80 100644
--- a/libsolidity/LValue.h
+++ b/libsolidity/codegen/LValue.h
@@ -25,7 +25,7 @@
 #include <memory>
 #include <vector>
 #include <libevmasm/SourceLocation.h>
-#include <libsolidity/ArrayUtils.h>
+#include <libsolidity/codegen/ArrayUtils.h>
 
 namespace dev
 {
@@ -204,7 +204,7 @@ public:
 	/// Constructs the LValue assuming that the other LValues are present on the stack.
 	/// Empty unique_ptrs are possible if e.g. some values should be ignored during assignment.
 	TupleObject(CompilerContext& _compilerContext, std::vector<std::unique_ptr<LValue>>&& _lvalues);
-	virtual unsigned sizeOnStack() const;
+	virtual unsigned sizeOnStack() const override;
 	virtual void retrieveValue(SourceLocation const& _location, bool _remove = false) const override;
 	virtual void storeValue(
 		Type const& _sourceType,
diff --git a/libsolidity/formal/Why3Translator.cpp b/libsolidity/formal/Why3Translator.cpp
new file mode 100644
index 00000000..14b324e0
--- /dev/null
+++ b/libsolidity/formal/Why3Translator.cpp
@@ -0,0 +1,547 @@
+/*
+	This file is part of cpp-ethereum.
+
+	cpp-ethereum is free software: you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
+
+	cpp-ethereum is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.
+*/
+/**
+ * @author Christian <c@ethdev.com>
+ * @date 2015
+ * Component that translates Solidity code into the why3 programming language.
+ */
+
+#include <libsolidity/formal/Why3Translator.h>
+
+using namespace std;
+using namespace dev;
+using namespace dev::solidity;
+
+bool Why3Translator::process(SourceUnit const& _source)
+{
+	try
+	{
+		m_indentation = 0;
+		if (!m_result.empty())
+			fatalError(_source, "Multiple source units not yet supported");
+		appendPreface();
+		_source.accept(*this);
+		addLine("end");
+	}
+	catch (FatalError& _e)
+	{
+		solAssert(m_errorOccured, "");
+	}
+	return !m_errorOccured;
+}
+
+void Why3Translator::error(ASTNode const& _node, string const& _description)
+{
+	auto err = make_shared<Error>(Error::Type::Why3TranslatorError);
+	*err <<
+		errinfo_sourceLocation(_node.location()) <<
+		errinfo_comment(_description);
+	m_errors.push_back(err);
+	m_errorOccured = true;
+}
+
+void Why3Translator::fatalError(ASTNode const& _node, string const& _description)
+{
+	error(_node, _description);
+	BOOST_THROW_EXCEPTION(FatalError());
+}
+
+void Why3Translator::appendPreface()
+{
+	m_result += R"(
+module UInt256
+	use import mach.int.Unsigned
+	type uint256
+	constant max_uint256: int = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
+	clone export mach.int.Unsigned with
+		type t = uint256,
+		constant max = max_uint256
+end
+
+module Solidity
+use import int.Int
+use import ref.Ref
+use import map.Map
+use import array.Array
+use import int.ComputerDivision
+use import mach.int.Unsigned
+use import UInt256
+
+exception Ret
+type state = StateUnused
+)";
+}
+
+string Why3Translator::toFormalType(Type const& _type) const
+{
+	if (auto type = dynamic_cast<IntegerType const*>(&_type))
+	{
+		if (!type->isAddress() && !type->isSigned() && type->numBits() == 256)
+			return "uint256";
+	}
+	else if (auto type = dynamic_cast<ArrayType const*>(&_type))
+		if (!type->isByteArray() && type->isDynamicallySized() && type->dataStoredIn(DataLocation::Memory))
+		{
+			string base = toFormalType(*type->baseType());
+			if (!base.empty())
+				return "array " + base;
+		}
+
+	return "";
+}
+
+void Why3Translator::addLine(string const& _line)
+{
+	newLine();
+	add(_line);
+	newLine();
+}
+
+void Why3Translator::add(string const& _str)
+{
+	if (m_currentLine.empty())
+		m_indentationAtLineStart = m_indentation;
+	m_currentLine += _str;
+}
+
+void Why3Translator::newLine()
+{
+	if (!m_currentLine.empty())
+	{
+		for (size_t i = 0; i < m_indentationAtLineStart; ++i)
+			m_result.push_back('\t');
+		m_result += m_currentLine;
+		m_result.push_back('\n');
+		m_currentLine.clear();
+	}
+}
+
+void Why3Translator::unindent()
+{
+	newLine();
+	solAssert(m_indentation > 0, "");
+	m_indentation--;
+}
+
+bool Why3Translator::visit(ContractDefinition const& _contract)
+{
+	if (m_seenContract)
+		error(_contract, "More than one contract not supported.");
+	m_seenContract = true;
+	if (_contract.isLibrary())
+		error(_contract, "Libraries not supported.");
+
+	addSourceFromDocStrings(_contract.annotation());
+
+	return true;
+}
+
+bool Why3Translator::visit(FunctionDefinition const& _function)
+{
+	if (!_function.isImplemented())
+	{
+		error(_function, "Unimplemented functions not supported.");
+		return false;
+	}
+	if (_function.name().empty())
+	{
+		error(_function, "Fallback functions not supported.");
+		return false;
+	}
+	if (!_function.modifiers().empty())
+	{
+		error(_function, "Modifiers not supported.");
+		return false;
+	}
+
+	add("let rec _" + _function.name());
+	add(" (state: state)");
+	for (auto const& param: _function.parameters())
+	{
+		string paramType = toFormalType(*param->annotation().type);
+		if (paramType.empty())
+			error(*param, "Parameter type not supported.");
+		if (param->name().empty())
+			error(*param, "Anonymous function parameters not supported.");
+		add(" (arg_" + param->name() + ": " + paramType + ")");
+	}
+	add(":");
+
+	indent();
+	indent();
+	string retString = "(";
+	for (auto const& retParam: _function.returnParameters())
+	{
+		string paramType = toFormalType(*retParam->annotation().type);
+		if (paramType.empty())
+			error(*retParam, "Parameter type not supported.");
+		if (retString.size() != 1)
+			retString += ", ";
+		retString += paramType;
+	}
+	add(retString + ")");
+	unindent();
+
+	addSourceFromDocStrings(_function.annotation());
+
+	addLine("=");
+
+	// initialise local variables
+	for (auto const& variable: _function.parameters())
+		addLine("let _" + variable->name() + " = ref arg_" + variable->name() + " in");
+	for (auto const& variable: _function.returnParameters())
+	{
+		if (variable->name().empty())
+			error(*variable, "Unnamed return variables not yet supported.");
+		string varType = toFormalType(*variable->annotation().type);
+		addLine("let _" + variable->name() + ": ref " + varType + " = ref (of_int 0) in");
+	}
+	for (VariableDeclaration const* variable: _function.localVariables())
+	{
+		if (variable->name().empty())
+			error(*variable, "Unnamed variables not yet supported.");
+		string varType = toFormalType(*variable->annotation().type);
+		addLine("let _" + variable->name() + ": ref " + varType + " = ref (of_int 0) in");
+	}
+	addLine("try");
+
+	_function.body().accept(*this);
+	add(";");
+	addLine("raise Ret");
+
+	string retVals;
+	for (auto const& variable: _function.returnParameters())
+	{
+		if (!retVals.empty())
+			retVals += ", ";
+		retVals += "!_" + variable->name();
+	}
+	addLine("with Ret -> (" + retVals + ")");
+	newLine();
+	unindent();
+	addLine("end");
+	addLine("");
+	return false;
+}
+
+bool Why3Translator::visit(Block const& _node)
+{
+	addSourceFromDocStrings(_node.annotation());
+	add("begin");
+	indent();
+	for (size_t i = 0; i < _node.statements().size(); ++i)
+	{
+		_node.statements()[i]->accept(*this);
+		if (!m_currentLine.empty() && i != _node.statements().size() - 1)
+			add(";");
+		newLine();
+	}
+	unindent();
+	add("end");
+	return false;
+}
+
+bool Why3Translator::visit(IfStatement const& _node)
+{
+	addSourceFromDocStrings(_node.annotation());
+
+	add("if ");
+	_node.condition().accept(*this);
+	add(" then");
+	visitIndentedUnlessBlock(_node.trueStatement());
+	if (_node.falseStatement())
+	{
+		newLine();
+		add("else");
+		visitIndentedUnlessBlock(*_node.falseStatement());
+	}
+	return false;
+}
+
+bool Why3Translator::visit(WhileStatement const& _node)
+{
+	addSourceFromDocStrings(_node.annotation());
+
+	add("while ");
+	_node.condition().accept(*this);
+	newLine();
+	add("do");
+	visitIndentedUnlessBlock(_node.body());
+	add("done");
+	return false;
+}
+
+bool Why3Translator::visit(Return const& _node)
+{
+	addSourceFromDocStrings(_node.annotation());
+
+	if (_node.expression())
+	{
+		solAssert(!!_node.annotation().functionReturnParameters, "");
+		auto const& params = _node.annotation().functionReturnParameters->parameters();
+		if (params.size() != 1)
+		{
+			error(_node, "Directly returning tuples not supported. Rather assign to return variable.");
+			return false;
+		}
+		add("begin _" + params.front()->name() + " := ");
+		_node.expression()->accept(*this);
+		add("; raise Ret end");
+	}
+	else
+		add("raise Ret");
+	return false;
+}
+
+bool Why3Translator::visit(VariableDeclarationStatement const& _node)
+{
+	addSourceFromDocStrings(_node.annotation());
+
+	if (_node.declarations().size() != 1)
+	{
+		error(_node, "Multiple variables not supported.");
+		return false;
+	}
+	if (_node.initialValue())
+	{
+		add("_" + _node.declarations().front()->name() + " := ");
+		_node.initialValue()->accept(*this);
+	}
+	return false;
+}
+
+bool Why3Translator::visit(ExpressionStatement const& _node)
+{
+	addSourceFromDocStrings(_node.annotation());
+	return true;
+}
+
+bool Why3Translator::visit(Assignment const& _node)
+{
+	if (_node.assignmentOperator() != Token::Assign)
+		error(_node, "Compound assignment not supported.");
+
+	_node.leftHandSide().accept(*this);
+	add(" := ");
+	_node.rightHandSide().accept(*this);
+
+	return false;
+}
+
+bool Why3Translator::visit(TupleExpression const& _node)
+{
+	if (_node.components().size() != 1)
+		error(_node, "Only tuples with exactly one component supported.");
+	add("(");
+	return true;
+}
+
+bool Why3Translator::visit(UnaryOperation const& _unaryOperation)
+{
+	if (toFormalType(*_unaryOperation.annotation().type).empty())
+		error(_unaryOperation, "Type not supported.");
+
+	switch (_unaryOperation.getOperator())
+	{
+	case Token::Not: // !
+		add("(not ");
+		break;
+	default:
+		error(_unaryOperation, "Operator not supported.");
+		break;
+	}
+
+	_unaryOperation.subExpression().accept(*this);
+	add(")");
+
+	return false;
+}
+
+bool Why3Translator::visit(BinaryOperation const& _binaryOperation)
+{
+	Expression const& leftExpression = _binaryOperation.leftExpression();
+	Expression const& rightExpression = _binaryOperation.rightExpression();
+	solAssert(!!_binaryOperation.annotation().commonType, "");
+	Type const& commonType = *_binaryOperation.annotation().commonType;
+	Token::Value const c_op = _binaryOperation.getOperator();
+
+	if (commonType.category() == Type::Category::IntegerConstant)
+	{
+		add("(of_int " + toString(commonType.literalValue(nullptr)) + ")");
+		return false;
+	}
+	static const map<Token::Value, char const*> optrans({
+		{Token::And, " && "},
+		{Token::Or, " || "},
+		{Token::BitOr, " lor "},
+		{Token::BitXor, " lxor "},
+		{Token::BitAnd, " land "},
+		{Token::Add, " + "},
+		{Token::Sub, " - "},
+		{Token::Mul, " * "},
+		{Token::Div, " / "},
+		{Token::Mod, " mod "},
+		{Token::Equal, " = "},
+		{Token::NotEqual, " <> "},
+		{Token::LessThan, " < "},
+		{Token::GreaterThan, " > "},
+		{Token::LessThanOrEqual, " <= "},
+		{Token::GreaterThanOrEqual, " >= "}
+	});
+	if (!optrans.count(c_op))
+		error(_binaryOperation, "Operator not supported.");
+
+	add("(");
+	leftExpression.accept(*this);
+	add(optrans.at(c_op));
+	rightExpression.accept(*this);
+	add(")");
+
+	return false;
+}
+
+bool Why3Translator::visit(FunctionCall const& _node)
+{
+	if (_node.annotation().isTypeConversion || _node.annotation().isStructConstructorCall)
+	{
+		error(_node, "Only ordinary function calls supported.");
+		return true;
+	}
+	FunctionType const& function = dynamic_cast<FunctionType const&>(*_node.expression().annotation().type);
+	if (function.location() != FunctionType::Location::Internal)
+	{
+		error(_node, "Only internal function calls supported.");
+		return true;
+	}
+	if (!_node.names().empty())
+	{
+		error(_node, "Function calls with named arguments not supported.");
+		return true;
+	}
+
+	//@TODO check type conversions
+
+	add("(");
+	_node.expression().accept(*this);
+	add(" StateUnused");
+	for (auto const& arg: _node.arguments())
+	{
+		add(" ");
+		arg->accept(*this);
+	}
+	add(")");
+	return false;
+}
+
+bool Why3Translator::visit(MemberAccess const& _node)
+{
+	if (
+		_node.expression().annotation().type->category() == Type::Category::Array &&
+		_node.memberName() == "length" &&
+		!_node.annotation().lValueRequested
+	)
+	{
+		add("(of_int ");
+		_node.expression().accept(*this);
+		add(".length");
+		add(")");
+	}
+	else
+		error(_node, "Only read-only length access for arrays supported.");
+	return false;
+}
+
+bool Why3Translator::visit(IndexAccess const& _node)
+{
+	auto baseType = dynamic_cast<ArrayType const*>(_node.baseExpression().annotation().type.get());
+	if (!baseType)
+	{
+		error(_node, "Index access only supported for arrays.");
+		return true;
+	}
+	if (_node.annotation().lValueRequested)
+	{
+		error(_node, "Assignment to array elements not supported.");
+		return true;
+	}
+	add("(");
+	_node.baseExpression().accept(*this);
+	add("[to_int ");
+	_node.indexExpression()->accept(*this);
+	add("]");
+	add(")");
+
+	return false;
+}
+
+bool Why3Translator::visit(Identifier const& _identifier)
+{
+	Declaration const* declaration = _identifier.annotation().referencedDeclaration;
+	if (FunctionDefinition const* functionDef = dynamic_cast<FunctionDefinition const*>(declaration))
+		add("_" + functionDef->name());
+	else if (auto variable = dynamic_cast<VariableDeclaration const*>(declaration))
+	{
+		if (_identifier.annotation().lValueRequested)
+			add("_" + variable->name());
+		else
+			add("!_" + variable->name());
+	}
+	else
+		error(_identifier, "Not supported.");
+	return false;
+}
+
+bool Why3Translator::visit(Literal const& _literal)
+{
+	TypePointer type = _literal.annotation().type;
+	switch (type->category())
+	{
+	case Type::Category::Bool:
+		if (type->literalValue(&_literal) == 0)
+			add("false");
+		else
+			add("true");
+		break;
+	case Type::Category::IntegerConstant:
+		add("(of_int " + toString(type->literalValue(&_literal)) + ")");
+		break;
+	default:
+		error(_literal, "Not supported.");
+	}
+	return false;
+}
+
+void Why3Translator::visitIndentedUnlessBlock(Statement const& _statement)
+{
+	bool isBlock = !!dynamic_cast<Block const*>(&_statement);
+	if (isBlock)
+		newLine();
+	else
+		indent();
+	_statement.accept(*this);
+	if (isBlock)
+		newLine();
+	else
+		unindent();
+}
+
+void Why3Translator::addSourceFromDocStrings(DocumentedAnnotation const& _annotation)
+{
+	auto why3Range = _annotation.docTags.equal_range("why3");
+	for (auto i = why3Range.first; i != why3Range.second; ++i)
+		addLine(i->second.content);
+}
diff --git a/libsolidity/formal/Why3Translator.h b/libsolidity/formal/Why3Translator.h
new file mode 100644
index 00000000..1aa46424
--- /dev/null
+++ b/libsolidity/formal/Why3Translator.h
@@ -0,0 +1,118 @@
+/*
+	This file is part of cpp-ethereum.
+
+	cpp-ethereum is free software: you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
+
+	cpp-ethereum is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.
+*/
+/**
+ * @author Christian <c@ethdev.com>
+ * @date 2015
+ * Component that translates Solidity code into the why3 programming language.
+ */
+
+#pragma once
+
+#include <libsolidity/ast/ASTVisitor.h>
+#include <libsolidity/interface/Exceptions.h>
+#include <string>
+
+namespace dev
+{
+namespace solidity
+{
+
+class SourceUnit;
+
+/**
+ * Simple translator from Solidity to Why3.
+ *
+ * @todo detect side effects in sub-expressions and limit them to one per statement.
+ * @todo `x = y = z`
+ * @todo implicit and explicit type conversion
+ */
+class Why3Translator: private ASTConstVisitor
+{
+public:
+	Why3Translator(ErrorList& _errors): m_errors(_errors) {}
+
+	/// Appends formalisation of the given source unit to the output.
+	/// @returns false on error.
+	bool process(SourceUnit const& _source);
+
+	std::string translation() const { return m_result; }
+
+private:
+	/// Returns an error.
+	void error(ASTNode const& _node, std::string const& _description);
+	/// Reports a fatal error and throws.
+	void fatalError(ASTNode const& _node, std::string const& _description);
+
+	/// Appends imports and constants use throughout the formal code.
+	void appendPreface();
+
+	/// @returns a string representation of the corresponding formal type or the empty string
+	/// if the type is not supported.
+	std::string toFormalType(Type const& _type) const;
+
+	void indent() { newLine(); m_indentation++; }
+	void unindent();
+	void addLine(std::string const& _line);
+	void add(std::string const& _str);
+	void newLine();
+
+	virtual bool visit(SourceUnit const&) override { return true; }
+	virtual bool visit(ContractDefinition const& _contract) override;
+	virtual bool visit(FunctionDefinition const& _function) override;
+	virtual bool visit(Block const&) override;
+	virtual bool visit(IfStatement const& _node) override;
+	virtual bool visit(WhileStatement const& _node) override;
+	virtual bool visit(Return const& _node) override;
+	virtual bool visit(VariableDeclarationStatement const& _node) override;
+	virtual bool visit(ExpressionStatement const&) override;
+	virtual bool visit(Assignment const& _node) override;
+	virtual bool visit(TupleExpression const& _node) override;
+	virtual void endVisit(TupleExpression const&) override { add(")"); }
+	virtual bool visit(UnaryOperation const& _node) override;
+	virtual bool visit(BinaryOperation const& _node) override;
+	virtual bool visit(FunctionCall const& _node) override;
+	virtual bool visit(MemberAccess const& _node) override;
+	virtual bool visit(IndexAccess const& _node) override;
+	virtual bool visit(Identifier const& _node) override;
+	virtual bool visit(Literal const& _node) override;
+
+	virtual bool visitNode(ASTNode const& _node) override
+	{
+		error(_node, "Code not supported for formal verification.");
+		return false;
+	}
+
+	/// Visits the givin statement and indents it unless it is a block
+	/// (which does its own indentation).
+	void visitIndentedUnlessBlock(Statement const& _statement);
+
+	void addSourceFromDocStrings(DocumentedAnnotation const& _annotation);
+
+	size_t m_indentationAtLineStart = 0;
+	size_t m_indentation = 0;
+	std::string m_currentLine;
+	/// True if we have already seen a contract. For now, only a single contract
+	/// is supported.
+	bool m_seenContract = false;
+	bool m_errorOccured = false;
+	std::string m_result;
+	ErrorList& m_errors;
+};
+
+
+}
+}
diff --git a/libsolidity/CompilerStack.cpp b/libsolidity/interface/CompilerStack.cpp
similarity index 92%
rename from libsolidity/CompilerStack.cpp
rename to libsolidity/interface/CompilerStack.cpp
index 03120f66..18eec0a2 100644
--- a/libsolidity/CompilerStack.cpp
+++ b/libsolidity/interface/CompilerStack.cpp
@@ -22,15 +22,17 @@
  */
 
 #include <boost/algorithm/string.hpp>
-#include <libsolidity/AST.h>
-#include <libsolidity/Scanner.h>
-#include <libsolidity/Parser.h>
-#include <libsolidity/GlobalContext.h>
-#include <libsolidity/NameAndTypeResolver.h>
-#include <libsolidity/TypeChecker.h>
-#include <libsolidity/Compiler.h>
-#include <libsolidity/CompilerStack.h>
-#include <libsolidity/InterfaceHandler.h>
+#include <libsolidity/ast/AST.h>
+#include <libsolidity/parsing/Scanner.h>
+#include <libsolidity/parsing/Parser.h>
+#include <libsolidity/analysis/GlobalContext.h>
+#include <libsolidity/analysis/NameAndTypeResolver.h>
+#include <libsolidity/analysis/TypeChecker.h>
+#include <libsolidity/analysis/DocStringAnalyser.h>
+#include <libsolidity/codegen/Compiler.h>
+#include <libsolidity/interface/CompilerStack.h>
+#include <libsolidity/interface/InterfaceHandler.h>
+#include <libsolidity/formal/Why3Translator.h>
 
 #include <libdevcore/SHA3.h>
 
@@ -114,6 +116,12 @@ bool CompilerStack::parse()
 
 	resolveImports();
 
+	bool noErrors = true;
+	DocStringAnalyser docStringAnalyser(m_errors);
+	for (Source const* source: m_sourceOrder)
+		if (!docStringAnalyser.analyseDocStrings(*source->ast))
+			noErrors = false;
+
 	m_globalContext = make_shared<GlobalContext>();
 	NameAndTypeResolver resolver(m_globalContext->declarations(), m_errors);
 	for (Source const* source: m_sourceOrder)
@@ -131,8 +139,6 @@ bool CompilerStack::parse()
 				m_contracts[contract->name()].contract = contract;
 			}
 
-	InterfaceHandler interfaceHandler;
-	bool typesFine = true;
 	for (Source const* source: m_sourceOrder)
 		for (ASTPointer<ASTNode> const& node: source->ast->nodes())
 			if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
@@ -142,15 +148,15 @@ bool CompilerStack::parse()
 				TypeChecker typeChecker(m_errors);
 				if (typeChecker.checkTypeRequirements(*contract))
 				{
-					contract->setDevDocumentation(interfaceHandler.devDocumentation(*contract));
-					contract->setUserDocumentation(interfaceHandler.userDocumentation(*contract));
+					contract->setDevDocumentation(InterfaceHandler::devDocumentation(*contract));
+					contract->setUserDocumentation(InterfaceHandler::userDocumentation(*contract));
 				}
 				else
-					typesFine = false;
+					noErrors = false;
 
 				m_contracts[contract->name()].contract = contract;
 			}
-	m_parseSuccessful = typesFine;
+	m_parseSuccessful = noErrors;
 	return m_parseSuccessful;
 }
 
@@ -200,6 +206,18 @@ void CompilerStack::link(const std::map<string, h160>& _libraries)
 	}
 }
 
+bool CompilerStack::prepareFormalAnalysis()
+{
+	Why3Translator translator(m_errors);
+	for (Source const* source: m_sourceOrder)
+		if (!translator.process(*source->ast))
+			return false;
+
+	m_formalTranslation = translator.translation();
+
+	return true;
+}
+
 eth::AssemblyItems const* CompilerStack::assemblyItems(string const& _contractName) const
 {
 	Contract const& currentContract = contract(_contractName);
@@ -287,7 +305,7 @@ string const& CompilerStack::metadata(string const& _contractName, Documentation
 
 	// caches the result
 	if (!*doc)
-		doc->reset(new string(currentContract.interfaceHandler->documentation(*currentContract.contract, _type)));
+		doc->reset(new string(InterfaceHandler::documentation(*currentContract.contract, _type)));
 
 	return *(*doc);
 }
@@ -428,8 +446,5 @@ CompilerStack::Source const& CompilerStack::source(string const& _sourceName) co
 	return it->second;
 }
 
-CompilerStack::Contract::Contract(): interfaceHandler(make_shared<InterfaceHandler>()) {}
-
-
 }
 }
diff --git a/libsolidity/CompilerStack.h b/libsolidity/interface/CompilerStack.h
similarity index 96%
rename from libsolidity/CompilerStack.h
rename to libsolidity/interface/CompilerStack.h
index de548bee..0473d58b 100644
--- a/libsolidity/CompilerStack.h
+++ b/libsolidity/interface/CompilerStack.h
@@ -33,7 +33,7 @@
 #include <libdevcore/FixedHash.h>
 #include <libevmasm/SourceLocation.h>
 #include <libevmasm/LinkerObject.h>
-#include <libsolidity/Exceptions.h>
+#include <libsolidity/interface/Exceptions.h>
 
 namespace dev
 {
@@ -108,6 +108,11 @@ public:
 	/// Inserts the given addresses into the linker objects of all compiled contracts.
 	void link(std::map<std::string, h160> const& _libraries);
 
+	/// Tries to translate all source files into a language suitable for formal analysis.
+	/// @returns false on error.
+	bool prepareFormalAnalysis();
+	std::string const& formalTranslation() const { return m_formalTranslation; }
+
 	/// @returns the assembled object for a contract.
 	eth::LinkerObject const& object(std::string const& _contractName = "") const;
 	/// @returns the runtime object for the contract.
@@ -167,7 +172,6 @@ public:
 	/// @returns the list of errors that occured during parsing and type checking.
 	ErrorList const& errors() const { return m_errors; }
 
-
 private:
 	/**
 	 * Information pertaining to one source unit, filled gradually during parsing and compilation.
@@ -188,13 +192,10 @@ private:
 		eth::LinkerObject object;
 		eth::LinkerObject runtimeObject;
 		eth::LinkerObject cloneObject;
-		std::shared_ptr<InterfaceHandler> interfaceHandler;
 		mutable std::unique_ptr<std::string const> interface;
 		mutable std::unique_ptr<std::string const> solidityInterface;
 		mutable std::unique_ptr<std::string const> userDocumentation;
 		mutable std::unique_ptr<std::string const> devDocumentation;
-
-		Contract();
 	};
 
 	void resolveImports();
@@ -214,6 +215,7 @@ private:
 	std::shared_ptr<GlobalContext> m_globalContext;
 	std::vector<Source const*> m_sourceOrder;
 	std::map<std::string const, Contract> m_contracts;
+	std::string m_formalTranslation;
 	ErrorList m_errors;
 };
 
diff --git a/libsolidity/Exceptions.cpp b/libsolidity/interface/Exceptions.cpp
similarity index 61%
rename from libsolidity/Exceptions.cpp
rename to libsolidity/interface/Exceptions.cpp
index 96bb2e37..465c3d2f 100644
--- a/libsolidity/Exceptions.cpp
+++ b/libsolidity/interface/Exceptions.cpp
@@ -20,8 +20,8 @@
  * Solidity exception hierarchy.
  */
 
-#include <libsolidity/Exceptions.h>
-#include <libsolidity/Utils.h>
+#include <libsolidity/interface/Exceptions.h>
+#include <libsolidity/interface/Utils.h>
 
 using namespace dev;
 using namespace dev::solidity;
@@ -30,23 +30,26 @@ Error::Error(Type _type): m_type(_type)
 {
 	switch(m_type)
 	{
-		case Type::DeclarationError:
-			m_typeName = "Declaration Error";
-			break;
-		case Type::DocstringParsingError:
-			m_typeName = "Docstring Parsing Error";
-			break;
-		case Type::ParserError:
-			m_typeName = "Parser Error";
-			break;
-		case Type::TypeError:
-			m_typeName = "Type Error";
-			break;
-		case Type::Warning:
-			m_typeName = "Warning";
-			break;
-		default:
-			solAssert(false, "");
-			break;
+	case Type::DeclarationError:
+		m_typeName = "Declaration Error";
+		break;
+	case Type::DocstringParsingError:
+		m_typeName = "Docstring Parsing Error";
+		break;
+	case Type::ParserError:
+		m_typeName = "Parser Error";
+		break;
+	case Type::TypeError:
+		m_typeName = "Type Error";
+		break;
+	case Type::Why3TranslatorError:
+		m_typeName = "Why3 Translator Error";
+		break;
+	case Type::Warning:
+		m_typeName = "Warning";
+		break;
+	default:
+		solAssert(false, "");
+		break;
 	}
 }
diff --git a/libsolidity/Exceptions.h b/libsolidity/interface/Exceptions.h
similarity index 99%
rename from libsolidity/Exceptions.h
rename to libsolidity/interface/Exceptions.h
index cda6b97e..14be3c3d 100644
--- a/libsolidity/Exceptions.h
+++ b/libsolidity/interface/Exceptions.h
@@ -47,6 +47,7 @@ public:
 		DocstringParsingError,
 		ParserError,
 		TypeError,
+		Why3TranslatorError,
 		Warning
 	};
 
diff --git a/libsolidity/GasEstimator.cpp b/libsolidity/interface/GasEstimator.cpp
similarity index 98%
rename from libsolidity/GasEstimator.cpp
rename to libsolidity/interface/GasEstimator.cpp
index d576561a..d460ba76 100644
--- a/libsolidity/GasEstimator.cpp
+++ b/libsolidity/interface/GasEstimator.cpp
@@ -28,9 +28,9 @@
 #include <libevmasm/ControlFlowGraph.h>
 #include <libevmasm/KnownState.h>
 #include <libevmasm/PathGasMeter.h>
-#include <libsolidity/AST.h>
-#include <libsolidity/ASTVisitor.h>
-#include <libsolidity/CompilerUtils.h>
+#include <libsolidity/ast/AST.h>
+#include <libsolidity/ast/ASTVisitor.h>
+#include <libsolidity/codegen/CompilerUtils.h>
 
 using namespace std;
 using namespace dev;
diff --git a/libsolidity/GasEstimator.h b/libsolidity/interface/GasEstimator.h
similarity index 98%
rename from libsolidity/GasEstimator.h
rename to libsolidity/interface/GasEstimator.h
index 4020d60b..518e58e4 100644
--- a/libsolidity/GasEstimator.h
+++ b/libsolidity/interface/GasEstimator.h
@@ -25,7 +25,6 @@
 #include <vector>
 #include <map>
 #include <array>
-#include <libsolidity/ASTForward.h>
 #include <libevmasm/GasMeter.h>
 #include <libevmasm/Assembly.h>
 
@@ -34,6 +33,9 @@ namespace dev
 namespace solidity
 {
 
+class ASTNode;
+class FunctionDefinition;
+
 struct GasEstimator
 {
 public:
diff --git a/libsolidity/interface/InterfaceHandler.cpp b/libsolidity/interface/InterfaceHandler.cpp
new file mode 100644
index 00000000..30cd9724
--- /dev/null
+++ b/libsolidity/interface/InterfaceHandler.cpp
@@ -0,0 +1,248 @@
+
+#include <libsolidity/interface/InterfaceHandler.h>
+#include <boost/range/irange.hpp>
+#include <libsolidity/ast/AST.h>
+#include <libsolidity/interface/CompilerStack.h>
+
+using namespace std;
+using namespace dev;
+using namespace dev::solidity;
+
+string InterfaceHandler::documentation(
+	ContractDefinition const& _contractDef,
+	DocumentationType _type
+)
+{
+	switch(_type)
+	{
+	case DocumentationType::NatspecUser:
+		return userDocumentation(_contractDef);
+	case DocumentationType::NatspecDev:
+		return devDocumentation(_contractDef);
+	case DocumentationType::ABIInterface:
+		return abiInterface(_contractDef);
+	case DocumentationType::ABISolidityInterface:
+		return ABISolidityInterface(_contractDef);
+	}
+
+	BOOST_THROW_EXCEPTION(InternalCompilerError() << errinfo_comment("Unknown documentation type"));
+	return "";
+}
+
+string InterfaceHandler::abiInterface(ContractDefinition const& _contractDef)
+{
+	Json::Value abi(Json::arrayValue);
+
+	auto populateParameters = [](vector<string> const& _paramNames, vector<string> const& _paramTypes)
+	{
+		Json::Value params(Json::arrayValue);
+		solAssert(_paramNames.size() == _paramTypes.size(), "Names and types vector size does not match");
+		for (unsigned i = 0; i < _paramNames.size(); ++i)
+		{
+			Json::Value param;
+			param["name"] = _paramNames[i];
+			param["type"] = _paramTypes[i];
+			params.append(param);
+		}
+		return params;
+	};
+
+	for (auto it: _contractDef.interfaceFunctions())
+	{
+		auto externalFunctionType = it.second->interfaceFunctionType();
+		Json::Value method;
+		method["type"] = "function";
+		method["name"] = it.second->declaration().name();
+		method["constant"] = it.second->isConstant();
+		method["inputs"] = populateParameters(
+			externalFunctionType->parameterNames(),
+			externalFunctionType->parameterTypeNames(_contractDef.isLibrary())
+		);
+		method["outputs"] = populateParameters(
+			externalFunctionType->returnParameterNames(),
+			externalFunctionType->returnParameterTypeNames(_contractDef.isLibrary())
+		);
+		abi.append(method);
+	}
+	if (_contractDef.constructor())
+	{
+		Json::Value method;
+		method["type"] = "constructor";
+		auto externalFunction = FunctionType(*_contractDef.constructor()).interfaceFunctionType();
+		solAssert(!!externalFunction, "");
+		method["inputs"] = populateParameters(
+			externalFunction->parameterNames(),
+			externalFunction->parameterTypeNames(_contractDef.isLibrary())
+		);
+		abi.append(method);
+	}
+
+	for (auto const& it: _contractDef.interfaceEvents())
+	{
+		Json::Value event;
+		event["type"] = "event";
+		event["name"] = it->name();
+		event["anonymous"] = it->isAnonymous();
+		Json::Value params(Json::arrayValue);
+		for (auto const& p: it->parameters())
+		{
+			Json::Value input;
+			input["name"] = p->name();
+			input["type"] = p->annotation().type->canonicalName(false);
+			input["indexed"] = p->isIndexed();
+			params.append(input);
+		}
+		event["inputs"] = params;
+		abi.append(event);
+	}
+	return Json::FastWriter().write(abi);
+}
+
+string InterfaceHandler::ABISolidityInterface(ContractDefinition const& _contractDef)
+{
+	string ret = (_contractDef.isLibrary() ? "library " : "contract ") + _contractDef.name() + "{";
+
+	auto populateParameters = [](vector<string> const& _paramNames, vector<string> const& _paramTypes)
+	{
+		string ret = "(";
+		for (size_t i = 0; i < _paramNames.size(); ++i)
+			ret += _paramTypes[i] + " " + _paramNames[i] + ",";
+		if (ret.size() != 1)
+			ret.pop_back();
+		return ret + ")";
+	};
+	// If this is a library, include all its enum and struct types. Should be more intelligent
+	// in the future and check what is actually used (it might even use types from other libraries
+	// or contracts or in the global scope).
+	if (_contractDef.isLibrary())
+	{
+		for (auto const& stru: _contractDef.definedStructs())
+		{
+			ret += "struct " + stru->name() + "{";
+			for (ASTPointer<VariableDeclaration> const& _member: stru->members())
+				ret += _member->type(nullptr)->canonicalName(false) + " " + _member->name() + ";";
+			ret += "}";
+		}
+		for (auto const& enu: _contractDef.definedEnums())
+		{
+			ret += "enum " + enu->name() + "{";
+			for (ASTPointer<EnumValue> const& val: enu->members())
+				ret += val->name() + ",";
+			if (ret.back() == ',')
+				ret.pop_back();
+			ret += "}";
+		}
+	}
+	if (_contractDef.constructor())
+	{
+		auto externalFunction = FunctionType(*_contractDef.constructor()).interfaceFunctionType();
+		solAssert(!!externalFunction, "");
+		ret +=
+			"function " +
+			_contractDef.name() +
+			populateParameters(
+				externalFunction->parameterNames(),
+				externalFunction->parameterTypeNames(_contractDef.isLibrary())
+			) +
+			";";
+	}
+	for (auto const& it: _contractDef.interfaceFunctions())
+	{
+		ret += "function " + it.second->declaration().name() +
+			populateParameters(
+				it.second->parameterNames(),
+				it.second->parameterTypeNames(_contractDef.isLibrary())
+			) + (it.second->isConstant() ? "constant " : "");
+		if (it.second->returnParameterTypes().size())
+			ret += "returns" + populateParameters(
+				it.second->returnParameterNames(),
+				it.second->returnParameterTypeNames(_contractDef.isLibrary())
+			);
+		else if (ret.back() == ' ')
+			ret.pop_back();
+		ret += ";";
+	}
+
+	return ret + "}";
+}
+
+string InterfaceHandler::userDocumentation(ContractDefinition const& _contractDef)
+{
+	Json::Value doc;
+	Json::Value methods(Json::objectValue);
+
+	for (auto const& it: _contractDef.interfaceFunctions())
+		if (it.second->hasDeclaration())
+			if (auto const* f = dynamic_cast<FunctionDefinition const*>(&it.second->declaration()))
+			{
+				string value = extractDoc(f->annotation().docTags, "notice");
+				if (!value.empty())
+				{
+					Json::Value user;
+					// since @notice is the only user tag if missing function should not appear
+					user["notice"] = Json::Value(value);
+					methods[it.second->externalSignature()] = user;
+				}
+			}
+	doc["methods"] = methods;
+
+	return Json::StyledWriter().write(doc);
+}
+
+string InterfaceHandler::devDocumentation(ContractDefinition const& _contractDef)
+{
+	Json::Value doc;
+	Json::Value methods(Json::objectValue);
+
+	auto author = extractDoc(_contractDef.annotation().docTags, "author");
+	if (!author.empty())
+		doc["author"] = author;
+	auto title = extractDoc(_contractDef.annotation().docTags, "title");
+	if (!title.empty())
+		doc["title"] = title;
+
+	for (auto const& it: _contractDef.interfaceFunctions())
+	{
+		if (!it.second->hasDeclaration())
+			continue;
+		Json::Value method;
+		if (auto fun = dynamic_cast<FunctionDefinition const*>(&it.second->declaration()))
+		{
+			auto dev = extractDoc(fun->annotation().docTags, "dev");
+			if (!dev.empty())
+				method["details"] = Json::Value(dev);
+
+			auto author = extractDoc(fun->annotation().docTags, "author");
+			if (!author.empty())
+				method["author"] = author;
+
+			auto ret = extractDoc(fun->annotation().docTags, "return");
+			if (!ret.empty())
+				method["return"] = ret;
+
+			Json::Value params(Json::objectValue);
+			auto paramRange = fun->annotation().docTags.equal_range("param");
+			for (auto i = paramRange.first; i != paramRange.second; ++i)
+				params[i->second.paramName] = Json::Value(i->second.content);
+
+			if (!params.empty())
+				method["params"] = params;
+
+			if (!method.empty())
+				// add the function, only if we have any documentation to add
+				methods[it.second->externalSignature()] = method;
+		}
+	}
+	doc["methods"] = methods;
+
+	return Json::StyledWriter().write(doc);
+}
+
+string InterfaceHandler::extractDoc(multimap<string, DocTag> const& _tags, string const& _name)
+{
+	string value;
+	auto range = _tags.equal_range(_name);
+	for (auto i = range.first; i != range.second; i++)
+		value += i->second.content;
+	return value;
+}
diff --git a/libsolidity/InterfaceHandler.h b/libsolidity/interface/InterfaceHandler.h
similarity index 62%
rename from libsolidity/InterfaceHandler.h
rename to libsolidity/interface/InterfaceHandler.h
index 62164517..30b8f520 100644
--- a/libsolidity/InterfaceHandler.h
+++ b/libsolidity/interface/InterfaceHandler.h
@@ -37,6 +37,7 @@ namespace solidity
 
 // Forward declarations
 class ContractDefinition;
+struct DocTag;
 enum class DocumentationType: uint8_t;
 
 enum class DocTagType: uint8_t
@@ -59,73 +60,33 @@ enum class CommentOwner
 class InterfaceHandler
 {
 public:
-	InterfaceHandler();
-
 	/// Get the given type of documentation
 	/// @param _contractDef The contract definition
 	/// @param _type        The type of the documentation. Can be one of the
 	///                     types provided by @c DocumentationType
 	/// @return             A string with the json representation of provided type
-	std::string documentation(
+	static std::string documentation(
 		ContractDefinition const& _contractDef,
 		DocumentationType _type
 	);
 	/// Get the ABI Interface of the contract
 	/// @param _contractDef The contract definition
 	/// @return             A string with the json representation of the contract's ABI Interface
-	std::string abiInterface(ContractDefinition const& _contractDef);
-	std::string ABISolidityInterface(ContractDefinition const& _contractDef);
+	static std::string abiInterface(ContractDefinition const& _contractDef);
+	static std::string ABISolidityInterface(ContractDefinition const& _contractDef);
 	/// Get the User documentation of the contract
 	/// @param _contractDef The contract definition
 	/// @return             A string with the json representation of the contract's user documentation
-	std::string userDocumentation(ContractDefinition const& _contractDef);
+	static std::string userDocumentation(ContractDefinition const& _contractDef);
 	/// Genereates the Developer's documentation of the contract
 	/// @param _contractDef The contract definition
 	/// @return             A string with the json representation
 	///                     of the contract's developer documentation
-	std::string devDocumentation(ContractDefinition const& _contractDef);
+	static std::string devDocumentation(ContractDefinition const& _contractDef);
 
 private:
-	void resetUser();
-	void resetDev();
-
-	std::string::const_iterator parseDocTagLine(
-		std::string::const_iterator _pos,
-		std::string::const_iterator _end,
-		std::string& _tagString,
-		DocTagType _tagType,
-		bool _appending
-	);
-	std::string::const_iterator parseDocTagParam(
-		std::string::const_iterator _pos,
-		std::string::const_iterator _end
-	);
-	std::string::const_iterator appendDocTagParam(
-		std::string::const_iterator _pos,
-		std::string::const_iterator _end
-	);
-	void parseDocString(std::string const& _string, CommentOwner _owner);
-	std::string::const_iterator appendDocTag(
-		std::string::const_iterator _pos,
-		std::string::const_iterator _end,
-		CommentOwner _owner
-	);
-	std::string::const_iterator parseDocTag(
-		std::string::const_iterator _pos,
-		std::string::const_iterator _end,
-		std::string const& _tag,
-		CommentOwner _owner
-	);
-
-	// internal state
-	DocTagType m_lastTag;
-	std::string m_notice;
-	std::string m_dev;
-	std::string m_return;
-	std::string m_contractAuthor;
-	std::string m_author;
-	std::string m_title;
-	std::vector<std::pair<std::string, std::string>> m_params;
+	/// Returns concatenation of all content under the given tag name.
+	static std::string extractDoc(std::multimap<std::string, DocTag> const& _tags, std::string const& _name);
 };
 
 } //solidity NS
diff --git a/libsolidity/SourceReferenceFormatter.cpp b/libsolidity/interface/SourceReferenceFormatter.cpp
similarity index 94%
rename from libsolidity/SourceReferenceFormatter.cpp
rename to libsolidity/interface/SourceReferenceFormatter.cpp
index 339d5b23..169e5c18 100644
--- a/libsolidity/SourceReferenceFormatter.cpp
+++ b/libsolidity/interface/SourceReferenceFormatter.cpp
@@ -20,10 +20,10 @@
  * Formatting functions for errors referencing positions and locations in the source.
  */
 
-#include <libsolidity/SourceReferenceFormatter.h>
-#include <libsolidity/CompilerStack.h>
-#include <libsolidity/Scanner.h>
-#include <libsolidity/Exceptions.h>
+#include <libsolidity/interface/SourceReferenceFormatter.h>
+#include <libsolidity/interface/CompilerStack.h>
+#include <libsolidity/parsing/Scanner.h>
+#include <libsolidity/interface/Exceptions.h>
 
 using namespace std;
 
diff --git a/libsolidity/SourceReferenceFormatter.h b/libsolidity/interface/SourceReferenceFormatter.h
similarity index 100%
rename from libsolidity/SourceReferenceFormatter.h
rename to libsolidity/interface/SourceReferenceFormatter.h
diff --git a/libsolidity/Utils.h b/libsolidity/interface/Utils.h
similarity index 95%
rename from libsolidity/Utils.h
rename to libsolidity/interface/Utils.h
index 48bb1e47..738669ac 100644
--- a/libsolidity/Utils.h
+++ b/libsolidity/interface/Utils.h
@@ -23,7 +23,7 @@
 #pragma once
 
 #include <libdevcore/Assertions.h>
-#include <libsolidity/Exceptions.h>
+#include <libsolidity/interface/Exceptions.h>
 
 namespace dev
 {
diff --git a/libsolidity/Version.cpp b/libsolidity/interface/Version.cpp
similarity index 90%
rename from libsolidity/Version.cpp
rename to libsolidity/interface/Version.cpp
index 09a6d84b..84a82dbf 100644
--- a/libsolidity/Version.cpp
+++ b/libsolidity/interface/Version.cpp
@@ -20,12 +20,12 @@
  * Versioning.
  */
 
-#include <libsolidity/Version.h>
+#include <libsolidity/interface/Version.h>
 #include <string>
 #include <libdevcore/CommonData.h>
 #include <libdevcore/Common.h>
 #include <libevmasm/Version.h>
-#include <libsolidity/Utils.h>
+#include <libsolidity/interface/Utils.h>
 #include <solidity/BuildInfo.h>
 
 using namespace dev;
@@ -65,7 +65,10 @@ bytes dev::solidity::binaryVersion()
 	solAssert(i < VersionString.size() && VersionString[i] == '-', "");
 	++i;
 	solAssert(i + 7 < VersionString.size(), "");
-	ret += fromHex(VersionString.substr(i, 8));
+	bytes commitHash = fromHex(VersionString.substr(i, 8));
+	if (commitHash.empty())
+		commitHash = bytes(4, 0);
+	ret += commitHash;
 	solAssert(ret.size() == 1 + 3 + 4, "");
 
 	return ret;
diff --git a/libsolidity/Version.h b/libsolidity/interface/Version.h
similarity index 100%
rename from libsolidity/Version.h
rename to libsolidity/interface/Version.h
diff --git a/libsolidity/parsing/DocStringParser.cpp b/libsolidity/parsing/DocStringParser.cpp
new file mode 100644
index 00000000..bbee35f5
--- /dev/null
+++ b/libsolidity/parsing/DocStringParser.cpp
@@ -0,0 +1,141 @@
+
+#include <libsolidity/parsing/DocStringParser.h>
+#include <boost/range/irange.hpp>
+#include <libsolidity/interface/Utils.h>
+
+using namespace std;
+using namespace dev;
+using namespace dev::solidity;
+
+
+static inline string::const_iterator skipLineOrEOS(
+	string::const_iterator _nlPos,
+	string::const_iterator _end
+)
+{
+	return (_nlPos == _end) ? _end : ++_nlPos;
+}
+
+static inline string::const_iterator firstSpaceOrNl(
+	string::const_iterator _pos,
+	string::const_iterator _end
+)
+{
+	auto spacePos = find(_pos, _end, ' ');
+	auto nlPos = find(_pos, _end, '\n');
+	return (spacePos < nlPos) ? spacePos : nlPos;
+}
+
+bool DocStringParser::parse(string const& _docString, ErrorList& _errors)
+{
+	m_errors = &_errors;
+	m_errorsOccurred = false;
+	m_lastTag = nullptr;
+
+	auto currPos = _docString.begin();
+	auto end = _docString.end();
+
+	while (currPos != end)
+	{
+		auto tagPos = find(currPos, end, '@');
+		auto nlPos = find(currPos, end, '\n');
+
+		if (tagPos != end && tagPos < nlPos)
+		{
+			// we found a tag
+			auto tagNameEndPos = firstSpaceOrNl(tagPos, end);
+			if (tagNameEndPos == end)
+			{
+				appendError("End of tag " + string(tagPos, tagNameEndPos) + "not found");
+				break;
+			}
+
+			currPos = parseDocTag(tagNameEndPos + 1, end, string(tagPos + 1, tagNameEndPos));
+		}
+		else if (!!m_lastTag) // continuation of the previous tag
+			currPos = appendDocTag(currPos, end);
+		else if (currPos != end)
+		{
+			// if it begins without a tag then consider it as @notice
+			if (currPos == _docString.begin())
+			{
+				currPos = parseDocTag(currPos, end, "notice");
+				continue;
+			}
+			else if (nlPos == end) //end of text
+				break;
+			// else skip the line if a newline was found and we get here
+			currPos = nlPos + 1;
+		}
+	}
+	return !m_errorsOccurred;
+}
+
+DocStringParser::iter DocStringParser::parseDocTagLine(iter _pos, iter _end, bool _appending)
+{
+	solAssert(!!m_lastTag, "");
+	auto nlPos = find(_pos, _end, '\n');
+	if (_appending && _pos < _end && *_pos != ' ')
+		m_lastTag->content += " ";
+	copy(_pos, nlPos, back_inserter(m_lastTag->content));
+	return skipLineOrEOS(nlPos, _end);
+}
+
+DocStringParser::iter DocStringParser::parseDocTagParam(iter _pos, iter _end)
+{
+	// find param name
+	auto currPos = find(_pos, _end, ' ');
+	if (currPos == _end)
+	{
+		appendError("End of param name not found" + string(_pos, _end));
+		return _end;
+	}
+
+	auto paramName = string(_pos, currPos);
+
+	currPos += 1;
+	auto nlPos = find(currPos, _end, '\n');
+	auto paramDesc = string(currPos, nlPos);
+	newTag("param");
+	m_lastTag->paramName = paramName;
+	m_lastTag->content = paramDesc;
+
+	return skipLineOrEOS(nlPos, _end);
+}
+
+DocStringParser::iter DocStringParser::parseDocTag(iter _pos, iter _end, string const& _tag)
+{
+	// LTODO: need to check for @(start of a tag) between here and the end of line
+	// for all cases.
+	if (!m_lastTag || _tag != "")
+	{
+		if (_tag == "param")
+			return parseDocTagParam(_pos, _end);
+		else
+		{
+			newTag(_tag);
+			return parseDocTagLine(_pos, _end, false);
+		}
+	}
+	else
+		return appendDocTag(_pos, _end);
+}
+
+DocStringParser::iter DocStringParser::appendDocTag(iter _pos, iter _end)
+{
+	solAssert(!!m_lastTag, "");
+	return parseDocTagLine(_pos, _end, true);
+}
+
+void DocStringParser::newTag(string const& _tagName)
+{
+	m_lastTag = &m_docTags.insert(make_pair(_tagName, DocTag()))->second;
+}
+
+void DocStringParser::appendError(string const& _description)
+{
+	auto err = make_shared<Error>(Error::Type::DocstringParsingError);
+	*err << errinfo_comment(_description);
+	m_errors->push_back(err);
+	m_errorsOccurred = true;
+}
diff --git a/libsolidity/parsing/DocStringParser.h b/libsolidity/parsing/DocStringParser.h
new file mode 100644
index 00000000..f67b8bbd
--- /dev/null
+++ b/libsolidity/parsing/DocStringParser.h
@@ -0,0 +1,70 @@
+/*
+	This file is part of cpp-ethereum.
+
+	cpp-ethereum is free software: you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
+
+	cpp-ethereum is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.
+*/
+/**
+ * @author Lefteris <lefteris@ethdev.com>
+ * @date 2014, 2015
+ * Parses a given docstring into pieces introduced by tags.
+ */
+
+#pragma once
+
+#include <string>
+#include <libsolidity/interface/Exceptions.h>
+#include <libsolidity/ast/ASTAnnotations.h>
+
+namespace dev
+{
+namespace solidity
+{
+
+class DocStringParser
+{
+public:
+	/// Parse the given @a _docString and stores the parsed components internally.
+	/// @returns false on error and appends the error to @a _errors.
+	bool parse(std::string const& _docString, ErrorList& _errors);
+
+	std::multimap<std::string, DocTag> const& tags() const { return m_docTags; }
+
+private:
+	using iter = std::string::const_iterator;
+	void resetUser();
+	void resetDev();
+
+	iter parseDocTagLine(iter _pos, iter _end, bool _appending);
+	iter parseDocTagParam(iter _pos, iter _end);
+	iter appendDocTagParam(iter _pos, iter _end);
+	void parseDocString(std::string const& _string);
+	iter appendDocTag(iter _pos, iter _end);
+	/// Parses the doc tag named @a _tag, adds it to m_docTags and returns the position
+	/// after the tag.
+	iter parseDocTag(iter _pos, iter _end, std::string const& _tag);
+
+	/// Creates and inserts a new tag and adjusts m_lastTag.
+	void newTag(std::string const& _tagName);
+
+	void appendError(std::string const& _description);
+
+	/// Mapping tag name -> content.
+	std::multimap<std::string, DocTag> m_docTags;
+	DocTag* m_lastTag = nullptr;
+	ErrorList* m_errors = nullptr;
+	bool m_errorsOccurred = false;
+};
+
+} //solidity NS
+} // dev NS
diff --git a/libsolidity/Parser.cpp b/libsolidity/parsing/Parser.cpp
similarity index 92%
rename from libsolidity/Parser.cpp
rename to libsolidity/parsing/Parser.cpp
index 4fdfd2e4..d89218bb 100644
--- a/libsolidity/Parser.cpp
+++ b/libsolidity/parsing/Parser.cpp
@@ -23,10 +23,10 @@
 #include <vector>
 #include <libdevcore/Log.h>
 #include <libevmasm/SourceLocation.h>
-#include <libsolidity/Parser.h>
-#include <libsolidity/Scanner.h>
-#include <libsolidity/Exceptions.h>
-#include <libsolidity/InterfaceHandler.h>
+#include <libsolidity/parsing/Parser.h>
+#include <libsolidity/parsing/Scanner.h>
+#include <libsolidity/interface/Exceptions.h>
+#include <libsolidity/interface/InterfaceHandler.h>
 
 using namespace std;
 
@@ -600,7 +600,7 @@ ASTPointer<ParameterList> Parser::parseParameterList(
 	return nodeFactory.createNode<ParameterList>(parameters);
 }
 
-ASTPointer<Block> Parser::parseBlock()
+ASTPointer<Block> Parser::parseBlock(ASTPointer<ASTString> const& _docString)
 {
 	ASTNodeFactory nodeFactory(*this);
 	expectToken(Token::LBrace);
@@ -609,29 +609,32 @@ ASTPointer<Block> Parser::parseBlock()
 		statements.push_back(parseStatement());
 	nodeFactory.markEndPosition();
 	expectToken(Token::RBrace);
-	return nodeFactory.createNode<Block>(statements);
+	return nodeFactory.createNode<Block>(_docString, statements);
 }
 
 ASTPointer<Statement> Parser::parseStatement()
 {
+	ASTPointer<ASTString> docString;
+	if (m_scanner->currentCommentLiteral() != "")
+		docString = make_shared<ASTString>(m_scanner->currentCommentLiteral());
 	ASTPointer<Statement> statement;
 	switch (m_scanner->currentToken())
 	{
 	case Token::If:
-		return parseIfStatement();
+		return parseIfStatement(docString);
 	case Token::While:
-		return parseWhileStatement();
+		return parseWhileStatement(docString);
 	case Token::For:
-		return parseForStatement();
+		return parseForStatement(docString);
 	case Token::LBrace:
-		return parseBlock();
+		return parseBlock(docString);
 		// starting from here, all statements must be terminated by a semicolon
 	case Token::Continue:
-		statement = ASTNodeFactory(*this).createNode<Continue>();
+		statement = ASTNodeFactory(*this).createNode<Continue>(docString);
 		m_scanner->next();
 		break;
 	case Token::Break:
-		statement = ASTNodeFactory(*this).createNode<Break>();
+		statement = ASTNodeFactory(*this).createNode<Break>(docString);
 		m_scanner->next();
 		break;
 	case Token::Return:
@@ -643,31 +646,31 @@ ASTPointer<Statement> Parser::parseStatement()
 			expression = parseExpression();
 			nodeFactory.setEndPositionFromNode(expression);
 		}
-		statement = nodeFactory.createNode<Return>(expression);
+		statement = nodeFactory.createNode<Return>(docString, expression);
 		break;
 	}
 	case Token::Throw:
 	{
-		statement = ASTNodeFactory(*this).createNode<Throw>();
+		statement = ASTNodeFactory(*this).createNode<Throw>(docString);
 		m_scanner->next();
 		break;
 	}
 	case Token::Identifier:
 		if (m_insideModifier && m_scanner->currentLiteral() == "_")
 		{
-			statement = ASTNodeFactory(*this).createNode<PlaceholderStatement>();
+			statement = ASTNodeFactory(*this).createNode<PlaceholderStatement>(docString);
 			m_scanner->next();
 			return statement;
 		}
 	// fall-through
 	default:
-		statement = parseSimpleStatement();
+		statement = parseSimpleStatement(docString);
 	}
 	expectToken(Token::Semicolon);
 	return statement;
 }
 
-ASTPointer<IfStatement> Parser::parseIfStatement()
+ASTPointer<IfStatement> Parser::parseIfStatement(ASTPointer<ASTString> const& _docString)
 {
 	ASTNodeFactory nodeFactory(*this);
 	expectToken(Token::If);
@@ -684,10 +687,10 @@ ASTPointer<IfStatement> Parser::parseIfStatement()
 	}
 	else
 		nodeFactory.setEndPositionFromNode(trueBody);
-	return nodeFactory.createNode<IfStatement>(condition, trueBody, falseBody);
+	return nodeFactory.createNode<IfStatement>(_docString, condition, trueBody, falseBody);
 }
 
-ASTPointer<WhileStatement> Parser::parseWhileStatement()
+ASTPointer<WhileStatement> Parser::parseWhileStatement(ASTPointer<ASTString> const& _docString)
 {
 	ASTNodeFactory nodeFactory(*this);
 	expectToken(Token::While);
@@ -696,10 +699,10 @@ ASTPointer<WhileStatement> Parser::parseWhileStatement()
 	expectToken(Token::RParen);
 	ASTPointer<Statement> body = parseStatement();
 	nodeFactory.setEndPositionFromNode(body);
-	return nodeFactory.createNode<WhileStatement>(condition, body);
+	return nodeFactory.createNode<WhileStatement>(_docString, condition, body);
 }
 
-ASTPointer<ForStatement> Parser::parseForStatement()
+ASTPointer<ForStatement> Parser::parseForStatement(ASTPointer<ASTString> const& _docString)
 {
 	ASTNodeFactory nodeFactory(*this);
 	ASTPointer<Statement> initExpression;
@@ -710,7 +713,7 @@ ASTPointer<ForStatement> Parser::parseForStatement()
 
 	// LTODO: Maybe here have some predicate like peekExpression() instead of checking for semicolon and RParen?
 	if (m_scanner->currentToken() != Token::Semicolon)
-		initExpression = parseSimpleStatement();
+		initExpression = parseSimpleStatement(ASTPointer<ASTString>());
 	expectToken(Token::Semicolon);
 
 	if (m_scanner->currentToken() != Token::Semicolon)
@@ -718,18 +721,21 @@ ASTPointer<ForStatement> Parser::parseForStatement()
 	expectToken(Token::Semicolon);
 
 	if (m_scanner->currentToken() != Token::RParen)
-		loopExpression = parseExpressionStatement();
+		loopExpression = parseExpressionStatement(ASTPointer<ASTString>());
 	expectToken(Token::RParen);
 
 	ASTPointer<Statement> body = parseStatement();
 	nodeFactory.setEndPositionFromNode(body);
-	return nodeFactory.createNode<ForStatement>(initExpression,
-												conditionExpression,
-												loopExpression,
-												body);
+	return nodeFactory.createNode<ForStatement>(
+		_docString,
+		initExpression,
+		conditionExpression,
+		loopExpression,
+		body
+	);
 }
 
-ASTPointer<Statement> Parser::parseSimpleStatement()
+ASTPointer<Statement> Parser::parseSimpleStatement(ASTPointer<ASTString> const& _docString)
 {
 	// These two cases are very hard to distinguish:
 	// x[7 * 20 + 3] a;  -  x[7 * 20 + 3] = 9;
@@ -740,9 +746,9 @@ ASTPointer<Statement> Parser::parseSimpleStatement()
 	switch (peekStatementType())
 	{
 	case LookAheadInfo::VariableDeclarationStatement:
-		return parseVariableDeclarationStatement();
+		return parseVariableDeclarationStatement(_docString);
 	case LookAheadInfo::ExpressionStatement:
-		return parseExpressionStatement();
+		return parseExpressionStatement(_docString);
 	default:
 		break;
 	}
@@ -781,12 +787,13 @@ ASTPointer<Statement> Parser::parseSimpleStatement()
 	}
 
 	if (m_scanner->currentToken() == Token::Identifier || Token::isLocationSpecifier(m_scanner->currentToken()))
-		return parseVariableDeclarationStatement(typeNameIndexAccessStructure(path, indices));
+		return parseVariableDeclarationStatement(_docString, typeNameIndexAccessStructure(path, indices));
 	else
-		return parseExpressionStatement(expressionFromIndexAccessStructure(path, indices));
+		return parseExpressionStatement(_docString, expressionFromIndexAccessStructure(path, indices));
 }
 
 ASTPointer<VariableDeclarationStatement> Parser::parseVariableDeclarationStatement(
+	ASTPointer<ASTString> const& _docString,
 	ASTPointer<TypeName> const& _lookAheadArrayType
 )
 {
@@ -845,15 +852,16 @@ ASTPointer<VariableDeclarationStatement> Parser::parseVariableDeclarationStateme
 		value = parseExpression();
 		nodeFactory.setEndPositionFromNode(value);
 	}
-	return nodeFactory.createNode<VariableDeclarationStatement>(variables, value);
+	return nodeFactory.createNode<VariableDeclarationStatement>(_docString, variables, value);
 }
 
 ASTPointer<ExpressionStatement> Parser::parseExpressionStatement(
+	ASTPointer<ASTString> const& _docString,
 	ASTPointer<Expression> const& _lookAheadIndexAccessStructure
 )
 {
 	ASTPointer<Expression> expression = parseExpression(_lookAheadIndexAccessStructure);
-	return ASTNodeFactory(*this, expression).createNode<ExpressionStatement>(expression);
+	return ASTNodeFactory(*this, expression).createNode<ExpressionStatement>(_docString, expression);
 }
 
 ASTPointer<Expression> Parser::parseExpression(
@@ -1180,7 +1188,13 @@ ASTPointer<Expression> Parser::expressionFromIndexAccessStructure(
 void Parser::expectToken(Token::Value _value)
 {
 	if (m_scanner->currentToken() != _value)
-		fatalParserError(std::string(string("Expected token ") + string(Token::name(_value))));
+		fatalParserError(
+			string("Expected token ") +
+			string(Token::name(_value)) +
+			string(" got '") +
+			string(Token::name(m_scanner->currentToken())) +
+			string("'")
+		);
 	m_scanner->next();
 }
 
@@ -1188,7 +1202,12 @@ Token::Value Parser::expectAssignmentOperator()
 {
 	Token::Value op = m_scanner->currentToken();
 	if (!Token::isAssignmentOp(op))
-		fatalParserError(std::string("Expected assignment operator"));
+		fatalParserError(
+			std::string("Expected assignment operator ") +
+			string(" got '") +
+			string(Token::name(m_scanner->currentToken())) +
+			string("'")
+		);
 	m_scanner->next();
 	return op;
 }
@@ -1196,7 +1215,12 @@ Token::Value Parser::expectAssignmentOperator()
 ASTPointer<ASTString> Parser::expectIdentifierToken()
 {
 	if (m_scanner->currentToken() != Token::Identifier)
-		fatalParserError(std::string("Expected identifier"));
+		fatalParserError(
+			std::string("Expected identifier ") +
+			string(" got '") +
+			string(Token::name(m_scanner->currentToken())) +
+			string("'")
+		);
 	return getLiteralAndAdvance();
 }
 
diff --git a/libsolidity/Parser.h b/libsolidity/parsing/Parser.h
similarity index 91%
rename from libsolidity/Parser.h
rename to libsolidity/parsing/Parser.h
index bd483e09..663c0f92 100644
--- a/libsolidity/Parser.h
+++ b/libsolidity/parsing/Parser.h
@@ -22,7 +22,7 @@
 
 #pragma once
 
-#include "libsolidity/AST.h"
+#include "libsolidity/ast/AST.h"
 
 namespace dev
 {
@@ -82,17 +82,19 @@ private:
 		VarDeclParserOptions const& _options,
 		bool _allowEmpty = true
 	);
-	ASTPointer<Block> parseBlock();
+	ASTPointer<Block> parseBlock(ASTPointer<ASTString> const& _docString = {});
 	ASTPointer<Statement> parseStatement();
-	ASTPointer<IfStatement> parseIfStatement();
-	ASTPointer<WhileStatement> parseWhileStatement();
-	ASTPointer<ForStatement> parseForStatement();
+	ASTPointer<IfStatement> parseIfStatement(ASTPointer<ASTString> const& _docString);
+	ASTPointer<WhileStatement> parseWhileStatement(ASTPointer<ASTString> const& _docString);
+	ASTPointer<ForStatement> parseForStatement(ASTPointer<ASTString> const& _docString);
 	/// A "simple statement" can be a variable declaration statement or an expression statement.
-	ASTPointer<Statement> parseSimpleStatement();
+	ASTPointer<Statement> parseSimpleStatement(ASTPointer<ASTString> const& _docString);
 	ASTPointer<VariableDeclarationStatement> parseVariableDeclarationStatement(
+		ASTPointer<ASTString> const& _docString,
 		ASTPointer<TypeName> const& _lookAheadArrayType = ASTPointer<TypeName>()
 	);
 	ASTPointer<ExpressionStatement> parseExpressionStatement(
+		ASTPointer<ASTString> const& _docString,
 		ASTPointer<Expression> const& _lookAheadIndexAccessStructure = ASTPointer<Expression>()
 	);
 	ASTPointer<Expression> parseExpression(
diff --git a/libsolidity/Scanner.cpp b/libsolidity/parsing/Scanner.cpp
similarity index 99%
rename from libsolidity/Scanner.cpp
rename to libsolidity/parsing/Scanner.cpp
index d67b6423..fe0807d5 100644
--- a/libsolidity/Scanner.cpp
+++ b/libsolidity/parsing/Scanner.cpp
@@ -52,8 +52,8 @@
 
 #include <algorithm>
 #include <tuple>
-#include <libsolidity/Utils.h>
-#include <libsolidity/Scanner.h>
+#include <libsolidity/interface/Utils.h>
+#include <libsolidity/parsing/Scanner.h>
 
 using namespace std;
 
diff --git a/libsolidity/Scanner.h b/libsolidity/parsing/Scanner.h
similarity index 99%
rename from libsolidity/Scanner.h
rename to libsolidity/parsing/Scanner.h
index 29b44d15..a1a5c9c1 100644
--- a/libsolidity/Scanner.h
+++ b/libsolidity/parsing/Scanner.h
@@ -56,7 +56,7 @@
 #include <libdevcore/Log.h>
 #include <libdevcore/CommonData.h>
 #include <libevmasm/SourceLocation.h>
-#include <libsolidity/Token.h>
+#include <libsolidity/parsing/Token.h>
 
 namespace dev
 {
diff --git a/libsolidity/Token.cpp b/libsolidity/parsing/Token.cpp
similarity index 98%
rename from libsolidity/Token.cpp
rename to libsolidity/parsing/Token.cpp
index d07d7502..cda639fb 100644
--- a/libsolidity/Token.cpp
+++ b/libsolidity/parsing/Token.cpp
@@ -41,7 +41,7 @@
 // along with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <map>
-#include <libsolidity/Token.h>
+#include <libsolidity/parsing/Token.h>
 
 using namespace std;
 
diff --git a/libsolidity/Token.h b/libsolidity/parsing/Token.h
similarity index 99%
rename from libsolidity/Token.h
rename to libsolidity/parsing/Token.h
index 2ea7eb01..98461fa4 100644
--- a/libsolidity/Token.h
+++ b/libsolidity/parsing/Token.h
@@ -44,8 +44,8 @@
 
 #include <libdevcore/Common.h>
 #include <libdevcore/Log.h>
-#include <libsolidity/Utils.h>
-#include <libsolidity/Exceptions.h>
+#include <libsolidity/interface/Utils.h>
+#include <libsolidity/interface/Exceptions.h>
 #include <libdevcore/UndefMacros.h>
 
 namespace dev
diff --git a/solc/CommandLineInterface.cpp b/solc/CommandLineInterface.cpp
index deae5928..b4121574 100644
--- a/solc/CommandLineInterface.cpp
+++ b/solc/CommandLineInterface.cpp
@@ -35,16 +35,17 @@
 #include <libdevcore/CommonIO.h>
 #include <libevmcore/Instruction.h>
 #include <libevmcore/Params.h>
-#include <libsolidity/Version.h>
-#include <libsolidity/Scanner.h>
-#include <libsolidity/Parser.h>
-#include <libsolidity/ASTPrinter.h>
-#include <libsolidity/ASTJsonConverter.h>
-#include <libsolidity/NameAndTypeResolver.h>
-#include <libsolidity/Exceptions.h>
-#include <libsolidity/CompilerStack.h>
-#include <libsolidity/SourceReferenceFormatter.h>
-#include <libsolidity/GasEstimator.h>
+#include <libsolidity/interface/Version.h>
+#include <libsolidity/parsing/Scanner.h>
+#include <libsolidity/parsing/Parser.h>
+#include <libsolidity/ast/ASTPrinter.h>
+#include <libsolidity/ast/ASTJsonConverter.h>
+#include <libsolidity/analysis/NameAndTypeResolver.h>
+#include <libsolidity/interface/Exceptions.h>
+#include <libsolidity/interface/CompilerStack.h>
+#include <libsolidity/interface/SourceReferenceFormatter.h>
+#include <libsolidity/interface/GasEstimator.h>
+#include <libsolidity/formal/Why3Translator.h>
 
 using namespace std;
 namespace po = boost::program_options;
@@ -96,28 +97,30 @@ static void version()
 	exit(0);
 }
 
-static inline bool humanTargetedStdout(po::variables_map const& _args, string const& _name)
-{
-	return _args.count(_name) && !(_args.count("output-dir"));
-}
-
 static bool needsHumanTargetedStdout(po::variables_map const& _args)
 {
-
-	return
-		_args.count(g_argGas) ||
-		humanTargetedStdout(_args, g_argAbiStr) ||
-		humanTargetedStdout(_args, g_argSolInterfaceStr) ||
-		humanTargetedStdout(_args, g_argSignatureHashes) ||
-		humanTargetedStdout(_args, g_argNatspecUserStr) ||
-		humanTargetedStdout(_args, g_argAstJson) ||
-		humanTargetedStdout(_args, g_argNatspecDevStr) ||
-		humanTargetedStdout(_args, g_argAsmStr) ||
-		humanTargetedStdout(_args, g_argAsmJsonStr) ||
-		humanTargetedStdout(_args, g_argOpcodesStr) ||
-		humanTargetedStdout(_args, g_argBinaryStr) ||
-		humanTargetedStdout(_args, g_argRuntimeBinaryStr) ||
-		humanTargetedStdout(_args, g_argCloneBinaryStr);
+	if (_args.count(g_argGas))
+		return true;
+	if (_args.count("output-dir"))
+		return false;
+	for (string const& arg: {
+		g_argAbiStr,
+		g_argSolInterfaceStr,
+		g_argSignatureHashes,
+		g_argNatspecUserStr,
+		g_argAstJson,
+		g_argNatspecDevStr,
+		g_argAsmStr,
+		g_argAsmJsonStr,
+		g_argOpcodesStr,
+		g_argBinaryStr,
+		g_argRuntimeBinaryStr,
+		g_argCloneBinaryStr,
+		string("formal")
+	})
+		if (_args.count(arg))
+			return true;
+	return false;
 }
 
 void CommandLineInterface::handleBinary(string const& _contract)
@@ -164,7 +167,6 @@ void CommandLineInterface::handleOpcode(string const& _contract)
 		cout << eth::disassemble(m_compiler->object(_contract).bytecode);
 		cout << endl;
 	}
-
 }
 
 void CommandLineInterface::handleBytecode(string const& _contract)
@@ -284,6 +286,17 @@ void CommandLineInterface::handleGasEstimation(string const& _contract)
 	}
 }
 
+void CommandLineInterface::handleFormal()
+{
+	if (!m_args.count("formal"))
+		return;
+
+	if (m_args.count("output-dir"))
+		createFile("solidity.mlw", m_compiler->formalTranslation());
+	else
+		cout << "Formal version:" << endl << m_compiler->formalTranslation() << endl;
+}
+
 bool CommandLineInterface::parseLibraryOption(string const& _input)
 {
 	namespace fs = boost::filesystem;
@@ -391,7 +404,8 @@ Allowed options)",
 		(g_argSolInterfaceStr.c_str(), "Solidity interface of the contracts.")
 		(g_argSignatureHashes.c_str(), "Function signature hashes of the contracts.")
 		(g_argNatspecUserStr.c_str(), "Natspec user documentation of all contracts.")
-		(g_argNatspecDevStr.c_str(), "Natspec developer documentation of all contracts.");
+		(g_argNatspecDevStr.c_str(), "Natspec developer documentation of all contracts.")
+		("formal", "Translated source suitable for formal analysis.");
 	desc.add(outputComponents);
 
 	po::options_description allOptions = desc;
@@ -492,15 +506,22 @@ bool CommandLineInterface::processInput()
 		bool optimize = m_args.count("optimize") > 0;
 		unsigned runs = m_args["optimize-runs"].as<unsigned>();
 		bool successful = m_compiler->compile(optimize, runs);
+		if (successful)
+			m_compiler->link(m_libraries);
+
+		if (successful && m_args.count("formal"))
+			if (!m_compiler->prepareFormalAnalysis())
+				successful = false;
+
 		for (auto const& error: m_compiler->errors())
 			SourceReferenceFormatter::printExceptionInformation(
 				cerr,
 				*error,
 				(error->type() == Error::Type::Warning) ? "Warning" : "Error", *m_compiler
 			);
+
 		if (!successful)
 			return false;
-		m_compiler->link(m_libraries);
 	}
 	catch (CompilerError const& _exception)
 	{
@@ -755,6 +776,8 @@ void CommandLineInterface::outputCompilationResults()
 		handleMeta(DocumentationType::NatspecDev, contract);
 		handleMeta(DocumentationType::NatspecUser, contract);
 	} // end of contracts iteration
+
+	handleFormal();
 }
 
 }
diff --git a/solc/CommandLineInterface.h b/solc/CommandLineInterface.h
index 2af5a5e9..7c7aa4b4 100644
--- a/solc/CommandLineInterface.h
+++ b/solc/CommandLineInterface.h
@@ -21,7 +21,7 @@
  */
 #pragma once
 
-#include <libsolidity/CompilerStack.h>
+#include <libsolidity/interface/CompilerStack.h>
 #include <memory>
 #include <boost/program_options.hpp>
 
@@ -57,9 +57,9 @@ private:
 	void handleOpcode(std::string const& _contract);
 	void handleBytecode(std::string const& _contract);
 	void handleSignatureHashes(std::string const& _contract);
-	void handleMeta(DocumentationType _type,
-					std::string const& _contract);
+	void handleMeta(DocumentationType _type, std::string const& _contract);
 	void handleGasEstimation(std::string const& _contract);
+	void handleFormal();
 
 	/// Tries to read from the file @a _input or interprets _input literally if that fails.
 	/// It then tries to parse the contents and appends to m_libraries.
diff --git a/solc/jsonCompiler.cpp b/solc/jsonCompiler.cpp
index 1690fadb..43164807 100644
--- a/solc/jsonCompiler.cpp
+++ b/solc/jsonCompiler.cpp
@@ -28,15 +28,15 @@
 #include <libdevcore/CommonIO.h>
 #include <libevmcore/Instruction.h>
 #include <libevmcore/Params.h>
-#include <libsolidity/Scanner.h>
-#include <libsolidity/Parser.h>
-#include <libsolidity/ASTPrinter.h>
-#include <libsolidity/NameAndTypeResolver.h>
-#include <libsolidity/Exceptions.h>
-#include <libsolidity/CompilerStack.h>
-#include <libsolidity/SourceReferenceFormatter.h>
-#include <libsolidity/ASTJsonConverter.h>
-#include <libsolidity/Version.h>
+#include <libsolidity/parsing/Scanner.h>
+#include <libsolidity/parsing/Parser.h>
+#include <libsolidity/ast/ASTPrinter.h>
+#include <libsolidity/analysis/NameAndTypeResolver.h>
+#include <libsolidity/interface/Exceptions.h>
+#include <libsolidity/interface/CompilerStack.h>
+#include <libsolidity/interface/SourceReferenceFormatter.h>
+#include <libsolidity/ast/ASTJsonConverter.h>
+#include <libsolidity/interface/Version.h>
 
 using namespace std;
 using namespace dev;
diff --git a/test/TestHelper.h b/test/TestHelper.h
index 0bf62224..96678007 100644
--- a/test/TestHelper.h
+++ b/test/TestHelper.h
@@ -24,15 +24,31 @@
 #include <functional>
 #include <boost/test/unit_test.hpp>
 #include <boost/filesystem.hpp>
+#include <boost/version.hpp>
 
 namespace dev
 {
 namespace test
 {
 
+#if (BOOST_VERSION >= 105900)
+#define ETH_BOOST_CHECK_IMPL(_message, _requireOrCheck) BOOST_TEST_TOOL_DIRECT_IMPL( \
+		false,															\
+		_requireOrCheck,												\
+		_message														\
+	)
+#else
+#define ETH_BOOST_CHECK_IMPL(_message, _requireOrCheck) BOOST_CHECK_IMPL( \
+		false,															\
+		_message,														\
+		_requireOrCheck,												\
+		CHECK_MSG														\
+	)
+#endif
+
 /// Make sure that no Exception is thrown during testing. If one is thrown show its info and fail the test.
 /// Our version of BOOST_REQUIRE_NO_THROW()
-/// @param _statenent    The statement for which to make sure no exceptions are thrown
+/// @param _statement     The statement for which to make sure no exceptions are thrown
 /// @param _message       A message to act as a prefix to the expression's error information
 #define ETH_TEST_REQUIRE_NO_THROW(_statement, _message)				\
 	do																	\
@@ -46,12 +62,14 @@ namespace test
 		{																\
 			auto msg = std::string(_message " due to an exception thrown by " \
 				BOOST_STRINGIZE(_statement) "\n") + boost::diagnostic_information(_e); \
-			BOOST_CHECK_IMPL(false, msg, REQUIRE, CHECK_MSG);			\
+			ETH_BOOST_CHECK_IMPL(msg, REQUIRE);							\
 		}																\
 		catch (...)														\
 		{																\
-			BOOST_CHECK_IMPL(false, "Unknown exception thrown by "		\
-				BOOST_STRINGIZE(_statement), REQUIRE, CHECK_MSG);		\
+			ETH_BOOST_CHECK_IMPL(										\
+				"Unknown exception thrown by " BOOST_STRINGIZE(_statement),	\
+				REQUIRE													\
+			);															\
 		}																\
 	}																	\
 	while (0)
@@ -72,12 +90,14 @@ namespace test
 		{																\
 			auto msg = std::string(_message " due to an exception thrown by " \
 				BOOST_STRINGIZE(_statement) "\n") + boost::diagnostic_information(_e); \
-			BOOST_CHECK_IMPL(false, msg, CHECK, CHECK_MSG);				\
+			ETH_BOOST_CHECK_IMPL(msg, CHECK);							\
 		}																\
 		catch (...)														\
 		{																\
-			BOOST_CHECK_IMPL(false, "Unknown exception thrown by "		\
-				BOOST_STRINGIZE(_statement), CHECK, CHECK_MSG );		\
+			ETH_BOOST_CHECK_IMPL(										\
+				"Unknown exception thrown by " BOOST_STRINGIZE(_statement),	\
+				CHECK													\
+			);															\
 		}																\
 	}																	\
 	while (0)
diff --git a/test/libsolidity/Assembly.cpp b/test/libsolidity/Assembly.cpp
index f69ae680..13665a33 100644
--- a/test/libsolidity/Assembly.cpp
+++ b/test/libsolidity/Assembly.cpp
@@ -26,12 +26,12 @@
 #include <libdevcore/Log.h>
 #include <libevmasm/SourceLocation.h>
 #include <libevmasm/Assembly.h>
-#include <libsolidity/Scanner.h>
-#include <libsolidity/Parser.h>
-#include <libsolidity/NameAndTypeResolver.h>
-#include <libsolidity/Compiler.h>
-#include <libsolidity/AST.h>
-#include <libsolidity/TypeChecker.h>
+#include <libsolidity/parsing/Scanner.h>
+#include <libsolidity/parsing/Parser.h>
+#include <libsolidity/analysis/NameAndTypeResolver.h>
+#include <libsolidity/codegen/Compiler.h>
+#include <libsolidity/ast/AST.h>
+#include <libsolidity/analysis/TypeChecker.h>
 
 using namespace std;
 using namespace dev::eth;
diff --git a/test/libsolidity/GasMeter.cpp b/test/libsolidity/GasMeter.cpp
index 6d7c06a3..b5cee01e 100644
--- a/test/libsolidity/GasMeter.cpp
+++ b/test/libsolidity/GasMeter.cpp
@@ -24,9 +24,9 @@
 #include <libevmasm/GasMeter.h>
 #include <libevmasm/KnownState.h>
 #include <libevmasm/PathGasMeter.h>
-#include <libsolidity/AST.h>
-#include <libsolidity/GasEstimator.h>
-#include <libsolidity/SourceReferenceFormatter.h>
+#include <libsolidity/ast/AST.h>
+#include <libsolidity/interface/GasEstimator.h>
+#include <libsolidity/interface/SourceReferenceFormatter.h>
 
 using namespace std;
 using namespace dev::eth;
diff --git a/test/libsolidity/SolidityABIJSON.cpp b/test/libsolidity/SolidityABIJSON.cpp
index 68f5a64a..77b39978 100644
--- a/test/libsolidity/SolidityABIJSON.cpp
+++ b/test/libsolidity/SolidityABIJSON.cpp
@@ -21,7 +21,7 @@
  */
 
 #include "../TestHelper.h"
-#include <libsolidity/CompilerStack.h>
+#include <libsolidity/interface/CompilerStack.h>
 #include <json/json.h>
 #include <libdevcore/Exceptions.h>
 
diff --git a/test/libsolidity/SolidityEndToEndTest.cpp b/test/libsolidity/SolidityEndToEndTest.cpp
index 27c511f2..81543356 100644
--- a/test/libsolidity/SolidityEndToEndTest.cpp
+++ b/test/libsolidity/SolidityEndToEndTest.cpp
@@ -25,7 +25,7 @@
 #include <tuple>
 #include <boost/test/unit_test.hpp>
 #include <libdevcore/Hash.h>
-#include <libsolidity/Exceptions.h>
+#include <libsolidity/interface/Exceptions.h>
 #include <test/libsolidity/solidityExecutionFramework.h>
 
 using namespace std;
@@ -2484,6 +2484,41 @@ BOOST_AUTO_TEST_CASE(event_really_lots_of_data_from_storage)
 	BOOST_CHECK_EQUAL(m_logs[0].topics[0], dev::sha3(string("Deposit(uint256,bytes,uint256)")));
 }
 
+BOOST_AUTO_TEST_CASE(event_indexed_string)
+{
+	char const* sourceCode = R"(
+		contract C {
+			string x;
+			uint[4] y;
+			event E(string indexed r, uint[4] indexed t);
+			function deposit() {
+				bytes(x).length = 90;
+				for (uint i = 0; i < 90; i++)
+					bytes(x)[i] = byte(i);
+				y[0] = 4;
+				y[1] = 5;
+				y[2] = 6;
+				y[3] = 7;
+				E(x, y);
+			}
+		}
+	)";
+	compileAndRun(sourceCode);
+	callContractFunction("deposit()");
+	BOOST_REQUIRE_EQUAL(m_logs.size(), 1);
+	BOOST_CHECK_EQUAL(m_logs[0].address, m_contractAddress);
+	string dynx(90, 0);
+	for (size_t i = 0; i < dynx.size(); ++i)
+		dynx[i] = i;
+	BOOST_CHECK(m_logs[0].data == bytes());
+	BOOST_REQUIRE_EQUAL(m_logs[0].topics.size(), 3);
+	BOOST_CHECK_EQUAL(m_logs[0].topics[1], dev::sha3(dynx));
+	BOOST_CHECK_EQUAL(m_logs[0].topics[2], dev::sha3(
+		encodeArgs(u256(4), u256(5), u256(6), u256(7))
+	));
+	BOOST_CHECK_EQUAL(m_logs[0].topics[0], dev::sha3(string("E(string,uint256[4])")));
+}
+
 BOOST_AUTO_TEST_CASE(empty_name_input_parameter_with_named_one)
 {
 	char const* sourceCode = R"(
@@ -4735,32 +4770,6 @@ BOOST_AUTO_TEST_CASE(bytes_memory_index_access)
 	) == encodeArgs(u256(data.size()), string("d")));
 }
 
-BOOST_AUTO_TEST_CASE(dev_title_at_function_error)
-{
-	char const* sourceCode = " /// @author Lefteris\n"
-	" /// @title Just a test contract\n"
-	"contract test {\n"
-	"  /// @dev Mul function\n"
-	"  /// @title I really should not be here\n"
-	"  function mul(uint a, uint second) returns(uint d) { return a * 7 + second; }\n"
-	"}\n";
-
-	compileRequireError(sourceCode, Error::Type::DocstringParsingError);
-}
-
-BOOST_AUTO_TEST_CASE(dev_documenting_nonexistant_param)
-{
-	char const* sourceCode = "contract test {\n"
-	"  /// @dev Multiplies a number by 7 and adds second parameter\n"
-	"  /// @param a Documentation for the first parameter\n"
-	"  /// @param not_existing Documentation for the second parameter\n"
-	"  function mul(uint a, uint second) returns(uint d) { return a * 7 + second; }\n"
-	"}\n";
-
-	compileRequireError(sourceCode, Error::Type::DocstringParsingError);
-}
-
-
 BOOST_AUTO_TEST_CASE(storage_array_ref)
 {
 	char const* sourceCode = R"(
@@ -5708,6 +5717,26 @@ BOOST_AUTO_TEST_CASE(tuples)
 	BOOST_CHECK(callContractFunction("f()") == encodeArgs(u256(0)));
 }
 
+BOOST_AUTO_TEST_CASE(string_tuples)
+{
+	char const* sourceCode = R"(
+		contract C {
+			function f() returns (string, uint) {
+				return ("abc", 8);
+			}
+			function g() returns (string, string) {
+				return (h(), "def");
+			}
+			function h() returns (string) {
+				return ("abc",);
+			}
+		}
+	)";
+	compileAndRun(sourceCode);
+	BOOST_CHECK(callContractFunction("f()") == encodeArgs(u256(0x40), u256(8), u256(3), string("abc")));
+	BOOST_CHECK(callContractFunction("g()") == encodeArgs(u256(0x40), u256(0x80), u256(3), string("abc"), u256(3), string("def")));
+}
+
 BOOST_AUTO_TEST_CASE(destructuring_assignment)
 {
 	char const* sourceCode = R"(
@@ -5787,6 +5816,21 @@ BOOST_AUTO_TEST_CASE(lone_struct_array_type)
 	BOOST_CHECK(callContractFunction("f()") == encodeArgs(u256(3)));
 }
 
+BOOST_AUTO_TEST_CASE(memory_overwrite)
+{
+	char const* sourceCode = R"(
+		contract C {
+			function f() returns (bytes x) {
+				x = "12345";
+				x[3] = 0x61;
+				x[0] = 0x62;
+			}
+		}
+	)";
+	compileAndRun(sourceCode);
+	BOOST_CHECK(callContractFunction("f()") == encodeDyn(string("b23a5")));
+}
+
 BOOST_AUTO_TEST_SUITE_END()
 
 }
diff --git a/test/libsolidity/SolidityExpressionCompiler.cpp b/test/libsolidity/SolidityExpressionCompiler.cpp
index 4013581d..a622c738 100644
--- a/test/libsolidity/SolidityExpressionCompiler.cpp
+++ b/test/libsolidity/SolidityExpressionCompiler.cpp
@@ -23,13 +23,13 @@
 #include <string>
 
 #include <libdevcore/Log.h>
-#include <libsolidity/Scanner.h>
-#include <libsolidity/Parser.h>
-#include <libsolidity/NameAndTypeResolver.h>
-#include <libsolidity/CompilerContext.h>
-#include <libsolidity/ExpressionCompiler.h>
-#include <libsolidity/AST.h>
-#include <libsolidity/TypeChecker.h>
+#include <libsolidity/parsing/Scanner.h>
+#include <libsolidity/parsing/Parser.h>
+#include <libsolidity/analysis/NameAndTypeResolver.h>
+#include <libsolidity/codegen/CompilerContext.h>
+#include <libsolidity/codegen/ExpressionCompiler.h>
+#include <libsolidity/ast/AST.h>
+#include <libsolidity/analysis/TypeChecker.h>
 #include "../TestHelper.h"
 
 using namespace std;
diff --git a/test/libsolidity/SolidityInterface.cpp b/test/libsolidity/SolidityInterface.cpp
index f0d2be20..9a1c104d 100644
--- a/test/libsolidity/SolidityInterface.cpp
+++ b/test/libsolidity/SolidityInterface.cpp
@@ -21,8 +21,8 @@
  */
 
 #include "../TestHelper.h"
-#include <libsolidity/CompilerStack.h>
-#include <libsolidity/AST.h>
+#include <libsolidity/interface/CompilerStack.h>
+#include <libsolidity/ast/AST.h>
 
 using namespace std;
 
diff --git a/test/libsolidity/SolidityNameAndTypeResolution.cpp b/test/libsolidity/SolidityNameAndTypeResolution.cpp
index 4f0b70bd..e87e47a8 100644
--- a/test/libsolidity/SolidityNameAndTypeResolution.cpp
+++ b/test/libsolidity/SolidityNameAndTypeResolution.cpp
@@ -24,12 +24,12 @@
 
 #include <libdevcore/Log.h>
 #include <libdevcore/SHA3.h>
-#include <libsolidity/Scanner.h>
-#include <libsolidity/Parser.h>
-#include <libsolidity/NameAndTypeResolver.h>
-#include <libsolidity/Exceptions.h>
-#include <libsolidity/GlobalContext.h>
-#include <libsolidity/TypeChecker.h>
+#include <libsolidity/parsing/Scanner.h>
+#include <libsolidity/parsing/Parser.h>
+#include <libsolidity/analysis/NameAndTypeResolver.h>
+#include <libsolidity/interface/Exceptions.h>
+#include <libsolidity/analysis/GlobalContext.h>
+#include <libsolidity/analysis/TypeChecker.h>
 #include "../TestHelper.h"
 
 using namespace std;
@@ -62,35 +62,38 @@ parseAnalyseAndReturnError(string const& _source, bool _reportWarnings = false)
 		solAssert(Error::containsOnlyWarnings(errors), "");
 		resolver.registerDeclarations(*sourceUnit);
 
+		bool success = true;
 		for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
 			if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
 			{
 				globalContext->setCurrentContract(*contract);
 				resolver.updateDeclaration(*globalContext->currentThis());
 				resolver.updateDeclaration(*globalContext->currentSuper());
-				resolver.resolveNamesAndTypes(*contract);
+				if (!resolver.resolveNamesAndTypes(*contract))
+					success = false;
 			}
-		for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
-			if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
-			{
-				globalContext->setCurrentContract(*contract);
-				resolver.updateDeclaration(*globalContext->currentThis());
+		if (success)
+			for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
+				if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
+				{
+					globalContext->setCurrentContract(*contract);
+					resolver.updateDeclaration(*globalContext->currentThis());
 
-				TypeChecker typeChecker(errors);
-				bool success = typeChecker.checkTypeRequirements(*contract);
-				BOOST_CHECK(success || !errors.empty());
+					TypeChecker typeChecker(errors);
+					bool success = typeChecker.checkTypeRequirements(*contract);
+					BOOST_CHECK(success || !errors.empty());
 
-				for (auto const& currentError: errors)
-				{
-					if (
-						(_reportWarnings && currentError->type() == Error::Type::Warning) ||
-						(!_reportWarnings && currentError->type() != Error::Type::Warning)
-					)
-						return make_pair(sourceUnit, std::make_shared<Error::Type const>(currentError->type()));
 				}
-			}
+		for (auto const& currentError: errors)
+		{
+			if (
+				(_reportWarnings && currentError->type() == Error::Type::Warning) ||
+				(!_reportWarnings && currentError->type() != Error::Type::Warning)
+			)
+				return make_pair(sourceUnit, std::make_shared<Error::Type const>(currentError->type()));
+		}
 	}
-	catch(Error const& _e)
+	catch (Error const& _e)
 	{
 		return make_pair(sourceUnit, std::make_shared<Error::Type const>(_e.type()));
 	}
@@ -133,7 +136,7 @@ static ContractDefinition const* retrieveContract(ASTPointer<SourceUnit> _source
 	return nullptr;
 }
 
-static FunctionTypePointer const& retrieveFunctionBySignature(
+static FunctionTypePointer retrieveFunctionBySignature(
 	ContractDefinition const* _contract,
 	std::string const& _signature
 )
diff --git a/test/libsolidity/SolidityNatspecJSON.cpp b/test/libsolidity/SolidityNatspecJSON.cpp
index 5d20fe7b..8c0c2098 100644
--- a/test/libsolidity/SolidityNatspecJSON.cpp
+++ b/test/libsolidity/SolidityNatspecJSON.cpp
@@ -23,8 +23,8 @@
 #include "../TestHelper.h"
 #include <string>
 #include <json/json.h>
-#include <libsolidity/CompilerStack.h>
-#include <libsolidity/Exceptions.h>
+#include <libsolidity/interface/CompilerStack.h>
+#include <libsolidity/interface/Exceptions.h>
 #include <libdevcore/Exceptions.h>
 
 namespace dev
@@ -63,6 +63,12 @@ public:
 		);
 	}
 
+	void expectNatspecError(std::string const& _code)
+	{
+		BOOST_CHECK(!m_compilerStack.parse(_code));
+		BOOST_REQUIRE(Error::containsErrorOfType(m_compilerStack.errors(), Error::Type::DocstringParsingError));
+	}
+
 private:
 	CompilerStack m_compilerStack;
 	Json::Reader m_reader;
@@ -543,6 +549,31 @@ BOOST_AUTO_TEST_CASE(empty_comment)
 	checkNatspec(sourceCode, natspec, true);
 }
 
+BOOST_AUTO_TEST_CASE(dev_title_at_function_error)
+{
+	char const* sourceCode = " /// @author Lefteris\n"
+	" /// @title Just a test contract\n"
+	"contract test {\n"
+	"  /// @dev Mul function\n"
+	"  /// @title I really should not be here\n"
+	"  function mul(uint a, uint second) returns(uint d) { return a * 7 + second; }\n"
+	"}\n";
+
+	expectNatspecError(sourceCode);
+}
+
+BOOST_AUTO_TEST_CASE(dev_documenting_nonexistant_param)
+{
+	char const* sourceCode = "contract test {\n"
+	"  /// @dev Multiplies a number by 7 and adds second parameter\n"
+	"  /// @param a Documentation for the first parameter\n"
+	"  /// @param not_existing Documentation for the second parameter\n"
+	"  function mul(uint a, uint second) returns(uint d) { return a * 7 + second; }\n"
+	"}\n";
+
+	expectNatspecError(sourceCode);
+}
+
 BOOST_AUTO_TEST_SUITE_END()
 
 }
diff --git a/test/libsolidity/SolidityOptimizer.cpp b/test/libsolidity/SolidityOptimizer.cpp
index 20d59a04..732f599f 100644
--- a/test/libsolidity/SolidityOptimizer.cpp
+++ b/test/libsolidity/SolidityOptimizer.cpp
@@ -359,6 +359,16 @@ BOOST_AUTO_TEST_CASE(store_tags_as_unions)
 //	BOOST_CHECK_EQUAL(2, numSHA3s);
 }
 
+BOOST_AUTO_TEST_CASE(successor_not_found_bug)
+{
+	// This bug was caused because MSVC chose to use the u256->bool conversion
+	// instead of u256->unsigned
+	char const* sourceCode = R"(
+		contract greeter { function greeter() {} }
+	)";
+	compileBothVersions(sourceCode);
+}
+
 BOOST_AUTO_TEST_CASE(cse_intermediate_swap)
 {
 	eth::KnownState state;
@@ -1113,7 +1123,11 @@ BOOST_AUTO_TEST_CASE(computing_constants)
 	bytes complicatedConstant = toBigEndian(u256("0x817416927846239487123469187231298734162934871263941234127518276"));
 	unsigned occurrences = 0;
 	for (auto iter = optimizedBytecode.cbegin(); iter < optimizedBytecode.cend(); ++occurrences)
-		iter = search(iter, optimizedBytecode.cend(), complicatedConstant.cbegin(), complicatedConstant.cend()) + 1;
+	{
+		iter = search(iter, optimizedBytecode.cend(), complicatedConstant.cbegin(), complicatedConstant.cend());
+		if (iter < optimizedBytecode.cend())
+			++iter;
+	}
 	BOOST_CHECK_EQUAL(2, occurrences);
 
 	bytes constantWithZeros = toBigEndian(u256("0x77abc0000000000000000000000000000000000000000000000000000000001"));
diff --git a/test/libsolidity/SolidityParser.cpp b/test/libsolidity/SolidityParser.cpp
index 77582a2a..beb71942 100644
--- a/test/libsolidity/SolidityParser.cpp
+++ b/test/libsolidity/SolidityParser.cpp
@@ -23,9 +23,9 @@
 #include <string>
 #include <memory>
 #include <libdevcore/Log.h>
-#include <libsolidity/Scanner.h>
-#include <libsolidity/Parser.h>
-#include <libsolidity/Exceptions.h>
+#include <libsolidity/parsing/Scanner.h>
+#include <libsolidity/parsing/Parser.h>
+#include <libsolidity/interface/Exceptions.h>
 #include "../TestHelper.h"
 
 using namespace std;
diff --git a/test/libsolidity/SolidityScanner.cpp b/test/libsolidity/SolidityScanner.cpp
index dadcd903..10f30b8e 100644
--- a/test/libsolidity/SolidityScanner.cpp
+++ b/test/libsolidity/SolidityScanner.cpp
@@ -20,7 +20,7 @@
  * Unit tests for the solidity scanner.
  */
 
-#include <libsolidity/Scanner.h>
+#include <libsolidity/parsing/Scanner.h>
 #include <boost/test/unit_test.hpp>
 
 namespace dev
diff --git a/test/libsolidity/SolidityTypes.cpp b/test/libsolidity/SolidityTypes.cpp
index fc97667c..87dda9c2 100644
--- a/test/libsolidity/SolidityTypes.cpp
+++ b/test/libsolidity/SolidityTypes.cpp
@@ -20,7 +20,7 @@
  * Unit tests for the type system of Solidity.
  */
 
-#include <libsolidity/Types.h>
+#include <libsolidity/ast/Types.h>
 #include <boost/test/unit_test.hpp>
 
 using namespace std;
diff --git a/test/libsolidity/solidityExecutionFramework.h b/test/libsolidity/solidityExecutionFramework.h
index 82fede84..4da02eb2 100644
--- a/test/libsolidity/solidityExecutionFramework.h
+++ b/test/libsolidity/solidityExecutionFramework.h
@@ -28,8 +28,8 @@
 #include <libethcore/ABI.h>
 #include <libethereum/State.h>
 #include <libethereum/Executive.h>
-#include <libsolidity/CompilerStack.h>
-#include <libsolidity/Exceptions.h>
+#include <libsolidity/interface/CompilerStack.h>
+#include <libsolidity/interface/Exceptions.h>
 
 namespace dev
 {
@@ -67,28 +67,6 @@ public:
 		return m_output;
 	}
 
-	void compileRequireError(std::string const& _sourceCode, Error::Type _type)
-	{
-		m_compiler.reset(false, m_addStandardSources);
-		m_compiler.addSource("", _sourceCode);
-		bool foundError = false;
-		try
-		{
-			m_compiler.compile(m_optimize, m_optimizeRuns);
-			BOOST_REQUIRE(Error::containsErrorOfType(m_compiler.errors(), _type));
-		}
-		catch (Error const& _e)
-		{
-			BOOST_REQUIRE(_e.type() == _type);
-			foundError = true;
-		}
-		catch (Exception const& _exception)
-		{
-			BOOST_REQUIRE(false);
-		}
-		BOOST_REQUIRE(foundError);
-	}
-
 	bytes const& compileAndRun(
 		std::string const& _sourceCode,
 		u256 const& _value = 0,
