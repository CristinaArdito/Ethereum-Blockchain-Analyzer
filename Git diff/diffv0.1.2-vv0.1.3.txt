diff --git a/.gitignore b/.gitignore
index 675407ee..ebd0881e 100644
--- a/.gitignore
+++ b/.gitignore
@@ -28,4 +28,7 @@
 *.app
 
 # Build directory
-build/
\ No newline at end of file
+build/
+
+# vim stuff
+*.swp
diff --git a/CMakeLists.txt b/CMakeLists.txt
index e3c48341..db82855f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,50 +1,35 @@
-cmake_minimum_required(VERSION 2.8.12)
-
-cmake_policy(SET CMP0015 NEW)
-# let cmake autolink dependencies on windows
-cmake_policy(SET CMP0020 NEW)
-# this policy was introduced in cmake 3.0
-# remove if, once 3.0 will be used on unix
-if (${CMAKE_MAJOR_VERSION} GREATER 2)
-	cmake_policy(SET CMP0043 OLD)
-endif()
+cmake_minimum_required(VERSION 3.0.0)
 
-# TODO use version from Version.h
-set(PROJECT_VERSION "0.9.42")
-if (${CMAKE_VERSION} VERSION_GREATER 3.0)
-	cmake_policy(SET CMP0042 OLD) 	# fix MACOSX_RPATH
-	cmake_policy(SET CMP0048 NEW) 	# allow VERSION argument in project()
-	project(solidity VERSION ${PROJECT_VERSION})
-else()
-	project(solidity)
-endif()
+set(ETH_CMAKE_DIR   "${CMAKE_CURRENT_LIST_DIR}/../webthree-helpers/cmake"   CACHE PATH "The the path to the cmake directory")
+list(APPEND CMAKE_MODULE_PATH ${ETH_CMAKE_DIR})
 
-# Figure out environment.
-set(CPPETHEREUM_BUILD "${CMAKE_CURRENT_SOURCE_DIR}/../cpp-ethereum/${BUILD_DIR_NAME}" CACHE STRING "The absolute build directory of cpp-ethereum.")
-set(ETH_CMAKE_DIR   "${CMAKE_CURRENT_LIST_DIR}/../cpp-ethereum-cmake"   CACHE PATH "The the path to the cmake directory")
-set(ETH_DIR         "${CMAKE_CURRENT_LIST_DIR}/../cpp-ethereum"         CACHE PATH "The path to the cpp-ethereum directory")
-set(BUILD_DIR_NAME  "build"                                            CACHE STRING "The name of the build directory in cpp-ethereum")
-set(ETH_BUILD_DIR   "${ETH_DIR}/${BUILD_DIR_NAME}")
+# Set cmake_policies
+include(EthPolicy)
+eth_policy()
 
-list(APPEND CMAKE_MODULE_PATH ${ETH_CMAKE_DIR})
+# project name and version should be set after cmake_policy CMP0048
+set(PROJECT_VERSION "0.1.3")
+project(solidity VERSION ${PROJECT_VERSION})
 
+# Let's find our dependencies
 include(EthDependencies)
-include(EthExecutableHelper)
+
+# Figure out what compiler and system are we using
 include(EthCompilerSettings)
 
-include_directories(BEFORE ${JSONCPP_INCLUDE_DIRS})
-include_directories(BEFORE ..)
-include_directories(${Boost_INCLUDE_DIRS})
-include_directories(libsolidity)
-# Include a directory with BuildInfo.h
-include_directories(${ETH_BUILD_DIR})
-include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../cpp-ethereum)
-include_directories(${CPPETHEREUM_BUILD})
+# Include helper macros
+include(EthExecutableHelper)
+
+# Include utils
+include(EthUtils)
 
-file(GLOB_RECURSE SRC_LIST "libsolidity/*.cpp")
-file(GLOB_RECURSE HEADERS "libsolidity/*.h")
+include(EthOptions)
+configure_project(TESTS)
 
-set(EXECUTABLE solidity)
-add_library(${EXECUTABLE} ${SRC_LIST} ${HEADERS})
+add_subdirectory(libsolidity)
+add_subdirectory(solc)
+if (NOT EMSCRIPTEN)
+	add_subdirectory(test)
+endif()
 
 # TODO installation and packaging rules
diff --git a/README.md b/README.md
index f3068674..a22dc6a1 100644
--- a/README.md
+++ b/README.md
@@ -1,2 +1,35 @@
-# solidity
-The Solidity Contract-Oriented Programming Langauge
+# The Solidity Contract-Oriented Programming Language
+
+## Useful links
+
+To get started you can find a basic introduction to the language in [Solidity Tutorial](https://github.com/ethereum/wiki/wiki/Solidity-Tutorial).
+
+You can start using [Solidity in your browser](https://chriseth.github.io/browser-solidity/) with no need to download or compile anything. This application only supports compilation - if you want to inject it into the blockchain, you have to use a client like [Geth](https://github.com/ethereum/go-ethereum/wiki) or [AlethZero](https://github.com/ethereum/cpp-ethereum/wiki/Using-AlethZero).
+
+Also check out more documentations for [Solidity ABI](https://github.com/ethereum/wiki/wiki/Solidity,-Docs-and-ABI) and a crowdfunding [example contract](https://github.com/chriseth/cpp-ethereum/wiki/Crowdfunding-example-contract-in-Solidity) written in Solidity.
+
+[Changelog](https://github.com/ethereum/wiki/wiki/Solidity-Changelog)
+
+The [Solidity Features](https://github.com/ethereum/wiki/wiki/Solidity-Features) page contains a list of already completed Solidity feature stories with explanations and demonstrations, it is being updated continuously. More technical information you can find in the [Pivotal Tracker](https://www.pivotaltracker.com/n/projects/1189488).
+
+Solidity is still under development. So please do not hesitate and open an [issue in github](https://github.com/ethereum/solidity/issues) if you encounter anything strange.
+
+## Building
+
+See the [Wiki](https://github.com/ethereum/cpp-ethereum/wiki) for build instructions, compatibility information and build tips. 
+
+## How to Contribute
+
+### External Contributors
+
+I hereby place all my contributions in this codebase under an MIT
+licence, as specified [here](http://opensource.org/licenses/MIT).
+- *Name Surname* (**email@domain**)
+
+### Contribution guideline
+
+Please add yourself in the `@author` doxygen  section of the file your are adding/editing
+with the same wording as the one you listed yourself in the external contributors section above,
+only replacing the word **contribution** by **file**
+
+Please read [CodingStandards.txt](CodingStandards.txt) thoroughly before making alterations to the code base. Please do *NOT* use an editor that automatically reformats whitespace away from astylerc or the formatting guidelines as described in [CodingStandards.txt](CodingStandards.txt).
diff --git a/libsolidity/AST.cpp b/libsolidity/AST.cpp
index 8bad6ccf..daa84016 100644
--- a/libsolidity/AST.cpp
+++ b/libsolidity/AST.cpp
@@ -40,17 +40,17 @@ namespace solidity
 
 TypeError ASTNode::createTypeError(string const& _description) const
 {
-	return TypeError() << errinfo_sourceLocation(getLocation()) << errinfo_comment(_description);
+	return TypeError() << errinfo_sourceLocation(location()) << errinfo_comment(_description);
 }
 
-TypePointer ContractDefinition::getType(ContractDefinition const* _currentContract) const
+TypePointer ContractDefinition::type(ContractDefinition const* _currentContract) const
 {
 	return make_shared<TypeType>(make_shared<ContractType>(*this), _currentContract);
 }
 
 void ContractDefinition::checkTypeRequirements()
 {
-	for (ASTPointer<InheritanceSpecifier> const& baseSpecifier: getBaseContracts())
+	for (ASTPointer<InheritanceSpecifier> const& baseSpecifier: baseContracts())
 		baseSpecifier->checkTypeRequirements();
 
 	checkDuplicateFunctions();
@@ -58,41 +58,46 @@ void ContractDefinition::checkTypeRequirements()
 	checkAbstractFunctions();
 	checkAbstractConstructors();
 
-	FunctionDefinition const* constructor = getConstructor();
-	if (constructor && !constructor->getReturnParameters().empty())
-		BOOST_THROW_EXCEPTION(constructor->getReturnParameterList()->createTypeError(
-									"Non-empty \"returns\" directive for constructor."));
+	FunctionDefinition const* functionDefinition = constructor();
+	if (functionDefinition && !functionDefinition->returnParameters().empty())
+		BOOST_THROW_EXCEPTION(functionDefinition->returnParameterList()->createTypeError(
+			"Non-empty \"returns\" directive for constructor."
+		));
 
 	FunctionDefinition const* fallbackFunction = nullptr;
-	for (ASTPointer<FunctionDefinition> const& function: getDefinedFunctions())
+	for (ASTPointer<FunctionDefinition> const& function: definedFunctions())
 	{
-		if (function->getName().empty())
+		if (function->name().empty())
 		{
 			if (fallbackFunction)
 				BOOST_THROW_EXCEPTION(DeclarationError() << errinfo_comment("Only one fallback function is allowed."));
 			else
 			{
 				fallbackFunction = function.get();
-				if (!fallbackFunction->getParameters().empty())
-					BOOST_THROW_EXCEPTION(fallbackFunction->getParameterList().createTypeError("Fallback function cannot take parameters."));
+				if (!fallbackFunction->parameters().empty())
+					BOOST_THROW_EXCEPTION(fallbackFunction->parameterList().createTypeError("Fallback function cannot take parameters."));
 			}
 		}
 		if (!function->isFullyImplemented())
 			setFullyImplemented(false);
 	}
-	for (ASTPointer<ModifierDefinition> const& modifier: getFunctionModifiers())
-		modifier->checkTypeRequirements();
-
-	for (ASTPointer<FunctionDefinition> const& function: getDefinedFunctions())
-		function->checkTypeRequirements();
 
 	for (ASTPointer<VariableDeclaration> const& variable: m_stateVariables)
 		variable->checkTypeRequirements();
 
+	for (ASTPointer<EventDefinition> const& event: events())
+		event->checkTypeRequirements();
+
+	for (ASTPointer<ModifierDefinition> const& modifier: functionModifiers())
+		modifier->checkTypeRequirements();
+
+	for (ASTPointer<FunctionDefinition> const& function: definedFunctions())
+		function->checkTypeRequirements();
+
 	checkExternalTypeClashes();
 	// check for hash collisions in function signatures
 	set<FixedHash<4>> hashes;
-	for (auto const& it: getInterfaceFunctionList())
+	for (auto const& it: interfaceFunctionList())
 	{
 		FixedHash<4> const& hash = it.first;
 		if (hashes.count(hash))
@@ -101,23 +106,28 @@ void ContractDefinition::checkTypeRequirements()
 			));
 		hashes.insert(hash);
 	}
+
+	if (isLibrary())
+		checkLibraryRequirements();
 }
 
-map<FixedHash<4>, FunctionTypePointer> ContractDefinition::getInterfaceFunctions() const
+map<FixedHash<4>, FunctionTypePointer> ContractDefinition::interfaceFunctions() const
 {
-	auto exportedFunctionList = getInterfaceFunctionList();
+	auto exportedFunctionList = interfaceFunctionList();
 
 	map<FixedHash<4>, FunctionTypePointer> exportedFunctions;
 	for (auto const& it: exportedFunctionList)
 		exportedFunctions.insert(it);
 
-	solAssert(exportedFunctionList.size() == exportedFunctions.size(),
-			  "Hash collision at Function Definition Hash calculation");
+	solAssert(
+		exportedFunctionList.size() == exportedFunctions.size(),
+		"Hash collision at Function Definition Hash calculation"
+	);
 
 	return exportedFunctions;
 }
 
-FunctionDefinition const* ContractDefinition::getConstructor() const
+FunctionDefinition const* ContractDefinition::constructor() const
 {
 	for (ASTPointer<FunctionDefinition> const& f: m_definedFunctions)
 		if (f->isConstructor())
@@ -125,11 +135,11 @@ FunctionDefinition const* ContractDefinition::getConstructor() const
 	return nullptr;
 }
 
-FunctionDefinition const* ContractDefinition::getFallbackFunction() const
+FunctionDefinition const* ContractDefinition::fallbackFunction() const
 {
-	for (ContractDefinition const* contract: getLinearizedBaseContracts())
-		for (ASTPointer<FunctionDefinition> const& f: contract->getDefinedFunctions())
-			if (f->getName().empty())
+	for (ContractDefinition const* contract: linearizedBaseContracts())
+		for (ASTPointer<FunctionDefinition> const& f: contract->definedFunctions())
+			if (f->name().empty())
 				return f.get();
 	return nullptr;
 }
@@ -139,20 +149,20 @@ void ContractDefinition::checkDuplicateFunctions() const
 	/// Checks that two functions with the same name defined in this contract have different
 	/// argument types and that there is at most one constructor.
 	map<string, vector<FunctionDefinition const*>> functions;
-	for (ASTPointer<FunctionDefinition> const& function: getDefinedFunctions())
-		functions[function->getName()].push_back(function.get());
+	for (ASTPointer<FunctionDefinition> const& function: definedFunctions())
+		functions[function->name()].push_back(function.get());
 
-	if (functions[getName()].size() > 1)
+	if (functions[name()].size() > 1)
 	{
 		SecondarySourceLocation ssl;
-		auto it = functions[getName()].begin();
+		auto it = functions[name()].begin();
 		++it;
-		for (; it != functions[getName()].end(); ++it)
-			ssl.append("Another declaration is here:", (*it)->getLocation());
+		for (; it != functions[name()].end(); ++it)
+			ssl.append("Another declaration is here:", (*it)->location());
 
 		BOOST_THROW_EXCEPTION(
 			DeclarationError() <<
-			errinfo_sourceLocation(functions[getName()].front()->getLocation()) <<
+			errinfo_sourceLocation(functions[name()].front()->location()) <<
 			errinfo_comment("More than one constructor defined.") <<
 			errinfo_secondarySourceLocation(ssl)
 		);
@@ -165,10 +175,12 @@ void ContractDefinition::checkDuplicateFunctions() const
 				if (FunctionType(*overloads[i]).hasEqualArgumentTypes(FunctionType(*overloads[j])))
 					BOOST_THROW_EXCEPTION(
 						DeclarationError() <<
-						errinfo_sourceLocation(overloads[j]->getLocation()) <<
+						errinfo_sourceLocation(overloads[j]->location()) <<
 						errinfo_comment("Function with same name and arguments defined twice.") <<
 						errinfo_secondarySourceLocation(SecondarySourceLocation().append(
-							"Other declaration is here:", overloads[i]->getLocation()))
+							"Other declaration is here:", overloads[i]->location())
+						)
+
 					);
 	}
 }
@@ -181,10 +193,10 @@ void ContractDefinition::checkAbstractFunctions()
 	map<string, vector<FunTypeAndFlag>> functions;
 
 	// Search from base to derived
-	for (ContractDefinition const* contract: boost::adaptors::reverse(getLinearizedBaseContracts()))
-		for (ASTPointer<FunctionDefinition> const& function: contract->getDefinedFunctions())
+	for (ContractDefinition const* contract: boost::adaptors::reverse(linearizedBaseContracts()))
+		for (ASTPointer<FunctionDefinition> const& function: contract->definedFunctions())
 		{
-			auto& overloads = functions[function->getName()];
+			auto& overloads = functions[function->name()];
 			FunctionTypePointer funType = make_shared<FunctionType>(*function);
 			auto it = find_if(overloads.begin(), overloads.end(), [&](FunTypeAndFlag const& _funAndFlag)
 			{
@@ -217,32 +229,32 @@ void ContractDefinition::checkAbstractConstructors()
 	// check that we get arguments for all base constructors that need it.
 	// If not mark the contract as abstract (not fully implemented)
 
-	vector<ContractDefinition const*> const& bases = getLinearizedBaseContracts();
+	vector<ContractDefinition const*> const& bases = linearizedBaseContracts();
 	for (ContractDefinition const* contract: bases)
-		if (FunctionDefinition const* constructor = contract->getConstructor())
-			if (contract != this && !constructor->getParameters().empty())
+		if (FunctionDefinition const* constructor = contract->constructor())
+			if (contract != this && !constructor->parameters().empty())
 				argumentsNeeded.insert(contract);
 
 	for (ContractDefinition const* contract: bases)
 	{
-		if (FunctionDefinition const* constructor = contract->getConstructor())
-			for (auto const& modifier: constructor->getModifiers())
+		if (FunctionDefinition const* constructor = contract->constructor())
+			for (auto const& modifier: constructor->modifiers())
 			{
 				auto baseContract = dynamic_cast<ContractDefinition const*>(
-					&modifier->getName()->getReferencedDeclaration()
+					&modifier->name()->referencedDeclaration()
 				);
 				if (baseContract)
 					argumentsNeeded.erase(baseContract);
 			}
 
 
-		for (ASTPointer<InheritanceSpecifier> const& base: contract->getBaseContracts())
+		for (ASTPointer<InheritanceSpecifier> const& base: contract->baseContracts())
 		{
 			auto baseContract = dynamic_cast<ContractDefinition const*>(
-				&base->getName()->getReferencedDeclaration()
+				&base->name()->referencedDeclaration()
 			);
 			solAssert(baseContract, "");
-			if (!base->getArguments().empty())
+			if (!base->arguments().empty())
 				argumentsNeeded.erase(baseContract);
 		}
 	}
@@ -258,13 +270,13 @@ void ContractDefinition::checkIllegalOverrides() const
 	map<string, ModifierDefinition const*> modifiers;
 
 	// We search from derived to base, so the stored item causes the error.
-	for (ContractDefinition const* contract: getLinearizedBaseContracts())
+	for (ContractDefinition const* contract: linearizedBaseContracts())
 	{
-		for (ASTPointer<FunctionDefinition> const& function: contract->getDefinedFunctions())
+		for (ASTPointer<FunctionDefinition> const& function: contract->definedFunctions())
 		{
 			if (function->isConstructor())
 				continue; // constructors can neither be overridden nor override anything
-			string const& name = function->getName();
+			string const& name = function->name();
 			if (modifiers.count(name))
 				BOOST_THROW_EXCEPTION(modifiers[name]->createTypeError("Override changes function to modifier."));
 			FunctionType functionType(*function);
@@ -275,7 +287,7 @@ void ContractDefinition::checkIllegalOverrides() const
 				if (!overridingType.hasEqualArgumentTypes(functionType))
 					continue;
 				if (
-					overriding->getVisibility() != function->getVisibility() ||
+					overriding->visibility() != function->visibility() ||
 					overriding->isDeclaredConst() != function->isDeclaredConst() ||
 					overridingType != functionType
 				)
@@ -283,9 +295,9 @@ void ContractDefinition::checkIllegalOverrides() const
 			}
 			functions[name].push_back(function.get());
 		}
-		for (ASTPointer<ModifierDefinition> const& modifier: contract->getFunctionModifiers())
+		for (ASTPointer<ModifierDefinition> const& modifier: contract->functionModifiers())
 		{
-			string const& name = modifier->getName();
+			string const& name = modifier->name();
 			ModifierDefinition const*& override = modifiers[name];
 			if (!override)
 				override = modifier.get();
@@ -300,21 +312,21 @@ void ContractDefinition::checkIllegalOverrides() const
 void ContractDefinition::checkExternalTypeClashes() const
 {
 	map<string, vector<pair<Declaration const*, shared_ptr<FunctionType>>>> externalDeclarations;
-	for (ContractDefinition const* contract: getLinearizedBaseContracts())
+	for (ContractDefinition const* contract: linearizedBaseContracts())
 	{
-		for (ASTPointer<FunctionDefinition> const& f: contract->getDefinedFunctions())
+		for (ASTPointer<FunctionDefinition> const& f: contract->definedFunctions())
 			if (f->isPartOfExternalInterface())
 			{
 				auto functionType = make_shared<FunctionType>(*f);
-				externalDeclarations[functionType->externalSignature(f->getName())].push_back(
+				externalDeclarations[functionType->externalSignature(f->name())].push_back(
 					make_pair(f.get(), functionType)
 				);
 			}
-		for (ASTPointer<VariableDeclaration> const& v: contract->getStateVariables())
+		for (ASTPointer<VariableDeclaration> const& v: contract->stateVariables())
 			if (v->isPartOfExternalInterface())
 			{
 				auto functionType = make_shared<FunctionType>(*v);
-				externalDeclarations[functionType->externalSignature(v->getName())].push_back(
+				externalDeclarations[functionType->externalSignature(v->name())].push_back(
 					make_pair(v.get(), functionType)
 				);
 			}
@@ -328,53 +340,64 @@ void ContractDefinition::checkExternalTypeClashes() const
 					));
 }
 
-vector<ASTPointer<EventDefinition>> const& ContractDefinition::getInterfaceEvents() const
+void ContractDefinition::checkLibraryRequirements() const
+{
+	solAssert(m_isLibrary, "");
+	if (!m_baseContracts.empty())
+		BOOST_THROW_EXCEPTION(createTypeError("Library is not allowed to inherit."));
+
+	for (auto const& var: m_stateVariables)
+		if (!var->isConstant())
+			BOOST_THROW_EXCEPTION(var->createTypeError("Library cannot have non-constant state variables"));
+}
+
+vector<ASTPointer<EventDefinition>> const& ContractDefinition::interfaceEvents() const
 {
 	if (!m_interfaceEvents)
 	{
 		set<string> eventsSeen;
 		m_interfaceEvents.reset(new vector<ASTPointer<EventDefinition>>());
-		for (ContractDefinition const* contract: getLinearizedBaseContracts())
-			for (ASTPointer<EventDefinition> const& e: contract->getEvents())
-				if (eventsSeen.count(e->getName()) == 0)
+		for (ContractDefinition const* contract: linearizedBaseContracts())
+			for (ASTPointer<EventDefinition> const& e: contract->events())
+				if (eventsSeen.count(e->name()) == 0)
 				{
-					eventsSeen.insert(e->getName());
+					eventsSeen.insert(e->name());
 					m_interfaceEvents->push_back(e);
 				}
 	}
 	return *m_interfaceEvents;
 }
 
-vector<pair<FixedHash<4>, FunctionTypePointer>> const& ContractDefinition::getInterfaceFunctionList() const
+vector<pair<FixedHash<4>, FunctionTypePointer>> const& ContractDefinition::interfaceFunctionList() const
 {
 	if (!m_interfaceFunctionList)
 	{
 		set<string> functionsSeen;
 		set<string> signaturesSeen;
 		m_interfaceFunctionList.reset(new vector<pair<FixedHash<4>, FunctionTypePointer>>());
-		for (ContractDefinition const* contract: getLinearizedBaseContracts())
+		for (ContractDefinition const* contract: linearizedBaseContracts())
 		{
-			for (ASTPointer<FunctionDefinition> const& f: contract->getDefinedFunctions())
+			for (ASTPointer<FunctionDefinition> const& f: contract->definedFunctions())
 			{
 				if (!f->isPartOfExternalInterface())
 					continue;
 				string functionSignature = f->externalSignature();
 				if (signaturesSeen.count(functionSignature) == 0)
 				{
-					functionsSeen.insert(f->getName());
+					functionsSeen.insert(f->name());
 					signaturesSeen.insert(functionSignature);
 					FixedHash<4> hash(dev::sha3(functionSignature));
 					m_interfaceFunctionList->push_back(make_pair(hash, make_shared<FunctionType>(*f, false)));
 				}
 			}
 
-			for (ASTPointer<VariableDeclaration> const& v: contract->getStateVariables())
-				if (functionsSeen.count(v->getName()) == 0 && v->isPartOfExternalInterface())
+			for (ASTPointer<VariableDeclaration> const& v: contract->stateVariables())
+				if (functionsSeen.count(v->name()) == 0 && v->isPartOfExternalInterface())
 				{
 					FunctionType ftype(*v);
-					solAssert(v->getType().get(), "");
-					functionsSeen.insert(v->getName());
-					FixedHash<4> hash(dev::sha3(ftype.externalSignature(v->getName())));
+					solAssert(v->type().get(), "");
+					functionsSeen.insert(v->name());
+					FixedHash<4> hash(dev::sha3(ftype.externalSignature(v->name())));
 					m_interfaceFunctionList->push_back(make_pair(hash, make_shared<FunctionType>(*v)));
 				}
 		}
@@ -403,7 +426,7 @@ void ContractDefinition::setUserDocumentation(string const& _userDocumentation)
 }
 
 
-vector<Declaration const*> const& ContractDefinition::getInheritableMembers() const
+vector<Declaration const*> const& ContractDefinition::inheritableMembers() const
 {
 	if (!m_inheritableMembers)
 	{
@@ -411,28 +434,28 @@ vector<Declaration const*> const& ContractDefinition::getInheritableMembers() co
 		m_inheritableMembers.reset(new vector<Declaration const*>());
 		auto addInheritableMember = [&](Declaration const* _decl)
 		{
-			if (memberSeen.count(_decl->getName()) == 0 && _decl->isVisibleInDerivedContracts())
+			if (memberSeen.count(_decl->name()) == 0 && _decl->isVisibleInDerivedContracts())
 			{
-				memberSeen.insert(_decl->getName());
+				memberSeen.insert(_decl->name());
 				m_inheritableMembers->push_back(_decl);
 			}
 		};
 
-		for (ASTPointer<FunctionDefinition> const& f: getDefinedFunctions())
+		for (ASTPointer<FunctionDefinition> const& f: definedFunctions())
 			addInheritableMember(f.get());
 
-		for (ASTPointer<VariableDeclaration> const& v: getStateVariables())
+		for (ASTPointer<VariableDeclaration> const& v: stateVariables())
 			addInheritableMember(v.get());
 
-		for (ASTPointer<StructDefinition> const& s: getDefinedStructs())
+		for (ASTPointer<StructDefinition> const& s: definedStructs())
 			addInheritableMember(s.get());
 	}
 	return *m_inheritableMembers;
 }
 
-TypePointer EnumValue::getType(ContractDefinition const*) const
+TypePointer EnumValue::type(ContractDefinition const*) const
 {
-	EnumDefinition const* parentDef = dynamic_cast<EnumDefinition const*>(getScope());
+	EnumDefinition const* parentDef = dynamic_cast<EnumDefinition const*>(scope());
 	solAssert(parentDef, "Enclosing Scope of EnumValue was not set");
 	return make_shared<EnumType>(*parentDef);
 }
@@ -443,9 +466,13 @@ void InheritanceSpecifier::checkTypeRequirements()
 	for (ASTPointer<Expression> const& argument: m_arguments)
 		argument->checkTypeRequirements(nullptr);
 
-	ContractDefinition const* base = dynamic_cast<ContractDefinition const*>(&m_baseName->getReferencedDeclaration());
+	ContractDefinition const* base = dynamic_cast<ContractDefinition const*>(&m_baseName->referencedDeclaration());
 	solAssert(base, "Base contract not available.");
-	TypePointers parameterTypes = ContractType(*base).getConstructorType()->getParameterTypes();
+
+	if (base->isLibrary())
+		BOOST_THROW_EXCEPTION(createTypeError("Libraries cannot be inherited from."));
+
+	TypePointers parameterTypes = ContractType(*base).constructorType()->parameterTypes();
 	if (!m_arguments.empty() && parameterTypes.size() != m_arguments.size())
 		BOOST_THROW_EXCEPTION(createTypeError(
 			"Wrong argument count for constructor call: " +
@@ -456,26 +483,26 @@ void InheritanceSpecifier::checkTypeRequirements()
 		));
 
 	for (size_t i = 0; i < m_arguments.size(); ++i)
-		if (!m_arguments[i]->getType()->isImplicitlyConvertibleTo(*parameterTypes[i]))
+		if (!m_arguments[i]->type()->isImplicitlyConvertibleTo(*parameterTypes[i]))
 			BOOST_THROW_EXCEPTION(m_arguments[i]->createTypeError(
 				"Invalid type for argument in constructor call. "
 				"Invalid implicit conversion from " +
-				m_arguments[i]->getType()->toString() +
+				m_arguments[i]->type()->toString() +
 				" to " +
 				parameterTypes[i]->toString() +
 				" requested."
 			));
 }
 
-TypePointer StructDefinition::getType(ContractDefinition const*) const
+TypePointer StructDefinition::type(ContractDefinition const*) const
 {
 	return make_shared<TypeType>(make_shared<StructType>(*this));
 }
 
 void StructDefinition::checkMemberTypes() const
 {
-	for (ASTPointer<VariableDeclaration> const& member: getMembers())
-		if (!member->getType()->canBeStored())
+	for (ASTPointer<VariableDeclaration> const& member: members())
+		if (!member->type()->canBeStored())
 			BOOST_THROW_EXCEPTION(member->createTypeError("Type cannot be used in struct."));
 }
 
@@ -488,17 +515,17 @@ void StructDefinition::checkRecursion() const
 		if (_parents.count(_struct))
 			BOOST_THROW_EXCEPTION(
 				ParserError() <<
-				errinfo_sourceLocation(_struct->getLocation()) <<
+				errinfo_sourceLocation(_struct->location()) <<
 				errinfo_comment("Recursive struct definition.")
 			);
 		set<StructDefinition const*> parents = _parents;
 		parents.insert(_struct);
-		for (ASTPointer<VariableDeclaration> const& member: _struct->getMembers())
-			if (member->getType()->getCategory() == Type::Category::Struct)
+		for (ASTPointer<VariableDeclaration> const& member: _struct->members())
+			if (member->type()->category() == Type::Category::Struct)
 			{
-				auto const& typeName = dynamic_cast<UserDefinedTypeName const&>(*member->getTypeName());
+				auto const& typeName = dynamic_cast<UserDefinedTypeName const&>(*member->typeName());
 				check(
-					&dynamic_cast<StructDefinition const&>(*typeName.getReferencedDeclaration()),
+					&dynamic_cast<StructDefinition const&>(*typeName.referencedDeclaration()),
 					parents
 				);
 			}
@@ -506,28 +533,28 @@ void StructDefinition::checkRecursion() const
 	check(this, StructPointersSet{});
 }
 
-TypePointer EnumDefinition::getType(ContractDefinition const*) const
+TypePointer EnumDefinition::type(ContractDefinition const*) const
 {
 	return make_shared<TypeType>(make_shared<EnumType>(*this));
 }
 
-TypePointer FunctionDefinition::getType(ContractDefinition const*) const
+TypePointer FunctionDefinition::type(ContractDefinition const*) const
 {
 	return make_shared<FunctionType>(*this);
 }
 
 void FunctionDefinition::checkTypeRequirements()
 {
-	for (ASTPointer<VariableDeclaration> const& var: getParameters() + getReturnParameters())
+	for (ASTPointer<VariableDeclaration> const& var: parameters() + returnParameters())
 	{
-		if (!var->getType()->canLiveOutsideStorage())
+		if (!var->type()->canLiveOutsideStorage())
 			BOOST_THROW_EXCEPTION(var->createTypeError("Type is required to live outside storage."));
-		if (getVisibility() >= Visibility::Public && !(var->getType()->externalType()))
+		if (visibility() >= Visibility::Public && !(var->type()->externalType()))
 			BOOST_THROW_EXCEPTION(var->createTypeError("Internal type is not allowed for public and external functions."));
 	}
 	for (ASTPointer<ModifierInvocation> const& modifier: m_functionModifiers)
 		modifier->checkTypeRequirements(isConstructor() ?
-			dynamic_cast<ContractDefinition const&>(*getScope()).getLinearizedBaseContracts() :
+			dynamic_cast<ContractDefinition const&>(*scope()).linearizedBaseContracts() :
 			vector<ContractDefinition const*>());
 	if (m_body)
 		m_body->checkTypeRequirements();
@@ -535,7 +562,7 @@ void FunctionDefinition::checkTypeRequirements()
 
 string FunctionDefinition::externalSignature() const
 {
-	return FunctionType(*this).externalSignature(getName());
+	return FunctionType(*this).externalSignature(name());
 }
 
 bool VariableDeclaration::isLValue() const
@@ -552,10 +579,22 @@ void VariableDeclaration::checkTypeRequirements()
 	// rules inherited from JavaScript.
 	if (m_isConstant)
 	{
-		if (!dynamic_cast<ContractDefinition const*>(getScope()))
+		if (!dynamic_cast<ContractDefinition const*>(scope()))
 			BOOST_THROW_EXCEPTION(createTypeError("Illegal use of \"constant\" specifier."));
-		if ((m_type && !m_type->isValueType()) || !m_value)
-			BOOST_THROW_EXCEPTION(createTypeError("Unitialized \"constant\" variable."));
+		if (!m_value)
+			BOOST_THROW_EXCEPTION(createTypeError("Uninitialized \"constant\" variable."));
+		if (m_type && !m_type->isValueType())
+		{
+			// TODO: const is implemented only for uint, bytesXX, string and enums types.
+			bool constImplemented = false;
+			if (auto arrayType = dynamic_cast<ArrayType const*>(m_type.get()))
+				constImplemented = arrayType->isByteArray();
+			if (!constImplemented)
+				BOOST_THROW_EXCEPTION(createTypeError(
+					"Illegal use of \"constant\" specifier. \"constant\" "
+					"is not yet implemented for this type."
+				));
+		}
 	}
 	if (m_type)
 	{
@@ -569,13 +608,13 @@ void VariableDeclaration::checkTypeRequirements()
 			BOOST_THROW_EXCEPTION(createTypeError("Assignment necessary for type detection."));
 		m_value->checkTypeRequirements(nullptr);
 
-		TypePointer const& type = m_value->getType();
+		TypePointer const& type = m_value->type();
 		if (
-			type->getCategory() == Type::Category::IntegerConstant &&
-			!dynamic_pointer_cast<IntegerConstantType const>(type)->getIntegerType()
+			type->category() == Type::Category::IntegerConstant &&
+			!dynamic_pointer_cast<IntegerConstantType const>(type)->integerType()
 		)
 			BOOST_THROW_EXCEPTION(m_value->createTypeError("Invalid integer constant " + type->toString() + "."));
-		else if (type->getCategory() == Type::Category::Void)
+		else if (type->category() == Type::Category::Void)
 			BOOST_THROW_EXCEPTION(createTypeError("Variable cannot have void type."));
 		m_type = type->mobileType();
 	}
@@ -588,20 +627,20 @@ void VariableDeclaration::checkTypeRequirements()
 					"Type " + m_type->toString() + " is only valid in storage."
 				));
 	}
-	else if (getVisibility() >= Visibility::Public && !FunctionType(*this).externalType())
+	else if (visibility() >= Visibility::Public && !FunctionType(*this).externalType())
 		BOOST_THROW_EXCEPTION(createTypeError("Internal type is not allowed for public state variables."));
 }
 
 bool VariableDeclaration::isCallableParameter() const
 {
-	auto const* callable = dynamic_cast<CallableDeclaration const*>(getScope());
+	auto const* callable = dynamic_cast<CallableDeclaration const*>(scope());
 	if (!callable)
 		return false;
-	for (auto const& variable: callable->getParameters())
+	for (auto const& variable: callable->parameters())
 		if (variable.get() == this)
 			return true;
-	if (callable->getReturnParameterList())
-		for (auto const& variable: callable->getReturnParameterList()->getParameters())
+	if (callable->returnParameterList())
+		for (auto const& variable: callable->returnParameterList()->parameters())
 			if (variable.get() == this)
 				return true;
 	return false;
@@ -609,16 +648,16 @@ bool VariableDeclaration::isCallableParameter() const
 
 bool VariableDeclaration::isExternalCallableParameter() const
 {
-	auto const* callable = dynamic_cast<CallableDeclaration const*>(getScope());
-	if (!callable || callable->getVisibility() != Declaration::Visibility::External)
+	auto const* callable = dynamic_cast<CallableDeclaration const*>(scope());
+	if (!callable || callable->visibility() != Declaration::Visibility::External)
 		return false;
-	for (auto const& variable: callable->getParameters())
+	for (auto const& variable: callable->parameters())
 		if (variable.get() == this)
 			return true;
 	return false;
 }
 
-TypePointer ModifierDefinition::getType(ContractDefinition const*) const
+TypePointer ModifierDefinition::type(ContractDefinition const*) const
 {
 	return make_shared<ModifierType>(*this);
 }
@@ -634,22 +673,22 @@ void ModifierInvocation::checkTypeRequirements(vector<ContractDefinition const*>
 	for (ASTPointer<Expression> const& argument: m_arguments)
 	{
 		argument->checkTypeRequirements(nullptr);
-		argumentTypes.push_back(argument->getType());
+		argumentTypes.push_back(argument->type());
 	}
 	m_modifierName->checkTypeRequirements(&argumentTypes);
 
-	auto const* declaration = &m_modifierName->getReferencedDeclaration();
+	auto const* declaration = &m_modifierName->referencedDeclaration();
 	vector<ASTPointer<VariableDeclaration>> emptyParameterList;
 	vector<ASTPointer<VariableDeclaration>> const* parameters = nullptr;
 	if (auto modifier = dynamic_cast<ModifierDefinition const*>(declaration))
-		parameters = &modifier->getParameters();
+		parameters = &modifier->parameters();
 	else
 		// check parameters for Base constructors
 		for (ContractDefinition const* base: _bases)
 			if (declaration == base)
 			{
-				if (auto referencedConstructor = base->getConstructor())
-					parameters = &referencedConstructor->getParameters();
+				if (auto referencedConstructor = base->constructor())
+					parameters = &referencedConstructor->parameters();
 				else
 					parameters = &emptyParameterList;
 				break;
@@ -665,13 +704,13 @@ void ModifierInvocation::checkTypeRequirements(vector<ContractDefinition const*>
 			"."
 		));
 	for (size_t i = 0; i < m_arguments.size(); ++i)
-		if (!m_arguments[i]->getType()->isImplicitlyConvertibleTo(*(*parameters)[i]->getType()))
+		if (!m_arguments[i]->type()->isImplicitlyConvertibleTo(*(*parameters)[i]->type()))
 			BOOST_THROW_EXCEPTION(m_arguments[i]->createTypeError(
 				"Invalid type for argument in modifier invocation. "
 				"Invalid implicit conversion from " +
-				m_arguments[i]->getType()->toString() +
+				m_arguments[i]->type()->toString() +
 				" to " +
-				(*parameters)[i]->getType()->toString() +
+				(*parameters)[i]->type()->toString() +
 				" requested."
 			));
 }
@@ -679,17 +718,17 @@ void ModifierInvocation::checkTypeRequirements(vector<ContractDefinition const*>
 void EventDefinition::checkTypeRequirements()
 {
 	int numIndexed = 0;
-	for (ASTPointer<VariableDeclaration> const& var: getParameters())
+	for (ASTPointer<VariableDeclaration> const& var: parameters())
 	{
 		if (var->isIndexed())
 			numIndexed++;
-		if (!var->getType()->canLiveOutsideStorage())
+		if (numIndexed > 3)
+			BOOST_THROW_EXCEPTION(createTypeError("More than 3 indexed arguments for event."));
+		if (!var->type()->canLiveOutsideStorage())
 			BOOST_THROW_EXCEPTION(var->createTypeError("Type is required to live outside storage."));
-		if (!var->getType()->externalType())
+		if (!var->type()->externalType())
 			BOOST_THROW_EXCEPTION(var->createTypeError("Internal type is not allowed as event parameter type."));
 	}
-	if (numIndexed > 3)
-		BOOST_THROW_EXCEPTION(createTypeError("More than 3 indexed arguments for event."));
 }
 
 void Block::checkTypeRequirements()
@@ -729,12 +768,14 @@ void Return::checkTypeRequirements()
 		return;
 	if (!m_returnParameters)
 		BOOST_THROW_EXCEPTION(createTypeError("Return arguments not allowed."));
-	if (m_returnParameters->getParameters().size() != 1)
-		BOOST_THROW_EXCEPTION(createTypeError("Different number of arguments in return statement "
-											  "than in returns declaration."));
+	if (m_returnParameters->parameters().size() != 1)
+		BOOST_THROW_EXCEPTION(createTypeError(
+			"Different number of arguments in return statement "
+			"than in returns declaration."
+		));
 	// this could later be changed such that the paramaters type is an anonymous struct type,
 	// but for now, we only allow one return parameter
-	m_expression->expectType(*m_returnParameters->getParameters().front()->getType());
+	m_expression->expectType(*m_returnParameters->parameters().front()->type());
 }
 
 void VariableDeclarationStatement::checkTypeRequirements()
@@ -746,9 +787,9 @@ void Assignment::checkTypeRequirements(TypePointers const*)
 {
 	m_leftHandSide->checkTypeRequirements(nullptr);
 	m_leftHandSide->requireLValue();
-	if (m_leftHandSide->getType()->getCategory() == Type::Category::Mapping)
+	if (m_leftHandSide->type()->category() == Type::Category::Mapping)
 		BOOST_THROW_EXCEPTION(createTypeError("Mappings cannot be assigned to."));
-	m_type = m_leftHandSide->getType();
+	m_type = m_leftHandSide->type();
 	if (m_assigmentOperator == Token::Assign)
 		m_rightHandSide->expectType(*m_type);
 	else
@@ -756,35 +797,41 @@ void Assignment::checkTypeRequirements(TypePointers const*)
 		// compound assignment
 		m_rightHandSide->checkTypeRequirements(nullptr);
 		TypePointer resultType = m_type->binaryOperatorResult(Token::AssignmentToBinaryOp(m_assigmentOperator),
-															  m_rightHandSide->getType());
+															  m_rightHandSide->type());
 		if (!resultType || *resultType != *m_type)
-			BOOST_THROW_EXCEPTION(createTypeError("Operator " + string(Token::toString(m_assigmentOperator)) +
-												  " not compatible with types " +
-												  m_type->toString() + " and " +
-												  m_rightHandSide->getType()->toString()));
+			BOOST_THROW_EXCEPTION(createTypeError(
+				"Operator " +
+				string(Token::toString(m_assigmentOperator)) +
+				" not compatible with types " +
+				m_type->toString() +
+				" and " +
+				m_rightHandSide->type()->toString()
+			));
 	}
 }
 
 void ExpressionStatement::checkTypeRequirements()
 {
 	m_expression->checkTypeRequirements(nullptr);
-	if (m_expression->getType()->getCategory() == Type::Category::IntegerConstant)
-		if (!dynamic_pointer_cast<IntegerConstantType const>(m_expression->getType())->getIntegerType())
+	if (m_expression->type()->category() == Type::Category::IntegerConstant)
+		if (!dynamic_pointer_cast<IntegerConstantType const>(m_expression->type())->integerType())
 			BOOST_THROW_EXCEPTION(m_expression->createTypeError("Invalid integer constant."));
 }
 
 void Expression::expectType(Type const& _expectedType)
 {
 	checkTypeRequirements(nullptr);
-	Type const& type = *getType();
-	if (!type.isImplicitlyConvertibleTo(_expectedType))
-		BOOST_THROW_EXCEPTION(createTypeError(
-			"Type " +
-			type.toString() +
-			" is not implicitly convertible to expected type " +
-			_expectedType.toString() +
-			"."
-		));
+	Type const& currentType = *type();
+	if (!currentType.isImplicitlyConvertibleTo(_expectedType))
+		BOOST_THROW_EXCEPTION(
+			createTypeError(
+				"Type " +
+				currentType.toString() +
+				" is not implicitly convertible to expected type " +
+				_expectedType.toString() +
+				"."
+			)
+		);
 }
 
 void Expression::requireLValue()
@@ -800,7 +847,7 @@ void UnaryOperation::checkTypeRequirements(TypePointers const*)
 	m_subExpression->checkTypeRequirements(nullptr);
 	if (m_operator == Token::Value::Inc || m_operator == Token::Value::Dec || m_operator == Token::Value::Delete)
 		m_subExpression->requireLValue();
-	m_type = m_subExpression->getType()->unaryOperatorResult(m_operator);
+	m_type = m_subExpression->type()->unaryOperatorResult(m_operator);
 	if (!m_type)
 		BOOST_THROW_EXCEPTION(createTypeError("Unary operator not compatible with type."));
 }
@@ -809,12 +856,15 @@ void BinaryOperation::checkTypeRequirements(TypePointers const*)
 {
 	m_left->checkTypeRequirements(nullptr);
 	m_right->checkTypeRequirements(nullptr);
-	m_commonType = m_left->getType()->binaryOperatorResult(m_operator, m_right->getType());
+	m_commonType = m_left->type()->binaryOperatorResult(m_operator, m_right->type());
 	if (!m_commonType)
-		BOOST_THROW_EXCEPTION(createTypeError("Operator " + string(Token::toString(m_operator)) +
-											  " not compatible with types " +
-											  m_left->getType()->toString() + " and " +
-											  m_right->getType()->toString()));
+		BOOST_THROW_EXCEPTION(createTypeError(
+			"Operator " + string(Token::toString(m_operator)) +
+			" not compatible with types " +
+			m_left->type()->toString() +
+			" and " +
+			m_right->type()->toString()
+		));
 	m_type = Token::isCompareOp(m_operator) ? make_shared<BoolType>() : m_commonType;
 }
 
@@ -830,12 +880,12 @@ void FunctionCall::checkTypeRequirements(TypePointers const*)
 		argument->checkTypeRequirements(nullptr);
 		// only store them for positional calls
 		if (isPositionalCall)
-			argumentTypes.push_back(argument->getType());
+			argumentTypes.push_back(argument->type());
 	}
 
 	m_expression->checkTypeRequirements(isPositionalCall ? &argumentTypes : nullptr);
 
-	TypePointer const& expressionType = m_expression->getType();
+	TypePointer const& expressionType = m_expression->type();
 	FunctionTypePointer functionType;
 	if (isTypeConversion())
 	{
@@ -844,8 +894,8 @@ void FunctionCall::checkTypeRequirements(TypePointers const*)
 			BOOST_THROW_EXCEPTION(createTypeError("Exactly one argument expected for explicit type conversion."));
 		if (!isPositionalCall)
 			BOOST_THROW_EXCEPTION(createTypeError("Type conversion cannot allow named arguments."));
-		m_type = type.getActualType();
-		auto argType = m_arguments.front()->getType();
+		m_type = type.actualType();
+		auto argType = m_arguments.front()->type();
 		if (auto argRefType = dynamic_cast<ReferenceType const*>(argType.get()))
 			// do not change the data location when converting
 			// (data location cannot yet be specified for type conversions)
@@ -861,7 +911,7 @@ void FunctionCall::checkTypeRequirements(TypePointers const*)
 	if (isStructConstructorCall())
 	{
 		TypeType const& type = dynamic_cast<TypeType const&>(*expressionType);
-		auto const& structType = dynamic_cast<StructType const&>(*type.getActualType());
+		auto const& structType = dynamic_cast<StructType const&>(*type.actualType());
 		functionType = structType.constructorType();
 		membersRemovedForStructConstructor = structType.membersMissingInMemory();
 	}
@@ -874,7 +924,7 @@ void FunctionCall::checkTypeRequirements(TypePointers const*)
 	//@todo would be nice to create a struct type from the arguments
 	// and then ask if that is implicitly convertible to the struct represented by the
 	// function parameters
-	TypePointers const& parameterTypes = functionType->getParameterTypes();
+	TypePointers const& parameterTypes = functionType->parameterTypes();
 	if (!functionType->takesArbitraryParameters() && parameterTypes.size() != m_arguments.size())
 	{
 		string msg =
@@ -899,12 +949,12 @@ void FunctionCall::checkTypeRequirements(TypePointers const*)
 		for (size_t i = 0; i < m_arguments.size(); ++i)
 			if (
 				!functionType->takesArbitraryParameters() &&
-				!m_arguments[i]->getType()->isImplicitlyConvertibleTo(*parameterTypes[i])
+				!m_arguments[i]->type()->isImplicitlyConvertibleTo(*parameterTypes[i])
 			)
 				BOOST_THROW_EXCEPTION(m_arguments[i]->createTypeError(
 					"Invalid type for argument in function call. "
 					"Invalid implicit conversion from " +
-					m_arguments[i]->getType()->toString() +
+					m_arguments[i]->type()->toString() +
 					" to " +
 					parameterTypes[i]->toString() +
 					" requested."
@@ -917,7 +967,7 @@ void FunctionCall::checkTypeRequirements(TypePointers const*)
 			BOOST_THROW_EXCEPTION(createTypeError(
 				"Named arguments cannnot be used for functions that take arbitrary parameters."
 			));
-		auto const& parameterNames = functionType->getParameterNames();
+		auto const& parameterNames = functionType->parameterNames();
 		if (parameterNames.size() != m_names.size())
 			BOOST_THROW_EXCEPTION(createTypeError("Some argument names are missing."));
 
@@ -932,11 +982,11 @@ void FunctionCall::checkTypeRequirements(TypePointers const*)
 			for (size_t j = 0; j < parameterNames.size(); j++) {
 				if (parameterNames[j] == *m_names[i]) {
 					// check type convertible
-					if (!m_arguments[i]->getType()->isImplicitlyConvertibleTo(*parameterTypes[j]))
+					if (!m_arguments[i]->type()->isImplicitlyConvertibleTo(*parameterTypes[j]))
 						BOOST_THROW_EXCEPTION(m_arguments[i]->createTypeError(
 							"Invalid type for argument in function call. "
 							"Invalid implicit conversion from " +
-							m_arguments[i]->getType()->toString() +
+							m_arguments[i]->type()->toString() +
 							" to " +
 							parameterTypes[i]->toString() +
 							" requested."
@@ -954,21 +1004,21 @@ void FunctionCall::checkTypeRequirements(TypePointers const*)
 	// @todo actually the return type should be an anonymous struct,
 	// but we change it to the type of the first return value until we have anonymous
 	// structs and tuples
-	if (functionType->getReturnParameterTypes().empty())
+	if (functionType->returnParameterTypes().empty())
 		m_type = make_shared<VoidType>();
 	else
-		m_type = functionType->getReturnParameterTypes().front();
+		m_type = functionType->returnParameterTypes().front();
 }
 
 bool FunctionCall::isTypeConversion() const
 {
-	return m_expression->getType()->getCategory() == Type::Category::TypeType && !isStructConstructorCall();
+	return m_expression->type()->category() == Type::Category::TypeType && !isStructConstructorCall();
 }
 
 bool FunctionCall::isStructConstructorCall() const
 {
-	if (auto const* type = dynamic_cast<TypeType const*>(m_expression->getType().get()))
-		return type->getActualType()->getCategory() == Type::Category::Struct;
+	if (auto const* type = dynamic_cast<TypeType const*>(m_expression->type().get()))
+		return type->actualType()->category() == Type::Category::Struct;
 	else
 		return false;
 }
@@ -976,33 +1026,41 @@ bool FunctionCall::isStructConstructorCall() const
 void NewExpression::checkTypeRequirements(TypePointers const*)
 {
 	m_contractName->checkTypeRequirements(nullptr);
-	m_contract = dynamic_cast<ContractDefinition const*>(&m_contractName->getReferencedDeclaration());
+	m_contract = dynamic_cast<ContractDefinition const*>(&m_contractName->referencedDeclaration());
+
 	if (!m_contract)
 		BOOST_THROW_EXCEPTION(createTypeError("Identifier is not a contract."));
 	if (!m_contract->isFullyImplemented())
 		BOOST_THROW_EXCEPTION(createTypeError("Trying to create an instance of an abstract contract."));
+
+	auto scopeContract = m_contractName->contractScope();
+	auto bases = m_contract->linearizedBaseContracts();
+	if (find(bases.begin(), bases.end(), scopeContract) != bases.end())
+		BOOST_THROW_EXCEPTION(createTypeError("Circular reference for contract creation: cannot create instance of derived or same contract."));
+
 	shared_ptr<ContractType const> contractType = make_shared<ContractType>(*m_contract);
-	TypePointers const& parameterTypes = contractType->getConstructorType()->getParameterTypes();
+	TypePointers const& parameterTypes = contractType->constructorType()->parameterTypes();
 	m_type = make_shared<FunctionType>(
 		parameterTypes,
 		TypePointers{contractType},
 		strings(),
 		strings(),
-		FunctionType::Location::Creation);
+		FunctionType::Location::Creation
+	);
 }
 
 void MemberAccess::checkTypeRequirements(TypePointers const* _argumentTypes)
 {
 	m_expression->checkTypeRequirements(nullptr);
-	Type const& type = *m_expression->getType();
+	Type const& type = *m_expression->type();
 
-	MemberList::MemberMap possibleMembers = type.getMembers().membersByName(*m_memberName);
+	MemberList::MemberMap possibleMembers = type.members().membersByName(*m_memberName);
 	if (possibleMembers.size() > 1 && _argumentTypes)
 	{
 		// do override resolution
 		for (auto it = possibleMembers.begin(); it != possibleMembers.end();)
 			if (
-				it->type->getCategory() == Type::Category::Function &&
+				it->type->category() == Type::Category::Function &&
 				!dynamic_cast<FunctionType const&>(*it->type).canTakeArguments(*_argumentTypes)
 			)
 				it = possibleMembers.erase(it);
@@ -1013,30 +1071,36 @@ void MemberAccess::checkTypeRequirements(TypePointers const* _argumentTypes)
 	{
 		auto storageType = ReferenceType::copyForLocationIfReference(
 			DataLocation::Storage,
-			m_expression->getType()
+			m_expression->type()
 		);
-		if (!storageType->getMembers().membersByName(*m_memberName).empty())
+		if (!storageType->members().membersByName(*m_memberName).empty())
 			BOOST_THROW_EXCEPTION(createTypeError(
-				"Member \"" + *m_memberName + "\" is not available in " +
+				"Member \"" +
+				*m_memberName +
+				"\" is not available in " +
 				type.toString() +
 				" outside of storage."
 			));
 		BOOST_THROW_EXCEPTION(createTypeError(
-			"Member \"" + *m_memberName + "\" not found or not visible "
-			"after argument-dependent lookup in " + type.toString()
+			"Member \"" +
+			*m_memberName +
+			"\" not found or not visible after argument-dependent lookup in " +
+			type.toString()
 		));
 	}
 	else if (possibleMembers.size() > 1)
 		BOOST_THROW_EXCEPTION(createTypeError(
-			"Member \"" + *m_memberName + "\" not unique "
-			"after argument-dependent lookup in " + type.toString()
+			"Member \"" +
+			*m_memberName +
+			"\" not unique after argument-dependent lookup in " +
+			type.toString()
 		));
 
 	m_referencedDeclaration = possibleMembers.front().declaration;
 	m_type = possibleMembers.front().type;
-	if (type.getCategory() == Type::Category::Struct)
+	if (type.category() == Type::Category::Struct)
 		m_isLValue = true;
-	else if (type.getCategory() == Type::Category::Array)
+	else if (type.category() == Type::Category::Array)
 	{
 		auto const& arrayType(dynamic_cast<ArrayType const&>(type));
 		m_isLValue = (
@@ -1052,46 +1116,49 @@ void MemberAccess::checkTypeRequirements(TypePointers const* _argumentTypes)
 void IndexAccess::checkTypeRequirements(TypePointers const*)
 {
 	m_base->checkTypeRequirements(nullptr);
-	switch (m_base->getType()->getCategory())
+	switch (m_base->type()->category())
 	{
 	case Type::Category::Array:
 	{
-		ArrayType const& type = dynamic_cast<ArrayType const&>(*m_base->getType());
+		ArrayType const& type = dynamic_cast<ArrayType const&>(*m_base->type());
 		if (!m_index)
 			BOOST_THROW_EXCEPTION(createTypeError("Index expression cannot be omitted."));
 		if (type.isString())
 			BOOST_THROW_EXCEPTION(createTypeError("Index access for string is not possible."));
 		m_index->expectType(IntegerType(256));
-		if (type.isByteArray())
-			m_type = make_shared<FixedBytesType>(1);
-		else
-			m_type = type.getBaseType();
+
+		m_type = type.baseType();
+		if (auto integerType = dynamic_cast<IntegerConstantType const*>(m_index->type().get()))
+			if (!type.isDynamicallySized() && type.length() <= integerType->literalValue(nullptr))
+				BOOST_THROW_EXCEPTION(createTypeError("Out of bounds access."));
+
 		m_isLValue = type.location() != DataLocation::CallData;
 		break;
 	}
 	case Type::Category::Mapping:
 	{
-		MappingType const& type = dynamic_cast<MappingType const&>(*m_base->getType());
+		MappingType const& type = dynamic_cast<MappingType const&>(*m_base->type());
 		if (!m_index)
 			BOOST_THROW_EXCEPTION(createTypeError("Index expression cannot be omitted."));
-		m_index->expectType(*type.getKeyType());
-		m_type = type.getValueType();
+		m_index->expectType(*type.keyType());
+		m_type = type.valueType();
 		m_isLValue = true;
 		break;
 	}
 	case Type::Category::TypeType:
 	{
-		TypeType const& type = dynamic_cast<TypeType const&>(*m_base->getType());
+		TypeType const& type = dynamic_cast<TypeType const&>(*m_base->type());
 		if (!m_index)
-			m_type = make_shared<TypeType>(make_shared<ArrayType>(DataLocation::Memory, type.getActualType()));
+			m_type = make_shared<TypeType>(make_shared<ArrayType>(DataLocation::Memory, type.actualType()));
 		else
 		{
 			m_index->checkTypeRequirements(nullptr);
-			auto length = dynamic_cast<IntegerConstantType const*>(m_index->getType().get());
+			auto length = dynamic_cast<IntegerConstantType const*>(m_index->type().get());
 			if (!length)
 				BOOST_THROW_EXCEPTION(m_index->createTypeError("Integer constant expected."));
 			m_type = make_shared<TypeType>(make_shared<ArrayType>(
-				DataLocation::Memory, type.getActualType(),
+				DataLocation::Memory,
+				type.actualType(),
 				length->literalValue(nullptr)
 			));
 		}
@@ -1099,7 +1166,10 @@ void IndexAccess::checkTypeRequirements(TypePointers const*)
 	}
 	default:
 		BOOST_THROW_EXCEPTION(m_base->createTypeError(
-			"Indexed expression has to be a type, mapping or array (is " + m_base->getType()->toString() + ")"));
+			"Indexed expression has to be a type, mapping or array (is " +
+			m_base->type()->toString() +
+			")"
+		));
 	}
 }
 
@@ -1113,12 +1183,12 @@ void Identifier::checkTypeRequirements(TypePointers const* _argumentTypes)
 	}
 	solAssert(!!m_referencedDeclaration, "Referenced declaration is null after overload resolution.");
 	m_isLValue = m_referencedDeclaration->isLValue();
-	m_type = m_referencedDeclaration->getType(m_currentContract);
+	m_type = m_referencedDeclaration->type(m_contractScope);
 	if (!m_type)
 		BOOST_THROW_EXCEPTION(createTypeError("Declaration referenced before type could be determined."));
 }
 
-Declaration const& Identifier::getReferencedDeclaration() const
+Declaration const& Identifier::referencedDeclaration() const
 {
 	solAssert(!!m_referencedDeclaration, "Identifier not resolved.");
 	return *m_referencedDeclaration;
@@ -1135,7 +1205,7 @@ void Identifier::overloadResolution(TypePointers const& _argumentTypes)
 
 	for (Declaration const* declaration: m_overloadedDeclarations)
 	{
-		TypePointer const& function = declaration->getType();
+		TypePointer const& function = declaration->type();
 		auto const* functionType = dynamic_cast<FunctionType const*>(function.get());
 		if (functionType && functionType->canTakeArguments(_argumentTypes))
 			possibles.push_back(declaration);
diff --git a/libsolidity/AST.h b/libsolidity/AST.h
index fb83d4e1..ba529a8a 100644
--- a/libsolidity/AST.h
+++ b/libsolidity/AST.h
@@ -71,7 +71,7 @@ public:
 	}
 
 	/// Returns the source code location of this node.
-	SourceLocation const& getLocation() const { return m_location; }
+	SourceLocation const& location() const { return m_location; }
 
 	/// Creates a @ref TypeError exception and decorates it with the location of the node and
 	/// the given description
@@ -100,7 +100,7 @@ public:
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 
-	std::vector<ASTPointer<ASTNode>> getNodes() const { return m_nodes; }
+	std::vector<ASTPointer<ASTNode>> nodes() const { return m_nodes; }
 
 private:
 	std::vector<ASTPointer<ASTNode>> m_nodes;
@@ -120,7 +120,7 @@ public:
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 
-	ASTString const& getIdentifier() const { return *m_identifier; }
+	ASTString const& identifier() const { return *m_identifier; }
 
 private:
 	ASTPointer<ASTString> m_identifier;
@@ -140,26 +140,26 @@ public:
 		ASTNode(_location), m_name(_name), m_visibility(_visibility), m_scope(nullptr) {}
 
 	/// @returns the declared name.
-	ASTString const& getName() const { return *m_name; }
-	Visibility getVisibility() const { return m_visibility == Visibility::Default ? getDefaultVisibility() : m_visibility; }
-	bool isPublic() const { return getVisibility() >= Visibility::Public; }
-	virtual bool isVisibleInContract() const { return getVisibility() != Visibility::External; }
-	bool isVisibleInDerivedContracts() const { return isVisibleInContract() && getVisibility() >= Visibility::Internal; }
+	ASTString const& name() const { return *m_name; }
+	Visibility visibility() const { return m_visibility == Visibility::Default ? defaultVisibility() : m_visibility; }
+	bool isPublic() const { return visibility() >= Visibility::Public; }
+	virtual bool isVisibleInContract() const { return visibility() != Visibility::External; }
+	bool isVisibleInDerivedContracts() const { return isVisibleInContract() && visibility() >= Visibility::Internal; }
 
 	/// @returns the scope this declaration resides in. Can be nullptr if it is the global scope.
 	/// Available only after name and type resolution step.
-	Declaration const* getScope() const { return m_scope; }
+	Declaration const* scope() const { return m_scope; }
 	void setScope(Declaration const* _scope) { m_scope = _scope; }
 
 	/// @returns the type of expressions referencing this declaration.
 	/// The current contract has to be given since this context can change the type, especially of
 	/// contract types.
-	virtual TypePointer getType(ContractDefinition const* m_currentContract = nullptr) const = 0;
+	virtual TypePointer type(ContractDefinition const* m_currentContract = nullptr) const = 0;
 	virtual bool isLValue() const { return false; }
 	virtual bool isPartOfExternalInterface() const { return false; }
 
 protected:
-	virtual Visibility getDefaultVisibility() const { return Visibility::Public; }
+	virtual Visibility defaultVisibility() const { return Visibility::Public; }
 
 private:
 	ASTPointer<ASTString> m_name;
@@ -174,7 +174,7 @@ class VariableScope
 {
 public:
 	void addLocalVariable(VariableDeclaration const& _localVariable) { m_localVariables.push_back(&_localVariable); }
-	std::vector<VariableDeclaration const*> const& getLocalVariables() const { return m_localVariables; }
+	std::vector<VariableDeclaration const*> const& localVariables() const { return m_localVariables; }
 
 private:
 	std::vector<VariableDeclaration const*> m_localVariables;
@@ -190,7 +190,7 @@ public:
 
 	/// @return A shared pointer of an ASTString.
 	/// Can contain a nullptr in which case indicates absence of documentation
-	ASTPointer<ASTString> const& getDocumentation() const { return m_documentation; }
+	ASTPointer<ASTString> const& documentation() const { return m_documentation; }
 
 protected:
 	ASTPointer<ASTString> m_documentation;
@@ -215,7 +215,7 @@ protected:
 /// @}
 
 /**
- * Definition of a contract. This is the only AST nodes where child nodes are not visited in
+ * Definition of a contract or library. This is the only AST nodes where child nodes are not visited in
  * document order. It first visits all struct declarations, then all variable declarations and
  * finally all function declarations.
  */
@@ -232,7 +232,8 @@ public:
 		std::vector<ASTPointer<VariableDeclaration>> const& _stateVariables,
 		std::vector<ASTPointer<FunctionDefinition>> const& _definedFunctions,
 		std::vector<ASTPointer<ModifierDefinition>> const& _functionModifiers,
-		std::vector<ASTPointer<EventDefinition>> const& _events
+		std::vector<ASTPointer<EventDefinition>> const& _events,
+		bool _isLibrary
 	):
 		Declaration(_location, _name),
 		Documented(_documentation),
@@ -243,22 +244,24 @@ public:
 		m_stateVariables(_stateVariables),
 		m_definedFunctions(_definedFunctions),
 		m_functionModifiers(_functionModifiers),
-		m_events(_events)
+		m_events(_events),
+		m_isLibrary(_isLibrary)
 	{}
 
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 
-	std::vector<ASTPointer<InheritanceSpecifier>> const& getBaseContracts() const { return m_baseContracts; }
-	std::vector<ASTPointer<StructDefinition>> const& getDefinedStructs() const { return m_definedStructs; }
-	std::vector<ASTPointer<EnumDefinition>> const& getDefinedEnums() const { return m_definedEnums; }
-	std::vector<ASTPointer<VariableDeclaration>> const& getStateVariables() const { return m_stateVariables; }
-	std::vector<ASTPointer<ModifierDefinition>> const& getFunctionModifiers() const { return m_functionModifiers; }
-	std::vector<ASTPointer<FunctionDefinition>> const& getDefinedFunctions() const { return m_definedFunctions; }
-	std::vector<ASTPointer<EventDefinition>> const& getEvents() const { return m_events; }
-	std::vector<ASTPointer<EventDefinition>> const& getInterfaceEvents() const;
+	std::vector<ASTPointer<InheritanceSpecifier>> const& baseContracts() const { return m_baseContracts; }
+	std::vector<ASTPointer<StructDefinition>> const& definedStructs() const { return m_definedStructs; }
+	std::vector<ASTPointer<EnumDefinition>> const& definedEnums() const { return m_definedEnums; }
+	std::vector<ASTPointer<VariableDeclaration>> const& stateVariables() const { return m_stateVariables; }
+	std::vector<ASTPointer<ModifierDefinition>> const& functionModifiers() const { return m_functionModifiers; }
+	std::vector<ASTPointer<FunctionDefinition>> const& definedFunctions() const { return m_definedFunctions; }
+	std::vector<ASTPointer<EventDefinition>> const& events() const { return m_events; }
+	std::vector<ASTPointer<EventDefinition>> const& interfaceEvents() const;
+	bool isLibrary() const { return m_isLibrary; }
 
-	virtual TypePointer getType(ContractDefinition const* m_currentContract) const override;
+	virtual TypePointer type(ContractDefinition const* m_currentContract) const override;
 
 	/// Checks that there are no illegal overrides, that the constructor does not have a "returns"
 	/// and calls checkTypeRequirements on all its functions.
@@ -266,20 +269,20 @@ public:
 
 	/// @returns a map of canonical function signatures to FunctionDefinitions
 	/// as intended for use by the ABI.
-	std::map<FixedHash<4>, FunctionTypePointer> getInterfaceFunctions() const;
+	std::map<FixedHash<4>, FunctionTypePointer> interfaceFunctions() const;
 
 	/// @returns a list of the inheritable members of this contract
-	std::vector<Declaration const*> const& getInheritableMembers() const;
+	std::vector<Declaration const*> const& inheritableMembers() const;
 
 	/// List of all (direct and indirect) base contracts in order from derived to base, including
 	/// the contract itself. Available after name resolution
-	std::vector<ContractDefinition const*> const& getLinearizedBaseContracts() const { return m_linearizedBaseContracts; }
+	std::vector<ContractDefinition const*> const& linearizedBaseContracts() const { return m_linearizedBaseContracts; }
 	void setLinearizedBaseContracts(std::vector<ContractDefinition const*> const& _bases) { m_linearizedBaseContracts = _bases; }
 
 	/// Returns the constructor or nullptr if no constructor was specified.
-	FunctionDefinition const* getConstructor() const;
+	FunctionDefinition const* constructor() const;
 	/// Returns the fallback function or nullptr if no fallback function was specified.
-	FunctionDefinition const* getFallbackFunction() const;
+	FunctionDefinition const* fallbackFunction() const;
 
 	std::string const& userDocumentation() const;
 	void setUserDocumentation(std::string const& _userDocumentation);
@@ -297,8 +300,10 @@ private:
 	/// Checks that different functions with external visibility end up having different
 	/// external argument types (i.e. different signature).
 	void checkExternalTypeClashes() const;
+	/// Checks that all requirements for a library are fulfilled if this is a library.
+	void checkLibraryRequirements() const;
 
-	std::vector<std::pair<FixedHash<4>, FunctionTypePointer>> const& getInterfaceFunctionList() const;
+	std::vector<std::pair<FixedHash<4>, FunctionTypePointer>> const& interfaceFunctionList() const;
 
 	std::vector<ASTPointer<InheritanceSpecifier>> m_baseContracts;
 	std::vector<ASTPointer<StructDefinition>> m_definedStructs;
@@ -307,6 +312,7 @@ private:
 	std::vector<ASTPointer<FunctionDefinition>> m_definedFunctions;
 	std::vector<ASTPointer<ModifierDefinition>> m_functionModifiers;
 	std::vector<ASTPointer<EventDefinition>> m_events;
+	bool m_isLibrary;
 
 	// parsed Natspec documentation of the contract.
 	std::string m_userDocumentation;
@@ -328,8 +334,8 @@ public:
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 
-	ASTPointer<Identifier> const& getName() const { return m_baseName; }
-	std::vector<ASTPointer<Expression>> const& getArguments() const { return m_arguments; }
+	ASTPointer<Identifier> const& name() const { return m_baseName; }
+	std::vector<ASTPointer<Expression>> const& arguments() const { return m_arguments; }
 
 	void checkTypeRequirements();
 
@@ -341,16 +347,19 @@ private:
 class StructDefinition: public Declaration
 {
 public:
-	StructDefinition(SourceLocation const& _location,
-					 ASTPointer<ASTString> const& _name,
-					 std::vector<ASTPointer<VariableDeclaration>> const& _members):
+	StructDefinition(
+		SourceLocation const& _location,
+		ASTPointer<ASTString> const& _name,
+		std::vector<ASTPointer<VariableDeclaration>> const& _members
+	):
 		Declaration(_location, _name), m_members(_members) {}
+
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 
-	std::vector<ASTPointer<VariableDeclaration>> const& getMembers() const { return m_members; }
+	std::vector<ASTPointer<VariableDeclaration>> const& members() const { return m_members; }
 
-	virtual TypePointer getType(ContractDefinition const*) const override;
+	virtual TypePointer type(ContractDefinition const*) const override;
 
 	/// Checks that the members do not include any recursive structs and have valid types
 	/// (e.g. no functions).
@@ -373,9 +382,9 @@ public:
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 
-	std::vector<ASTPointer<EnumValue>> const& getMembers() const { return m_members; }
+	std::vector<ASTPointer<EnumValue>> const& members() const { return m_members; }
 
-	virtual TypePointer getType(ContractDefinition const*) const override;
+	virtual TypePointer type(ContractDefinition const*) const override;
 
 private:
 	std::vector<ASTPointer<EnumValue>> m_members;
@@ -393,7 +402,7 @@ class EnumValue: public Declaration
 
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
-	virtual TypePointer getType(ContractDefinition const* = nullptr) const override;
+	virtual TypePointer type(ContractDefinition const* = nullptr) const override;
 };
 
 /**
@@ -410,7 +419,7 @@ public:
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 
-	std::vector<ASTPointer<VariableDeclaration>> const& getParameters() const { return m_parameters; }
+	std::vector<ASTPointer<VariableDeclaration>> const& parameters() const { return m_parameters; }
 
 private:
 	std::vector<ASTPointer<VariableDeclaration>> m_parameters;
@@ -436,9 +445,9 @@ public:
 	{
 	}
 
-	std::vector<ASTPointer<VariableDeclaration>> const& getParameters() const { return m_parameters->getParameters(); }
-	ParameterList const& getParameterList() const { return *m_parameters; }
-	ASTPointer<ParameterList> const& getReturnParameterList() const { return m_returnParameters; }
+	std::vector<ASTPointer<VariableDeclaration>> const& parameters() const { return m_parameters->parameters(); }
+	ParameterList const& parameterList() const { return *m_parameters; }
+	ASTPointer<ParameterList> const& returnParameterList() const { return m_returnParameters; }
 
 protected:
 	ASTPointer<ParameterList> m_parameters;
@@ -474,16 +483,16 @@ public:
 
 	bool isConstructor() const { return m_isConstructor; }
 	bool isDeclaredConst() const { return m_isDeclaredConst; }
-	std::vector<ASTPointer<ModifierInvocation>> const& getModifiers() const { return m_functionModifiers; }
-	std::vector<ASTPointer<VariableDeclaration>> const& getReturnParameters() const { return m_returnParameters->getParameters(); }
-	Block const& getBody() const { return *m_body; }
+	std::vector<ASTPointer<ModifierInvocation>> const& modifiers() const { return m_functionModifiers; }
+	std::vector<ASTPointer<VariableDeclaration>> const& returnParameters() const { return m_returnParameters->parameters(); }
+	Block const& body() const { return *m_body; }
 
 	virtual bool isVisibleInContract() const override
 	{
-		return Declaration::isVisibleInContract() && !isConstructor() && !getName().empty();
+		return Declaration::isVisibleInContract() && !isConstructor() && !name().empty();
 	}
-	virtual TypePointer getType(ContractDefinition const*) const override;
-	virtual bool isPartOfExternalInterface() const override { return isPublic() && !m_isConstructor && !getName().empty(); }
+	virtual TypePointer type(ContractDefinition const*) const override;
+	virtual bool isPartOfExternalInterface() const override { return isPublic() && !m_isConstructor && !name().empty(); }
 
 	/// Checks that all parameters have allowed types and calls checkTypeRequirements on the body.
 	void checkTypeRequirements();
@@ -531,19 +540,19 @@ public:
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 
-	TypeName* getTypeName() { return m_typeName.get(); }
-	ASTPointer<Expression> const& getValue() const { return m_value; }
+	TypeName* typeName() { return m_typeName.get(); }
+	ASTPointer<Expression> const& value() const { return m_value; }
 
 	/// Returns the declared or inferred type. Can be an empty pointer if no type was explicitly
 	/// declared and there is no assignment to the variable that fixes the type.
-	TypePointer getType(ContractDefinition const* = nullptr) const override { return m_type; }
+	TypePointer type(ContractDefinition const* = nullptr) const override { return m_type; }
 	void setType(std::shared_ptr<Type const> const& _type) { m_type = _type; }
 
 	virtual bool isLValue() const override;
-	virtual bool isPartOfExternalInterface() const override { return isPublic() && !m_isConstant; }
+	virtual bool isPartOfExternalInterface() const override { return isPublic(); }
 
 	void checkTypeRequirements();
-	bool isLocalVariable() const { return !!dynamic_cast<FunctionDefinition const*>(getScope()); }
+	bool isLocalVariable() const { return !!dynamic_cast<FunctionDefinition const*>(scope()); }
 	/// @returns true if this variable is a parameter or return parameter of a function.
 	bool isCallableParameter() const;
 	/// @returns true if this variable is a parameter (not return parameter) of an external function.
@@ -554,7 +563,7 @@ public:
 	Location referenceLocation() const { return m_location; }
 
 protected:
-	Visibility getDefaultVisibility() const override { return Visibility::Internal; }
+	Visibility defaultVisibility() const override { return Visibility::Internal; }
 
 private:
 	ASTPointer<TypeName> m_typeName; ///< can be empty ("var")
@@ -589,9 +598,9 @@ public:
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 
-	Block const& getBody() const { return *m_body; }
+	Block const& body() const { return *m_body; }
 
-	virtual TypePointer getType(ContractDefinition const* = nullptr) const override;
+	virtual TypePointer type(ContractDefinition const* = nullptr) const override;
 
 	void checkTypeRequirements();
 
@@ -612,8 +621,8 @@ public:
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 
-	ASTPointer<Identifier> const& getName() const { return m_modifierName; }
-	std::vector<ASTPointer<Expression>> const& getArguments() const { return m_arguments; }
+	ASTPointer<Identifier> const& name() const { return m_modifierName; }
+	std::vector<ASTPointer<Expression>> const& arguments() const { return m_arguments; }
 
 	/// @param _bases is the list of base contracts for base constructor calls. For modifiers an empty vector should be passed.
 	void checkTypeRequirements(std::vector<ContractDefinition const*> const& _bases);
@@ -647,7 +656,7 @@ public:
 
 	bool isAnonymous() const { return m_anonymous; }
 
-	virtual TypePointer getType(ContractDefinition const* = nullptr) const override
+	virtual TypePointer type(ContractDefinition const* = nullptr) const override
 	{
 		return std::make_shared<FunctionType>(*this);
 	}
@@ -672,7 +681,7 @@ public:
 	virtual void accept(ASTConstVisitor&) const override { BOOST_THROW_EXCEPTION(InternalCompilerError()
 							<< errinfo_comment("MagicVariableDeclaration used inside real AST.")); }
 
-	virtual TypePointer getType(ContractDefinition const* = nullptr) const override { return m_type; }
+	virtual TypePointer type(ContractDefinition const* = nullptr) const override { return m_type; }
 
 private:
 	std::shared_ptr<Type const> m_type;
@@ -713,7 +722,7 @@ public:
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 	virtual std::shared_ptr<Type const> toType() override { return Type::fromElementaryTypeName(m_type); }
 
-	Token::Value getTypeName() const { return m_type; }
+	Token::Value typeName() const { return m_type; }
 
 private:
 	Token::Value m_type;
@@ -731,9 +740,9 @@ public:
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 	virtual std::shared_ptr<Type const> toType() override { return Type::fromUserDefinedTypeName(*this); }
 
-	ASTString const& getName() const { return *m_name; }
+	ASTString const& name() const { return *m_name; }
 	void setReferencedDeclaration(Declaration const& _referencedDeclaration) { m_referencedDeclaration = &_referencedDeclaration; }
-	Declaration const* getReferencedDeclaration() const { return m_referencedDeclaration; }
+	Declaration const* referencedDeclaration() const { return m_referencedDeclaration; }
 
 private:
 	ASTPointer<ASTString> m_name;
@@ -754,8 +763,8 @@ public:
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 	virtual TypePointer toType() override { return Type::fromMapping(*m_keyType, *m_valueType); }
 
-	ElementaryTypeName const& getKeyType() const { return *m_keyType; }
-	TypeName const& getValueType() const { return *m_valueType; }
+	ElementaryTypeName const& keyType() const { return *m_keyType; }
+	TypeName const& valueType() const { return *m_valueType; }
 
 private:
 	ASTPointer<ElementaryTypeName> m_keyType;
@@ -775,8 +784,8 @@ public:
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 	virtual std::shared_ptr<Type const> toType() override { return Type::fromArrayTypeName(*m_baseType, m_length.get()); }
 
-	TypeName const& getBaseType() const { return *m_baseType; }
-	Expression const* getLength() const { return m_length.get(); }
+	TypeName const& baseType() const { return *m_baseType; }
+	Expression const* length() const { return m_length.get(); }
 
 private:
 	ASTPointer<TypeName> m_baseType;
@@ -850,10 +859,10 @@ public:
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 	virtual void checkTypeRequirements() override;
 
-	Expression const& getCondition() const { return *m_condition; }
-	Statement const& getTrueStatement() const { return *m_trueBody; }
+	Expression const& condition() const { return *m_condition; }
+	Statement const& trueStatement() const { return *m_trueBody; }
 	/// @returns the "else" part of the if statement or nullptr if there is no "else" part.
-	Statement const* getFalseStatement() const { return m_falseBody.get(); }
+	Statement const* falseStatement() const { return m_falseBody.get(); }
 
 private:
 	ASTPointer<Expression> m_condition;
@@ -880,8 +889,8 @@ public:
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 	virtual void checkTypeRequirements() override;
 
-	Expression const& getCondition() const { return *m_condition; }
-	Statement const& getBody() const { return *m_body; }
+	Expression const& condition() const { return *m_condition; }
+	Statement const& body() const { return *m_body; }
 
 private:
 	ASTPointer<Expression> m_condition;
@@ -908,10 +917,10 @@ public:
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 	virtual void checkTypeRequirements() override;
 
-	Statement const* getInitializationExpression() const { return m_initExpression.get(); }
-	Expression const* getCondition() const { return m_condExpression.get(); }
-	ExpressionStatement const* getLoopExpression() const { return m_loopExpression.get(); }
-	Statement const& getBody() const { return *m_body; }
+	Statement const* initializationExpression() const { return m_initExpression.get(); }
+	Expression const* condition() const { return m_condExpression.get(); }
+	ExpressionStatement const* loopExpression() const { return m_loopExpression.get(); }
+	Statement const& body() const { return *m_body; }
 
 private:
 	/// For statement's initialization expresion. for(XXX; ; ). Can be empty
@@ -952,8 +961,8 @@ public:
 	virtual void checkTypeRequirements() override;
 
 	void setFunctionReturnParameters(ParameterList const* _parameters) { m_returnParameters = _parameters; }
-	ParameterList const* getFunctionReturnParameters() const { return m_returnParameters; }
-	Expression const* getExpression() const { return m_expression.get(); }
+	ParameterList const* functionReturnParameters() const { return m_returnParameters; }
+	Expression const* expression() const { return m_expression.get(); }
 
 private:
 	ASTPointer<Expression> m_expression; ///< value to return, optional
@@ -962,6 +971,18 @@ private:
 	ParameterList const* m_returnParameters;
 };
 
+/**
+ * @brief The Throw statement to throw that triggers a solidity exception(jump to ErrorTag)
+ */
+class Throw: public Statement
+{
+public:
+	Throw(SourceLocation const& _location): Statement(_location) {}
+	virtual void accept(ASTVisitor& _visitor) override;
+	virtual void accept(ASTConstVisitor& _visitor) const override;
+	virtual void checkTypeRequirements() override {};
+};
+
 /**
  * Definition of a variable as a statement inside a function. It requires a type name (which can
  * also be "var") but the actual assignment can be missing.
@@ -976,8 +997,8 @@ public:
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 	virtual void checkTypeRequirements() override;
 
-	VariableDeclaration const& getDeclaration() const { return *m_variable; }
-	Expression const* getExpression() const { return m_variable->getValue().get(); }
+	VariableDeclaration const& declaration() const { return *m_variable; }
+	Expression const* expression() const { return m_variable->value().get(); }
 
 private:
 	ASTPointer<VariableDeclaration> m_variable;
@@ -995,7 +1016,7 @@ public:
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 	virtual void checkTypeRequirements() override;
 
-	Expression const& getExpression() const { return *m_expression; }
+	Expression const& expression() const { return *m_expression; }
 
 private:
 	ASTPointer<Expression> m_expression;
@@ -1020,7 +1041,7 @@ public:
 	/// is used in the context of a call, used for function overload resolution.
 	virtual void checkTypeRequirements(TypePointers const* _argumentTypes) = 0;
 
-	std::shared_ptr<Type const> const& getType() const { return m_type; }
+	std::shared_ptr<Type const> const& type() const { return m_type; }
 	bool isLValue() const { return m_isLValue; }
 
 	/// Helper function, infer the type via @ref checkTypeRequirements and then check that it
@@ -1059,9 +1080,9 @@ public:
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 	virtual void checkTypeRequirements(TypePointers const* _argumentTypes) override;
 
-	Expression const& getLeftHandSide() const { return *m_leftHandSide; }
-	Token::Value getAssignmentOperator() const { return m_assigmentOperator; }
-	Expression const& getRightHandSide() const { return *m_rightHandSide; }
+	Expression const& leftHandSide() const { return *m_leftHandSide; }
+	Token::Value assignmentOperator() const { return m_assigmentOperator; }
+	Expression const& rightHandSide() const { return *m_rightHandSide; }
 
 private:
 	ASTPointer<Expression> m_leftHandSide;
@@ -1089,7 +1110,7 @@ public:
 
 	Token::Value getOperator() const { return m_operator; }
 	bool isPrefixOperation() const { return m_isPrefix; }
-	Expression const& getSubExpression() const { return *m_subExpression; }
+	Expression const& subExpression() const { return *m_subExpression; }
 
 private:
 	Token::Value m_operator;
@@ -1114,10 +1135,10 @@ public:
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 	virtual void checkTypeRequirements(TypePointers const* _argumentTypes) override;
 
-	Expression const& getLeftExpression() const { return *m_left; }
-	Expression const& getRightExpression() const { return *m_right; }
+	Expression const& leftExpression() const { return *m_left; }
+	Expression const& rightExpression() const { return *m_right; }
 	Token::Value getOperator() const { return m_operator; }
-	Type const& getCommonType() const { return *m_commonType; }
+	Type const& commonType() const { return *m_commonType; }
 
 private:
 	ASTPointer<Expression> m_left;
@@ -1142,9 +1163,9 @@ public:
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 	virtual void checkTypeRequirements(TypePointers const* _argumentTypes) override;
 
-	Expression const& getExpression() const { return *m_expression; }
-	std::vector<ASTPointer<Expression const>> getArguments() const { return {m_arguments.begin(), m_arguments.end()}; }
-	std::vector<ASTPointer<ASTString>> const& getNames() const { return m_names; }
+	Expression const& expression() const { return *m_expression; }
+	std::vector<ASTPointer<Expression const>> arguments() const { return {m_arguments.begin(), m_arguments.end()}; }
+	std::vector<ASTPointer<ASTString>> const& names() const { return m_names; }
 
 	/// @returns true if this is not an actual function call, but an explicit type conversion.
 	/// Returns false for struct constructor calls.
@@ -1171,7 +1192,7 @@ public:
 	virtual void checkTypeRequirements(TypePointers const* _argumentTypes) override;
 
 	/// Returns the referenced contract. Can only be called after type checking.
-	ContractDefinition const* getContract() const { solAssert(m_contract, ""); return m_contract; }
+	ContractDefinition const* contract() const { solAssert(m_contract, ""); return m_contract; }
 
 private:
 	ASTPointer<Identifier> m_contractName;
@@ -1190,8 +1211,8 @@ public:
 		Expression(_location), m_expression(_expression), m_memberName(_memberName) {}
 	virtual void accept(ASTVisitor& _visitor) override;
 	virtual void accept(ASTConstVisitor& _visitor) const override;
-	Expression const& getExpression() const { return *m_expression; }
-	ASTString const& getMemberName() const { return *m_memberName; }
+	Expression const& expression() const { return *m_expression; }
+	ASTString const& memberName() const { return *m_memberName; }
 	/// @returns the declaration referenced by this expression. Might return nullptr even if the
 	/// expression is valid, e.g. if the member does not correspond to an AST node.
 	Declaration const* referencedDeclaration() const { return m_referencedDeclaration; }
@@ -1219,8 +1240,8 @@ public:
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 	virtual void checkTypeRequirements(TypePointers const* _argumentTypes) override;
 
-	Expression const& getBaseExpression() const { return *m_base; }
-	Expression const* getIndexExpression() const { return m_index.get(); }
+	Expression const& baseExpression() const { return *m_base; }
+	Expression const* indexExpression() const { return m_index.get(); }
 
 private:
 	ASTPointer<Expression> m_base;
@@ -1249,7 +1270,7 @@ public:
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 	virtual void checkTypeRequirements(TypePointers const* _argumentTypes) override;
 
-	ASTString const& getName() const { return *m_name; }
+	ASTString const& name() const { return *m_name; }
 
 	void setReferencedDeclaration(
 		Declaration const& _referencedDeclaration,
@@ -1257,9 +1278,9 @@ public:
 	)
 	{
 		m_referencedDeclaration = &_referencedDeclaration;
-		m_currentContract = _currentContract;
+		m_contractScope = _currentContract;
 	}
-	Declaration const& getReferencedDeclaration() const;
+	Declaration const& referencedDeclaration() const;
 
 	/// Stores a set of possible declarations referenced by this identifier. Has to be resolved
 	/// providing argument types using overloadResolution before the referenced declaration
@@ -1273,6 +1294,8 @@ public:
 	/// argument types in a call context.
 	void overloadResolution(TypePointers const& _argumentTypes);
 
+	ContractDefinition const* contractScope() const { return m_contractScope; }
+
 private:
 	ASTPointer<ASTString> m_name;
 
@@ -1280,7 +1303,7 @@ private:
 	Declaration const* m_referencedDeclaration = nullptr;
 	/// Stores a reference to the current contract. This is needed because types of base contracts
 	/// change depending on the context.
-	ContractDefinition const* m_currentContract = nullptr;
+	ContractDefinition const* m_contractScope = nullptr;
 	/// A vector of overloaded declarations, right now only FunctionDefinition has overloaded declarations.
 	std::vector<Declaration const*> m_overloadedDeclarations;
 };
@@ -1302,7 +1325,7 @@ public:
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 	virtual void checkTypeRequirements(TypePointers const* _argumentTypes) override;
 
-	Token::Value getTypeToken() const { return m_typeToken; }
+	Token::Value typeToken() const { return m_typeToken; }
 
 private:
 	Token::Value m_typeToken;
@@ -1336,11 +1359,11 @@ public:
 	virtual void accept(ASTConstVisitor& _visitor) const override;
 	virtual void checkTypeRequirements(TypePointers const* _argumentTypes) override;
 
-	Token::Value getToken() const { return m_token; }
+	Token::Value token() const { return m_token; }
 	/// @returns the non-parsed value of the literal
-	ASTString const& getValue() const { return *m_value; }
+	ASTString const& value() const { return *m_value; }
 
-	SubDenomination getSubDenomination() const { return m_subDenomination; }
+	SubDenomination subDenomination() const { return m_subDenomination; }
 
 private:
 	Token::Value m_token;
diff --git a/libsolidity/ASTForward.h b/libsolidity/ASTForward.h
index 0ba485a2..396cf50a 100644
--- a/libsolidity/ASTForward.h
+++ b/libsolidity/ASTForward.h
@@ -64,6 +64,7 @@ class ForStatement;
 class Continue;
 class Break;
 class Return;
+class Throw;
 class VariableDeclarationStatement;
 class ExpressionStatement;
 class Expression;
diff --git a/libsolidity/ASTJsonConverter.cpp b/libsolidity/ASTJsonConverter.cpp
index 122b1c0d..96e5cf2a 100644
--- a/libsolidity/ASTJsonConverter.cpp
+++ b/libsolidity/ASTJsonConverter.cpp
@@ -90,19 +90,19 @@ Json::Value const& ASTJsonConverter::json()
 
 bool ASTJsonConverter::visit(ImportDirective const& _node)
 {
-	addJsonNode("Import", { make_pair("file", _node.getIdentifier())});
+	addJsonNode("Import", { make_pair("file", _node.identifier())});
 	return true;
 }
 
 bool ASTJsonConverter::visit(ContractDefinition const& _node)
 {
-	addJsonNode("Contract", { make_pair("name", _node.getName()) }, true);
+	addJsonNode("Contract", { make_pair("name", _node.name()) }, true);
 	return true;
 }
 
 bool ASTJsonConverter::visit(StructDefinition const& _node)
 {
-	addJsonNode("Struct", { make_pair("name", _node.getName()) }, true);
+	addJsonNode("Struct", { make_pair("name", _node.name()) }, true);
 	return true;
 }
 
@@ -115,7 +115,7 @@ bool ASTJsonConverter::visit(ParameterList const&)
 bool ASTJsonConverter::visit(FunctionDefinition const& _node)
 {
 	addJsonNode("Function",
-				{ make_pair("name", _node.getName()),
+				{ make_pair("name", _node.name()),
 					make_pair("public", boost::lexical_cast<std::string>(_node.isPublic())),
 					make_pair("const", boost::lexical_cast<std::string>(_node.isDeclaredConst())) },
 				true);
@@ -124,7 +124,7 @@ bool ASTJsonConverter::visit(FunctionDefinition const& _node)
 
 bool ASTJsonConverter::visit(VariableDeclaration const& _node)
 {
-	addJsonNode("VariableDeclaration", { make_pair("name", _node.getName()) }, true);
+	addJsonNode("VariableDeclaration", { make_pair("name", _node.name()) }, true);
 	return true;
 }
 
@@ -135,13 +135,13 @@ bool ASTJsonConverter::visit(TypeName const&)
 
 bool ASTJsonConverter::visit(ElementaryTypeName const& _node)
 {
-	addJsonNode("ElementaryTypeName", { make_pair("name", Token::toString(_node.getTypeName())) });
+	addJsonNode("ElementaryTypeName", { make_pair("name", Token::toString(_node.typeName())) });
 	return true;
 }
 
 bool ASTJsonConverter::visit(UserDefinedTypeName const& _node)
 {
-	addJsonNode("UserDefinedTypeName", { make_pair("name", _node.getName()) });
+	addJsonNode("UserDefinedTypeName", { make_pair("name", _node.name()) });
 	return true;
 }
 
@@ -193,6 +193,12 @@ bool ASTJsonConverter::visit(Return const&)
 	return true;
 }
 
+bool ASTJsonConverter::visit(Throw const&)
+{
+	addJsonNode("Throw", {}, true);;
+	return true;
+}
+
 bool ASTJsonConverter::visit(VariableDeclarationStatement const&)
 {
 	addJsonNode("VariableDefinition", {}, true);
@@ -208,8 +214,8 @@ bool ASTJsonConverter::visit(ExpressionStatement const&)
 bool ASTJsonConverter::visit(Assignment const& _node)
 {
 	addJsonNode("Assignment",
-				{ make_pair("operator", Token::toString(_node.getAssignmentOperator())),
-					make_pair("type", getType(_node)) },
+				{ make_pair("operator", Token::toString(_node.assignmentOperator())),
+					make_pair("type", type(_node)) },
 				true);
 	return true;
 }
@@ -219,7 +225,7 @@ bool ASTJsonConverter::visit(UnaryOperation const& _node)
 	addJsonNode("UnaryOperation",
 				{ make_pair("prefix", boost::lexical_cast<std::string>(_node.isPrefixOperation())),
 					make_pair("operator", Token::toString(_node.getOperator())),
-					make_pair("type", getType(_node)) },
+					make_pair("type", type(_node)) },
 				true);
 	return true;
 }
@@ -228,7 +234,7 @@ bool ASTJsonConverter::visit(BinaryOperation const& _node)
 {
 	addJsonNode("BinaryOperation",
 				{ make_pair("operator", Token::toString(_node.getOperator())),
-					make_pair("type", getType(_node))},
+					make_pair("type", type(_node))},
 				true);
 	return true;
 }
@@ -237,53 +243,53 @@ bool ASTJsonConverter::visit(FunctionCall const& _node)
 {
 	addJsonNode("FunctionCall",
 				{ make_pair("type_conversion", boost::lexical_cast<std::string>(_node.isTypeConversion())),
-					make_pair("type", getType(_node)) },
+					make_pair("type", type(_node)) },
 				true);
 	return true;
 }
 
 bool ASTJsonConverter::visit(NewExpression const& _node)
 {
-	addJsonNode("NewExpression", { make_pair("type", getType(_node)) }, true);
+	addJsonNode("NewExpression", { make_pair("type", type(_node)) }, true);
 	return true;
 }
 
 bool ASTJsonConverter::visit(MemberAccess const& _node)
 {
 	addJsonNode("MemberAccess",
-				{ make_pair("member_name", _node.getMemberName()),
-					make_pair("type", getType(_node)) },
+				{ make_pair("member_name", _node.memberName()),
+					make_pair("type", type(_node)) },
 				true);
 	return true;
 }
 
 bool ASTJsonConverter::visit(IndexAccess const& _node)
 {
-	addJsonNode("IndexAccess", { make_pair("type", getType(_node)) }, true);
+	addJsonNode("IndexAccess", { make_pair("type", type(_node)) }, true);
 	return true;
 }
 
 bool ASTJsonConverter::visit(Identifier const& _node)
 {
 	addJsonNode("Identifier",
-				{ make_pair("value", _node.getName()), make_pair("type", getType(_node)) });
+				{ make_pair("value", _node.name()), make_pair("type", type(_node)) });
 	return true;
 }
 
 bool ASTJsonConverter::visit(ElementaryTypeNameExpression const& _node)
 {
 	addJsonNode("ElementaryTypenameExpression",
-				{ make_pair("value", Token::toString(_node.getTypeToken())), make_pair("type", getType(_node)) });
+				{ make_pair("value", Token::toString(_node.typeToken())), make_pair("type", type(_node)) });
 	return true;
 }
 
 bool ASTJsonConverter::visit(Literal const& _node)
 {
-	char const* tokenString = Token::toString(_node.getToken());
+	char const* tokenString = Token::toString(_node.token());
 	addJsonNode("Literal",
 				{ make_pair("string", (tokenString) ? tokenString : "null"),
-					make_pair("value", _node.getValue()),
-					make_pair("type", getType(_node)) });
+					make_pair("value", _node.value()),
+					make_pair("type", type(_node)) });
 	return true;
 }
 
@@ -364,6 +370,11 @@ void ASTJsonConverter::endVisit(Return const&)
 	goUp();
 }
 
+void ASTJsonConverter::endVisit(Throw const&)
+{
+	goUp();
+}
+
 void ASTJsonConverter::endVisit(VariableDeclarationStatement const&)
 {
 	goUp();
@@ -428,9 +439,9 @@ void ASTJsonConverter::process()
 	processed = true;
 }
 
-string ASTJsonConverter::getType(Expression const& _expression)
+string ASTJsonConverter::type(Expression const& _expression)
 {
-	return (_expression.getType()) ? _expression.getType()->toString() : "Unknown";
+	return (_expression.type()) ? _expression.type()->toString() : "Unknown";
 }
 
 }
diff --git a/libsolidity/ASTJsonConverter.h b/libsolidity/ASTJsonConverter.h
index aaa54f7f..77230d92 100644
--- a/libsolidity/ASTJsonConverter.h
+++ b/libsolidity/ASTJsonConverter.h
@@ -63,6 +63,7 @@ public:
 	bool visit(Continue const& _node) override;
 	bool visit(Break const& _node) override;
 	bool visit(Return const& _node) override;
+	bool visit(Throw const& _node) override;
 	bool visit(VariableDeclarationStatement const& _node) override;
 	bool visit(ExpressionStatement const& _node) override;
 	bool visit(Assignment const& _node) override;
@@ -93,6 +94,7 @@ public:
 	void endVisit(Continue const&) override;
 	void endVisit(Break const&) override;
 	void endVisit(Return const&) override;
+	void endVisit(Throw const&) override;
 	void endVisit(VariableDeclarationStatement const&) override;
 	void endVisit(ExpressionStatement const&) override;
 	void endVisit(Assignment const&) override;
@@ -112,7 +114,7 @@ private:
 	void addJsonNode(std::string const& _nodeName,
 					 std::initializer_list<std::pair<std::string const, std::string const>> _list,
 					 bool _hasChildren);
-	std::string getType(Expression const& _expression);
+	std::string type(Expression const& _expression);
 	inline void goUp()
 	{
 		solAssert(!m_jsonNodePtrs.empty(), "Uneven json nodes stack. Internal error.");
diff --git a/libsolidity/ASTPrinter.cpp b/libsolidity/ASTPrinter.cpp
index d29ace17..8ed45d87 100644
--- a/libsolidity/ASTPrinter.cpp
+++ b/libsolidity/ASTPrinter.cpp
@@ -48,41 +48,41 @@ void ASTPrinter::print(ostream& _stream)
 
 bool ASTPrinter::visit(ImportDirective const& _node)
 {
-	writeLine("ImportDirective \"" + _node.getIdentifier() + "\"");
+	writeLine("ImportDirective \"" + _node.identifier() + "\"");
 	printSourcePart(_node);
 	return goDeeper();
 }
 
 bool ASTPrinter::visit(ContractDefinition const& _node)
 {
-	writeLine("ContractDefinition \"" + _node.getName() + "\"");
+	writeLine("ContractDefinition \"" + _node.name() + "\"");
 	printSourcePart(_node);
 	return goDeeper();
 }
 
 bool ASTPrinter::visit(InheritanceSpecifier const& _node)
 {
-	writeLine("InheritanceSpecifier \"" + _node.getName()->getName() + "\"");
+	writeLine("InheritanceSpecifier \"" + _node.name()->name() + "\"");
 	printSourcePart(_node);
 	return goDeeper();
 }
 
 bool ASTPrinter::visit(StructDefinition const& _node)
 {
-	writeLine("StructDefinition \"" + _node.getName() + "\"");
+	writeLine("StructDefinition \"" + _node.name() + "\"");
 	printSourcePart(_node);
 	return goDeeper();
 }
 
 bool ASTPrinter::visit(EnumDefinition const& _node)
 {
-	writeLine("EnumDefinition \"" + _node.getName() + "\"");
+	writeLine("EnumDefinition \"" + _node.name() + "\"");
 	return goDeeper();
 }
 
 bool ASTPrinter::visit(EnumValue const& _node)
 {
-	writeLine("EnumValue \"" + _node.getName() + "\"");
+	writeLine("EnumValue \"" + _node.name() + "\"");
 	return goDeeper();
 }
 
@@ -95,7 +95,7 @@ bool ASTPrinter::visit(ParameterList const& _node)
 
 bool ASTPrinter::visit(FunctionDefinition const& _node)
 {
-	writeLine("FunctionDefinition \"" + _node.getName() + "\"" +
+	writeLine("FunctionDefinition \"" + _node.name() + "\"" +
 			  (_node.isPublic() ? " - public" : "") +
 			  (_node.isDeclaredConst() ? " - const" : ""));
 	printSourcePart(_node);
@@ -104,28 +104,28 @@ bool ASTPrinter::visit(FunctionDefinition const& _node)
 
 bool ASTPrinter::visit(VariableDeclaration const& _node)
 {
-	writeLine("VariableDeclaration \"" + _node.getName() + "\"");
+	writeLine("VariableDeclaration \"" + _node.name() + "\"");
 	printSourcePart(_node);
 	return goDeeper();
 }
 
 bool ASTPrinter::visit(ModifierDefinition const& _node)
 {
-	writeLine("ModifierDefinition \"" + _node.getName() + "\"");
+	writeLine("ModifierDefinition \"" + _node.name() + "\"");
 	printSourcePart(_node);
 	return goDeeper();
 }
 
 bool ASTPrinter::visit(ModifierInvocation const& _node)
 {
-	writeLine("ModifierInvocation \"" + _node.getName()->getName() + "\"");
+	writeLine("ModifierInvocation \"" + _node.name()->name() + "\"");
 	printSourcePart(_node);
 	return goDeeper();
 }
 
 bool ASTPrinter::visit(EventDefinition const& _node)
 {
-	writeLine("EventDefinition \"" + _node.getName() + "\"");
+	writeLine("EventDefinition \"" + _node.name() + "\"");
 	printSourcePart(_node);
 	return goDeeper();
 }
@@ -139,14 +139,14 @@ bool ASTPrinter::visit(TypeName const& _node)
 
 bool ASTPrinter::visit(ElementaryTypeName const& _node)
 {
-	writeLine(string("ElementaryTypeName ") + Token::toString(_node.getTypeName()));
+	writeLine(string("ElementaryTypeName ") + Token::toString(_node.typeName()));
 	printSourcePart(_node);
 	return goDeeper();
 }
 
 bool ASTPrinter::visit(UserDefinedTypeName const& _node)
 {
-	writeLine("UserDefinedTypeName \"" + _node.getName() + "\"");
+	writeLine("UserDefinedTypeName \"" + _node.name() + "\"");
 	printSourcePart(_node);
 	return goDeeper();
 }
@@ -221,6 +221,13 @@ bool ASTPrinter::visit(Return const& _node)
 	return goDeeper();
 }
 
+bool ASTPrinter::visit(Throw const& _node)
+{
+	writeLine("Throw");
+	printSourcePart(_node);
+	return goDeeper();
+}
+
 bool ASTPrinter::visit(VariableDeclarationStatement const& _node)
 {
 	writeLine("VariableDeclarationStatement");
@@ -237,7 +244,7 @@ bool ASTPrinter::visit(ExpressionStatement const& _node)
 
 bool ASTPrinter::visit(Assignment const& _node)
 {
-	writeLine(string("Assignment using operator ") + Token::toString(_node.getAssignmentOperator()));
+	writeLine(string("Assignment using operator ") + Token::toString(_node.assignmentOperator()));
 	printType(_node);
 	printSourcePart(_node);
 	return goDeeper();
@@ -278,7 +285,7 @@ bool ASTPrinter::visit(NewExpression const& _node)
 
 bool ASTPrinter::visit(MemberAccess const& _node)
 {
-	writeLine("MemberAccess to member " + _node.getMemberName());
+	writeLine("MemberAccess to member " + _node.memberName());
 	printType(_node);
 	printSourcePart(_node);
 	return goDeeper();
@@ -294,7 +301,7 @@ bool ASTPrinter::visit(IndexAccess const& _node)
 
 bool ASTPrinter::visit(Identifier const& _node)
 {
-	writeLine(string("Identifier ") + _node.getName());
+	writeLine(string("Identifier ") + _node.name());
 	printType(_node);
 	printSourcePart(_node);
 	return goDeeper();
@@ -302,7 +309,7 @@ bool ASTPrinter::visit(Identifier const& _node)
 
 bool ASTPrinter::visit(ElementaryTypeNameExpression const& _node)
 {
-	writeLine(string("ElementaryTypeNameExpression ") + Token::toString(_node.getTypeToken()));
+	writeLine(string("ElementaryTypeNameExpression ") + Token::toString(_node.typeToken()));
 	printType(_node);
 	printSourcePart(_node);
 	return goDeeper();
@@ -310,10 +317,10 @@ bool ASTPrinter::visit(ElementaryTypeNameExpression const& _node)
 
 bool ASTPrinter::visit(Literal const& _node)
 {
-	char const* tokenString = Token::toString(_node.getToken());
+	char const* tokenString = Token::toString(_node.token());
 	if (!tokenString)
 		tokenString = "[no token]";
-	writeLine(string("Literal, token: ") + tokenString + " value: " + _node.getValue());
+	writeLine(string("Literal, token: ") + tokenString + " value: " + _node.value());
 	printType(_node);
 	printSourcePart(_node);
 	return goDeeper();
@@ -444,6 +451,11 @@ void ASTPrinter::endVisit(Return const&)
 	m_indentation--;
 }
 
+void ASTPrinter::endVisit(Throw const&)
+{
+	m_indentation--;
+}
+
 void ASTPrinter::endVisit(VariableDeclarationStatement const&)
 {
 	m_indentation--;
@@ -507,31 +519,31 @@ void ASTPrinter::endVisit(Literal const&)
 void ASTPrinter::printSourcePart(ASTNode const& _node)
 {
 	if (m_gasCosts.count(&_node))
-		*m_ostream << getIndentation() << "   Gas costs: " << m_gasCosts.at(&_node) << endl;
+		*m_ostream << indentation() << "   Gas costs: " << m_gasCosts.at(&_node) << endl;
 	if (!m_source.empty())
 	{
-		SourceLocation const& location(_node.getLocation());
-		*m_ostream << getIndentation() << "   Source: "
+		SourceLocation const& location(_node.location());
+		*m_ostream << indentation() << "   Source: "
 				   << escaped(m_source.substr(location.start, location.end - location.start), false) << endl;
 	}
 }
 
 void ASTPrinter::printType(Expression const& _expression)
 {
-	if (_expression.getType())
-		*m_ostream << getIndentation() << "   Type: " << _expression.getType()->toString() << "\n";
+	if (_expression.type())
+		*m_ostream << indentation() << "   Type: " << _expression.type()->toString() << "\n";
 	else
-		*m_ostream << getIndentation() << "   Type unknown.\n";
+		*m_ostream << indentation() << "   Type unknown.\n";
 }
 
-string ASTPrinter::getIndentation() const
+string ASTPrinter::indentation() const
 {
 	return string(m_indentation * 2, ' ');
 }
 
 void ASTPrinter::writeLine(string const& _line)
 {
-	*m_ostream << getIndentation() << _line << endl;
+	*m_ostream << indentation() << _line << endl;
 }
 
 }
diff --git a/libsolidity/ASTPrinter.h b/libsolidity/ASTPrinter.h
index cdf651f3..a12ec0aa 100644
--- a/libsolidity/ASTPrinter.h
+++ b/libsolidity/ASTPrinter.h
@@ -72,6 +72,7 @@ public:
 	bool visit(Continue const& _node) override;
 	bool visit(Break const& _node) override;
 	bool visit(Return const& _node) override;
+	bool visit(Throw const& _node) override;
 	bool visit(VariableDeclarationStatement const& _node) override;
 	bool visit(ExpressionStatement const& _node) override;
 	bool visit(Assignment const& _node) override;
@@ -110,6 +111,7 @@ public:
 	void endVisit(Continue const&) override;
 	void endVisit(Break const&) override;
 	void endVisit(Return const&) override;
+	void endVisit(Throw const&) override;
 	void endVisit(VariableDeclarationStatement const&) override;
 	void endVisit(ExpressionStatement const&) override;
 	void endVisit(Assignment const&) override;
@@ -126,7 +128,7 @@ public:
 private:
 	void printSourcePart(ASTNode const& _node);
 	void printType(Expression const& _expression);
-	std::string getIndentation() const;
+	std::string indentation() const;
 	void writeLine(std::string const& _line);
 	bool goDeeper() { m_indentation++; return true; }
 
diff --git a/libsolidity/ASTUtils.cpp b/libsolidity/ASTUtils.cpp
index 081d6b31..a617bf94 100644
--- a/libsolidity/ASTUtils.cpp
+++ b/libsolidity/ASTUtils.cpp
@@ -39,7 +39,7 @@ ASTNode const* LocationFinder::leastUpperBound()
 
 bool LocationFinder::visitNode(const ASTNode& _node)
 {
-	if (_node.getLocation().contains(m_location))
+	if (_node.location().contains(m_location))
 	{
 		m_bestMatch = &_node;
 		return true;
diff --git a/libsolidity/ASTVisitor.h b/libsolidity/ASTVisitor.h
index f7847220..e665396c 100644
--- a/libsolidity/ASTVisitor.h
+++ b/libsolidity/ASTVisitor.h
@@ -69,6 +69,7 @@ public:
 	virtual bool visit(Continue& _node) { return visitNode(_node); }
 	virtual bool visit(Break& _node) { return visitNode(_node); }
 	virtual bool visit(Return& _node) { return visitNode(_node); }
+	virtual bool visit(Throw& _node) { return visitNode(_node); }
 	virtual bool visit(VariableDeclarationStatement& _node) { return visitNode(_node); }
 	virtual bool visit(ExpressionStatement& _node) { return visitNode(_node); }
 	virtual bool visit(Assignment& _node) { return visitNode(_node); }
@@ -108,6 +109,7 @@ public:
 	virtual void endVisit(Continue& _node) { endVisitNode(_node); }
 	virtual void endVisit(Break& _node) { endVisitNode(_node); }
 	virtual void endVisit(Return& _node) { endVisitNode(_node); }
+	virtual void endVisit(Throw& _node) { endVisitNode(_node); }
 	virtual void endVisit(VariableDeclarationStatement& _node) { endVisitNode(_node); }
 	virtual void endVisit(ExpressionStatement& _node) { endVisitNode(_node); }
 	virtual void endVisit(Assignment& _node) { endVisitNode(_node); }
@@ -159,6 +161,7 @@ public:
 	virtual bool visit(Continue const& _node) { return visitNode(_node); }
 	virtual bool visit(Break const& _node) { return visitNode(_node); }
 	virtual bool visit(Return const& _node) { return visitNode(_node); }
+	virtual bool visit(Throw const& _node) { return visitNode(_node); }
 	virtual bool visit(VariableDeclarationStatement const& _node) { return visitNode(_node); }
 	virtual bool visit(ExpressionStatement const& _node) { return visitNode(_node); }
 	virtual bool visit(Assignment const& _node) { return visitNode(_node); }
@@ -198,6 +201,7 @@ public:
 	virtual void endVisit(Continue const& _node) { endVisitNode(_node); }
 	virtual void endVisit(Break const& _node) { endVisitNode(_node); }
 	virtual void endVisit(Return const& _node) { endVisitNode(_node); }
+	virtual void endVisit(Throw const& _node) { endVisitNode(_node); }
 	virtual void endVisit(VariableDeclarationStatement const& _node) { endVisitNode(_node); }
 	virtual void endVisit(ExpressionStatement const& _node) { endVisitNode(_node); }
 	virtual void endVisit(Assignment const& _node) { endVisitNode(_node); }
diff --git a/libsolidity/AST_accept.h b/libsolidity/AST_accept.h
index 3557f877..1388466c 100644
--- a/libsolidity/AST_accept.h
+++ b/libsolidity/AST_accept.h
@@ -491,6 +491,18 @@ void Return::accept(ASTConstVisitor& _visitor) const
 	_visitor.endVisit(*this);
 }
 
+void Throw::accept(ASTVisitor& _visitor)
+{
+	_visitor.visit(*this);
+	_visitor.endVisit(*this);
+}
+
+void Throw::accept(ASTConstVisitor& _visitor) const
+{
+	_visitor.visit(*this);
+	_visitor.endVisit(*this);
+}
+
 void ExpressionStatement::accept(ASTVisitor& _visitor)
 {
 	if (_visitor.visit(*this))
diff --git a/libsolidity/ArrayUtils.cpp b/libsolidity/ArrayUtils.cpp
index 48ee5a05..32dde8a5 100644
--- a/libsolidity/ArrayUtils.cpp
+++ b/libsolidity/ArrayUtils.cpp
@@ -41,21 +41,21 @@ void ArrayUtils::copyArrayToStorage(ArrayType const& _targetType, ArrayType cons
 	solAssert(_targetType.location() == DataLocation::Storage, "");
 
 	IntegerType uint256(256);
-	Type const* targetBaseType = _targetType.isByteArray() ? &uint256 : &(*_targetType.getBaseType());
-	Type const* sourceBaseType = _sourceType.isByteArray() ? &uint256 : &(*_sourceType.getBaseType());
+	Type const* targetBaseType = _targetType.isByteArray() ? &uint256 : &(*_targetType.baseType());
+	Type const* sourceBaseType = _sourceType.isByteArray() ? &uint256 : &(*_sourceType.baseType());
 
 	// TODO unroll loop for small sizes
 
 	bool sourceIsStorage = _sourceType.location() == DataLocation::Storage;
 	bool fromCalldata = _sourceType.location() == DataLocation::CallData;
 	bool directCopy = sourceIsStorage && sourceBaseType->isValueType() && *sourceBaseType == *targetBaseType;
-	bool haveByteOffsetSource = !directCopy && sourceIsStorage && sourceBaseType->getStorageBytes() <= 16;
-	bool haveByteOffsetTarget = !directCopy && targetBaseType->getStorageBytes() <= 16;
+	bool haveByteOffsetSource = !directCopy && sourceIsStorage && sourceBaseType->storageBytes() <= 16;
+	bool haveByteOffsetTarget = !directCopy && targetBaseType->storageBytes() <= 16;
 	unsigned byteOffsetSize = (haveByteOffsetSource ? 1 : 0) + (haveByteOffsetTarget ? 1 : 0);
 
 	// stack: source_ref [source_length] target_ref
 	// store target_ref
-	for (unsigned i = _sourceType.getSizeOnStack(); i > 0; --i)
+	for (unsigned i = _sourceType.sizeOnStack(); i > 0; --i)
 		m_context << eth::swapInstruction(i);
 	// stack: target_ref source_ref [source_length]
 	// stack: target_ref source_ref [source_length]
@@ -77,9 +77,9 @@ void ArrayUtils::copyArrayToStorage(ArrayType const& _targetType, ArrayType cons
 	if (_targetType.isDynamicallySized())
 		// store new target length
 		m_context << eth::Instruction::DUP3 << eth::Instruction::DUP3 << eth::Instruction::SSTORE;
-	if (sourceBaseType->getCategory() == Type::Category::Mapping)
+	if (sourceBaseType->category() == Type::Category::Mapping)
 	{
-		solAssert(targetBaseType->getCategory() == Type::Category::Mapping, "");
+		solAssert(targetBaseType->category() == Type::Category::Mapping, "");
 		solAssert(_sourceType.location() == DataLocation::Storage, "");
 		// nothing to copy
 		m_context
@@ -125,7 +125,7 @@ void ArrayUtils::copyArrayToStorage(ArrayType const& _targetType, ArrayType cons
 	m_context.appendConditionalJumpTo(copyLoopEnd);
 	// stack: target_ref target_data_end source_data_pos target_data_pos source_data_end [target_byte_offset] [source_byte_offset]
 	// copy
-	if (sourceBaseType->getCategory() == Type::Category::Array)
+	if (sourceBaseType->category() == Type::Category::Array)
 	{
 		solAssert(byteOffsetSize == 0, "Byte offset for array as base type.");
 		auto const& sourceBaseArrayType = dynamic_cast<ArrayType const&>(*sourceBaseType);
@@ -164,13 +164,13 @@ void ArrayUtils::copyArrayToStorage(ArrayType const& _targetType, ArrayType cons
 			solAssert(false, "Copying of type " + _sourceType.toString(false) + " to storage not yet supported.");
 		// stack: target_ref target_data_end source_data_pos target_data_pos source_data_end [target_byte_offset] [source_byte_offset] <source_value>...
 		solAssert(
-			2 + byteOffsetSize + sourceBaseType->getSizeOnStack() <= 16,
+			2 + byteOffsetSize + sourceBaseType->sizeOnStack() <= 16,
 			"Stack too deep, try removing local variables."
 		);
 		// fetch target storage reference
-		m_context << eth::dupInstruction(2 + byteOffsetSize + sourceBaseType->getSizeOnStack());
+		m_context << eth::dupInstruction(2 + byteOffsetSize + sourceBaseType->sizeOnStack());
 		if (haveByteOffsetTarget)
-			m_context << eth::dupInstruction(1 + byteOffsetSize + sourceBaseType->getSizeOnStack());
+			m_context << eth::dupInstruction(1 + byteOffsetSize + sourceBaseType->sizeOnStack());
 		else
 			m_context << u256(0);
 		StorageItem(m_context, *targetBaseType).storeValue(*sourceBaseType, SourceLocation(), true);
@@ -178,27 +178,27 @@ void ArrayUtils::copyArrayToStorage(ArrayType const& _targetType, ArrayType cons
 	// stack: target_ref target_data_end source_data_pos target_data_pos source_data_end [target_byte_offset] [source_byte_offset]
 	// increment source
 	if (haveByteOffsetSource)
-		incrementByteOffset(sourceBaseType->getStorageBytes(), 1, haveByteOffsetTarget ? 5 : 4);
+		incrementByteOffset(sourceBaseType->storageBytes(), 1, haveByteOffsetTarget ? 5 : 4);
 	else
 	{
 		m_context << eth::swapInstruction(2 + byteOffsetSize);
 		if (sourceIsStorage)
-			m_context << sourceBaseType->getStorageSize();
+			m_context << sourceBaseType->storageSize();
 		else if (_sourceType.location() == DataLocation::Memory)
 			m_context << sourceBaseType->memoryHeadSize();
 		else
-			m_context << sourceBaseType->getCalldataEncodedSize(true);
+			m_context << sourceBaseType->calldataEncodedSize(true);
 		m_context
 			<< eth::Instruction::ADD
 			<< eth::swapInstruction(2 + byteOffsetSize);
 	}
 	// increment target
 	if (haveByteOffsetTarget)
-		incrementByteOffset(targetBaseType->getStorageBytes(), byteOffsetSize, byteOffsetSize + 2);
+		incrementByteOffset(targetBaseType->storageBytes(), byteOffsetSize, byteOffsetSize + 2);
 	else
 		m_context
 			<< eth::swapInstruction(1 + byteOffsetSize)
-			<< targetBaseType->getStorageSize()
+			<< targetBaseType->storageSize()
 			<< eth::Instruction::ADD
 			<< eth::swapInstruction(1 + byteOffsetSize);
 	m_context.appendJumpTo(copyLoopStart);
@@ -211,7 +211,7 @@ void ArrayUtils::copyArrayToStorage(ArrayType const& _targetType, ArrayType cons
 		eth::AssemblyItem copyCleanupLoopEnd = m_context.appendConditionalJump();
 		m_context << eth::dupInstruction(2 + byteOffsetSize) << eth::dupInstruction(1 + byteOffsetSize);
 		StorageItem(m_context, *targetBaseType).setToZero(SourceLocation(), true);
-		incrementByteOffset(targetBaseType->getStorageBytes(), byteOffsetSize, byteOffsetSize + 2);
+		incrementByteOffset(targetBaseType->storageBytes(), byteOffsetSize, byteOffsetSize + 2);
 		m_context.appendJumpTo(copyLoopEnd);
 
 		m_context << copyCleanupLoopEnd;
@@ -232,19 +232,19 @@ void ArrayUtils::copyArrayToStorage(ArrayType const& _targetType, ArrayType cons
 void ArrayUtils::copyArrayToMemory(const ArrayType& _sourceType, bool _padToWordBoundaries) const
 {
 	solAssert(
-		_sourceType.getBaseType()->getCalldataEncodedSize() > 0,
+		_sourceType.baseType()->calldataEncodedSize() > 0,
 		"Nested dynamic arrays not implemented here."
 	);
 	CompilerUtils utils(m_context);
 	unsigned baseSize = 1;
 	if (!_sourceType.isByteArray())
 		// We always pad the elements, regardless of _padToWordBoundaries.
-		baseSize = _sourceType.getBaseType()->getCalldataEncodedSize();
+		baseSize = _sourceType.baseType()->calldataEncodedSize();
 
 	if (_sourceType.location() == DataLocation::CallData)
 	{
 		if (!_sourceType.isDynamicallySized())
-			m_context << _sourceType.getLength();
+			m_context << _sourceType.length();
 		if (baseSize > 1)
 			m_context << u256(baseSize) << eth::Instruction::MUL;
 		// stack: target source_offset source_len
@@ -258,7 +258,7 @@ void ArrayUtils::copyArrayToMemory(const ArrayType& _sourceType, bool _padToWord
 	{
 		retrieveLength(_sourceType);
 		// stack: target source length
-		if (!_sourceType.getBaseType()->isValueType())
+		if (!_sourceType.baseType()->isValueType())
 		{
 			// copy using a loop
 			m_context << u256(0) << eth::Instruction::SWAP3;
@@ -270,11 +270,11 @@ void ArrayUtils::copyArrayToMemory(const ArrayType& _sourceType, bool _padToWord
 			auto loopEnd = m_context.appendConditionalJump();
 			m_context << eth::Instruction::DUP3 << eth::Instruction::DUP5;
 			accessIndex(_sourceType, false);
-			MemoryItem(m_context, *_sourceType.getBaseType(), true).retrieveValue(SourceLocation(), true);
-			if (auto baseArray = dynamic_cast<ArrayType const*>(_sourceType.getBaseType().get()))
+			MemoryItem(m_context, *_sourceType.baseType(), true).retrieveValue(SourceLocation(), true);
+			if (auto baseArray = dynamic_cast<ArrayType const*>(_sourceType.baseType().get()))
 				copyArrayToMemory(*baseArray, _padToWordBoundaries);
 			else
-				utils.storeInMemoryDynamic(*_sourceType.getBaseType());
+				utils.storeInMemoryDynamic(*_sourceType.baseType());
 			m_context << eth::Instruction::SWAP3 << u256(1) << eth::Instruction::ADD;
 			m_context << eth::Instruction::SWAP3;
 			m_context.appendJumpTo(repeat);
@@ -307,7 +307,7 @@ void ArrayUtils::copyArrayToMemory(const ArrayType& _sourceType, bool _padToWord
 		if (_sourceType.isDynamicallySized())
 			paddingNeeded = _padToWordBoundaries && ((baseSize % 32) != 0);
 		else
-			paddingNeeded = _padToWordBoundaries && (((_sourceType.getLength() * baseSize) % 32) != 0);
+			paddingNeeded = _padToWordBoundaries && (((_sourceType.length() * baseSize) % 32) != 0);
 		if (paddingNeeded)
 		{
 			// stack: <target> <size>
@@ -352,8 +352,8 @@ void ArrayUtils::copyArrayToMemory(const ArrayType& _sourceType, bool _padToWord
 	else
 	{
 		solAssert(_sourceType.location() == DataLocation::Storage, "");
-		unsigned storageBytes = _sourceType.getBaseType()->getStorageBytes();
-		u256 storageSize = _sourceType.getBaseType()->getStorageSize();
+		unsigned storageBytes = _sourceType.baseType()->storageBytes();
+		u256 storageSize = _sourceType.baseType()->storageSize();
 		solAssert(storageSize > 1 || (storageSize == 1 && storageBytes > 0), "");
 
 		retrieveLength(_sourceType);
@@ -400,11 +400,11 @@ void ArrayUtils::copyArrayToMemory(const ArrayType& _sourceType, bool _padToWord
 				m_context << eth::Instruction::DUP3 << eth::Instruction::DUP3;
 			else
 				m_context << eth::Instruction::DUP2 << u256(0);
-			StorageItem(m_context, *_sourceType.getBaseType()).retrieveValue(SourceLocation(), true);
-			if (auto baseArray = dynamic_cast<ArrayType const*>(_sourceType.getBaseType().get()))
+			StorageItem(m_context, *_sourceType.baseType()).retrieveValue(SourceLocation(), true);
+			if (auto baseArray = dynamic_cast<ArrayType const*>(_sourceType.baseType().get()))
 				copyArrayToMemory(*baseArray, _padToWordBoundaries);
 			else
-				utils.storeInMemoryDynamic(*_sourceType.getBaseType());
+				utils.storeInMemoryDynamic(*_sourceType.baseType());
 			// increment storage_data_offset and byte offset
 			if (haveByteOffset)
 				incrementByteOffset(storageBytes, 2, 3);
@@ -438,58 +438,58 @@ void ArrayUtils::copyArrayToMemory(const ArrayType& _sourceType, bool _padToWord
 
 void ArrayUtils::clearArray(ArrayType const& _type) const
 {
-	unsigned stackHeightStart = m_context.getStackHeight();
+	unsigned stackHeightStart = m_context.stackHeight();
 	solAssert(_type.location() == DataLocation::Storage, "");
-	if (_type.getBaseType()->getStorageBytes() < 32)
+	if (_type.baseType()->storageBytes() < 32)
 	{
-		solAssert(_type.getBaseType()->isValueType(), "Invalid storage size for non-value type.");
-		solAssert(_type.getBaseType()->getStorageSize() <= 1, "Invalid storage size for type.");
+		solAssert(_type.baseType()->isValueType(), "Invalid storage size for non-value type.");
+		solAssert(_type.baseType()->storageSize() <= 1, "Invalid storage size for type.");
 	}
-	if (_type.getBaseType()->isValueType())
-		solAssert(_type.getBaseType()->getStorageSize() <= 1, "Invalid size for value type.");
+	if (_type.baseType()->isValueType())
+		solAssert(_type.baseType()->storageSize() <= 1, "Invalid size for value type.");
 
 	m_context << eth::Instruction::POP; // remove byte offset
 	if (_type.isDynamicallySized())
 		clearDynamicArray(_type);
-	else if (_type.getLength() == 0 || _type.getBaseType()->getCategory() == Type::Category::Mapping)
+	else if (_type.length() == 0 || _type.baseType()->category() == Type::Category::Mapping)
 		m_context << eth::Instruction::POP;
-	else if (_type.getBaseType()->isValueType() && _type.getStorageSize() <= 5)
+	else if (_type.baseType()->isValueType() && _type.storageSize() <= 5)
 	{
 		// unroll loop for small arrays @todo choose a good value
 		// Note that we loop over storage slots here, not elements.
-		for (unsigned i = 1; i < _type.getStorageSize(); ++i)
+		for (unsigned i = 1; i < _type.storageSize(); ++i)
 			m_context
 				<< u256(0) << eth::Instruction::DUP2 << eth::Instruction::SSTORE
 				<< u256(1) << eth::Instruction::ADD;
 		m_context << u256(0) << eth::Instruction::SWAP1 << eth::Instruction::SSTORE;
 	}
-	else if (!_type.getBaseType()->isValueType() && _type.getLength() <= 4)
+	else if (!_type.baseType()->isValueType() && _type.length() <= 4)
 	{
 		// unroll loop for small arrays @todo choose a good value
-		solAssert(_type.getBaseType()->getStorageBytes() >= 32, "Invalid storage size.");
-		for (unsigned i = 1; i < _type.getLength(); ++i)
+		solAssert(_type.baseType()->storageBytes() >= 32, "Invalid storage size.");
+		for (unsigned i = 1; i < _type.length(); ++i)
 		{
 			m_context << u256(0);
-			StorageItem(m_context, *_type.getBaseType()).setToZero(SourceLocation(), false);
+			StorageItem(m_context, *_type.baseType()).setToZero(SourceLocation(), false);
 			m_context
 				<< eth::Instruction::POP
-				<< u256(_type.getBaseType()->getStorageSize()) << eth::Instruction::ADD;
+				<< u256(_type.baseType()->storageSize()) << eth::Instruction::ADD;
 		}
 		m_context << u256(0);
-		StorageItem(m_context, *_type.getBaseType()).setToZero(SourceLocation(), true);
+		StorageItem(m_context, *_type.baseType()).setToZero(SourceLocation(), true);
 	}
 	else
 	{
-		m_context << eth::Instruction::DUP1 << _type.getLength();
+		m_context << eth::Instruction::DUP1 << _type.length();
 		convertLengthToSize(_type);
 		m_context << eth::Instruction::ADD << eth::Instruction::SWAP1;
-		if (_type.getBaseType()->getStorageBytes() < 32)
+		if (_type.baseType()->storageBytes() < 32)
 			clearStorageLoop(IntegerType(256));
 		else
-			clearStorageLoop(*_type.getBaseType());
+			clearStorageLoop(*_type.baseType());
 		m_context << eth::Instruction::POP;
 	}
-	solAssert(m_context.getStackHeight() == stackHeightStart - 2, "");
+	solAssert(m_context.stackHeight() == stackHeightStart - 2, "");
 }
 
 void ArrayUtils::clearDynamicArray(ArrayType const& _type) const
@@ -497,7 +497,7 @@ void ArrayUtils::clearDynamicArray(ArrayType const& _type) const
 	solAssert(_type.location() == DataLocation::Storage, "");
 	solAssert(_type.isDynamicallySized(), "");
 
-	unsigned stackHeightStart = m_context.getStackHeight();
+	unsigned stackHeightStart = m_context.stackHeight();
 	// fetch length
 	m_context << eth::Instruction::DUP1 << eth::Instruction::SLOAD;
 	// set length to zero
@@ -511,23 +511,23 @@ void ArrayUtils::clearDynamicArray(ArrayType const& _type) const
 	m_context << eth::Instruction::SWAP1 << eth::Instruction::DUP2 << eth::Instruction::ADD
 		<< eth::Instruction::SWAP1;
 	// stack: data_pos_end data_pos
-	if (_type.isByteArray() || _type.getBaseType()->getStorageBytes() < 32)
+	if (_type.isByteArray() || _type.baseType()->storageBytes() < 32)
 		clearStorageLoop(IntegerType(256));
 	else
-		clearStorageLoop(*_type.getBaseType());
+		clearStorageLoop(*_type.baseType());
 	// cleanup
 	m_context << eth::Instruction::POP;
-	solAssert(m_context.getStackHeight() == stackHeightStart - 1, "");
+	solAssert(m_context.stackHeight() == stackHeightStart - 1, "");
 }
 
 void ArrayUtils::resizeDynamicArray(const ArrayType& _type) const
 {
 	solAssert(_type.location() == DataLocation::Storage, "");
 	solAssert(_type.isDynamicallySized(), "");
-	if (!_type.isByteArray() && _type.getBaseType()->getStorageBytes() < 32)
-		solAssert(_type.getBaseType()->isValueType(), "Invalid storage size for non-value type.");
+	if (!_type.isByteArray() && _type.baseType()->storageBytes() < 32)
+		solAssert(_type.baseType()->isValueType(), "Invalid storage size for non-value type.");
 
-	unsigned stackHeightStart = m_context.getStackHeight();
+	unsigned stackHeightStart = m_context.stackHeight();
 	eth::AssemblyItem resizeEnd = m_context.newTag();
 
 	// stack: ref new_length
@@ -555,21 +555,21 @@ void ArrayUtils::resizeDynamicArray(const ArrayType& _type) const
 	// stack: ref new_length data_pos new_size delete_end
 	m_context << eth::Instruction::SWAP2 << eth::Instruction::ADD;
 	// stack: ref new_length delete_end delete_start
-	if (_type.isByteArray() || _type.getBaseType()->getStorageBytes() < 32)
+	if (_type.isByteArray() || _type.baseType()->storageBytes() < 32)
 		clearStorageLoop(IntegerType(256));
 	else
-		clearStorageLoop(*_type.getBaseType());
+		clearStorageLoop(*_type.baseType());
 
 	m_context << resizeEnd;
 	// cleanup
 	m_context << eth::Instruction::POP << eth::Instruction::POP << eth::Instruction::POP;
-	solAssert(m_context.getStackHeight() == stackHeightStart - 2, "");
+	solAssert(m_context.stackHeight() == stackHeightStart - 2, "");
 }
 
 void ArrayUtils::clearStorageLoop(Type const& _type) const
 {
-	unsigned stackHeightStart = m_context.getStackHeight();
-	if (_type.getCategory() == Type::Category::Mapping)
+	unsigned stackHeightStart = m_context.stackHeight();
+	if (_type.category() == Type::Category::Mapping)
 	{
 		m_context << eth::Instruction::POP;
 		return;
@@ -602,16 +602,16 @@ void ArrayUtils::clearStorageLoop(Type const& _type) const
 	m_context << eth::Instruction::JUMP;
 
 	m_context << returnTag;
-	solAssert(m_context.getStackHeight() == stackHeightStart - 1, "");
+	solAssert(m_context.stackHeight() == stackHeightStart - 1, "");
 }
 
 void ArrayUtils::convertLengthToSize(ArrayType const& _arrayType, bool _pad) const
 {
 	if (_arrayType.location() == DataLocation::Storage)
 	{
-		if (_arrayType.getBaseType()->getStorageSize() <= 1)
+		if (_arrayType.baseType()->storageSize() <= 1)
 		{
-			unsigned baseBytes = _arrayType.getBaseType()->getStorageBytes();
+			unsigned baseBytes = _arrayType.baseType()->storageBytes();
 			if (baseBytes == 0)
 				m_context << eth::Instruction::POP << u256(1);
 			else if (baseBytes <= 16)
@@ -623,16 +623,16 @@ void ArrayUtils::convertLengthToSize(ArrayType const& _arrayType, bool _pad) con
 			}
 		}
 		else
-			m_context << _arrayType.getBaseType()->getStorageSize() << eth::Instruction::MUL;
+			m_context << _arrayType.baseType()->storageSize() << eth::Instruction::MUL;
 	}
 	else
 	{
 		if (!_arrayType.isByteArray())
 		{
 			if (_arrayType.location() == DataLocation::Memory)
-				m_context << _arrayType.getBaseType()->memoryHeadSize();
+				m_context << _arrayType.baseType()->memoryHeadSize();
 			else
-				m_context << _arrayType.getBaseType()->getCalldataEncodedSize();
+				m_context << _arrayType.baseType()->calldataEncodedSize();
 			m_context << eth::Instruction::MUL;
 		}
 		else if (_pad)
@@ -645,7 +645,7 @@ void ArrayUtils::convertLengthToSize(ArrayType const& _arrayType, bool _pad) con
 void ArrayUtils::retrieveLength(ArrayType const& _arrayType) const
 {
 	if (!_arrayType.isDynamicallySized())
-		m_context << _arrayType.getLength();
+		m_context << _arrayType.length();
 	else
 	{
 		m_context << eth::Instruction::DUP1;
@@ -676,7 +676,7 @@ void ArrayUtils::accessIndex(ArrayType const& _arrayType, bool _doBoundsCheck) c
 	{
 		// retrieve length
 		if (!_arrayType.isDynamicallySized())
-			m_context << _arrayType.getLength();
+			m_context << _arrayType.length();
 		else if (location == DataLocation::CallData)
 			// length is stored on the stack
 			m_context << eth::Instruction::SWAP1;
@@ -710,7 +710,7 @@ void ArrayUtils::accessIndex(ArrayType const& _arrayType, bool _doBoundsCheck) c
 		{
 			m_context << eth::Instruction::SWAP1;
 			if (location == DataLocation::CallData)
-				m_context << _arrayType.getBaseType()->getCalldataEncodedSize();
+				m_context << _arrayType.baseType()->calldataEncodedSize();
 			else
 				m_context << u256(_arrayType.memoryHeadSize());
 			m_context << eth::Instruction::MUL;
@@ -719,12 +719,12 @@ void ArrayUtils::accessIndex(ArrayType const& _arrayType, bool _doBoundsCheck) c
 		break;
 	case DataLocation::Storage:
 		m_context << eth::Instruction::SWAP1;
-		if (_arrayType.getBaseType()->getStorageBytes() <= 16)
+		if (_arrayType.baseType()->storageBytes() <= 16)
 		{
 			// stack: <data_ref> <index>
 			// goal:
 			// <ref> <byte_number> = <base_ref + index / itemsPerSlot> <(index % itemsPerSlot) * byteSize>
-			unsigned byteSize = _arrayType.getBaseType()->getStorageBytes();
+			unsigned byteSize = _arrayType.baseType()->storageBytes();
 			solAssert(byteSize != 0, "");
 			unsigned itemsPerSlot = 32 / byteSize;
 			m_context << u256(itemsPerSlot) << eth::Instruction::SWAP2;
@@ -740,8 +740,8 @@ void ArrayUtils::accessIndex(ArrayType const& _arrayType, bool _doBoundsCheck) c
 		}
 		else
 		{
-			if (_arrayType.getBaseType()->getStorageSize() != 1)
-				m_context << _arrayType.getBaseType()->getStorageSize() << eth::Instruction::MUL;
+			if (_arrayType.baseType()->storageSize() != 1)
+				m_context << _arrayType.baseType()->storageSize() << eth::Instruction::MUL;
 			m_context << eth::Instruction::ADD << u256(0);
 		}
 		break;
diff --git a/libsolidity/CMakeLists.txt b/libsolidity/CMakeLists.txt
index 787e5576..9fa35e3b 100644
--- a/libsolidity/CMakeLists.txt
+++ b/libsolidity/CMakeLists.txt
@@ -1,24 +1,15 @@
-cmake_policy(SET CMP0015 NEW)
-set(CMAKE_AUTOMOC OFF)
-
 set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DSTATICLIB")
 
 aux_source_directory(. SRC_LIST)
 
-include_directories(BEFORE ${JSONCPP_INCLUDE_DIRS})
-include_directories(BEFORE ..)
-include_directories(${Boost_INCLUDE_DIRS})
-
 set(EXECUTABLE solidity)
 
 file(GLOB HEADERS "*.h") 
 
+include_directories(BEFORE ..)
 add_library(${EXECUTABLE} ${SRC_LIST} ${HEADERS})
-add_dependencies(${EXECUTABLE} BuildInfo.h)
 
-target_link_libraries(${EXECUTABLE} ${JSONCPP_LIBRARIES})
-target_link_libraries(${EXECUTABLE} evmasm)
-target_link_libraries(${EXECUTABLE} devcrypto)
+eth_use(${EXECUTABLE} REQUIRED Dev::devcore Eth::evmasm)
 
 install( TARGETS ${EXECUTABLE} RUNTIME DESTINATION bin ARCHIVE DESTINATION lib LIBRARY DESTINATION lib )
 install( FILES ${HEADERS} DESTINATION include/${EXECUTABLE} )
diff --git a/libsolidity/Compiler.cpp b/libsolidity/Compiler.cpp
index f0d1b38e..d6582653 100644
--- a/libsolidity/Compiler.cpp
+++ b/libsolidity/Compiler.cpp
@@ -41,15 +41,17 @@ class StackHeightChecker
 {
 public:
 	StackHeightChecker(CompilerContext const& _context):
-		m_context(_context), stackHeight(m_context.getStackHeight()) {}
-	void check() { solAssert(m_context.getStackHeight() == stackHeight, "I sense a disturbance in the stack."); }
+		m_context(_context), stackHeight(m_context.stackHeight()) {}
+	void check() { solAssert(m_context.stackHeight() == stackHeight, "I sense a disturbance in the stack."); }
 private:
 	CompilerContext const& m_context;
 	unsigned stackHeight;
 };
 
-void Compiler::compileContract(ContractDefinition const& _contract,
-							   map<ContractDefinition const*, bytes const*> const& _contracts)
+void Compiler::compileContract(
+	ContractDefinition const& _contract,
+	std::map<const ContractDefinition*, eth::Assembly const*> const& _contracts
+)
 {
 	m_context = CompilerContext(); // clear it just in case
 	{
@@ -70,7 +72,7 @@ void Compiler::compileContract(ContractDefinition const& _contract,
 
 void Compiler::compileClone(
 	ContractDefinition const& _contract,
-	map<ContractDefinition const*, bytes const*> const& _contracts
+	map<ContractDefinition const*, eth::Assembly const*> const& _contracts
 )
 {
 	m_context = CompilerContext(); // clear it just in case
@@ -79,7 +81,7 @@ void Compiler::compileClone(
 	appendInitAndConstructorCode(_contract);
 
 	//@todo determine largest return size of all runtime functions
-	eth::AssemblyItem runtimeSub = m_context.addSubroutine(getCloneRuntime());
+	eth::AssemblyItem runtimeSub = m_context.addSubroutine(cloneRuntime());
 	solAssert(runtimeSub.data() < numeric_limits<size_t>::max(), "");
 	m_runtimeSub = size_t(runtimeSub.data());
 
@@ -93,17 +95,19 @@ void Compiler::compileClone(
 		m_context.optimise(m_optimizeRuns);
 }
 
-eth::AssemblyItem Compiler::getFunctionEntryLabel(FunctionDefinition const& _function) const
+eth::AssemblyItem Compiler::functionEntryLabel(FunctionDefinition const& _function) const
 {
-	return m_runtimeContext.getFunctionEntryLabelIfExists(_function);
+	return m_runtimeContext.functionEntryLabelIfExists(_function);
 }
 
-void Compiler::initializeContext(ContractDefinition const& _contract,
-								 map<ContractDefinition const*, bytes const*> const& _contracts)
+void Compiler::initializeContext(
+	ContractDefinition const& _contract,
+	map<ContractDefinition const*, eth::Assembly const*> const& _compiledContracts
+)
 {
 	CompilerUtils(m_context).initialiseFreeMemoryPointer();
-	m_context.setCompiledContracts(_contracts);
-	m_context.setInheritanceHierarchy(_contract.getLinearizedBaseContracts());
+	m_context.setCompiledContracts(_compiledContracts);
+	m_context.setInheritanceHierarchy(_contract.linearizedBaseContracts());
 	registerStateVariables(_contract);
 	m_context.resetVisitedNodes(&_contract);
 }
@@ -111,36 +115,36 @@ void Compiler::initializeContext(ContractDefinition const& _contract,
 void Compiler::appendInitAndConstructorCode(ContractDefinition const& _contract)
 {
 	// Determine the arguments that are used for the base constructors.
-	std::vector<ContractDefinition const*> const& bases = _contract.getLinearizedBaseContracts();
+	std::vector<ContractDefinition const*> const& bases = _contract.linearizedBaseContracts();
 	for (ContractDefinition const* contract: bases)
 	{
-		if (FunctionDefinition const* constructor = contract->getConstructor())
-			for (auto const& modifier: constructor->getModifiers())
+		if (FunctionDefinition const* constructor = contract->constructor())
+			for (auto const& modifier: constructor->modifiers())
 			{
 				auto baseContract = dynamic_cast<ContractDefinition const*>(
-					&modifier->getName()->getReferencedDeclaration());
+					&modifier->name()->referencedDeclaration());
 				if (baseContract)
-					if (m_baseArguments.count(baseContract->getConstructor()) == 0)
-						m_baseArguments[baseContract->getConstructor()] = &modifier->getArguments();
+					if (m_baseArguments.count(baseContract->constructor()) == 0)
+						m_baseArguments[baseContract->constructor()] = &modifier->arguments();
 			}
 
-		for (ASTPointer<InheritanceSpecifier> const& base: contract->getBaseContracts())
+		for (ASTPointer<InheritanceSpecifier> const& base: contract->baseContracts())
 		{
 			ContractDefinition const* baseContract = dynamic_cast<ContractDefinition const*>(
-						&base->getName()->getReferencedDeclaration());
+						&base->name()->referencedDeclaration());
 			solAssert(baseContract, "");
 
-			if (m_baseArguments.count(baseContract->getConstructor()) == 0)
-				m_baseArguments[baseContract->getConstructor()] = &base->getArguments();
+			if (m_baseArguments.count(baseContract->constructor()) == 0)
+				m_baseArguments[baseContract->constructor()] = &base->arguments();
 		}
 	}
 	// Initialization of state variables in base-to-derived order.
 	for (ContractDefinition const* contract: boost::adaptors::reverse(bases))
 		initializeStateVariables(*contract);
 
-	if (FunctionDefinition const* constructor = _contract.getConstructor())
+	if (FunctionDefinition const* constructor = _contract.constructor())
 		appendConstructor(*constructor);
-	else if (auto c = m_context.getNextConstructor(_contract))
+	else if (auto c = m_context.nextConstructor(_contract))
 		appendBaseConstructor(*c);
 }
 
@@ -148,7 +152,7 @@ void Compiler::packIntoContractCreator(ContractDefinition const& _contract, Comp
 {
 	appendInitAndConstructorCode(_contract);
 
-	eth::AssemblyItem runtimeSub = m_context.addSubroutine(_runtimeContext.getAssembly());
+	eth::AssemblyItem runtimeSub = m_context.addSubroutine(_runtimeContext.assembly());
 	solAssert(runtimeSub.data() < numeric_limits<size_t>::max(), "");
 	m_runtimeSub = size_t(runtimeSub.data());
 
@@ -164,13 +168,13 @@ void Compiler::appendBaseConstructor(FunctionDefinition const& _constructor)
 {
 	CompilerContext::LocationSetter locationSetter(m_context, _constructor);
 	FunctionType constructorType(_constructor);
-	if (!constructorType.getParameterTypes().empty())
+	if (!constructorType.parameterTypes().empty())
 	{
 		solAssert(m_baseArguments.count(&_constructor), "");
 		std::vector<ASTPointer<Expression>> const* arguments = m_baseArguments[&_constructor];
 		solAssert(arguments, "");
 		for (unsigned i = 0; i < arguments->size(); ++i)
-			compileExpression(*(arguments->at(i)), constructorType.getParameterTypes()[i]);
+			compileExpression(*(arguments->at(i)), constructorType.parameterTypes()[i]);
 	}
 	_constructor.accept(*this);
 }
@@ -179,17 +183,17 @@ void Compiler::appendConstructor(FunctionDefinition const& _constructor)
 {
 	CompilerContext::LocationSetter locationSetter(m_context, _constructor);
 	// copy constructor arguments from code to memory and then to stack, they are supplied after the actual program
-	if (!_constructor.getParameters().empty())
+	if (!_constructor.parameters().empty())
 	{
 		unsigned argumentSize = 0;
-		for (ASTPointer<VariableDeclaration> const& var: _constructor.getParameters())
-			if (var->getType()->isDynamicallySized())
+		for (ASTPointer<VariableDeclaration> const& var: _constructor.parameters())
+			if (var->type()->isDynamicallySized())
 			{
 				argumentSize = 0;
 				break;
 			}
 			else
-				argumentSize += var->getType()->getCalldataEncodedSize();
+				argumentSize += var->type()->calldataEncodedSize();
 
 		CompilerUtils(m_context).fetchFreeMemoryPointer();
 		if (argumentSize == 0)
@@ -208,7 +212,7 @@ void Compiler::appendConstructor(FunctionDefinition const& _constructor)
 		m_context << eth::Instruction::ADD;
 		CompilerUtils(m_context).storeFreeMemoryPointer();
 		appendCalldataUnpacker(
-			FunctionType(_constructor).getParameterTypes(),
+			FunctionType(_constructor).parameterTypes(),
 			true,
 			CompilerUtils::freeMemoryPointer + 0x20
 		);
@@ -218,10 +222,10 @@ void Compiler::appendConstructor(FunctionDefinition const& _constructor)
 
 void Compiler::appendFunctionSelector(ContractDefinition const& _contract)
 {
-	map<FixedHash<4>, FunctionTypePointer> interfaceFunctions = _contract.getInterfaceFunctions();
+	map<FixedHash<4>, FunctionTypePointer> interfaceFunctions = _contract.interfaceFunctions();
 	map<FixedHash<4>, const eth::AssemblyItem> callDataUnpackerEntryPoints;
 
-	FunctionDefinition const* fallback = _contract.getFallbackFunction();
+	FunctionDefinition const* fallback = _contract.fallbackFunction();
 	eth::AssemblyItem notFound = m_context.newTag();
 	// shortcut messages without data if we have many functions in order to be able to receive
 	// ether with constant gas
@@ -250,7 +254,7 @@ void Compiler::appendFunctionSelector(ContractDefinition const& _contract)
 		eth::AssemblyItem returnTag = m_context.pushNewTag();
 		fallback->accept(*this);
 		m_context << returnTag;
-		appendReturnValuePacker(FunctionType(*fallback).getReturnParameterTypes());
+		appendReturnValuePacker(FunctionType(*fallback).returnParameterTypes());
 	}
 	else
 		m_context << eth::Instruction::STOP; // function not found
@@ -259,13 +263,13 @@ void Compiler::appendFunctionSelector(ContractDefinition const& _contract)
 	{
 		FunctionTypePointer const& functionType = it.second;
 		solAssert(functionType->hasDeclaration(), "");
-		CompilerContext::LocationSetter locationSetter(m_context, functionType->getDeclaration());
+		CompilerContext::LocationSetter locationSetter(m_context, functionType->declaration());
 		m_context << callDataUnpackerEntryPoints.at(it.first);
 		eth::AssemblyItem returnTag = m_context.pushNewTag();
-		appendCalldataUnpacker(functionType->getParameterTypes());
-		m_context.appendJumpTo(m_context.getFunctionEntryLabel(functionType->getDeclaration()));
+		appendCalldataUnpacker(functionType->parameterTypes());
+		m_context.appendJumpTo(m_context.functionEntryLabel(functionType->declaration()));
 		m_context << returnTag;
-		appendReturnValuePacker(functionType->getReturnParameterTypes());
+		appendReturnValuePacker(functionType->returnParameterTypes());
 	}
 }
 
@@ -286,17 +290,17 @@ void Compiler::appendCalldataUnpacker(
 	for (TypePointer const& type: _typeParameters)
 	{
 		// stack: v1 v2 ... v(k-1) mem_offset
-		switch (type->getCategory())
+		switch (type->category())
 		{
 		case Type::Category::Array:
 		{
 			auto const& arrayType = dynamic_cast<ArrayType const&>(*type);
 			solAssert(arrayType.location() != DataLocation::Storage, "");
-			solAssert(!arrayType.getBaseType()->isDynamicallySized(), "Nested arrays not yet implemented.");
+			solAssert(!arrayType.baseType()->isDynamicallySized(), "Nested arrays not yet implemented.");
 			if (_fromMemory)
 			{
 				solAssert(
-					arrayType.getBaseType()->isValueType(),
+					arrayType.baseType()->isValueType(),
 					"Nested memory arrays not yet implemented here."
 				);
 				// @todo If base type is an array or struct, it is still calldata-style encoded, so
@@ -329,17 +333,17 @@ void Compiler::appendCalldataUnpacker(
 				{
 					// leave the pointer on the stack
 					m_context << eth::Instruction::DUP1;
-					m_context << u256(calldataType->getCalldataEncodedSize()) << eth::Instruction::ADD;
+					m_context << u256(calldataType->calldataEncodedSize()) << eth::Instruction::ADD;
 				}
 				if (arrayType.location() == DataLocation::Memory)
 				{
 					// stack: calldata_ref [length] next_calldata
 					// copy to memory
 					// move calldata type up again
-					CompilerUtils(m_context).moveIntoStack(calldataType->getSizeOnStack());
+					CompilerUtils(m_context).moveIntoStack(calldataType->sizeOnStack());
 					CompilerUtils(m_context).convertType(*calldataType, arrayType);
 					// fetch next pointer again
-					CompilerUtils(m_context).moveToStackTop(arrayType.getSizeOnStack());
+					CompilerUtils(m_context).moveToStackTop(arrayType.sizeOnStack());
 				}
 			}
 			break;
@@ -370,14 +374,14 @@ void Compiler::appendReturnValuePacker(TypePointers const& _typeParameters)
 
 void Compiler::registerStateVariables(ContractDefinition const& _contract)
 {
-	for (auto const& var: ContractType(_contract).getStateVariables())
+	for (auto const& var: ContractType(_contract).stateVariables())
 		m_context.addStateVariable(*get<0>(var), get<1>(var), get<2>(var));
 }
 
 void Compiler::initializeStateVariables(ContractDefinition const& _contract)
 {
-	for (ASTPointer<VariableDeclaration> const& variable: _contract.getStateVariables())
-		if (variable->getValue() && !variable->isConstant())
+	for (ASTPointer<VariableDeclaration> const& variable: _contract.stateVariables())
+		if (variable->value() && !variable->isConstant())
 			ExpressionCompiler(m_context, m_optimize).appendStateVariableInitialization(*variable);
 }
 
@@ -390,7 +394,10 @@ bool Compiler::visit(VariableDeclaration const& _variableDeclaration)
 	m_breakTags.clear();
 	m_continueTags.clear();
 
-	ExpressionCompiler(m_context, m_optimize).appendStateVariableAccessor(_variableDeclaration);
+	if (_variableDeclaration.isConstant())
+		ExpressionCompiler(m_context, m_optimize).appendConstStateVariableAccessor(_variableDeclaration);
+	else
+		ExpressionCompiler(m_context, m_optimize).appendStateVariableAccessor(_variableDeclaration);
 
 	return false;
 }
@@ -404,23 +411,23 @@ bool Compiler::visit(FunctionDefinition const& _function)
 	// stack upon entry: [return address] [arg0] [arg1] ... [argn]
 	// reserve additional slots: [retarg0] ... [retargm] [localvar0] ... [localvarp]
 
-	unsigned parametersSize = CompilerUtils::getSizeOnStack(_function.getParameters());
+	unsigned parametersSize = CompilerUtils::sizeOnStack(_function.parameters());
 	if (!_function.isConstructor())
 		// adding 1 for return address.
 		m_context.adjustStackOffset(parametersSize + 1);
-	for (ASTPointer<VariableDeclaration const> const& variable: _function.getParameters())
+	for (ASTPointer<VariableDeclaration const> const& variable: _function.parameters())
 	{
 		m_context.addVariable(*variable, parametersSize);
-		parametersSize -= variable->getType()->getSizeOnStack();
+		parametersSize -= variable->type()->sizeOnStack();
 	}
 
-	for (ASTPointer<VariableDeclaration const> const& variable: _function.getReturnParameters())
+	for (ASTPointer<VariableDeclaration const> const& variable: _function.returnParameters())
 		appendStackVariableInitialisation(*variable);
-	for (VariableDeclaration const* localVariable: _function.getLocalVariables())
+	for (VariableDeclaration const* localVariable: _function.localVariables())
 		appendStackVariableInitialisation(*localVariable);
 
 	if (_function.isConstructor())
-		if (auto c = m_context.getNextConstructor(dynamic_cast<ContractDefinition const&>(*_function.getScope())))
+		if (auto c = m_context.nextConstructor(dynamic_cast<ContractDefinition const&>(*_function.scope())))
 			appendBaseConstructor(*c);
 
 	m_returnTag = m_context.newTag();
@@ -440,9 +447,9 @@ bool Compiler::visit(FunctionDefinition const& _function)
 	// Note that the fact that the return arguments are of increasing index is vital for this
 	// algorithm to work.
 
-	unsigned const c_argumentsSize = CompilerUtils::getSizeOnStack(_function.getParameters());
-	unsigned const c_returnValuesSize = CompilerUtils::getSizeOnStack(_function.getReturnParameters());
-	unsigned const c_localVariablesSize = CompilerUtils::getSizeOnStack(_function.getLocalVariables());
+	unsigned const c_argumentsSize = CompilerUtils::sizeOnStack(_function.parameters());
+	unsigned const c_returnValuesSize = CompilerUtils::sizeOnStack(_function.returnParameters());
+	unsigned const c_localVariablesSize = CompilerUtils::sizeOnStack(_function.localVariables());
 
 	vector<int> stackLayout;
 	stackLayout.push_back(c_returnValuesSize); // target of return address
@@ -465,9 +472,9 @@ bool Compiler::visit(FunctionDefinition const& _function)
 		}
 	//@todo assert that everything is in place now
 
-	for (ASTPointer<VariableDeclaration const> const& variable: _function.getParameters() + _function.getReturnParameters())
+	for (ASTPointer<VariableDeclaration const> const& variable: _function.parameters() + _function.returnParameters())
 		m_context.removeVariable(*variable);
-	for (VariableDeclaration const* localVariable: _function.getLocalVariables())
+	for (VariableDeclaration const* localVariable: _function.localVariables())
 		m_context.removeVariable(*localVariable);
 
 	m_context.adjustStackOffset(-(int)c_returnValuesSize);
@@ -481,16 +488,16 @@ bool Compiler::visit(IfStatement const& _ifStatement)
 {
 	StackHeightChecker checker(m_context);
 	CompilerContext::LocationSetter locationSetter(m_context, _ifStatement);
-	compileExpression(_ifStatement.getCondition());
+	compileExpression(_ifStatement.condition());
 	m_context << eth::Instruction::ISZERO;
 	eth::AssemblyItem falseTag = m_context.appendConditionalJump();
 	eth::AssemblyItem endTag = falseTag;
-	_ifStatement.getTrueStatement().accept(*this);
-	if (_ifStatement.getFalseStatement())
+	_ifStatement.trueStatement().accept(*this);
+	if (_ifStatement.falseStatement())
 	{
 		endTag = m_context.appendJumpToNew();
 		m_context << falseTag;
-		_ifStatement.getFalseStatement()->accept(*this);
+		_ifStatement.falseStatement()->accept(*this);
 	}
 	m_context << endTag;
 
@@ -508,11 +515,11 @@ bool Compiler::visit(WhileStatement const& _whileStatement)
 	m_breakTags.push_back(loopEnd);
 
 	m_context << loopStart;
-	compileExpression(_whileStatement.getCondition());
+	compileExpression(_whileStatement.condition());
 	m_context << eth::Instruction::ISZERO;
 	m_context.appendConditionalJumpTo(loopEnd);
 
-	_whileStatement.getBody().accept(*this);
+	_whileStatement.body().accept(*this);
 
 	m_context.appendJumpTo(loopStart);
 	m_context << loopEnd;
@@ -534,26 +541,26 @@ bool Compiler::visit(ForStatement const& _forStatement)
 	m_continueTags.push_back(loopNext);
 	m_breakTags.push_back(loopEnd);
 
-	if (_forStatement.getInitializationExpression())
-		_forStatement.getInitializationExpression()->accept(*this);
+	if (_forStatement.initializationExpression())
+		_forStatement.initializationExpression()->accept(*this);
 
 	m_context << loopStart;
 
 	// if there is no terminating condition in for, default is to always be true
-	if (_forStatement.getCondition())
+	if (_forStatement.condition())
 	{
-		compileExpression(*_forStatement.getCondition());
+		compileExpression(*_forStatement.condition());
 		m_context << eth::Instruction::ISZERO;
 		m_context.appendConditionalJumpTo(loopEnd);
 	}
 
-	_forStatement.getBody().accept(*this);
+	_forStatement.body().accept(*this);
 
 	m_context << loopNext;
 
 	// for's loop expression if existing
-	if (_forStatement.getLoopExpression())
-		_forStatement.getLoopExpression()->accept(*this);
+	if (_forStatement.loopExpression())
+		_forStatement.loopExpression()->accept(*this);
 
 	m_context.appendJumpTo(loopStart);
 	m_context << loopEnd;
@@ -585,11 +592,11 @@ bool Compiler::visit(Return const& _return)
 {
 	CompilerContext::LocationSetter locationSetter(m_context, _return);
 	//@todo modifications are needed to make this work with functions returning multiple values
-	if (Expression const* expression = _return.getExpression())
+	if (Expression const* expression = _return.expression())
 	{
-		solAssert(_return.getFunctionReturnParameters(), "Invalid return parameters pointer.");
-		VariableDeclaration const& firstVariable = *_return.getFunctionReturnParameters()->getParameters().front();
-		compileExpression(*expression, firstVariable.getType());
+		solAssert(_return.functionReturnParameters(), "Invalid return parameters pointer.");
+		VariableDeclaration const& firstVariable = *_return.functionReturnParameters()->parameters().front();
+		compileExpression(*expression, firstVariable.type());
 		CompilerUtils(m_context).moveToStackVariable(firstVariable);
 	}
 	for (unsigned i = 0; i < m_stackCleanupForReturn; ++i)
@@ -599,14 +606,21 @@ bool Compiler::visit(Return const& _return)
 	return false;
 }
 
+bool Compiler::visit(Throw const& _throw)
+{
+	CompilerContext::LocationSetter locationSetter(m_context, _throw);
+	m_context.appendJumpTo(m_context.errorTag());
+	return false;
+}
+
 bool Compiler::visit(VariableDeclarationStatement const& _variableDeclarationStatement)
 {
 	StackHeightChecker checker(m_context);
 	CompilerContext::LocationSetter locationSetter(m_context, _variableDeclarationStatement);
-	if (Expression const* expression = _variableDeclarationStatement.getExpression())
+	if (Expression const* expression = _variableDeclarationStatement.expression())
 	{
-		compileExpression(*expression, _variableDeclarationStatement.getDeclaration().getType());
-		CompilerUtils(m_context).moveToStackVariable(_variableDeclarationStatement.getDeclaration());
+		compileExpression(*expression, _variableDeclarationStatement.declaration().type());
+		CompilerUtils(m_context).moveToStackVariable(_variableDeclarationStatement.declaration());
 	}
 	checker.check();
 	return false;
@@ -616,9 +630,9 @@ bool Compiler::visit(ExpressionStatement const& _expressionStatement)
 {
 	StackHeightChecker checker(m_context);
 	CompilerContext::LocationSetter locationSetter(m_context, _expressionStatement);
-	Expression const& expression = _expressionStatement.getExpression();
+	Expression const& expression = _expressionStatement.expression();
 	compileExpression(expression);
-	CompilerUtils(m_context).popStackElement(*expression.getType());
+	CompilerUtils(m_context).popStackElement(*expression.type());
 	checker.check();
 	return false;
 }
@@ -636,7 +650,7 @@ bool Compiler::visit(PlaceholderStatement const& _placeholderStatement)
 
 void Compiler::appendFunctionsWithoutCode()
 {
-	set<Declaration const*> functions = m_context.getFunctionsWithoutCode();
+	set<Declaration const*> functions = m_context.functionsWithoutCode();
 	while (!functions.empty())
 	{
 		for (Declaration const* function: functions)
@@ -644,21 +658,21 @@ void Compiler::appendFunctionsWithoutCode()
 			m_context.setStackOffset(0);
 			function->accept(*this);
 		}
-		functions = m_context.getFunctionsWithoutCode();
+		functions = m_context.functionsWithoutCode();
 	}
 }
 
 void Compiler::appendModifierOrFunctionCode()
 {
 	solAssert(m_currentFunction, "");
-	if (m_modifierDepth >= m_currentFunction->getModifiers().size())
-		m_currentFunction->getBody().accept(*this);
+	if (m_modifierDepth >= m_currentFunction->modifiers().size())
+		m_currentFunction->body().accept(*this);
 	else
 	{
-		ASTPointer<ModifierInvocation> const& modifierInvocation = m_currentFunction->getModifiers()[m_modifierDepth];
+		ASTPointer<ModifierInvocation> const& modifierInvocation = m_currentFunction->modifiers()[m_modifierDepth];
 
 		// constructor call should be excluded
-		if (dynamic_cast<ContractDefinition const*>(&modifierInvocation->getName()->getReferencedDeclaration()))
+		if (dynamic_cast<ContractDefinition const*>(&modifierInvocation->name()->referencedDeclaration()))
 		{
 			++m_modifierDepth;
 			appendModifierOrFunctionCode();
@@ -666,23 +680,25 @@ void Compiler::appendModifierOrFunctionCode()
 			return;
 		}
 
-		ModifierDefinition const& modifier = m_context.getFunctionModifier(modifierInvocation->getName()->getName());
+		ModifierDefinition const& modifier = m_context.functionModifier(modifierInvocation->name()->name());
 		CompilerContext::LocationSetter locationSetter(m_context, modifier);
-		solAssert(modifier.getParameters().size() == modifierInvocation->getArguments().size(), "");
-		for (unsigned i = 0; i < modifier.getParameters().size(); ++i)
+		solAssert(modifier.parameters().size() == modifierInvocation->arguments().size(), "");
+		for (unsigned i = 0; i < modifier.parameters().size(); ++i)
 		{
-			m_context.addVariable(*modifier.getParameters()[i]);
-			compileExpression(*modifierInvocation->getArguments()[i],
-							  modifier.getParameters()[i]->getType());
+			m_context.addVariable(*modifier.parameters()[i]);
+			compileExpression(
+				*modifierInvocation->arguments()[i],
+				modifier.parameters()[i]->type()
+			);
 		}
-		for (VariableDeclaration const* localVariable: modifier.getLocalVariables())
+		for (VariableDeclaration const* localVariable: modifier.localVariables())
 			appendStackVariableInitialisation(*localVariable);
 
-		unsigned const c_stackSurplus = CompilerUtils::getSizeOnStack(modifier.getParameters()) +
-										CompilerUtils::getSizeOnStack(modifier.getLocalVariables());
+		unsigned const c_stackSurplus = CompilerUtils::sizeOnStack(modifier.parameters()) +
+										CompilerUtils::sizeOnStack(modifier.localVariables());
 		m_stackCleanupForReturn += c_stackSurplus;
 
-		modifier.getBody().accept(*this);
+		modifier.body().accept(*this);
 
 		for (unsigned i = 0; i < c_stackSurplus; ++i)
 			m_context << eth::Instruction::POP;
@@ -694,7 +710,7 @@ void Compiler::appendStackVariableInitialisation(VariableDeclaration const& _var
 {
 	CompilerContext::LocationSetter location(m_context, _variable);
 	m_context.addVariable(_variable);
-	CompilerUtils(m_context).pushZeroValue(*_variable.getType());
+	CompilerUtils(m_context).pushZeroValue(*_variable.type());
 }
 
 void Compiler::compileExpression(Expression const& _expression, TypePointer const& _targetType)
@@ -702,10 +718,10 @@ void Compiler::compileExpression(Expression const& _expression, TypePointer cons
 	ExpressionCompiler expressionCompiler(m_context, m_optimize);
 	expressionCompiler.compile(_expression);
 	if (_targetType)
-		CompilerUtils(m_context).convertType(*_expression.getType(), *_targetType);
+		CompilerUtils(m_context).convertType(*_expression.type(), *_targetType);
 }
 
-eth::Assembly Compiler::getCloneRuntime()
+eth::Assembly Compiler::cloneRuntime()
 {
 	eth::Assembly a;
 	a << eth::Instruction::CALLDATASIZE;
@@ -720,6 +736,9 @@ eth::Assembly Compiler::getCloneRuntime()
 	a << u256("0xcafecafecafecafecafecafecafecafecafecafe");
 	a << u256(eth::c_callGas + eth::c_callValueTransferGas + 10) << eth::Instruction::GAS << eth::Instruction::SUB;
 	a << eth::Instruction::CALLCODE;
+	//Propagate error condition (if CALLCODE pushes 0 on stack).
+	a << eth::Instruction::ISZERO;
+	a.appendJumpI(a.errorTag());
 	//@todo adjust for larger return values, make this dynamic.
 	a << u256(0x20) << u256(0) << eth::Instruction::RETURN;
 	return a;
diff --git a/libsolidity/Compiler.h b/libsolidity/Compiler.h
index bec2b064..c7dd7d90 100644
--- a/libsolidity/Compiler.h
+++ b/libsolidity/Compiler.h
@@ -42,16 +42,19 @@ public:
 	{
 	}
 
-	void compileContract(ContractDefinition const& _contract,
-						 std::map<ContractDefinition const*, bytes const*> const& _contracts);
+	void compileContract(
+		ContractDefinition const& _contract,
+		std::map<ContractDefinition const*, eth::Assembly const*> const& _contracts
+	);
 	/// Compiles a contract that uses CALLCODE to call into a pre-deployed version of the given
 	/// contract at runtime, but contains the full creation-time code.
 	void compileClone(
 		ContractDefinition const& _contract,
-		std::map<ContractDefinition const*, bytes const*> const& _contracts
+		std::map<ContractDefinition const*, eth::Assembly const*> const& _contracts
 	);
-	bytes getAssembledBytecode() { return m_context.getAssembledBytecode(); }
-	bytes getRuntimeBytecode() { return m_context.getAssembledRuntimeBytecode(m_runtimeSub); }
+	eth::Assembly const& assembly() { return m_context.assembly(); }
+	eth::LinkerObject assembledObject() { return m_context.assembledObject(); }
+	eth::LinkerObject runtimeObject() { return m_context.assembledRuntimeObject(m_runtimeSub); }
 	/// @arg _sourceCodes is the map of input files to source code strings
 	/// @arg _inJsonFromat shows whether the out should be in Json format
 	Json::Value streamAssembly(std::ostream& _stream, StringMap const& _sourceCodes = StringMap(), bool _inJsonFormat = false) const
@@ -59,18 +62,20 @@ public:
 		return m_context.streamAssembly(_stream, _sourceCodes, _inJsonFormat);
 	}
 	/// @returns Assembly items of the normal compiler context
-	eth::AssemblyItems const& getAssemblyItems() const { return m_context.getAssembly().getItems(); }
+	eth::AssemblyItems const& assemblyItems() const { return m_context.assembly().items(); }
 	/// @returns Assembly items of the runtime compiler context
-	eth::AssemblyItems const& getRuntimeAssemblyItems() const { return m_context.getAssembly().getSub(m_runtimeSub).getItems(); }
+	eth::AssemblyItems const& runtimeAssemblyItems() const { return m_context.assembly().sub(m_runtimeSub).items(); }
 
 	/// @returns the entry label of the given function. Might return an AssemblyItem of type
 	/// UndefinedItem if it does not exist yet.
-	eth::AssemblyItem getFunctionEntryLabel(FunctionDefinition const& _function) const;
+	eth::AssemblyItem functionEntryLabel(FunctionDefinition const& _function) const;
 
 private:
 	/// Registers the non-function objects inside the contract with the context.
-	void initializeContext(ContractDefinition const& _contract,
-						   std::map<ContractDefinition const*, bytes const*> const& _contracts);
+	void initializeContext(
+		ContractDefinition const& _contract,
+		std::map<ContractDefinition const*, eth::Assembly const*> const& _compiledContracts
+	);
 	/// Adds the code that is run at creation time. Should be run after exchanging the run-time context
 	/// with a new and initialized context. Adds the constructor code.
 	void packIntoContractCreator(ContractDefinition const& _contract, CompilerContext const& _runtimeContext);
@@ -107,6 +112,7 @@ private:
 	virtual bool visit(Continue const& _continue) override;
 	virtual bool visit(Break const& _break) override;
 	virtual bool visit(Return const& _return) override;
+	virtual bool visit(Throw const& _throw) override;
 	virtual bool visit(VariableDeclarationStatement const& _variableDeclarationStatement) override;
 	virtual bool visit(ExpressionStatement const& _expressionStatement) override;
 	virtual bool visit(PlaceholderStatement const&) override;
@@ -122,7 +128,7 @@ private:
 	void compileExpression(Expression const& _expression, TypePointer const& _targetType = TypePointer());
 
 	/// @returns the runtime assembly for clone contracts.
-	static eth::Assembly getCloneRuntime();
+	static eth::Assembly cloneRuntime();
 
 	bool const m_optimize;
 	unsigned const m_optimizeRuns;
diff --git a/libsolidity/CompilerContext.cpp b/libsolidity/CompilerContext.cpp
index 0f6f5fe7..717627a5 100644
--- a/libsolidity/CompilerContext.cpp
+++ b/libsolidity/CompilerContext.cpp
@@ -49,7 +49,7 @@ void CompilerContext::addStateVariable(
 void CompilerContext::startFunction(Declaration const& _function)
 {
 	m_functionsWithCode.insert(&_function);
-	*this << getFunctionEntryLabel(_function);
+	*this << functionEntryLabel(_function);
 }
 
 void CompilerContext::addVariable(VariableDeclaration const& _declaration,
@@ -65,7 +65,7 @@ void CompilerContext::removeVariable(VariableDeclaration const& _declaration)
 	m_localVariables.erase(&_declaration);
 }
 
-bytes const& CompilerContext::getCompiledContract(const ContractDefinition& _contract) const
+eth::Assembly const& CompilerContext::compiledContract(const ContractDefinition& _contract) const
 {
 	auto ret = m_compiledContracts.find(&_contract);
 	solAssert(ret != m_compiledContracts.end(), "Compiled contract not found.");
@@ -77,7 +77,7 @@ bool CompilerContext::isLocalVariable(Declaration const* _declaration) const
 	return !!m_localVariables.count(_declaration);
 }
 
-eth::AssemblyItem CompilerContext::getFunctionEntryLabel(Declaration const& _declaration)
+eth::AssemblyItem CompilerContext::functionEntryLabel(Declaration const& _declaration)
 {
 	auto res = m_functionEntryLabels.find(&_declaration);
 	if (res == m_functionEntryLabels.end())
@@ -90,35 +90,35 @@ eth::AssemblyItem CompilerContext::getFunctionEntryLabel(Declaration const& _dec
 		return res->second.tag();
 }
 
-eth::AssemblyItem CompilerContext::getFunctionEntryLabelIfExists(Declaration const& _declaration) const
+eth::AssemblyItem CompilerContext::functionEntryLabelIfExists(Declaration const& _declaration) const
 {
 	auto res = m_functionEntryLabels.find(&_declaration);
 	return res == m_functionEntryLabels.end() ? eth::AssemblyItem(eth::UndefinedItem) : res->second.tag();
 }
 
-eth::AssemblyItem CompilerContext::getVirtualFunctionEntryLabel(FunctionDefinition const& _function)
+eth::AssemblyItem CompilerContext::virtualFunctionEntryLabel(FunctionDefinition const& _function)
 {
 	solAssert(!m_inheritanceHierarchy.empty(), "No inheritance hierarchy set.");
-	return getVirtualFunctionEntryLabel(_function, m_inheritanceHierarchy.begin());
+	return virtualFunctionEntryLabel(_function, m_inheritanceHierarchy.begin());
 }
 
-eth::AssemblyItem CompilerContext::getSuperFunctionEntryLabel(FunctionDefinition const& _function, ContractDefinition const& _base)
+eth::AssemblyItem CompilerContext::superFunctionEntryLabel(FunctionDefinition const& _function, ContractDefinition const& _base)
 {
 	solAssert(!m_inheritanceHierarchy.empty(), "No inheritance hierarchy set.");
-	return getVirtualFunctionEntryLabel(_function, getSuperContract(_base));
+	return virtualFunctionEntryLabel(_function, superContract(_base));
 }
 
-FunctionDefinition const* CompilerContext::getNextConstructor(ContractDefinition const& _contract) const
+FunctionDefinition const* CompilerContext::nextConstructor(ContractDefinition const& _contract) const
 {
-	vector<ContractDefinition const*>::const_iterator it = getSuperContract(_contract);
+	vector<ContractDefinition const*>::const_iterator it = superContract(_contract);
 	for (; it != m_inheritanceHierarchy.end(); ++it)
-		if ((*it)->getConstructor())
-			return (*it)->getConstructor();
+		if ((*it)->constructor())
+			return (*it)->constructor();
 
 	return nullptr;
 }
 
-set<Declaration const*> CompilerContext::getFunctionsWithoutCode()
+set<Declaration const*> CompilerContext::functionsWithoutCode()
 {
 	set<Declaration const*> functions;
 	for (auto const& it: m_functionEntryLabels)
@@ -127,18 +127,18 @@ set<Declaration const*> CompilerContext::getFunctionsWithoutCode()
 	return functions;
 }
 
-ModifierDefinition const& CompilerContext::getFunctionModifier(string const& _name) const
+ModifierDefinition const& CompilerContext::functionModifier(string const& _name) const
 {
 	solAssert(!m_inheritanceHierarchy.empty(), "No inheritance hierarchy set.");
 	for (ContractDefinition const* contract: m_inheritanceHierarchy)
-		for (ASTPointer<ModifierDefinition> const& modifier: contract->getFunctionModifiers())
-			if (modifier->getName() == _name)
+		for (ASTPointer<ModifierDefinition> const& modifier: contract->functionModifiers())
+			if (modifier->name() == _name)
 				return *modifier.get();
 	BOOST_THROW_EXCEPTION(InternalCompilerError()
 						  << errinfo_comment("Function modifier " + _name + " not found."));
 }
 
-unsigned CompilerContext::getBaseStackOffsetOfVariable(Declaration const& _declaration) const
+unsigned CompilerContext::baseStackOffsetOfVariable(Declaration const& _declaration) const
 {
 	auto res = m_localVariables.find(&_declaration);
 	solAssert(res != m_localVariables.end(), "Variable not found on stack.");
@@ -155,7 +155,7 @@ unsigned CompilerContext::currentToBaseStackOffset(unsigned _offset) const
 	return m_asm.deposit() - _offset - 1;
 }
 
-pair<u256, unsigned> CompilerContext::getStorageLocationOfVariable(const Declaration& _declaration) const
+pair<u256, unsigned> CompilerContext::storageLocationOfVariable(const Declaration& _declaration) const
 {
 	auto it = m_stateVariables.find(&_declaration);
 	solAssert(it != m_stateVariables.end(), "Variable not found in storage.");
@@ -177,27 +177,27 @@ void CompilerContext::resetVisitedNodes(ASTNode const* _node)
 	updateSourceLocation();
 }
 
-eth::AssemblyItem CompilerContext::getVirtualFunctionEntryLabel(
+eth::AssemblyItem CompilerContext::virtualFunctionEntryLabel(
 	FunctionDefinition const& _function,
 	vector<ContractDefinition const*>::const_iterator _searchStart
 )
 {
-	string name = _function.getName();
+	string name = _function.name();
 	FunctionType functionType(_function);
 	auto it = _searchStart;
 	for (; it != m_inheritanceHierarchy.end(); ++it)
-		for (ASTPointer<FunctionDefinition> const& function: (*it)->getDefinedFunctions())
+		for (ASTPointer<FunctionDefinition> const& function: (*it)->definedFunctions())
 			if (
-				function->getName() == name &&
+				function->name() == name &&
 				!function->isConstructor() &&
 				FunctionType(*function).hasEqualArgumentTypes(functionType)
 			)
-				return getFunctionEntryLabel(*function);
+				return functionEntryLabel(*function);
 	solAssert(false, "Super function " + name + " not found.");
 	return m_asm.newTag(); // not reached
 }
 
-vector<ContractDefinition const*>::const_iterator CompilerContext::getSuperContract(ContractDefinition const& _contract) const
+vector<ContractDefinition const*>::const_iterator CompilerContext::superContract(ContractDefinition const& _contract) const
 {
 	solAssert(!m_inheritanceHierarchy.empty(), "No inheritance hierarchy set.");
 	auto it = find(m_inheritanceHierarchy.begin(), m_inheritanceHierarchy.end(), &_contract);
@@ -207,7 +207,7 @@ vector<ContractDefinition const*>::const_iterator CompilerContext::getSuperContr
 
 void CompilerContext::updateSourceLocation()
 {
-	m_asm.setSourceLocation(m_visitedNodes.empty() ? SourceLocation() : m_visitedNodes.top()->getLocation());
+	m_asm.setSourceLocation(m_visitedNodes.empty() ? SourceLocation() : m_visitedNodes.top()->location());
 }
 
 }
diff --git a/libsolidity/CompilerContext.h b/libsolidity/CompilerContext.h
index 3f97d900..39f4e75f 100644
--- a/libsolidity/CompilerContext.h
+++ b/libsolidity/CompilerContext.h
@@ -47,47 +47,47 @@ public:
 	void addVariable(VariableDeclaration const& _declaration, unsigned _offsetToCurrent = 0);
 	void removeVariable(VariableDeclaration const& _declaration);
 
-	void setCompiledContracts(std::map<ContractDefinition const*, bytes const*> const& _contracts) { m_compiledContracts = _contracts; }
-	bytes const& getCompiledContract(ContractDefinition const& _contract) const;
+	void setCompiledContracts(std::map<ContractDefinition const*, eth::Assembly const*> const& _contracts) { m_compiledContracts = _contracts; }
+	eth::Assembly const& compiledContract(ContractDefinition const& _contract) const;
 
 	void setStackOffset(int _offset) { m_asm.setDeposit(_offset); }
 	void adjustStackOffset(int _adjustment) { m_asm.adjustDeposit(_adjustment); }
-	unsigned getStackHeight() const { solAssert(m_asm.deposit() >= 0, ""); return unsigned(m_asm.deposit()); }
+	unsigned stackHeight() const { solAssert(m_asm.deposit() >= 0, ""); return unsigned(m_asm.deposit()); }
 
 	bool isMagicGlobal(Declaration const* _declaration) const { return m_magicGlobals.count(_declaration) != 0; }
 	bool isLocalVariable(Declaration const* _declaration) const;
 	bool isStateVariable(Declaration const* _declaration) const { return m_stateVariables.count(_declaration) != 0; }
 
 	/// @returns the entry label of the given function and creates it if it does not exist yet.
-	eth::AssemblyItem getFunctionEntryLabel(Declaration const& _declaration);
+	eth::AssemblyItem functionEntryLabel(Declaration const& _declaration);
 	/// @returns the entry label of the given function. Might return an AssemblyItem of type
 	/// UndefinedItem if it does not exist yet.
-	eth::AssemblyItem getFunctionEntryLabelIfExists(Declaration const& _declaration) const;
+	eth::AssemblyItem functionEntryLabelIfExists(Declaration const& _declaration) const;
 	void setInheritanceHierarchy(std::vector<ContractDefinition const*> const& _hierarchy) { m_inheritanceHierarchy = _hierarchy; }
 	/// @returns the entry label of the given function and takes overrides into account.
-	eth::AssemblyItem getVirtualFunctionEntryLabel(FunctionDefinition const& _function);
+	eth::AssemblyItem virtualFunctionEntryLabel(FunctionDefinition const& _function);
 	/// @returns the entry label of a function that overrides the given declaration from the most derived class just
 	/// above _base in the current inheritance hierarchy.
-	eth::AssemblyItem getSuperFunctionEntryLabel(FunctionDefinition const& _function, ContractDefinition const& _base);
-	FunctionDefinition const* getNextConstructor(ContractDefinition const& _contract) const;
+	eth::AssemblyItem superFunctionEntryLabel(FunctionDefinition const& _function, ContractDefinition const& _base);
+	FunctionDefinition const* nextConstructor(ContractDefinition const& _contract) const;
 
 	/// @returns the set of functions for which we still need to generate code
-	std::set<Declaration const*> getFunctionsWithoutCode();
+	std::set<Declaration const*> functionsWithoutCode();
 	/// Resets function specific members, inserts the function entry label and marks the function
 	/// as "having code".
 	void startFunction(Declaration const& _function);
 
-	ModifierDefinition const& getFunctionModifier(std::string const& _name) const;
+	ModifierDefinition const& functionModifier(std::string const& _name) const;
 	/// Returns the distance of the given local variable from the bottom of the stack (of the current function).
-	unsigned getBaseStackOffsetOfVariable(Declaration const& _declaration) const;
-	/// If supplied by a value returned by @ref getBaseStackOffsetOfVariable(variable), returns
+	unsigned baseStackOffsetOfVariable(Declaration const& _declaration) const;
+	/// If supplied by a value returned by @ref baseStackOffsetOfVariable(variable), returns
 	/// the distance of that variable from the current top of the stack.
 	unsigned baseToCurrentStackOffset(unsigned _baseOffset) const;
 	/// Converts an offset relative to the current stack height to a value that can be used later
 	/// with baseToCurrentStackOffset to point to the same stack element.
 	unsigned currentToBaseStackOffset(unsigned _offset) const;
 	/// @returns pair of slot and byte offset of the value inside this slot.
-	std::pair<u256, unsigned> getStorageLocationOfVariable(Declaration const& _declaration) const;
+	std::pair<u256, unsigned> storageLocationOfVariable(Declaration const& _declaration) const;
 
 	/// Appends a JUMPI instruction to a new tag and @returns the tag
 	eth::AssemblyItem appendConditionalJump() { return m_asm.appendJumpI().tag(); }
@@ -112,6 +112,8 @@ public:
 	void appendProgramSize() { return m_asm.appendProgramSize(); }
 	/// Adds data to the data section, pushes a reference to the stack
 	eth::AssemblyItem appendData(bytes const& _data) { return m_asm.append(_data); }
+	/// Appends the address (virtual, will be filled in by linker) of a library.
+	void appendLibraryAddress(std::string const& _identifier) { m_asm.appendLibraryAddress(_identifier); }
 	/// Resets the stack of visited nodes with a new stack having only @c _node
 	void resetVisitedNodes(ASTNode const* _node);
 	/// Pops the stack of visited nodes
@@ -127,7 +129,7 @@ public:
 
 	void optimise(unsigned _runs = 200) { m_asm.optimise(true, true, _runs); }
 
-	eth::Assembly const& getAssembly() const { return m_asm; }
+	eth::Assembly const& assembly() const { return m_asm; }
 	/// @arg _sourceCodes is the map of input files to source code strings
 	/// @arg _inJsonFormat shows whether the out should be in Json format
 	Json::Value streamAssembly(std::ostream& _stream, StringMap const& _sourceCodes = StringMap(), bool _inJsonFormat = false) const
@@ -135,8 +137,8 @@ public:
 		return m_asm.stream(_stream, "", _sourceCodes, _inJsonFormat);
 	}
 
-	bytes getAssembledBytecode() { return m_asm.assemble(); }
-	bytes getAssembledRuntimeBytecode(size_t _subIndex) { m_asm.assemble(); return m_asm.data(u256(_subIndex)); }
+	eth::LinkerObject const& assembledObject() { return m_asm.assemble(); }
+	eth::LinkerObject const& assembledRuntimeObject(size_t _subIndex) { return m_asm.sub(_subIndex).assemble(); }
 
 	/**
 	 * Helper class to pop the visited nodes stack when a scope closes
@@ -151,12 +153,12 @@ public:
 private:
 	/// @returns the entry label of the given function - searches the inheritance hierarchy
 	/// startig from the given point towards the base.
-	eth::AssemblyItem getVirtualFunctionEntryLabel(
+	eth::AssemblyItem virtualFunctionEntryLabel(
 		FunctionDefinition const& _function,
 		std::vector<ContractDefinition const*>::const_iterator _searchStart
 	);
 	/// @returns an iterator to the contract directly above the given contract.
-	std::vector<ContractDefinition const*>::const_iterator getSuperContract(const ContractDefinition &_contract) const;
+	std::vector<ContractDefinition const*>::const_iterator superContract(const ContractDefinition &_contract) const;
 	/// Updates source location set in the assembly.
 	void updateSourceLocation();
 
@@ -164,7 +166,7 @@ private:
 	/// Magic global variables like msg, tx or this, distinguished by type.
 	std::set<Declaration const*> m_magicGlobals;
 	/// Other already compiled contracts to be used in contract creation calls.
-	std::map<ContractDefinition const*, bytes const*> m_compiledContracts;
+	std::map<ContractDefinition const*, eth::Assembly const*> m_compiledContracts;
 	/// Storage offsets of state variables
 	std::map<Declaration const*, std::pair<u256, unsigned>> m_stateVariables;
 	/// Offsets of local variables on the stack (relative to stack base).
diff --git a/libsolidity/CompilerStack.cpp b/libsolidity/CompilerStack.cpp
index a85738eb..70bb1b4c 100644
--- a/libsolidity/CompilerStack.cpp
+++ b/libsolidity/CompilerStack.cpp
@@ -103,30 +103,30 @@ void CompilerStack::parse()
 	resolveImports();
 
 	m_globalContext = make_shared<GlobalContext>();
-	NameAndTypeResolver resolver(m_globalContext->getDeclarations());
+	NameAndTypeResolver resolver(m_globalContext->declarations());
 	for (Source const* source: m_sourceOrder)
 		resolver.registerDeclarations(*source->ast);
 	for (Source const* source: m_sourceOrder)
-		for (ASTPointer<ASTNode> const& node: source->ast->getNodes())
+		for (ASTPointer<ASTNode> const& node: source->ast->nodes())
 			if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
 			{
 				m_globalContext->setCurrentContract(*contract);
-				resolver.updateDeclaration(*m_globalContext->getCurrentThis());
-				resolver.updateDeclaration(*m_globalContext->getCurrentSuper());
+				resolver.updateDeclaration(*m_globalContext->currentThis());
+				resolver.updateDeclaration(*m_globalContext->currentSuper());
 				resolver.resolveNamesAndTypes(*contract);
-				m_contracts[contract->getName()].contract = contract;
+				m_contracts[contract->name()].contract = contract;
 			}
 	InterfaceHandler interfaceHandler;
 	for (Source const* source: m_sourceOrder)
-		for (ASTPointer<ASTNode> const& node: source->ast->getNodes())
+		for (ASTPointer<ASTNode> const& node: source->ast->nodes())
 			if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
 			{
 				m_globalContext->setCurrentContract(*contract);
-				resolver.updateDeclaration(*m_globalContext->getCurrentThis());
+				resolver.updateDeclaration(*m_globalContext->currentThis());
 				resolver.checkTypeRequirements(*contract);
 				contract->setDevDocumentation(interfaceHandler.devDocumentation(*contract));
 				contract->setUserDocumentation(interfaceHandler.userDocumentation(*contract));
-				m_contracts[contract->getName()].contract = contract;
+				m_contracts[contract->name()].contract = contract;
 			}
 	m_parseSuccessful = true;
 }
@@ -137,7 +137,7 @@ void CompilerStack::parse(string const& _sourceCode)
 	parse();
 }
 
-vector<string> CompilerStack::getContractNames() const
+vector<string> CompilerStack::contractNames() const
 {
 	if (!m_parseSuccessful)
 		BOOST_THROW_EXCEPTION(CompilerError() << errinfo_comment("Parsing was not successful."));
@@ -153,73 +153,85 @@ void CompilerStack::compile(bool _optimize, unsigned _runs)
 	if (!m_parseSuccessful)
 		parse();
 
-	map<ContractDefinition const*, bytes const*> contractBytecode;
+	map<ContractDefinition const*, eth::Assembly const*> compiledContracts;
 	for (Source const* source: m_sourceOrder)
-		for (ASTPointer<ASTNode> const& node: source->ast->getNodes())
+		for (ASTPointer<ASTNode> const& node: source->ast->nodes())
 			if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
 			{
 				if (!contract->isFullyImplemented())
 					continue;
 				shared_ptr<Compiler> compiler = make_shared<Compiler>(_optimize, _runs);
-				compiler->compileContract(*contract, contractBytecode);
-				Contract& compiledContract = m_contracts.at(contract->getName());
-				compiledContract.bytecode = compiler->getAssembledBytecode();
-				compiledContract.runtimeBytecode = compiler->getRuntimeBytecode();
-				compiledContract.compiler = move(compiler);
-				compiler = make_shared<Compiler>(_optimize, _runs);
-				compiler->compileContract(*contract, contractBytecode);
-				contractBytecode[compiledContract.contract] = &compiledContract.bytecode;
+				compiler->compileContract(*contract, compiledContracts);
+				Contract& compiledContract = m_contracts.at(contract->name());
+				compiledContract.compiler = compiler;
+				compiledContract.object = compiler->assembledObject();
+				compiledContract.runtimeObject = compiler->runtimeObject();
+				compiledContracts[compiledContract.contract] = &compiler->assembly();
 
 				Compiler cloneCompiler(_optimize, _runs);
-				cloneCompiler.compileClone(*contract, contractBytecode);
-				compiledContract.cloneBytecode = cloneCompiler.getAssembledBytecode();
+				cloneCompiler.compileClone(*contract, compiledContracts);
+				compiledContract.cloneObject = cloneCompiler.assembledObject();
 			}
 }
 
-bytes const& CompilerStack::compile(string const& _sourceCode, bool _optimize)
+eth::LinkerObject const& CompilerStack::compile(string const& _sourceCode, bool _optimize)
 {
 	parse(_sourceCode);
 	compile(_optimize);
-	return getBytecode();
+	return object();
 }
 
-eth::AssemblyItems const* CompilerStack::getAssemblyItems(string const& _contractName) const
+void CompilerStack::link(const std::map<string, h160>& _libraries)
 {
-	Contract const& contract = getContract(_contractName);
-	return contract.compiler ? &getContract(_contractName).compiler->getAssemblyItems() : nullptr;
+	for (auto& contract: m_contracts)
+	{
+		contract.second.object.link(_libraries);
+		contract.second.runtimeObject.link(_libraries);
+		contract.second.cloneObject.link(_libraries);
+	}
+}
+
+eth::AssemblyItems const* CompilerStack::assemblyItems(string const& _contractName) const
+{
+	Contract const& currentContract = contract(_contractName);
+	return currentContract.compiler ? &contract(_contractName).compiler->assemblyItems() : nullptr;
 }
 
-eth::AssemblyItems const* CompilerStack::getRuntimeAssemblyItems(string const& _contractName) const
+eth::AssemblyItems const* CompilerStack::runtimeAssemblyItems(string const& _contractName) const
 {
-	Contract const& contract = getContract(_contractName);
-	return contract.compiler ? &getContract(_contractName).compiler->getRuntimeAssemblyItems() : nullptr;
+	Contract const& currentContract = contract(_contractName);
+	return currentContract.compiler ? &contract(_contractName).compiler->runtimeAssemblyItems() : nullptr;
 }
 
-bytes const& CompilerStack::getBytecode(string const& _contractName) const
+eth::LinkerObject const& CompilerStack::object(string const& _contractName) const
 {
-	return getContract(_contractName).bytecode;
+	return contract(_contractName).object;
 }
 
-bytes const& CompilerStack::getRuntimeBytecode(string const& _contractName) const
+eth::LinkerObject const& CompilerStack::runtimeObject(string const& _contractName) const
 {
-	return getContract(_contractName).runtimeBytecode;
+	return contract(_contractName).runtimeObject;
 }
 
-bytes const& CompilerStack::getCloneBytecode(string const& _contractName) const
+eth::LinkerObject const& CompilerStack::cloneObject(string const& _contractName) const
 {
-	return getContract(_contractName).cloneBytecode;
+	return contract(_contractName).cloneObject;
 }
 
-dev::h256 CompilerStack::getContractCodeHash(string const& _contractName) const
+dev::h256 CompilerStack::contractCodeHash(string const& _contractName) const
 {
-	return dev::sha3(getRuntimeBytecode(_contractName));
+	auto const& obj = runtimeObject(_contractName);
+	if (obj.bytecode.empty() || !obj.linkReferences.empty())
+		return dev::h256();
+	else
+		return dev::sha3(obj.bytecode);
 }
 
 Json::Value CompilerStack::streamAssembly(ostream& _outStream, string const& _contractName, StringMap _sourceCodes, bool _inJsonFormat) const
 {
-	Contract const& contract = getContract(_contractName);
-	if (contract.compiler)
-		return contract.compiler->streamAssembly(_outStream, _sourceCodes, _inJsonFormat);
+	Contract const& currentContract = contract(_contractName);
+	if (currentContract.compiler)
+		return currentContract.compiler->streamAssembly(_outStream, _sourceCodes, _inJsonFormat);
 	else
 	{
 		_outStream << "Contract not fully implemented" << endl;
@@ -227,22 +239,22 @@ Json::Value CompilerStack::streamAssembly(ostream& _outStream, string const& _co
 	}
 }
 
-string const& CompilerStack::getInterface(string const& _contractName) const
+string const& CompilerStack::interface(string const& _contractName) const
 {
-	return getMetadata(_contractName, DocumentationType::ABIInterface);
+	return metadata(_contractName, DocumentationType::ABIInterface);
 }
 
-string const& CompilerStack::getSolidityInterface(string const& _contractName) const
+string const& CompilerStack::solidityInterface(string const& _contractName) const
 {
-	return getMetadata(_contractName, DocumentationType::ABISolidityInterface);
+	return metadata(_contractName, DocumentationType::ABISolidityInterface);
 }
 
-string const& CompilerStack::getMetadata(string const& _contractName, DocumentationType _type) const
+string const& CompilerStack::metadata(string const& _contractName, DocumentationType _type) const
 {
 	if (!m_parseSuccessful)
 		BOOST_THROW_EXCEPTION(CompilerError() << errinfo_comment("Parsing was not successful."));
 
-	Contract const& contract = getContract(_contractName);
+	Contract const& currentContract = contract(_contractName);
 
 	std::unique_ptr<string const>* doc;
 
@@ -250,16 +262,16 @@ string const& CompilerStack::getMetadata(string const& _contractName, Documentat
 	switch (_type)
 	{
 	case DocumentationType::NatspecUser:
-		doc = &contract.userDocumentation;
+		doc = &currentContract.userDocumentation;
 		break;
 	case DocumentationType::NatspecDev:
-		doc = &contract.devDocumentation;
+		doc = &currentContract.devDocumentation;
 		break;
 	case DocumentationType::ABIInterface:
-		doc = &contract.interface;
+		doc = &currentContract.interface;
 		break;
 	case DocumentationType::ABISolidityInterface:
-		doc = &contract.solidityInterface;
+		doc = &currentContract.solidityInterface;
 		break;
 	default:
 		BOOST_THROW_EXCEPTION(InternalCompilerError() << errinfo_comment("Illegal documentation type."));
@@ -267,45 +279,45 @@ string const& CompilerStack::getMetadata(string const& _contractName, Documentat
 
 	// caches the result
 	if (!*doc)
-		doc->reset(new string(contract.interfaceHandler->getDocumentation(*contract.contract, _type)));
+		doc->reset(new string(currentContract.interfaceHandler->documentation(*currentContract.contract, _type)));
 
 	return *(*doc);
 }
 
-Scanner const& CompilerStack::getScanner(string const& _sourceName) const
+Scanner const& CompilerStack::scanner(string const& _sourceName) const
 {
-	return *getSource(_sourceName).scanner;
+	return *source(_sourceName).scanner;
 }
 
-SourceUnit const& CompilerStack::getAST(string const& _sourceName) const
+SourceUnit const& CompilerStack::ast(string const& _sourceName) const
 {
-	return *getSource(_sourceName).ast;
+	return *source(_sourceName).ast;
 }
 
-ContractDefinition const& CompilerStack::getContractDefinition(string const& _contractName) const
+ContractDefinition const& CompilerStack::contractDefinition(string const& _contractName) const
 {
-	return *getContract(_contractName).contract;
+	return *contract(_contractName).contract;
 }
 
-size_t CompilerStack::getFunctionEntryPoint(
+size_t CompilerStack::functionEntryPoint(
 	std::string const& _contractName,
 	FunctionDefinition const& _function
 ) const
 {
-	shared_ptr<Compiler> const& compiler = getContract(_contractName).compiler;
+	shared_ptr<Compiler> const& compiler = contract(_contractName).compiler;
 	if (!compiler)
 		return 0;
-	eth::AssemblyItem tag = compiler->getFunctionEntryLabel(_function);
+	eth::AssemblyItem tag = compiler->functionEntryLabel(_function);
 	if (tag.type() == eth::UndefinedItem)
 		return 0;
-	eth::AssemblyItems const& items = compiler->getRuntimeAssemblyItems();
+	eth::AssemblyItems const& items = compiler->runtimeAssemblyItems();
 	for (size_t i = 0; i < items.size(); ++i)
 		if (items.at(i).type() == eth::Tag && items.at(i).data() == tag.data())
 			return i;
 	return 0;
 }
 
-bytes CompilerStack::staticCompile(std::string const& _sourceCode, bool _optimize)
+eth::LinkerObject CompilerStack::staticCompile(std::string const& _sourceCode, bool _optimize)
 {
 	CompilerStack stack;
 	return stack.compile(_sourceCode, _optimize);
@@ -317,8 +329,8 @@ tuple<int, int, int, int> CompilerStack::positionFromSourceLocation(SourceLocati
 	int startColumn;
 	int endLine;
 	int endColumn;
-	tie(startLine, startColumn) = getScanner(*_sourceLocation.sourceName).translatePositionToLineColumn(_sourceLocation.start);
-	tie(endLine, endColumn) = getScanner(*_sourceLocation.sourceName).translatePositionToLineColumn(_sourceLocation.end);
+	tie(startLine, startColumn) = scanner(*_sourceLocation.sourceName).translatePositionToLineColumn(_sourceLocation.start);
+	tie(endLine, endColumn) = scanner(*_sourceLocation.sourceName).translatePositionToLineColumn(_sourceLocation.end);
 
 	return make_tuple(++startLine, ++startColumn, ++endLine, ++endColumn);
 }
@@ -334,14 +346,16 @@ void CompilerStack::resolveImports()
 		if (sourcesSeen.count(_source))
 			return;
 		sourcesSeen.insert(_source);
-		for (ASTPointer<ASTNode> const& node: _source->ast->getNodes())
+		for (ASTPointer<ASTNode> const& node: _source->ast->nodes())
 			if (ImportDirective const* import = dynamic_cast<ImportDirective*>(node.get()))
 			{
-				string const& id = import->getIdentifier();
+				string const& id = import->identifier();
 				if (!m_sources.count(id))
-					BOOST_THROW_EXCEPTION(ParserError()
-										  << errinfo_sourceLocation(import->getLocation())
-										  << errinfo_comment("Source not found."));
+					BOOST_THROW_EXCEPTION(
+						ParserError()
+							  << errinfo_sourceLocation(import->location())
+							  << errinfo_comment("Source not found.")
+					);
 				toposort(&m_sources[id]);
 			}
 		sourceOrder.push_back(_source);
@@ -356,10 +370,10 @@ void CompilerStack::resolveImports()
 
 std::string CompilerStack::defaultContractName() const
 {
-	return getContract("").contract->getName();
+	return contract("").contract->name();
 }
 
-CompilerStack::Contract const& CompilerStack::getContract(string const& _contractName) const
+CompilerStack::Contract const& CompilerStack::contract(string const& _contractName) const
 {
 	if (m_contracts.empty())
 		BOOST_THROW_EXCEPTION(CompilerError() << errinfo_comment("No compiled contracts found."));
@@ -368,16 +382,16 @@ CompilerStack::Contract const& CompilerStack::getContract(string const& _contrac
 		// try to find some user-supplied contract
 		for (auto const& it: m_sources)
 			if (!StandardSources.count(it.first))
-				for (ASTPointer<ASTNode> const& node: it.second.ast->getNodes())
+				for (ASTPointer<ASTNode> const& node: it.second.ast->nodes())
 					if (auto contract = dynamic_cast<ContractDefinition const*>(node.get()))
-						contractName = contract->getName();
+						contractName = contract->name();
 	auto it = m_contracts.find(contractName);
 	if (it == m_contracts.end())
 		BOOST_THROW_EXCEPTION(CompilerError() << errinfo_comment("Contract " + _contractName + " not found."));
 	return it->second;
 }
 
-CompilerStack::Source const& CompilerStack::getSource(string const& _sourceName) const
+CompilerStack::Source const& CompilerStack::source(string const& _sourceName) const
 {
 	auto it = m_sources.find(_sourceName);
 	if (it == m_sources.end())
diff --git a/libsolidity/CompilerStack.h b/libsolidity/CompilerStack.h
index 735c4d15..99e8af1a 100644
--- a/libsolidity/CompilerStack.h
+++ b/libsolidity/CompilerStack.h
@@ -32,6 +32,7 @@
 #include <libdevcore/Common.h>
 #include <libdevcore/FixedHash.h>
 #include <libevmasm/SourceLocation.h>
+#include <libevmasm/LinkerObject.h>
 
 namespace dev
 {
@@ -86,30 +87,35 @@ public:
 	/// Sets the given source code as the only source unit apart from standard sources and parses it.
 	void parse(std::string const& _sourceCode);
 	/// Returns a list of the contract names in the sources.
-	std::vector<std::string> getContractNames() const;
+	std::vector<std::string> contractNames() const;
 	std::string defaultContractName() const;
 
 	/// Compiles the source units that were previously added and parsed.
 	void compile(bool _optimize = false, unsigned _runs = 200);
 	/// Parses and compiles the given source code.
-	/// @returns the compiled bytecode
-	bytes const& compile(std::string const& _sourceCode, bool _optimize = false);
+	/// @returns the compiled linker object
+	eth::LinkerObject const& compile(std::string const& _sourceCode, bool _optimize = false);
 
-	/// @returns the assembled bytecode for a contract.
-	bytes const& getBytecode(std::string const& _contractName = "") const;
-	/// @returns the runtime bytecode for the contract, i.e. the code that is returned by the constructor.
-	bytes const& getRuntimeBytecode(std::string const& _contractName = "") const;
+	/// Inserts the given addresses into the linker objects of all compiled contracts.
+	void link(std::map<std::string, h160> const& _libraries);
+
+	/// @returns the assembled object for a contract.
+	eth::LinkerObject const& object(std::string const& _contractName = "") const;
+	/// @returns the runtime object for the contract.
+	eth::LinkerObject const& runtimeObject(std::string const& _contractName = "") const;
 	/// @returns the bytecode of a contract that uses an already deployed contract via CALLCODE.
 	/// The returned bytes will contain a sequence of 20 bytes of the format "XXX...XXX" which have to
 	/// substituted by the actual address. Note that this sequence starts end ends in three X
 	/// characters but can contain anything in between.
-	bytes const& getCloneBytecode(std::string const& _contractName = "") const;
+	eth::LinkerObject const& cloneObject(std::string const& _contractName = "") const;
 	/// @returns normal contract assembly items
-	eth::AssemblyItems const* getAssemblyItems(std::string const& _contractName = "") const;
+	eth::AssemblyItems const* assemblyItems(std::string const& _contractName = "") const;
 	/// @returns runtime contract assembly items
-	eth::AssemblyItems const* getRuntimeAssemblyItems(std::string const& _contractName = "") const;
-	/// @returns hash of the runtime bytecode for the contract, i.e. the code that is returned by the constructor.
-	dev::h256 getContractCodeHash(std::string const& _contractName = "") const;
+	eth::AssemblyItems const* runtimeAssemblyItems(std::string const& _contractName = "") const;
+	/// @returns hash of the runtime bytecode for the contract, i.e. the code that is
+	/// returned by the constructor or the zero-h256 if the contract still needs to be linked or
+	/// does not have runtime code.
+	dev::h256 contractCodeHash(std::string const& _contractName = "") const;
 
 	/// Streams a verbose version of the assembly to @a _outStream.
 	/// @arg _sourceCodes is the map of input files to source code strings
@@ -119,34 +125,34 @@ public:
 
 	/// Returns a string representing the contract interface in JSON.
 	/// Prerequisite: Successful call to parse or compile.
-	std::string const& getInterface(std::string const& _contractName = "") const;
+	std::string const& interface(std::string const& _contractName = "") const;
 	/// Returns a string representing the contract interface in Solidity.
 	/// Prerequisite: Successful call to parse or compile.
-	std::string const& getSolidityInterface(std::string const& _contractName = "") const;
+	std::string const& solidityInterface(std::string const& _contractName = "") const;
 	/// Returns a string representing the contract's documentation in JSON.
 	/// Prerequisite: Successful call to parse or compile.
 	/// @param type The type of the documentation to get.
 	/// Can be one of 4 types defined at @c DocumentationType
-	std::string const& getMetadata(std::string const& _contractName, DocumentationType _type) const;
+	std::string const& metadata(std::string const& _contractName, DocumentationType _type) const;
 
 	/// @returns the previously used scanner, useful for counting lines during error reporting.
-	Scanner const& getScanner(std::string const& _sourceName = "") const;
+	Scanner const& scanner(std::string const& _sourceName = "") const;
 	/// @returns the parsed source unit with the supplied name.
-	SourceUnit const& getAST(std::string const& _sourceName = "") const;
+	SourceUnit const& ast(std::string const& _sourceName = "") const;
 	/// @returns the parsed contract with the supplied name. Throws an exception if the contract
 	/// does not exist.
-	ContractDefinition const& getContractDefinition(std::string const& _contractName) const;
+	ContractDefinition const& contractDefinition(std::string const& _contractName) const;
 
 	/// @returns the offset of the entry point of the given function into the list of assembly items
 	/// or zero if it is not found or does not exist.
-	size_t getFunctionEntryPoint(
+	size_t functionEntryPoint(
 		std::string const& _contractName,
 		FunctionDefinition const& _function
 	) const;
 
 	/// Compile the given @a _sourceCode to bytecode. If a scanner is provided, it is used for
 	/// scanning the source code - this is useful for printing exception information.
-	static bytes staticCompile(std::string const& _sourceCode, bool _optimize = false);
+	static eth::LinkerObject staticCompile(std::string const& _sourceCode, bool _optimize = false);
 
 	/// Helper function for logs printing. Do only use in error cases, it's quite expensive.
 	/// line and columns are numbered starting from 1 with following order:
@@ -170,9 +176,9 @@ private:
 	{
 		ContractDefinition const* contract = nullptr;
 		std::shared_ptr<Compiler> compiler;
-		bytes bytecode;
-		bytes runtimeBytecode;
-		bytes cloneBytecode;
+		eth::LinkerObject object;
+		eth::LinkerObject runtimeObject;
+		eth::LinkerObject cloneObject;
 		std::shared_ptr<InterfaceHandler> interfaceHandler;
 		mutable std::unique_ptr<std::string const> interface;
 		mutable std::unique_ptr<std::string const> solidityInterface;
@@ -184,8 +190,8 @@ private:
 
 	void resolveImports();
 
-	Contract const& getContract(std::string const& _contractName = "") const;
-	Source const& getSource(std::string const& _sourceName = "") const;
+	Contract const& contract(std::string const& _contractName = "") const;
+	Source const& source(std::string const& _sourceName = "") const;
 
 	bool m_parseSuccessful;
 	std::map<std::string const, Source> m_sources;
diff --git a/libsolidity/CompilerUtils.cpp b/libsolidity/CompilerUtils.cpp
index 49247581..e370c6be 100644
--- a/libsolidity/CompilerUtils.cpp
+++ b/libsolidity/CompilerUtils.cpp
@@ -75,7 +75,7 @@ unsigned CompilerUtils::loadFromMemory(
 	bool _padToWordBoundaries
 )
 {
-	solAssert(_type.getCategory() != Type::Category::Array, "Unable to statically load dynamic type.");
+	solAssert(_type.category() != Type::Category::Array, "Unable to statically load dynamic type.");
 	m_context << u256(_offset);
 	return loadFromMemoryHelper(_type, _fromCalldata, _padToWordBoundaries);
 }
@@ -87,14 +87,14 @@ void CompilerUtils::loadFromMemoryDynamic(
 	bool _keepUpdatedMemoryOffset
 )
 {
-	solAssert(_type.getCategory() != Type::Category::Array, "Arrays not yet implemented.");
+	solAssert(_type.category() != Type::Category::Array, "Arrays not yet implemented.");
 	if (_keepUpdatedMemoryOffset)
 		m_context << eth::Instruction::DUP1;
 	unsigned numBytes = loadFromMemoryHelper(_type, _fromCalldata, _padToWordBoundaries);
 	if (_keepUpdatedMemoryOffset)
 	{
 		// update memory counter
-		moveToStackTop(_type.getSizeOnStack());
+		moveToStackTop(_type.sizeOnStack());
 		m_context << u256(numBytes) << eth::Instruction::ADD;
 	}
 }
@@ -129,7 +129,7 @@ void CompilerUtils::storeInMemoryDynamic(Type const& _type, bool _padToWordBound
 		if (numBytes > 0)
 		{
 			solAssert(
-				_type.getSizeOnStack() == 1,
+				_type.sizeOnStack() == 1,
 				"Memory store of types with stack size != 1 not implemented."
 			);
 			m_context << eth::Instruction::DUP2 << eth::Instruction::MSTORE;
@@ -159,7 +159,7 @@ void CompilerUtils::encodeToMemory(
 	// store memory start pointer
 	m_context << eth::Instruction::DUP1;
 
-	unsigned argSize = CompilerUtils::getSizeOnStack(_givenTypes);
+	unsigned argSize = CompilerUtils::sizeOnStack(_givenTypes);
 	unsigned stackPos = 0; // advances through the argument values
 	unsigned dynPointers = 0; // number of dynamic head pointers on the stack
 	for (size_t i = 0; i < _givenTypes.size(); ++i)
@@ -174,13 +174,13 @@ void CompilerUtils::encodeToMemory(
 		}
 		else
 		{
-			copyToStackTop(argSize - stackPos + dynPointers + 2, _givenTypes[i]->getSizeOnStack());
+			copyToStackTop(argSize - stackPos + dynPointers + 2, _givenTypes[i]->sizeOnStack());
 			solAssert(!!targetType, "Externalable type expected.");
 			TypePointer type = targetType;
 			if (
 				_givenTypes[i]->dataStoredIn(DataLocation::Storage) ||
 				_givenTypes[i]->dataStoredIn(DataLocation::CallData) ||
-				_givenTypes[i]->getCategory() == Type::Category::StringLiteral
+				_givenTypes[i]->category() == Type::Category::StringLiteral
 			)
 				type = _givenTypes[i]; // delay conversion
 			else
@@ -190,7 +190,7 @@ void CompilerUtils::encodeToMemory(
 			else
 				storeInMemoryDynamic(*type, _padToWordBoundaries);
 		}
-		stackPos += _givenTypes[i]->getSizeOnStack();
+		stackPos += _givenTypes[i]->sizeOnStack();
 	}
 
 	// now copy the dynamic part
@@ -209,7 +209,7 @@ void CompilerUtils::encodeToMemory(
 			m_context << eth::dupInstruction(2 + dynPointers - thisDynPointer);
 			m_context << eth::Instruction::MSTORE;
 			// stack: ... <end_of_mem>
-			if (_givenTypes[i]->getCategory() == Type::Category::StringLiteral)
+			if (_givenTypes[i]->category() == Type::Category::StringLiteral)
 			{
 				auto const& strType = dynamic_cast<StringLiteralType const&>(*_givenTypes[i]);
 				m_context << u256(strType.value().size());
@@ -219,13 +219,13 @@ void CompilerUtils::encodeToMemory(
 			}
 			else
 			{
-				solAssert(_givenTypes[i]->getCategory() == Type::Category::Array, "Unknown dynamic type.");
+				solAssert(_givenTypes[i]->category() == Type::Category::Array, "Unknown dynamic type.");
 				auto const& arrayType = dynamic_cast<ArrayType const&>(*_givenTypes[i]);
 				// now copy the array
-				copyToStackTop(argSize - stackPos + dynPointers + 2, arrayType.getSizeOnStack());
+				copyToStackTop(argSize - stackPos + dynPointers + 2, arrayType.sizeOnStack());
 				// stack: ... <end_of_mem> <value...>
 				// copy length to memory
-				m_context << eth::dupInstruction(1 + arrayType.getSizeOnStack());
+				m_context << eth::dupInstruction(1 + arrayType.sizeOnStack());
 				if (arrayType.location() == DataLocation::CallData)
 					m_context << eth::Instruction::DUP2; // length is on stack
 				else if (arrayType.location() == DataLocation::Storage)
@@ -239,7 +239,7 @@ void CompilerUtils::encodeToMemory(
 				storeInMemoryDynamic(IntegerType(256), true);
 				// stack: ... <end_of_mem> <value...> <end_of_mem''>
 				// copy the new memory pointer
-				m_context << eth::swapInstruction(arrayType.getSizeOnStack() + 1) << eth::Instruction::POP;
+				m_context << eth::swapInstruction(arrayType.sizeOnStack() + 1) << eth::Instruction::POP;
 				// stack: ... <end_of_mem''> <value...>
 				// copy data part
 				ArrayUtils(m_context).copyArrayToMemory(arrayType, _padToWordBoundaries);
@@ -248,7 +248,7 @@ void CompilerUtils::encodeToMemory(
 
 			thisDynPointer++;
 		}
-		stackPos += _givenTypes[i]->getSizeOnStack();
+		stackPos += _givenTypes[i]->sizeOnStack();
 	}
 
 	// remove unneeded stack elements (and retain memory pointer)
@@ -279,8 +279,8 @@ void CompilerUtils::convertType(Type const& _typeOnStack, Type const& _targetTyp
 
 	if (_typeOnStack == _targetType && !_cleanupNeeded)
 		return;
-	Type::Category stackTypeCategory = _typeOnStack.getCategory();
-	Type::Category targetTypeCategory = _targetType.getCategory();
+	Type::Category stackTypeCategory = _typeOnStack.category();
+	Type::Category targetTypeCategory = _targetType.category();
 
 	switch (stackTypeCategory)
 	{
@@ -293,7 +293,7 @@ void CompilerUtils::convertType(Type const& _typeOnStack, Type const& _targetTyp
 			// only to shift right because of opposite alignment
 			IntegerType const& targetIntegerType = dynamic_cast<IntegerType const&>(_targetType);
 			m_context << (u256(1) << (256 - typeOnStack.numBytes() * 8)) << eth::Instruction::SWAP1 << eth::Instruction::DIV;
-			if (targetIntegerType.getNumBits() < typeOnStack.numBytes() * 8)
+			if (targetIntegerType.numBits() < typeOnStack.numBytes() * 8)
 				convertType(IntegerType(typeOnStack.numBytes() * 8), _targetType, _cleanupNeeded);
 		}
 		else
@@ -329,7 +329,7 @@ void CompilerUtils::convertType(Type const& _typeOnStack, Type const& _targetTyp
 			// only to shift left because of opposite alignment
 			FixedBytesType const& targetBytesType = dynamic_cast<FixedBytesType const&>(_targetType);
 			if (auto typeOnStack = dynamic_cast<IntegerType const*>(&_typeOnStack))
-				if (targetBytesType.numBytes() * 8 > typeOnStack->getNumBits())
+				if (targetBytesType.numBytes() * 8 > typeOnStack->numBits())
 					cleanHigherOrderBits(*typeOnStack);
 			m_context << (u256(1) << (256 - targetBytesType.numBytes() * 8)) << eth::Instruction::MUL;
 		}
@@ -347,7 +347,7 @@ void CompilerUtils::convertType(Type const& _typeOnStack, Type const& _targetTyp
 				IntegerConstantType const& constType = dynamic_cast<IntegerConstantType const&>(_typeOnStack);
 				// We know that the stack is clean, we only have to clean for a narrowing conversion
 				// where cleanup is forced.
-				if (targetType.getNumBits() < constType.getIntegerType()->getNumBits() && _cleanupNeeded)
+				if (targetType.numBits() < constType.integerType()->numBits() && _cleanupNeeded)
 					cleanHigherOrderBits(targetType);
 			}
 			else
@@ -356,7 +356,7 @@ void CompilerUtils::convertType(Type const& _typeOnStack, Type const& _targetTyp
 					? dynamic_cast<IntegerType const&>(_typeOnStack) : addressType;
 				// Widening: clean up according to source type width
 				// Non-widening and force: clean up according to target type bits
-				if (targetType.getNumBits() > typeOnStack.getNumBits())
+				if (targetType.numBits() > typeOnStack.numBits())
 					cleanHigherOrderBits(typeOnStack);
 				else if (_cleanupNeeded)
 					cleanHigherOrderBits(targetType);
@@ -415,7 +415,7 @@ void CompilerUtils::convertType(Type const& _typeOnStack, Type const& _targetTyp
 			if (typeOnStack.location() != DataLocation::Memory)
 			{
 				// stack: <source ref> (variably sized)
-				unsigned stackSize = typeOnStack.getSizeOnStack();
+				unsigned stackSize = typeOnStack.sizeOnStack();
 				ArrayUtils(m_context).retrieveLength(typeOnStack);
 
 				// allocate memory
@@ -435,9 +435,9 @@ void CompilerUtils::convertType(Type const& _typeOnStack, Type const& _targetTyp
 					storeInMemoryDynamic(IntegerType(256));
 				}
 				// stack: <mem start> <source ref> (variably sized) <length> <mem data pos>
-				if (targetType.getBaseType()->isValueType())
+				if (targetType.baseType()->isValueType())
 				{
-					solAssert(typeOnStack.getBaseType()->isValueType(), "");
+					solAssert(typeOnStack.baseType()->isValueType(), "");
 					copyToStackTop(2 + stackSize, stackSize);
 					ArrayUtils(m_context).copyArrayToMemory(typeOnStack);
 				}
@@ -454,9 +454,9 @@ void CompilerUtils::convertType(Type const& _typeOnStack, Type const& _targetTyp
 					copyToStackTop(2 + stackSize, 1);
 					ArrayUtils(m_context).accessIndex(typeOnStack, false);
 					if (typeOnStack.location() == DataLocation::Storage)
-						StorageItem(m_context, *typeOnStack.getBaseType()).retrieveValue(SourceLocation(), true);
-					convertType(*typeOnStack.getBaseType(), *targetType.getBaseType(), _cleanupNeeded);
-					storeInMemoryDynamic(*targetType.getBaseType(), true);
+						StorageItem(m_context, *typeOnStack.baseType()).retrieveValue(SourceLocation(), true);
+					convertType(*typeOnStack.baseType(), *targetType.baseType(), _cleanupNeeded);
+					storeInMemoryDynamic(*targetType.baseType(), true);
 					m_context << eth::Instruction::SWAP1 << u256(1) << eth::Instruction::ADD;
 					m_context << eth::Instruction::SWAP1;
 					m_context.appendJumpTo(repeat);
@@ -517,15 +517,15 @@ void CompilerUtils::convertType(Type const& _typeOnStack, Type const& _targetTyp
 				allocateMemory();
 				m_context << eth::Instruction::SWAP1 << eth::Instruction::DUP2;
 				// stack: <memory ptr> <source ref> <memory ptr>
-				for (auto const& member: typeOnStack.getMembers())
+				for (auto const& member: typeOnStack.members())
 				{
 					if (!member.type->canLiveOutsideStorage())
 						continue;
-					pair<u256, unsigned> const& offsets = typeOnStack.getStorageOffsetsOfMember(member.name);
+					pair<u256, unsigned> const& offsets = typeOnStack.storageOffsetsOfMember(member.name);
 					m_context << offsets.first << eth::Instruction::DUP3 << eth::Instruction::ADD;
 					m_context << u256(offsets.second);
 					StorageItem(m_context, *member.type).retrieveValue(SourceLocation(), true);
-					TypePointer targetMemberType = targetType.getMemberType(member.name);
+					TypePointer targetMemberType = targetType.memberType(member.name);
 					solAssert(!!targetMemberType, "Member not found in target type.");
 					convertType(*member.type, *targetMemberType, true);
 					storeInMemoryDynamic(*targetMemberType, true);
@@ -551,18 +551,18 @@ void CompilerUtils::pushZeroValue(const Type& _type)
 	auto const* referenceType = dynamic_cast<ReferenceType const*>(&_type);
 	if (!referenceType || referenceType->location() == DataLocation::Storage)
 	{
-		for (size_t i = 0; i < _type.getSizeOnStack(); ++i)
+		for (size_t i = 0; i < _type.sizeOnStack(); ++i)
 			m_context << u256(0);
 		return;
 	}
 	solAssert(referenceType->location() == DataLocation::Memory, "");
 
-	m_context << u256(max(32u, _type.getCalldataEncodedSize()));
+	m_context << u256(max(32u, _type.calldataEncodedSize()));
 	allocateMemory();
 	m_context << eth::Instruction::DUP1;
 
 	if (auto structType = dynamic_cast<StructType const*>(&_type))
-		for (auto const& member: structType->getMembers())
+		for (auto const& member: structType->members())
 		{
 			pushZeroValue(*member.type);
 			storeInMemoryDynamic(*member.type);
@@ -575,14 +575,14 @@ void CompilerUtils::pushZeroValue(const Type& _type)
 			m_context << u256(0);
 			storeInMemoryDynamic(IntegerType(256));
 		}
-		else if (arrayType->getLength() > 0)
+		else if (arrayType->length() > 0)
 		{
-			m_context << arrayType->getLength() << eth::Instruction::SWAP1;
+			m_context << arrayType->length() << eth::Instruction::SWAP1;
 			// stack: items_to_do memory_pos
 			auto repeat = m_context.newTag();
 			m_context << repeat;
-			pushZeroValue(*arrayType->getBaseType());
-			storeInMemoryDynamic(*arrayType->getBaseType());
+			pushZeroValue(*arrayType->baseType());
+			storeInMemoryDynamic(*arrayType->baseType());
 			m_context << eth::Instruction::SWAP1 << u256(1) << eth::Instruction::SWAP1;
 			m_context << eth::Instruction::SUB << eth::Instruction::SWAP1;
 			m_context << eth::Instruction::DUP2;
@@ -599,14 +599,14 @@ void CompilerUtils::pushZeroValue(const Type& _type)
 
 void CompilerUtils::moveToStackVariable(VariableDeclaration const& _variable)
 {
-	unsigned const stackPosition = m_context.baseToCurrentStackOffset(m_context.getBaseStackOffsetOfVariable(_variable));
-	unsigned const size = _variable.getType()->getSizeOnStack();
+	unsigned const stackPosition = m_context.baseToCurrentStackOffset(m_context.baseStackOffsetOfVariable(_variable));
+	unsigned const size = _variable.type()->sizeOnStack();
 	solAssert(stackPosition >= size, "Variable size and position mismatch.");
 	// move variable starting from its top end in the stack
 	if (stackPosition - size + 1 > 16)
 		BOOST_THROW_EXCEPTION(
 			CompilerError() <<
-			errinfo_sourceLocation(_variable.getLocation()) <<
+			errinfo_sourceLocation(_variable.location()) <<
 			errinfo_comment("Stack too deep, try removing local variables.")
 		);
 	for (unsigned i = 0; i < size; ++i)
@@ -636,7 +636,7 @@ void CompilerUtils::moveIntoStack(unsigned _stackDepth)
 
 void CompilerUtils::popStackElement(Type const& _type)
 {
-	popStackSlots(_type.getSizeOnStack());
+	popStackSlots(_type.sizeOnStack());
 }
 
 void CompilerUtils::popStackSlots(size_t _amount)
@@ -645,11 +645,11 @@ void CompilerUtils::popStackSlots(size_t _amount)
 		m_context << eth::Instruction::POP;
 }
 
-unsigned CompilerUtils::getSizeOnStack(vector<shared_ptr<Type const>> const& _variableTypes)
+unsigned CompilerUtils::sizeOnStack(vector<shared_ptr<Type const>> const& _variableTypes)
 {
 	unsigned size = 0;
 	for (shared_ptr<Type const> const& type: _variableTypes)
-		size += type->getSizeOnStack();
+		size += type->sizeOnStack();
 	return size;
 }
 
@@ -683,8 +683,8 @@ void CompilerUtils::storeStringData(bytesConstRef _data)
 
 unsigned CompilerUtils::loadFromMemoryHelper(Type const& _type, bool _fromCalldata, bool _padToWordBoundaries)
 {
-	unsigned numBytes = _type.getCalldataEncodedSize(_padToWordBoundaries);
-	bool leftAligned = _type.getCategory() == Type::Category::FixedBytes;
+	unsigned numBytes = _type.calldataEncodedSize(_padToWordBoundaries);
+	bool leftAligned = _type.category() == Type::Category::FixedBytes;
 	if (numBytes == 0)
 		m_context << eth::Instruction::POP << u256(0);
 	else
@@ -706,18 +706,18 @@ unsigned CompilerUtils::loadFromMemoryHelper(Type const& _type, bool _fromCallda
 
 void CompilerUtils::cleanHigherOrderBits(IntegerType const& _typeOnStack)
 {
-	if (_typeOnStack.getNumBits() == 256)
+	if (_typeOnStack.numBits() == 256)
 		return;
 	else if (_typeOnStack.isSigned())
-		m_context << u256(_typeOnStack.getNumBits() / 8 - 1) << eth::Instruction::SIGNEXTEND;
+		m_context << u256(_typeOnStack.numBits() / 8 - 1) << eth::Instruction::SIGNEXTEND;
 	else
-		m_context << ((u256(1) << _typeOnStack.getNumBits()) - 1) << eth::Instruction::AND;
+		m_context << ((u256(1) << _typeOnStack.numBits()) - 1) << eth::Instruction::AND;
 }
 
 unsigned CompilerUtils::prepareMemoryStore(Type const& _type, bool _padToWordBoundaries) const
 {
-	unsigned numBytes = _type.getCalldataEncodedSize(_padToWordBoundaries);
-	bool leftAligned = _type.getCategory() == Type::Category::FixedBytes;
+	unsigned numBytes = _type.calldataEncodedSize(_padToWordBoundaries);
+	bool leftAligned = _type.category() == Type::Category::FixedBytes;
 	if (numBytes == 0)
 		m_context << eth::Instruction::POP;
 	else
diff --git a/libsolidity/CompilerUtils.h b/libsolidity/CompilerUtils.h
index dbb00a1d..0875ddd2 100644
--- a/libsolidity/CompilerUtils.h
+++ b/libsolidity/CompilerUtils.h
@@ -131,8 +131,8 @@ public:
 	void popStackSlots(size_t _amount);
 
 	template <class T>
-	static unsigned getSizeOnStack(std::vector<T> const& _variables);
-	static unsigned getSizeOnStack(std::vector<std::shared_ptr<Type const>> const& _variableTypes);
+	static unsigned sizeOnStack(std::vector<T> const& _variables);
+	static unsigned sizeOnStack(std::vector<std::shared_ptr<Type const>> const& _variableTypes);
 
 	/// Appends code that computes tha SHA3 hash of the topmost stack element of 32 byte type.
 	void computeHashStatic();
@@ -166,11 +166,11 @@ private:
 
 
 template <class T>
-unsigned CompilerUtils::getSizeOnStack(std::vector<T> const& _variables)
+unsigned CompilerUtils::sizeOnStack(std::vector<T> const& _variables)
 {
 	unsigned size = 0;
 	for (T const& variable: _variables)
-		size += variable->getType()->getSizeOnStack();
+		size += variable->type()->sizeOnStack();
 	return size;
 }
 
diff --git a/libsolidity/DeclarationContainer.cpp b/libsolidity/DeclarationContainer.cpp
index 3e23d93b..dbe9715d 100644
--- a/libsolidity/DeclarationContainer.cpp
+++ b/libsolidity/DeclarationContainer.cpp
@@ -30,13 +30,13 @@ using namespace dev::solidity;
 
 Declaration const* DeclarationContainer::conflictingDeclaration(Declaration const& _declaration) const
 {
-	ASTString const& name(_declaration.getName());
-	solAssert(!name.empty(), "");
+	ASTString const& declarationName(_declaration.name());
+	solAssert(!declarationName.empty(), "");
 	vector<Declaration const*> declarations;
-	if (m_declarations.count(name))
-		declarations += m_declarations.at(name);
-	if (m_invisibleDeclarations.count(name))
-		declarations += m_invisibleDeclarations.at(name);
+	if (m_declarations.count(declarationName))
+		declarations += m_declarations.at(declarationName);
+	if (m_invisibleDeclarations.count(declarationName))
+		declarations += m_invisibleDeclarations.at(declarationName);
 
 	if (dynamic_cast<FunctionDefinition const*>(&_declaration))
 	{
@@ -53,23 +53,23 @@ Declaration const* DeclarationContainer::conflictingDeclaration(Declaration cons
 
 bool DeclarationContainer::registerDeclaration(Declaration const& _declaration, bool _invisible, bool _update)
 {
-	ASTString const& name(_declaration.getName());
-	if (name.empty())
+	ASTString const& declarationName(_declaration.name());
+	if (declarationName.empty())
 		return true;
 
 	if (_update)
 	{
 		solAssert(!dynamic_cast<FunctionDefinition const*>(&_declaration), "Attempt to update function definition.");
-		m_declarations.erase(name);
-		m_invisibleDeclarations.erase(name);
+		m_declarations.erase(declarationName);
+		m_invisibleDeclarations.erase(declarationName);
 	}
 	else if (conflictingDeclaration(_declaration))
 		return false;
 
 	if (_invisible)
-		m_invisibleDeclarations[name].push_back(&_declaration);
+		m_invisibleDeclarations[declarationName].push_back(&_declaration);
 	else
-		m_declarations[name].push_back(&_declaration);
+		m_declarations[declarationName].push_back(&_declaration);
 	return true;
 }
 
diff --git a/libsolidity/DeclarationContainer.h b/libsolidity/DeclarationContainer.h
index 0f0b5717..ffbd1fcb 100644
--- a/libsolidity/DeclarationContainer.h
+++ b/libsolidity/DeclarationContainer.h
@@ -49,8 +49,8 @@ public:
 	/// @returns false if the name was already declared.
 	bool registerDeclaration(Declaration const& _declaration, bool _invisible = false, bool _update = false);
 	std::vector<Declaration const*> resolveName(ASTString const& _name, bool _recursive = false) const;
-	Declaration const* getEnclosingDeclaration() const { return m_enclosingDeclaration; }
-	std::map<ASTString, std::vector<Declaration const*>> const& getDeclarations() const { return m_declarations; }
+	Declaration const* enclosingDeclaration() const { return m_enclosingDeclaration; }
+	std::map<ASTString, std::vector<Declaration const*>> const& declarations() const { return m_declarations; }
 	/// @returns whether declaration is valid, and if not also returns previous declaration.
 	Declaration const* conflictingDeclaration(Declaration const& _declaration) const;
 
diff --git a/libsolidity/ExpressionCompiler.cpp b/libsolidity/ExpressionCompiler.cpp
index 0841089b..7db0dde9 100644
--- a/libsolidity/ExpressionCompiler.cpp
+++ b/libsolidity/ExpressionCompiler.cpp
@@ -46,14 +46,14 @@ void ExpressionCompiler::compile(Expression const& _expression)
 
 void ExpressionCompiler::appendStateVariableInitialization(VariableDeclaration const& _varDecl)
 {
-	if (!_varDecl.getValue())
+	if (!_varDecl.value())
 		return;
-	TypePointer type = _varDecl.getValue()->getType();
+	TypePointer type = _varDecl.value()->type();
 	solAssert(!!type, "Type information not available.");
 	CompilerContext::LocationSetter locationSetter(m_context, _varDecl);
-	_varDecl.getValue()->accept(*this);
+	_varDecl.value()->accept(*this);
 
-	if (_varDecl.getType()->dataStoredIn(DataLocation::Storage))
+	if (_varDecl.type()->dataStoredIn(DataLocation::Storage))
 	{
 		// reference type, only convert value to mobile type and do final conversion in storeValue.
 		utils().convertType(*type, *type->mobileType());
@@ -61,24 +61,36 @@ void ExpressionCompiler::appendStateVariableInitialization(VariableDeclaration c
 	}
 	else
 	{
-		utils().convertType(*type, *_varDecl.getType());
-		type = _varDecl.getType();
+		utils().convertType(*type, *_varDecl.type());
+		type = _varDecl.type();
 	}
-	StorageItem(m_context, _varDecl).storeValue(*type, _varDecl.getLocation(), true);
+	StorageItem(m_context, _varDecl).storeValue(*type, _varDecl.location(), true);
+}
+
+void ExpressionCompiler::appendConstStateVariableAccessor(VariableDeclaration const& _varDecl)
+{
+	solAssert(_varDecl.isConstant(), "");
+	_varDecl.value()->accept(*this);
+	utils().convertType(*_varDecl.value()->type(), *_varDecl.type());
+
+	// append return
+	m_context << eth::dupInstruction(_varDecl.type()->sizeOnStack() + 1);
+	m_context.appendJump(eth::AssemblyItem::JumpType::OutOfFunction);
 }
 
 void ExpressionCompiler::appendStateVariableAccessor(VariableDeclaration const& _varDecl)
 {
+	solAssert(!_varDecl.isConstant(), "");
 	CompilerContext::LocationSetter locationSetter(m_context, _varDecl);
 	FunctionType accessorType(_varDecl);
 
-	TypePointers const& paramTypes = accessorType.getParameterTypes();
+	TypePointers const& paramTypes = accessorType.parameterTypes();
 
 	// retrieve the position of the variable
-	auto const& location = m_context.getStorageLocationOfVariable(_varDecl);
+	auto const& location = m_context.storageLocationOfVariable(_varDecl);
 	m_context << location.first << u256(location.second);
 
-	TypePointer returnType = _varDecl.getType();
+	TypePointer returnType = _varDecl.type();
 
 	for (size_t i = 0; i < paramTypes.size(); ++i)
 	{
@@ -99,7 +111,7 @@ void ExpressionCompiler::appendStateVariableAccessor(VariableDeclaration const&
 			m_context << u256(64) << u256(0) << eth::Instruction::SHA3;
 			// push offset
 			m_context << u256(0);
-			returnType = mappingType->getValueType();
+			returnType = mappingType->valueType();
 		}
 		else if (auto arrayType = dynamic_cast<ArrayType const*>(returnType.get()))
 		{
@@ -107,7 +119,7 @@ void ExpressionCompiler::appendStateVariableAccessor(VariableDeclaration const&
 			m_context << eth::Instruction::POP;
 			utils().copyToStackTop(paramTypes.size() - i + 1, 1);
 			ArrayUtils(m_context).accessIndex(*arrayType);
-			returnType = arrayType->getBaseType();
+			returnType = arrayType->baseType();
 		}
 		else
 			solAssert(false, "Index access is allowed only for \"mapping\" and \"array\" types.");
@@ -123,28 +135,28 @@ void ExpressionCompiler::appendStateVariableAccessor(VariableDeclaration const&
 		utils().popStackSlots(paramTypes.size() - 1);
 	}
 	unsigned retSizeOnStack = 0;
-	solAssert(accessorType.getReturnParameterTypes().size() >= 1, "");
-	auto const& returnTypes = accessorType.getReturnParameterTypes();
+	solAssert(accessorType.returnParameterTypes().size() >= 1, "");
+	auto const& returnTypes = accessorType.returnParameterTypes();
 	if (StructType const* structType = dynamic_cast<StructType const*>(returnType.get()))
 	{
 		// remove offset
 		m_context << eth::Instruction::POP;
-		auto const& names = accessorType.getReturnParameterNames();
+		auto const& names = accessorType.returnParameterNames();
 		// struct
 		for (size_t i = 0; i < names.size(); ++i)
 		{
-			if (returnTypes[i]->getCategory() == Type::Category::Mapping)
+			if (returnTypes[i]->category() == Type::Category::Mapping)
 				continue;
 			if (auto arrayType = dynamic_cast<ArrayType const*>(returnTypes[i].get()))
 				if (!arrayType->isByteArray())
 					continue;
-			pair<u256, unsigned> const& offsets = structType->getStorageOffsetsOfMember(names[i]);
+			pair<u256, unsigned> const& offsets = structType->storageOffsetsOfMember(names[i]);
 			m_context << eth::Instruction::DUP1 << u256(offsets.first) << eth::Instruction::ADD << u256(offsets.second);
-			TypePointer memberType = structType->getMemberType(names[i]);
+			TypePointer memberType = structType->memberType(names[i]);
 			StorageItem(m_context, *memberType).retrieveValue(SourceLocation(), true);
 			utils().convertType(*memberType, *returnTypes[i]);
-			utils().moveToStackTop(returnTypes[i]->getSizeOnStack());
-			retSizeOnStack += returnTypes[i]->getSizeOnStack();
+			utils().moveToStackTop(returnTypes[i]->sizeOnStack());
+			retSizeOnStack += returnTypes[i]->sizeOnStack();
 		}
 		// remove slot
 		m_context << eth::Instruction::POP;
@@ -155,9 +167,9 @@ void ExpressionCompiler::appendStateVariableAccessor(VariableDeclaration const&
 		solAssert(returnTypes.size() == 1, "");
 		StorageItem(m_context, *returnType).retrieveValue(SourceLocation(), true);
 		utils().convertType(*returnType, *returnTypes.front());
-		retSizeOnStack = returnTypes.front()->getSizeOnStack();
+		retSizeOnStack = returnTypes.front()->sizeOnStack();
 	}
-	solAssert(retSizeOnStack == utils().getSizeOnStack(returnTypes), "");
+	solAssert(retSizeOnStack == utils().sizeOnStack(returnTypes), "");
 	solAssert(retSizeOnStack <= 15, "Stack is too deep.");
 	m_context << eth::dupInstruction(retSizeOnStack + 1);
 	m_context.appendJump(eth::AssemblyItem::JumpType::OutOfFunction);
@@ -166,12 +178,12 @@ void ExpressionCompiler::appendStateVariableAccessor(VariableDeclaration const&
 bool ExpressionCompiler::visit(Assignment const& _assignment)
 {
 	CompilerContext::LocationSetter locationSetter(m_context, _assignment);
-	_assignment.getRightHandSide().accept(*this);
-	TypePointer type = _assignment.getRightHandSide().getType();
-	if (!_assignment.getType()->dataStoredIn(DataLocation::Storage))
+	_assignment.rightHandSide().accept(*this);
+	TypePointer type = _assignment.rightHandSide().type();
+	if (!_assignment.type()->dataStoredIn(DataLocation::Storage))
 	{
-		utils().convertType(*type, *_assignment.getType());
-		type = _assignment.getType();
+		utils().convertType(*type, *_assignment.type());
+		type = _assignment.type();
 	}
 	else
 	{
@@ -179,23 +191,23 @@ bool ExpressionCompiler::visit(Assignment const& _assignment)
 		type = type->mobileType();
 	}
 
-	_assignment.getLeftHandSide().accept(*this);
+	_assignment.leftHandSide().accept(*this);
 	solAssert(!!m_currentLValue, "LValue not retrieved.");
 
-	Token::Value op = _assignment.getAssignmentOperator();
+	Token::Value op = _assignment.assignmentOperator();
 	if (op != Token::Assign) // compound assignment
 	{
-		solAssert(_assignment.getType()->isValueType(), "Compound operators not implemented for non-value types.");
+		solAssert(_assignment.type()->isValueType(), "Compound operators not implemented for non-value types.");
 		unsigned lvalueSize = m_currentLValue->sizeOnStack();
-		unsigned itemSize = _assignment.getType()->getSizeOnStack();
+		unsigned itemSize = _assignment.type()->sizeOnStack();
 		if (lvalueSize > 0)
 		{
 			utils().copyToStackTop(lvalueSize + itemSize, itemSize);
 			utils().copyToStackTop(itemSize + lvalueSize, lvalueSize);
 			// value lvalue_ref value lvalue_ref
 		}
-		m_currentLValue->retrieveValue(_assignment.getLocation(), true);
-		appendOrdinaryBinaryOperatorCode(Token::AssignmentToBinaryOp(op), *_assignment.getType());
+		m_currentLValue->retrieveValue(_assignment.location(), true);
+		appendOrdinaryBinaryOperatorCode(Token::AssignmentToBinaryOp(op), *_assignment.type());
 		if (lvalueSize > 0)
 		{
 			solAssert(itemSize + lvalueSize <= 16, "Stack too deep, try removing local variables.");
@@ -204,7 +216,7 @@ bool ExpressionCompiler::visit(Assignment const& _assignment)
 				m_context << eth::swapInstruction(itemSize + lvalueSize) << eth::Instruction::POP;
 		}
 	}
-	m_currentLValue->storeValue(*type, _assignment.getLocation());
+	m_currentLValue->storeValue(*type, _assignment.location());
 	m_currentLValue.reset();
 	return false;
 }
@@ -216,13 +228,13 @@ bool ExpressionCompiler::visit(UnaryOperation const& _unaryOperation)
 	// the operator should know how to convert itself and to which types it applies, so
 	// put this code together with "Type::acceptsBinary/UnaryOperator" into a class that
 	// represents the operator
-	if (_unaryOperation.getType()->getCategory() == Type::Category::IntegerConstant)
+	if (_unaryOperation.type()->category() == Type::Category::IntegerConstant)
 	{
-		m_context << _unaryOperation.getType()->literalValue(nullptr);
+		m_context << _unaryOperation.type()->literalValue(nullptr);
 		return false;
 	}
 
-	_unaryOperation.getSubExpression().accept(*this);
+	_unaryOperation.subExpression().accept(*this);
 
 	switch (_unaryOperation.getOperator())
 	{
@@ -237,17 +249,17 @@ bool ExpressionCompiler::visit(UnaryOperation const& _unaryOperation)
 		break;
 	case Token::Delete: // delete
 		solAssert(!!m_currentLValue, "LValue not retrieved.");
-		m_currentLValue->setToZero(_unaryOperation.getLocation());
+		m_currentLValue->setToZero(_unaryOperation.location());
 		m_currentLValue.reset();
 		break;
 	case Token::Inc: // ++ (pre- or postfix)
 	case Token::Dec: // -- (pre- or postfix)
 		solAssert(!!m_currentLValue, "LValue not retrieved.");
-		m_currentLValue->retrieveValue(_unaryOperation.getLocation());
+		m_currentLValue->retrieveValue(_unaryOperation.location());
 		if (!_unaryOperation.isPrefixOperation())
 		{
 			// store value for later
-			solAssert(_unaryOperation.getType()->getSizeOnStack() == 1, "Stack size != 1 not implemented.");
+			solAssert(_unaryOperation.type()->sizeOnStack() == 1, "Stack size != 1 not implemented.");
 			m_context << eth::Instruction::DUP1;
 			if (m_currentLValue->sizeOnStack() > 0)
 				for (unsigned i = 1 + m_currentLValue->sizeOnStack(); i > 0; --i)
@@ -263,7 +275,7 @@ bool ExpressionCompiler::visit(UnaryOperation const& _unaryOperation)
 		for (unsigned i = m_currentLValue->sizeOnStack(); i > 0; --i)
 			m_context << eth::swapInstruction(i);
 		m_currentLValue->storeValue(
-			*_unaryOperation.getType(), _unaryOperation.getLocation(),
+			*_unaryOperation.type(), _unaryOperation.location(),
 			!_unaryOperation.isPrefixOperation());
 		m_currentLValue.reset();
 		break;
@@ -283,39 +295,39 @@ bool ExpressionCompiler::visit(UnaryOperation const& _unaryOperation)
 bool ExpressionCompiler::visit(BinaryOperation const& _binaryOperation)
 {
 	CompilerContext::LocationSetter locationSetter(m_context, _binaryOperation);
-	Expression const& leftExpression = _binaryOperation.getLeftExpression();
-	Expression const& rightExpression = _binaryOperation.getRightExpression();
-	Type const& commonType = _binaryOperation.getCommonType();
+	Expression const& leftExpression = _binaryOperation.leftExpression();
+	Expression const& rightExpression = _binaryOperation.rightExpression();
+	Type const& commonType = _binaryOperation.commonType();
 	Token::Value const c_op = _binaryOperation.getOperator();
 
 	if (c_op == Token::And || c_op == Token::Or) // special case: short-circuiting
 		appendAndOrOperatorCode(_binaryOperation);
-	else if (commonType.getCategory() == Type::Category::IntegerConstant)
+	else if (commonType.category() == Type::Category::IntegerConstant)
 		m_context << commonType.literalValue(nullptr);
 	else
 	{
-		bool cleanupNeeded = commonType.getCategory() == Type::Category::Integer &&
+		bool cleanupNeeded = commonType.category() == Type::Category::Integer &&
 			(Token::isCompareOp(c_op) || c_op == Token::Div || c_op == Token::Mod);
 
 		// for commutative operators, push the literal as late as possible to allow improved optimization
 		auto isLiteral = [](Expression const& _e)
 		{
-			return dynamic_cast<Literal const*>(&_e) || _e.getType()->getCategory() == Type::Category::IntegerConstant;
+			return dynamic_cast<Literal const*>(&_e) || _e.type()->category() == Type::Category::IntegerConstant;
 		};
 		bool swap = m_optimize && Token::isCommutativeOp(c_op) && isLiteral(rightExpression) && !isLiteral(leftExpression);
 		if (swap)
 		{
 			leftExpression.accept(*this);
-			utils().convertType(*leftExpression.getType(), commonType, cleanupNeeded);
+			utils().convertType(*leftExpression.type(), commonType, cleanupNeeded);
 			rightExpression.accept(*this);
-			utils().convertType(*rightExpression.getType(), commonType, cleanupNeeded);
+			utils().convertType(*rightExpression.type(), commonType, cleanupNeeded);
 		}
 		else
 		{
 			rightExpression.accept(*this);
-			utils().convertType(*rightExpression.getType(), commonType, cleanupNeeded);
+			utils().convertType(*rightExpression.type(), commonType, cleanupNeeded);
 			leftExpression.accept(*this);
-			utils().convertType(*leftExpression.getType(), commonType, cleanupNeeded);
+			utils().convertType(*leftExpression.type(), commonType, cleanupNeeded);
 		}
 		if (Token::isCompareOp(c_op))
 			appendCompareOperatorCode(c_op, commonType);
@@ -333,27 +345,27 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 	using Location = FunctionType::Location;
 	if (_functionCall.isTypeConversion())
 	{
-		solAssert(_functionCall.getArguments().size() == 1, "");
-		solAssert(_functionCall.getNames().empty(), "");
-		Expression const& firstArgument = *_functionCall.getArguments().front();
+		solAssert(_functionCall.arguments().size() == 1, "");
+		solAssert(_functionCall.names().empty(), "");
+		Expression const& firstArgument = *_functionCall.arguments().front();
 		firstArgument.accept(*this);
-		utils().convertType(*firstArgument.getType(), *_functionCall.getType());
+		utils().convertType(*firstArgument.type(), *_functionCall.type());
 		return false;
 	}
 
 	FunctionTypePointer functionType;
 	if (_functionCall.isStructConstructorCall())
 	{
-		auto const& type = dynamic_cast<TypeType const&>(*_functionCall.getExpression().getType());
-		auto const& structType = dynamic_cast<StructType const&>(*type.getActualType());
+		auto const& type = dynamic_cast<TypeType const&>(*_functionCall.expression().type());
+		auto const& structType = dynamic_cast<StructType const&>(*type.actualType());
 		functionType = structType.constructorType();
 	}
 	else
-		functionType = dynamic_pointer_cast<FunctionType const>(_functionCall.getExpression().getType());
+		functionType = dynamic_pointer_cast<FunctionType const>(_functionCall.expression().type());
 
-	TypePointers const& parameterTypes = functionType->getParameterTypes();
-	vector<ASTPointer<Expression const>> const& callArguments = _functionCall.getArguments();
-	vector<ASTPointer<ASTString>> const& callArgumentNames = _functionCall.getNames();
+	TypePointers const& parameterTypes = functionType->parameterTypes();
+	vector<ASTPointer<Expression const>> const& callArguments = _functionCall.arguments();
+	vector<ASTPointer<ASTString>> const& callArgumentNames = _functionCall.names();
 	if (!functionType->takesArbitraryParameters())
 		solAssert(callArguments.size() == parameterTypes.size(), "");
 
@@ -363,7 +375,7 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 		arguments = callArguments;
 	else
 		// named arguments
-		for (auto const& parameterName: functionType->getParameterNames())
+		for (auto const& parameterName: functionType->parameterNames())
 		{
 			bool found = false;
 			for (size_t j = 0; j < callArgumentNames.size() && !found; j++)
@@ -375,25 +387,25 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 
 	if (_functionCall.isStructConstructorCall())
 	{
-		TypeType const& type = dynamic_cast<TypeType const&>(*_functionCall.getExpression().getType());
-		auto const& structType = dynamic_cast<StructType const&>(*type.getActualType());
+		TypeType const& type = dynamic_cast<TypeType const&>(*_functionCall.expression().type());
+		auto const& structType = dynamic_cast<StructType const&>(*type.actualType());
 
-		m_context << u256(max(32u, structType.getCalldataEncodedSize(true)));
+		m_context << max(u256(32u), structType.memorySize());
 		utils().allocateMemory();
 		m_context << eth::Instruction::DUP1;
 
 		for (unsigned i = 0; i < arguments.size(); ++i)
 		{
 			arguments[i]->accept(*this);
-			utils().convertType(*arguments[i]->getType(), *functionType->getParameterTypes()[i]);
-			utils().storeInMemoryDynamic(*functionType->getParameterTypes()[i]);
+			utils().convertType(*arguments[i]->type(), *functionType->parameterTypes()[i]);
+			utils().storeInMemoryDynamic(*functionType->parameterTypes()[i]);
 		}
 		m_context << eth::Instruction::POP;
 	}
 	else
 	{
 		FunctionType const& function = *functionType;
-		switch (function.getLocation())
+		switch (function.location())
 		{
 		case Location::Internal:
 		{
@@ -404,54 +416,53 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 			for (unsigned i = 0; i < arguments.size(); ++i)
 			{
 				arguments[i]->accept(*this);
-				utils().convertType(*arguments[i]->getType(), *function.getParameterTypes()[i]);
+				utils().convertType(*arguments[i]->type(), *function.parameterTypes()[i]);
 			}
-			_functionCall.getExpression().accept(*this);
+			_functionCall.expression().accept(*this);
 
 			m_context.appendJump(eth::AssemblyItem::JumpType::IntoFunction);
 			m_context << returnLabel;
 
-			unsigned returnParametersSize = CompilerUtils::getSizeOnStack(function.getReturnParameterTypes());
+			unsigned returnParametersSize = CompilerUtils::sizeOnStack(function.returnParameterTypes());
 			// callee adds return parameters, but removes arguments and return label
-			m_context.adjustStackOffset(returnParametersSize - CompilerUtils::getSizeOnStack(function.getParameterTypes()) - 1);
+			m_context.adjustStackOffset(returnParametersSize - CompilerUtils::sizeOnStack(function.parameterTypes()) - 1);
 
 			// @todo for now, the return value of a function is its first return value, so remove
 			// all others
-			for (unsigned i = 1; i < function.getReturnParameterTypes().size(); ++i)
-				utils().popStackElement(*function.getReturnParameterTypes()[i]);
+			for (unsigned i = 1; i < function.returnParameterTypes().size(); ++i)
+				utils().popStackElement(*function.returnParameterTypes()[i]);
 			break;
 		}
 		case Location::External:
 		case Location::CallCode:
 		case Location::Bare:
 		case Location::BareCallCode:
-			_functionCall.getExpression().accept(*this);
+			_functionCall.expression().accept(*this);
 			appendExternalFunctionCall(function, arguments);
 			break;
 		case Location::Creation:
 		{
-			_functionCall.getExpression().accept(*this);
+			_functionCall.expression().accept(*this);
 			solAssert(!function.gasSet(), "Gas limit set for contract creation.");
-			solAssert(function.getReturnParameterTypes().size() == 1, "");
+			solAssert(function.returnParameterTypes().size() == 1, "");
 			TypePointers argumentTypes;
 			for (auto const& arg: arguments)
 			{
 				arg->accept(*this);
-				argumentTypes.push_back(arg->getType());
+				argumentTypes.push_back(arg->type());
 			}
-			ContractDefinition const& contract = dynamic_cast<ContractType const&>(
-							*function.getReturnParameterTypes().front()).getContractDefinition();
+			ContractDefinition const& contract =
+				dynamic_cast<ContractType const&>(*function.returnParameterTypes().front()).contractDefinition();
 			// copy the contract's code into memory
-			bytes const& bytecode = m_context.getCompiledContract(contract);
+			eth::Assembly const& assembly = m_context.compiledContract(contract);
 			utils().fetchFreeMemoryPointer();
-			m_context << u256(bytecode.size()) << eth::Instruction::DUP1;
-			//@todo could be done by actually appending the Assembly, but then we probably need to compile
-			// multiple times. Will revisit once external fuctions are inlined.
-			m_context.appendData(bytecode);
+			// pushes size
+			eth::AssemblyItem subroutine = m_context.addSubroutine(assembly);
+			m_context << eth::Instruction::DUP1 << subroutine;
 			m_context << eth::Instruction::DUP4 << eth::Instruction::CODECOPY;
 
 			m_context << eth::Instruction::ADD;
-			utils().encodeToMemory(argumentTypes, function.getParameterTypes());
+			utils().encodeToMemory(argumentTypes, function.parameterTypes());
 			// now on stack: memory_end_ptr
 			// need: size, offset, endowment
 			utils().toSizeAfterFreeMemoryPointer();
@@ -467,10 +478,10 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 		case Location::SetGas:
 		{
 			// stack layout: contract_address function_id [gas] [value]
-			_functionCall.getExpression().accept(*this);
+			_functionCall.expression().accept(*this);
 
 			arguments.front()->accept(*this);
-			utils().convertType(*arguments.front()->getType(), IntegerType(256), true);
+			utils().convertType(*arguments.front()->type(), IntegerType(256), true);
 			// Note that function is not the original function, but the ".gas" function.
 			// Its values of gasSet and valueSet is equal to the original function's though.
 			unsigned stackDepth = (function.gasSet() ? 1 : 0) + (function.valueSet() ? 1 : 0);
@@ -482,7 +493,7 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 		}
 		case Location::SetValue:
 			// stack layout: contract_address function_id [gas] [value]
-			_functionCall.getExpression().accept(*this);
+			_functionCall.expression().accept(*this);
 			// Note that function is not the original function, but the ".value" function.
 			// Its values of gasSet and valueSet is equal to the original function's though.
 			if (function.valueSet())
@@ -490,12 +501,12 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 			arguments.front()->accept(*this);
 			break;
 		case Location::Send:
-			_functionCall.getExpression().accept(*this);
+			_functionCall.expression().accept(*this);
 			m_context << u256(0); // do not send gas (there still is the stipend)
 			arguments.front()->accept(*this);
 			utils().convertType(
-				*arguments.front()->getType(),
-				*function.getParameterTypes().front(), true
+				*arguments.front()->type(),
+				*function.parameterTypes().front(), true
 			);
 			appendExternalFunctionCall(
 				FunctionType(
@@ -514,7 +525,7 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 			break;
 		case Location::Suicide:
 			arguments.front()->accept(*this);
-			utils().convertType(*arguments.front()->getType(), *function.getParameterTypes().front(), true);
+			utils().convertType(*arguments.front()->type(), *function.parameterTypes().front(), true);
 			m_context << eth::Instruction::SUICIDE;
 			break;
 		case Location::SHA3:
@@ -523,7 +534,7 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 			for (auto const& arg: arguments)
 			{
 				arg->accept(*this);
-				argumentTypes.push_back(arg->getType());
+				argumentTypes.push_back(arg->type());
 			}
 			utils().fetchFreeMemoryPointer();
 			utils().encodeToMemory(argumentTypes, TypePointers(), function.padArguments(), true);
@@ -537,17 +548,17 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 		case Location::Log3:
 		case Location::Log4:
 		{
-			unsigned logNumber = int(function.getLocation()) - int(Location::Log0);
+			unsigned logNumber = int(function.location()) - int(Location::Log0);
 			for (unsigned arg = logNumber; arg > 0; --arg)
 			{
 				arguments[arg]->accept(*this);
-				utils().convertType(*arguments[arg]->getType(), *function.getParameterTypes()[arg], true);
+				utils().convertType(*arguments[arg]->type(), *function.parameterTypes()[arg], true);
 			}
 			arguments.front()->accept(*this);
 			utils().fetchFreeMemoryPointer();
 			utils().encodeToMemory(
-				{arguments.front()->getType()},
-				{function.getParameterTypes().front()},
+				{arguments.front()->type()},
+				{function.parameterTypes().front()},
 				false,
 				true);
 			utils().toSizeAfterFreeMemoryPointer();
@@ -556,24 +567,24 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 		}
 		case Location::Event:
 		{
-			_functionCall.getExpression().accept(*this);
-			auto const& event = dynamic_cast<EventDefinition const&>(function.getDeclaration());
+			_functionCall.expression().accept(*this);
+			auto const& event = dynamic_cast<EventDefinition const&>(function.declaration());
 			unsigned numIndexed = 0;
 			// All indexed arguments go to the stack
 			for (unsigned arg = arguments.size(); arg > 0; --arg)
-				if (event.getParameters()[arg - 1]->isIndexed())
+				if (event.parameters()[arg - 1]->isIndexed())
 				{
 					++numIndexed;
 					arguments[arg - 1]->accept(*this);
 					utils().convertType(
-						*arguments[arg - 1]->getType(),
-						*function.getParameterTypes()[arg - 1],
+						*arguments[arg - 1]->type(),
+						*function.parameterTypes()[arg - 1],
 						true
 					);
 				}
 			if (!event.isAnonymous())
 			{
-				m_context << u256(h256::Arith(dev::sha3(function.externalSignature(event.getName()))));
+				m_context << u256(h256::Arith(dev::sha3(function.externalSignature(event.name()))));
 				++numIndexed;
 			}
 			solAssert(numIndexed <= 4, "Too many indexed arguments.");
@@ -582,11 +593,11 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 			TypePointers nonIndexedArgTypes;
 			TypePointers nonIndexedParamTypes;
 			for (unsigned arg = 0; arg < arguments.size(); ++arg)
-				if (!event.getParameters()[arg]->isIndexed())
+				if (!event.parameters()[arg]->isIndexed())
 				{
 					arguments[arg]->accept(*this);
-					nonIndexedArgTypes.push_back(arguments[arg]->getType());
-					nonIndexedParamTypes.push_back(function.getParameterTypes()[arg]);
+					nonIndexedArgTypes.push_back(arguments[arg]->type());
+					nonIndexedParamTypes.push_back(function.parameterTypes()[arg]);
 				}
 			utils().fetchFreeMemoryPointer();
 			utils().encodeToMemory(nonIndexedArgTypes, nonIndexedParamTypes);
@@ -598,7 +609,7 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 		case Location::BlockHash:
 		{
 			arguments[0]->accept(*this);
-			utils().convertType(*arguments[0]->getType(), *function.getParameterTypes()[0], true);
+			utils().convertType(*arguments[0]->type(), *function.parameterTypes()[0], true);
 			m_context << eth::Instruction::BLOCKHASH;
 			break;
 		}
@@ -606,12 +617,12 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 		case Location::SHA256:
 		case Location::RIPEMD160:
 		{
-			_functionCall.getExpression().accept(*this);
+			_functionCall.expression().accept(*this);
 			static const map<Location, u256> contractAddresses{{Location::ECRecover, 1},
 															   {Location::SHA256, 2},
 															   {Location::RIPEMD160, 3}};
-			m_context << contractAddresses.find(function.getLocation())->second;
-			for (unsigned i = function.getSizeOnStack(); i > 0; --i)
+			m_context << contractAddresses.find(function.location())->second;
+			for (unsigned i = function.sizeOnStack(); i > 0; --i)
 				m_context << eth::swapInstruction(i);
 			appendExternalFunctionCall(function, arguments);
 			break;
@@ -632,19 +643,19 @@ bool ExpressionCompiler::visit(NewExpression const&)
 void ExpressionCompiler::endVisit(MemberAccess const& _memberAccess)
 {
 	CompilerContext::LocationSetter locationSetter(m_context, _memberAccess);
-	ASTString const& member = _memberAccess.getMemberName();
-	switch (_memberAccess.getExpression().getType()->getCategory())
+	ASTString const& member = _memberAccess.memberName();
+	switch (_memberAccess.expression().type()->category())
 	{
 	case Type::Category::Contract:
 	{
 		bool alsoSearchInteger = false;
-		ContractType const& type = dynamic_cast<ContractType const&>(*_memberAccess.getExpression().getType());
+		ContractType const& type = dynamic_cast<ContractType const&>(*_memberAccess.expression().type());
 		if (type.isSuper())
 		{
 			solAssert(!!_memberAccess.referencedDeclaration(), "Referenced declaration not resolved.");
-			m_context << m_context.getSuperFunctionEntryLabel(
+			m_context << m_context.superFunctionEntryLabel(
 				dynamic_cast<FunctionDefinition const&>(*_memberAccess.referencedDeclaration()),
-				type.getContractDefinition()
+				type.contractDefinition()
 			).pushTag();
 		}
 		else
@@ -673,7 +684,7 @@ void ExpressionCompiler::endVisit(MemberAccess const& _memberAccess)
 		if (member == "balance")
 		{
 			utils().convertType(
-				*_memberAccess.getExpression().getType(),
+				*_memberAccess.expression().type(),
 				IntegerType(0, IntegerType::Modifier::Address),
 				true
 			);
@@ -681,7 +692,7 @@ void ExpressionCompiler::endVisit(MemberAccess const& _memberAccess)
 		}
 		else if ((set<string>{"send", "call", "callcode"}).count(member))
 			utils().convertType(
-				*_memberAccess.getExpression().getType(),
+				*_memberAccess.expression().type(),
 				IntegerType(0, IntegerType::Modifier::Address),
 				true
 			);
@@ -689,7 +700,7 @@ void ExpressionCompiler::endVisit(MemberAccess const& _memberAccess)
 			BOOST_THROW_EXCEPTION(InternalCompilerError() << errinfo_comment("Invalid member access to integer."));
 		break;
 	case Type::Category::Function:
-		solAssert(!!_memberAccess.getExpression().getType()->getMemberType(member),
+		solAssert(!!_memberAccess.expression().type()->memberType(member),
 				 "Invalid member access to function.");
 		break;
 	case Type::Category::Magic:
@@ -724,12 +735,12 @@ void ExpressionCompiler::endVisit(MemberAccess const& _memberAccess)
 		break;
 	case Type::Category::Struct:
 	{
-		StructType const& type = dynamic_cast<StructType const&>(*_memberAccess.getExpression().getType());
+		StructType const& type = dynamic_cast<StructType const&>(*_memberAccess.expression().type());
 		switch (type.location())
 		{
 		case DataLocation::Storage:
 		{
-			pair<u256, unsigned> const& offsets = type.getStorageOffsetsOfMember(member);
+			pair<u256, unsigned> const& offsets = type.storageOffsetsOfMember(member);
 			m_context << offsets.first << eth::Instruction::ADD << u256(offsets.second);
 			setLValueToStorageItem(_memberAccess);
 			break;
@@ -737,7 +748,7 @@ void ExpressionCompiler::endVisit(MemberAccess const& _memberAccess)
 		case DataLocation::Memory:
 		{
 			m_context << type.memoryOffsetOfMember(member) << eth::Instruction::ADD;
-			setLValue<MemoryItem>(_memberAccess, *_memberAccess.getType());
+			setLValue<MemoryItem>(_memberAccess, *_memberAccess.type());
 			break;
 		}
 		default:
@@ -747,36 +758,42 @@ void ExpressionCompiler::endVisit(MemberAccess const& _memberAccess)
 	}
 	case Type::Category::Enum:
 	{
-		EnumType const& type = dynamic_cast<EnumType const&>(*_memberAccess.getExpression().getType());
-		m_context << type.getMemberValue(_memberAccess.getMemberName());
+		EnumType const& type = dynamic_cast<EnumType const&>(*_memberAccess.expression().type());
+		m_context << type.memberValue(_memberAccess.memberName());
 		break;
 	}
 	case Type::Category::TypeType:
 	{
-		TypeType const& type = dynamic_cast<TypeType const&>(*_memberAccess.getExpression().getType());
+		TypeType const& type = dynamic_cast<TypeType const&>(*_memberAccess.expression().type());
 		solAssert(
-			!type.getMembers().membersByName(_memberAccess.getMemberName()).empty(),
+			!type.members().membersByName(_memberAccess.memberName()).empty(),
 			"Invalid member access to " + type.toString(false)
 		);
 
-		if (dynamic_cast<ContractType const*>(type.getActualType().get()))
+		if (dynamic_cast<ContractType const*>(type.actualType().get()))
 		{
-			auto const* function = dynamic_cast<FunctionDefinition const*>(_memberAccess.referencedDeclaration());
-			solAssert(!!function, "Function not found in member access");
-			m_context << m_context.getFunctionEntryLabel(*function).pushTag();
+			auto const& funType = dynamic_cast<FunctionType const&>(*_memberAccess.type());
+			if (funType.location() != FunctionType::Location::Internal)
+				m_context << funType.externalIdentifier();
+			else
+			{
+				auto const* function = dynamic_cast<FunctionDefinition const*>(_memberAccess.referencedDeclaration());
+				solAssert(!!function, "Function not found in member access");
+				m_context << m_context.functionEntryLabel(*function).pushTag();
+			}
 		}
-		else if (auto enumType = dynamic_cast<EnumType const*>(type.getActualType().get()))
-			m_context << enumType->getMemberValue(_memberAccess.getMemberName());
+		else if (auto enumType = dynamic_cast<EnumType const*>(type.actualType().get()))
+			m_context << enumType->memberValue(_memberAccess.memberName());
 		break;
 	}
 	case Type::Category::Array:
 	{
 		solAssert(member == "length", "Illegal array member.");
-		auto const& type = dynamic_cast<ArrayType const&>(*_memberAccess.getExpression().getType());
+		auto const& type = dynamic_cast<ArrayType const&>(*_memberAccess.expression().type());
 		if (!type.isDynamicallySized())
 		{
 			utils().popStackElement(type);
-			m_context << type.getLength();
+			m_context << type.length();
 		}
 		else
 			switch (type.location())
@@ -801,22 +818,23 @@ void ExpressionCompiler::endVisit(MemberAccess const& _memberAccess)
 bool ExpressionCompiler::visit(IndexAccess const& _indexAccess)
 {
 	CompilerContext::LocationSetter locationSetter(m_context, _indexAccess);
-	_indexAccess.getBaseExpression().accept(*this);
+	_indexAccess.baseExpression().accept(*this);
+
+	Type const& baseType = *_indexAccess.baseExpression().type();
 
-	Type const& baseType = *_indexAccess.getBaseExpression().getType();
-	if (baseType.getCategory() == Type::Category::Mapping)
+	if (baseType.category() == Type::Category::Mapping)
 	{
 		// stack: storage_base_ref
-		TypePointer keyType = dynamic_cast<MappingType const&>(baseType).getKeyType();
-		solAssert(_indexAccess.getIndexExpression(), "Index expression expected.");
+		TypePointer keyType = dynamic_cast<MappingType const&>(baseType).keyType();
+		solAssert(_indexAccess.indexExpression(), "Index expression expected.");
 		if (keyType->isDynamicallySized())
 		{
-			_indexAccess.getIndexExpression()->accept(*this);
+			_indexAccess.indexExpression()->accept(*this);
 			utils().fetchFreeMemoryPointer();
 			// stack: base index mem
 			// note: the following operations must not allocate memory!
 			utils().encodeToMemory(
-				TypePointers{_indexAccess.getIndexExpression()->getType()},
+				TypePointers{_indexAccess.indexExpression()->type()},
 				TypePointers{keyType},
 				false,
 				true
@@ -828,7 +846,7 @@ bool ExpressionCompiler::visit(IndexAccess const& _indexAccess)
 		else
 		{
 			m_context << u256(0); // memory position
-			appendExpressionCopyToMemory(*keyType, *_indexAccess.getIndexExpression());
+			appendExpressionCopyToMemory(*keyType, *_indexAccess.indexExpression());
 			m_context << eth::Instruction::SWAP1;
 			solAssert(CompilerUtils::freeMemoryPointer >= 0x40, "");
 			utils().storeInMemoryDynamic(IntegerType(256));
@@ -838,12 +856,12 @@ bool ExpressionCompiler::visit(IndexAccess const& _indexAccess)
 		m_context << u256(0);
 		setLValueToStorageItem(_indexAccess);
 	}
-	else if (baseType.getCategory() == Type::Category::Array)
+	else if (baseType.category() == Type::Category::Array)
 	{
 		ArrayType const& arrayType = dynamic_cast<ArrayType const&>(baseType);
-		solAssert(_indexAccess.getIndexExpression(), "Index expression expected.");
+		solAssert(_indexAccess.indexExpression(), "Index expression expected.");
 
-		_indexAccess.getIndexExpression()->accept(*this);
+		_indexAccess.indexExpression()->accept(*this);
 		// stack layout: <base_ref> [<length>] <index>
 		ArrayUtils(m_context).accessIndex(arrayType);
 		switch (arrayType.location())
@@ -858,14 +876,14 @@ bool ExpressionCompiler::visit(IndexAccess const& _indexAccess)
 				setLValueToStorageItem(_indexAccess);
 			break;
 		case DataLocation::Memory:
-			setLValue<MemoryItem>(_indexAccess, *_indexAccess.getType(), !arrayType.isByteArray());
+			setLValue<MemoryItem>(_indexAccess, *_indexAccess.type(), !arrayType.isByteArray());
 			break;
 		case DataLocation::CallData:
 			//@todo if we implement this, the value in calldata has to be added to the base offset
-			solAssert(!arrayType.getBaseType()->isDynamicallySized(), "Nested arrays not yet implemented.");
-			if (arrayType.getBaseType()->isValueType())
+			solAssert(!arrayType.baseType()->isDynamicallySized(), "Nested arrays not yet implemented.");
+			if (arrayType.baseType()->isValueType())
 				CompilerUtils(m_context).loadFromMemoryDynamic(
-					*arrayType.getBaseType(),
+					*arrayType.baseType(),
 					true,
 					!arrayType.isByteArray(),
 					false
@@ -882,14 +900,14 @@ bool ExpressionCompiler::visit(IndexAccess const& _indexAccess)
 void ExpressionCompiler::endVisit(Identifier const& _identifier)
 {
 	CompilerContext::LocationSetter locationSetter(m_context, _identifier);
-	Declaration const* declaration = &_identifier.getReferencedDeclaration();
+	Declaration const* declaration = &_identifier.referencedDeclaration();
 	if (MagicVariableDeclaration const* magicVar = dynamic_cast<MagicVariableDeclaration const*>(declaration))
 	{
-		switch (magicVar->getType()->getCategory())
+		switch (magicVar->type()->category())
 		{
 		case Type::Category::Contract:
 			// "this" or "super"
-			if (!dynamic_cast<ContractType const&>(*magicVar->getType()).isSuper())
+			if (!dynamic_cast<ContractType const&>(*magicVar->type()).isSuper())
 				m_context << eth::Instruction::ADDRESS;
 			break;
 		case Type::Category::Integer:
@@ -901,17 +919,22 @@ void ExpressionCompiler::endVisit(Identifier const& _identifier)
 		}
 	}
 	else if (FunctionDefinition const* functionDef = dynamic_cast<FunctionDefinition const*>(declaration))
-		m_context << m_context.getVirtualFunctionEntryLabel(*functionDef).pushTag();
+		m_context << m_context.virtualFunctionEntryLabel(*functionDef).pushTag();
 	else if (auto variable = dynamic_cast<VariableDeclaration const*>(declaration))
 	{
 		if (!variable->isConstant())
 			setLValueFromDeclaration(*declaration, _identifier);
 		else
-			variable->getValue()->accept(*this);
+		{
+			variable->value()->accept(*this);
+			utils().convertType(*variable->value()->type(), *variable->type());
+		}
 	}
-	else if (dynamic_cast<ContractDefinition const*>(declaration))
+	else if (auto contract = dynamic_cast<ContractDefinition const*>(declaration))
 	{
-		// no-op
+		if (contract->isLibrary())
+			//@todo name should be unique, change once we have module management
+			m_context.appendLibraryAddress(contract->name());
 	}
 	else if (dynamic_cast<EventDefinition const*>(declaration))
 	{
@@ -930,8 +953,8 @@ void ExpressionCompiler::endVisit(Identifier const& _identifier)
 void ExpressionCompiler::endVisit(Literal const& _literal)
 {
 	CompilerContext::LocationSetter locationSetter(m_context, _literal);
-	TypePointer type = _literal.getType();
-	switch (type->getCategory())
+	TypePointer type = _literal.type();
+	switch (type->category())
 	{
 	case Type::Category::IntegerConstant:
 	case Type::Category::Bool:
@@ -949,13 +972,13 @@ void ExpressionCompiler::appendAndOrOperatorCode(BinaryOperation const& _binaryO
 	Token::Value const c_op = _binaryOperation.getOperator();
 	solAssert(c_op == Token::Or || c_op == Token::And, "");
 
-	_binaryOperation.getLeftExpression().accept(*this);
+	_binaryOperation.leftExpression().accept(*this);
 	m_context << eth::Instruction::DUP1;
 	if (c_op == Token::And)
 		m_context << eth::Instruction::ISZERO;
 	eth::AssemblyItem endLabel = m_context.appendConditionalJump();
 	m_context << eth::Instruction::POP;
-	_binaryOperation.getRightExpression().accept(*this);
+	_binaryOperation.rightExpression().accept(*this);
 	m_context << endLabel;
 }
 
@@ -1076,8 +1099,10 @@ void ExpressionCompiler::appendExternalFunctionCall(
 	vector<ASTPointer<Expression const>> const& _arguments
 )
 {
-	solAssert(_functionType.takesArbitraryParameters() ||
-			  _arguments.size() == _functionType.getParameterTypes().size(), "");
+	solAssert(
+		_functionType.takesArbitraryParameters() ||
+		_arguments.size() == _functionType.parameterTypes().size(), ""
+	);
 
 	// Assumed stack content here:
 	// <stack top>
@@ -1093,21 +1118,21 @@ void ExpressionCompiler::appendExternalFunctionCall(
 	unsigned valueStackPos = m_context.currentToBaseStackOffset(1);
 
 	using FunctionKind = FunctionType::Location;
-	FunctionKind funKind = _functionType.getLocation();
+	FunctionKind funKind = _functionType.location();
 	bool returnSuccessCondition = funKind == FunctionKind::Bare || funKind == FunctionKind::BareCallCode;
 	bool isCallCode = funKind == FunctionKind::BareCallCode || funKind == FunctionKind::CallCode;
 
 	//@todo only return the first return value for now
 	Type const* firstReturnType =
-		_functionType.getReturnParameterTypes().empty() ?
+		_functionType.returnParameterTypes().empty() ?
 		nullptr :
-		_functionType.getReturnParameterTypes().front().get();
+		_functionType.returnParameterTypes().front().get();
 	unsigned retSize = 0;
 	if (returnSuccessCondition)
 		retSize = 0; // return value actually is success condition
 	else if (firstReturnType)
 	{
-		retSize = firstReturnType->getCalldataEncodedSize();
+		retSize = firstReturnType->calldataEncodedSize();
 		solAssert(retSize > 0, "Unable to return dynamic type from external call.");
 	}
 
@@ -1116,7 +1141,7 @@ void ExpressionCompiler::appendExternalFunctionCall(
 	bool manualFunctionId =
 		(funKind == FunctionKind::Bare || funKind == FunctionKind::BareCallCode) &&
 		!_arguments.empty() &&
-		_arguments.front()->getType()->mobileType()->getCalldataEncodedSize(false) ==
+		_arguments.front()->type()->mobileType()->calldataEncodedSize(false) ==
 			CompilerUtils::dataStartOffset;
 	if (manualFunctionId)
 	{
@@ -1124,7 +1149,7 @@ void ExpressionCompiler::appendExternalFunctionCall(
 		// function identifier.
 		_arguments.front()->accept(*this);
 		utils().convertType(
-			*_arguments.front()->getType(),
+			*_arguments.front()->type(),
 			IntegerType(8 * CompilerUtils::dataStartOffset),
 			true
 		);
@@ -1136,14 +1161,14 @@ void ExpressionCompiler::appendExternalFunctionCall(
 	for (size_t i = manualFunctionId ? 1 : 0; i < _arguments.size(); ++i)
 	{
 		_arguments[i]->accept(*this);
-		argumentTypes.push_back(_arguments[i]->getType());
+		argumentTypes.push_back(_arguments[i]->type());
 	}
 
 	// Copy function identifier to memory.
 	utils().fetchFreeMemoryPointer();
 	if (!_functionType.isBareCall() || manualFunctionId)
 	{
-		m_context << eth::dupInstruction(2 + gasValueSize + CompilerUtils::getSizeOnStack(argumentTypes));
+		m_context << eth::dupInstruction(2 + gasValueSize + CompilerUtils::sizeOnStack(argumentTypes));
 		utils().storeInMemoryDynamic(IntegerType(8 * CompilerUtils::dataStartOffset), false);
 	}
 	// If the function takes arbitrary parameters, copy dynamic length data in place.
@@ -1151,7 +1176,7 @@ void ExpressionCompiler::appendExternalFunctionCall(
 	// pointer on the stack).
 	utils().encodeToMemory(
 		argumentTypes,
-		_functionType.getParameterTypes(),
+		_functionType.parameterTypes(),
 		_functionType.padArguments(),
 		_functionType.takesArbitraryParameters()
 	);
@@ -1241,7 +1266,7 @@ void ExpressionCompiler::appendExpressionCopyToMemory(Type const& _expectedType,
 {
 	solAssert(_expectedType.isValueType(), "Not implemented for non-value types.");
 	_expression.accept(*this);
-	utils().convertType(*_expression.getType(), _expectedType, true);
+	utils().convertType(*_expression.type(), _expectedType, true);
 	utils().storeInMemoryDynamic(_expectedType);
 }
 
@@ -1253,13 +1278,13 @@ void ExpressionCompiler::setLValueFromDeclaration(Declaration const& _declaratio
 		setLValue<StorageItem>(_expression, _declaration);
 	else
 		BOOST_THROW_EXCEPTION(InternalCompilerError()
-			<< errinfo_sourceLocation(_expression.getLocation())
+			<< errinfo_sourceLocation(_expression.location())
 			<< errinfo_comment("Identifier type not supported or identifier not found."));
 }
 
 void ExpressionCompiler::setLValueToStorageItem(Expression const& _expression)
 {
-	setLValue<StorageItem>(_expression, *_expression.getType());
+	setLValue<StorageItem>(_expression, *_expression.type());
 }
 
 CompilerUtils ExpressionCompiler::utils()
diff --git a/libsolidity/ExpressionCompiler.h b/libsolidity/ExpressionCompiler.h
index 642560c6..02df4b87 100644
--- a/libsolidity/ExpressionCompiler.h
+++ b/libsolidity/ExpressionCompiler.h
@@ -67,6 +67,9 @@ public:
 	/// Appends code for a State Variable accessor function
 	void appendStateVariableAccessor(VariableDeclaration const& _varDecl);
 
+	/// Appends code for a Constant State Variable accessor function
+	void appendConstStateVariableAccessor(const VariableDeclaration& _varDecl);
+
 private:
 	virtual bool visit(Assignment const& _assignment) override;
 	virtual bool visit(UnaryOperation const& _unaryOperation) override;
@@ -127,7 +130,7 @@ void ExpressionCompiler::setLValue(Expression const& _expression, _Arguments con
 	if (_expression.lvalueRequested())
 		m_currentLValue = move(lvalue);
 	else
-		lvalue->retrieveValue(_expression.getLocation(), true);
+		lvalue->retrieveValue(_expression.location(), true);
 }
 
 }
diff --git a/libsolidity/GasEstimator.cpp b/libsolidity/GasEstimator.cpp
index 01219a65..d576561a 100644
--- a/libsolidity/GasEstimator.cpp
+++ b/libsolidity/GasEstimator.cpp
@@ -52,7 +52,7 @@ GasEstimator::ASTGasConsumptionSelfAccumulated GasEstimator::structuralEstimatio
 		GasMeter meter(block.startState->copy());
 		auto const end = _items.begin() + block.end;
 		for (auto iter = _items.begin() + block.begin; iter != end; ++iter)
-			particularCosts[iter->getLocation()] += meter.estimateMax(*iter);
+			particularCosts[iter->location()] += meter.estimateMax(*iter);
 	}
 
 	set<ASTNode const*> finestNodes = finestNodesAtLocation(_ast);
@@ -61,7 +61,7 @@ GasEstimator::ASTGasConsumptionSelfAccumulated GasEstimator::structuralEstimatio
 	{
 		if (!finestNodes.count(&_node))
 			return true;
-		gasCosts[&_node][0] = gasCosts[&_node][1] = particularCosts[_node.getLocation()];
+		gasCosts[&_node][0] = gasCosts[&_node][1] = particularCosts[_node.location()];
 		return true;
 	};
 	auto onEdge = [&](ASTNode const& _parent, ASTNode const& _child)
@@ -156,7 +156,7 @@ GasEstimator::GasConsumption GasEstimator::functionalEstimation(
 {
 	auto state = make_shared<KnownState>();
 
-	unsigned parametersSize = CompilerUtils::getSizeOnStack(_function.getParameters());
+	unsigned parametersSize = CompilerUtils::sizeOnStack(_function.parameters());
 	if (parametersSize > 16)
 		return GasConsumption::infinite();
 
@@ -178,9 +178,9 @@ set<ASTNode const*> GasEstimator::finestNodesAtLocation(
 	set<ASTNode const*> nodes;
 	SimpleASTVisitor visitor(function<bool(ASTNode const&)>(), [&](ASTNode const& _n)
 	{
-		if (!locations.count(_n.getLocation()))
+		if (!locations.count(_n.location()))
 		{
-			locations[_n.getLocation()] = &_n;
+			locations[_n.location()] = &_n;
 			nodes.insert(&_n);
 		}
 	});
diff --git a/libsolidity/GlobalContext.cpp b/libsolidity/GlobalContext.cpp
index 80cebd76..a0f5396f 100644
--- a/libsolidity/GlobalContext.cpp
+++ b/libsolidity/GlobalContext.cpp
@@ -66,7 +66,7 @@ void GlobalContext::setCurrentContract(ContractDefinition const& _contract)
 	m_currentContract = &_contract;
 }
 
-vector<Declaration const*> GlobalContext::getDeclarations() const
+vector<Declaration const*> GlobalContext::declarations() const
 {
 	vector<Declaration const*> declarations;
 	declarations.reserve(m_magicVariables.size());
@@ -75,7 +75,7 @@ vector<Declaration const*> GlobalContext::getDeclarations() const
 	return declarations;
 }
 
-MagicVariableDeclaration const* GlobalContext::getCurrentThis() const
+MagicVariableDeclaration const* GlobalContext::currentThis() const
 {
 	if (!m_thisPointer[m_currentContract])
 		m_thisPointer[m_currentContract] = make_shared<MagicVariableDeclaration>(
@@ -84,7 +84,7 @@ MagicVariableDeclaration const* GlobalContext::getCurrentThis() const
 
 }
 
-MagicVariableDeclaration const* GlobalContext::getCurrentSuper() const
+MagicVariableDeclaration const* GlobalContext::currentSuper() const
 {
 	if (!m_superPointer[m_currentContract])
 		m_superPointer[m_currentContract] = make_shared<MagicVariableDeclaration>(
diff --git a/libsolidity/GlobalContext.h b/libsolidity/GlobalContext.h
index f861c67d..20ffecb4 100644
--- a/libsolidity/GlobalContext.h
+++ b/libsolidity/GlobalContext.h
@@ -47,11 +47,11 @@ class GlobalContext: private boost::noncopyable
 public:
 	GlobalContext();
 	void setCurrentContract(ContractDefinition const& _contract);
-	MagicVariableDeclaration const* getCurrentThis() const;
-	MagicVariableDeclaration const* getCurrentSuper() const;
+	MagicVariableDeclaration const* currentThis() const;
+	MagicVariableDeclaration const* currentSuper() const;
 
 	/// @returns a vector of all implicit global declarations excluding "this".
-	std::vector<Declaration const*> getDeclarations() const;
+	std::vector<Declaration const*> declarations() const;
 
 private:
 	std::vector<std::shared_ptr<MagicVariableDeclaration const>> m_magicVariables;
diff --git a/libsolidity/InterfaceHandler.cpp b/libsolidity/InterfaceHandler.cpp
index c6f8553d..fc79b493 100644
--- a/libsolidity/InterfaceHandler.cpp
+++ b/libsolidity/InterfaceHandler.cpp
@@ -16,7 +16,7 @@ InterfaceHandler::InterfaceHandler()
 	m_lastTag = DocTagType::None;
 }
 
-string InterfaceHandler::getDocumentation(
+string InterfaceHandler::documentation(
 	ContractDefinition const& _contractDef,
 	DocumentationType _type
 )
@@ -28,16 +28,16 @@ string InterfaceHandler::getDocumentation(
 	case DocumentationType::NatspecDev:
 		return devDocumentation(_contractDef);
 	case DocumentationType::ABIInterface:
-		return getABIInterface(_contractDef);
+		return abiInterface(_contractDef);
 	case DocumentationType::ABISolidityInterface:
-		return getABISolidityInterface(_contractDef);
+		return ABISolidityInterface(_contractDef);
 	}
 
 	BOOST_THROW_EXCEPTION(InternalCompilerError() << errinfo_comment("Unknown documentation type"));
 	return "";
 }
 
-string InterfaceHandler::getABIInterface(ContractDefinition const& _contractDef)
+string InterfaceHandler::abiInterface(ContractDefinition const& _contractDef)
 {
 	Json::Value abi(Json::arrayValue);
 
@@ -55,48 +55,48 @@ string InterfaceHandler::getABIInterface(ContractDefinition const& _contractDef)
 		return params;
 	};
 
-	for (auto it: _contractDef.getInterfaceFunctions())
+	for (auto it: _contractDef.interfaceFunctions())
 	{
 		auto externalFunctionType = it.second->externalFunctionType();
 		Json::Value method;
 		method["type"] = "function";
-		method["name"] = it.second->getDeclaration().getName();
+		method["name"] = it.second->declaration().name();
 		method["constant"] = it.second->isConstant();
 		method["inputs"] = populateParameters(
-			externalFunctionType->getParameterNames(),
-			externalFunctionType->getParameterTypeNames()
+			externalFunctionType->parameterNames(),
+			externalFunctionType->parameterTypeNames()
 		);
 		method["outputs"] = populateParameters(
-			externalFunctionType->getReturnParameterNames(),
-			externalFunctionType->getReturnParameterTypeNames()
+			externalFunctionType->returnParameterNames(),
+			externalFunctionType->returnParameterTypeNames()
 		);
 		abi.append(method);
 	}
-	if (_contractDef.getConstructor())
+	if (_contractDef.constructor())
 	{
 		Json::Value method;
 		method["type"] = "constructor";
-		auto externalFunction = FunctionType(*_contractDef.getConstructor()).externalFunctionType();
+		auto externalFunction = FunctionType(*_contractDef.constructor()).externalFunctionType();
 		solAssert(!!externalFunction, "");
 		method["inputs"] = populateParameters(
-			externalFunction->getParameterNames(),
-			externalFunction->getParameterTypeNames()
+			externalFunction->parameterNames(),
+			externalFunction->parameterTypeNames()
 		);
 		abi.append(method);
 	}
 
-	for (auto const& it: _contractDef.getInterfaceEvents())
+	for (auto const& it: _contractDef.interfaceEvents())
 	{
 		Json::Value event;
 		event["type"] = "event";
-		event["name"] = it->getName();
+		event["name"] = it->name();
 		event["anonymous"] = it->isAnonymous();
 		Json::Value params(Json::arrayValue);
-		for (auto const& p: it->getParameters())
+		for (auto const& p: it->parameters())
 		{
 			Json::Value input;
-			input["name"] = p->getName();
-			input["type"] = p->getType()->toString(true);
+			input["name"] = p->name();
+			input["type"] = p->type()->toString(true);
 			input["indexed"] = p->isIndexed();
 			params.append(input);
 		}
@@ -106,9 +106,9 @@ string InterfaceHandler::getABIInterface(ContractDefinition const& _contractDef)
 	return Json::FastWriter().write(abi);
 }
 
-string InterfaceHandler::getABISolidityInterface(ContractDefinition const& _contractDef)
+string InterfaceHandler::ABISolidityInterface(ContractDefinition const& _contractDef)
 {
-	string ret = "contract " + _contractDef.getName() + "{";
+	string ret = "contract " + _contractDef.name() + "{";
 
 	auto populateParameters = [](vector<string> const& _paramNames, vector<string> const& _paramTypes)
 	{
@@ -118,23 +118,23 @@ string InterfaceHandler::getABISolidityInterface(ContractDefinition const& _cont
 			r += (r.size() ? "," : "(") + _paramTypes[i] + " " + _paramNames[i];
 		return r.size() ? r + ")" : "()";
 	};
-	if (_contractDef.getConstructor())
+	if (_contractDef.constructor())
 	{
-		auto externalFunction = FunctionType(*_contractDef.getConstructor()).externalFunctionType();
+		auto externalFunction = FunctionType(*_contractDef.constructor()).externalFunctionType();
 		solAssert(!!externalFunction, "");
 		ret +=
 			"function " +
-			_contractDef.getName() +
-			populateParameters(externalFunction->getParameterNames(), externalFunction->getParameterTypeNames()) +
+			_contractDef.name() +
+			populateParameters(externalFunction->parameterNames(), externalFunction->parameterTypeNames()) +
 			";";
 	}
-	for (auto const& it: _contractDef.getInterfaceFunctions())
+	for (auto const& it: _contractDef.interfaceFunctions())
 	{
-		ret += "function " + it.second->getDeclaration().getName() +
-			populateParameters(it.second->getParameterNames(), it.second->getParameterTypeNames()) +
+		ret += "function " + it.second->declaration().name() +
+			populateParameters(it.second->parameterNames(), it.second->parameterTypeNames()) +
 			(it.second->isConstant() ? "constant " : "");
-		if (it.second->getReturnParameterTypes().size())
-			ret += "returns" + populateParameters(it.second->getReturnParameterNames(), it.second->getReturnParameterTypeNames());
+		if (it.second->returnParameterTypes().size())
+			ret += "returns" + populateParameters(it.second->returnParameterNames(), it.second->returnParameterTypeNames());
 		else if (ret.back() == ' ')
 			ret.pop_back();
 		ret += ";";
@@ -148,10 +148,10 @@ string InterfaceHandler::userDocumentation(ContractDefinition const& _contractDe
 	Json::Value doc;
 	Json::Value methods(Json::objectValue);
 
-	for (auto const& it: _contractDef.getInterfaceFunctions())
+	for (auto const& it: _contractDef.interfaceFunctions())
 	{
 		Json::Value user;
-		auto strPtr = it.second->getDocumentation();
+		auto strPtr = it.second->documentation();
 		if (strPtr)
 		{
 			resetUser();
@@ -175,7 +175,7 @@ string InterfaceHandler::devDocumentation(ContractDefinition const& _contractDef
 	Json::Value doc;
 	Json::Value methods(Json::objectValue);
 
-	auto contractDoc = _contractDef.getDocumentation();
+	auto contractDoc = _contractDef.documentation();
 	if (contractDoc)
 	{
 		m_contractAuthor.clear();
@@ -189,10 +189,10 @@ string InterfaceHandler::devDocumentation(ContractDefinition const& _contractDef
 			doc["title"] = m_title;
 	}
 
-	for (auto const& it: _contractDef.getInterfaceFunctions())
+	for (auto const& it: _contractDef.interfaceFunctions())
 	{
 		Json::Value method;
-		auto strPtr = it.second->getDocumentation();
+		auto strPtr = it.second->documentation();
 		if (strPtr)
 		{
 			resetDev();
@@ -205,7 +205,7 @@ string InterfaceHandler::devDocumentation(ContractDefinition const& _contractDef
 				method["author"] = m_author;
 
 			Json::Value params(Json::objectValue);
-			vector<string> paramNames = it.second->getParameterNames();
+			vector<string> paramNames = it.second->parameterNames();
 			for (auto const& pair: m_params)
 			{
 				if (find(paramNames.begin(), paramNames.end(), pair.first) == paramNames.end())
@@ -393,7 +393,7 @@ string::const_iterator InterfaceHandler::appendDocTag(
 	}
 }
 
-static inline string::const_iterator getFirstSpaceOrNl(
+static inline string::const_iterator firstSpaceOrNl(
 	string::const_iterator _pos,
 	string::const_iterator _end
 )
@@ -416,7 +416,7 @@ void InterfaceHandler::parseDocString(string const& _string, CommentOwner _owner
 		if (tagPos != end && tagPos < nlPos)
 		{
 			// we found a tag
-			auto tagNameEndPos = getFirstSpaceOrNl(tagPos, end);
+			auto tagNameEndPos = firstSpaceOrNl(tagPos, end);
 			if (tagNameEndPos == end)
 				BOOST_THROW_EXCEPTION(
 					DocstringParsingError() <<
diff --git a/libsolidity/InterfaceHandler.h b/libsolidity/InterfaceHandler.h
index 7784dbd7..62164517 100644
--- a/libsolidity/InterfaceHandler.h
+++ b/libsolidity/InterfaceHandler.h
@@ -66,15 +66,15 @@ public:
 	/// @param _type        The type of the documentation. Can be one of the
 	///                     types provided by @c DocumentationType
 	/// @return             A string with the json representation of provided type
-	std::string getDocumentation(
+	std::string documentation(
 		ContractDefinition const& _contractDef,
 		DocumentationType _type
 	);
 	/// Get the ABI Interface of the contract
 	/// @param _contractDef The contract definition
 	/// @return             A string with the json representation of the contract's ABI Interface
-	std::string getABIInterface(ContractDefinition const& _contractDef);
-	std::string getABISolidityInterface(ContractDefinition const& _contractDef);
+	std::string abiInterface(ContractDefinition const& _contractDef);
+	std::string ABISolidityInterface(ContractDefinition const& _contractDef);
 	/// Get the User documentation of the contract
 	/// @param _contractDef The contract definition
 	/// @return             A string with the json representation of the contract's user documentation
diff --git a/libsolidity/LValue.cpp b/libsolidity/LValue.cpp
index 5c43fb82..eb7cc073 100644
--- a/libsolidity/LValue.cpp
+++ b/libsolidity/LValue.cpp
@@ -32,9 +32,9 @@ using namespace solidity;
 
 
 StackVariable::StackVariable(CompilerContext& _compilerContext, Declaration const& _declaration):
-	LValue(_compilerContext, *_declaration.getType()),
-	m_baseStackOffset(m_context.getBaseStackOffsetOfVariable(_declaration)),
-	m_size(m_dataType.getSizeOnStack())
+	LValue(_compilerContext, *_declaration.type()),
+	m_baseStackOffset(m_context.baseStackOffsetOfVariable(_declaration)),
+	m_size(m_dataType.sizeOnStack())
 {
 }
 
@@ -98,12 +98,12 @@ void MemoryItem::storeValue(Type const& _sourceType, SourceLocation const&, bool
 	if (m_dataType.isValueType())
 	{
 		solAssert(_sourceType.isValueType(), "");
-		utils.moveIntoStack(_sourceType.getSizeOnStack());
+		utils.moveIntoStack(_sourceType.sizeOnStack());
 		utils.convertType(_sourceType, m_dataType, true);
 		if (!_move)
 		{
-			utils.moveToStackTop(m_dataType.getSizeOnStack());
-			utils.copyToStackTop(2, m_dataType.getSizeOnStack());
+			utils.moveToStackTop(m_dataType.sizeOnStack());
+			utils.copyToStackTop(2, m_dataType.sizeOnStack());
 		}
 		utils.storeInMemoryDynamic(m_dataType, m_padded);
 		m_context << eth::Instruction::POP;
@@ -112,7 +112,7 @@ void MemoryItem::storeValue(Type const& _sourceType, SourceLocation const&, bool
 	{
 		solAssert(_sourceType == m_dataType, "Conversion not implemented for assignment to memory.");
 
-		solAssert(m_dataType.getSizeOnStack() == 1, "");
+		solAssert(m_dataType.sizeOnStack() == 1, "");
 		if (!_move)
 			m_context << eth::Instruction::DUP2 << eth::Instruction::SWAP1;
 		// stack: [value] value lvalue
@@ -132,9 +132,9 @@ void MemoryItem::setToZero(SourceLocation const&, bool _removeReference) const
 }
 
 StorageItem::StorageItem(CompilerContext& _compilerContext, Declaration const& _declaration):
-	StorageItem(_compilerContext, *_declaration.getType())
+	StorageItem(_compilerContext, *_declaration.type())
 {
-	auto const& location = m_context.getStorageLocationOfVariable(_declaration);
+	auto const& location = m_context.storageLocationOfVariable(_declaration);
 	m_context << location.first << u256(location.second);
 }
 
@@ -143,8 +143,8 @@ StorageItem::StorageItem(CompilerContext& _compilerContext, Type const& _type):
 {
 	if (m_dataType.isValueType())
 	{
-		solAssert(m_dataType.getStorageSize() == m_dataType.getSizeOnStack(), "");
-		solAssert(m_dataType.getStorageSize() == 1, "Invalid storage size.");
+		solAssert(m_dataType.storageSize() == m_dataType.sizeOnStack(), "");
+		solAssert(m_dataType.storageSize() == 1, "Invalid storage size.");
 	}
 }
 
@@ -153,7 +153,7 @@ void StorageItem::retrieveValue(SourceLocation const&, bool _remove) const
 	// stack: storage_key storage_offset
 	if (!m_dataType.isValueType())
 	{
-		solAssert(m_dataType.getSizeOnStack() == 1, "Invalid storage ref size.");
+		solAssert(m_dataType.sizeOnStack() == 1, "Invalid storage ref size.");
 		if (_remove)
 			m_context << eth::Instruction::POP; // remove byte offset
 		else
@@ -162,22 +162,22 @@ void StorageItem::retrieveValue(SourceLocation const&, bool _remove) const
 	}
 	if (!_remove)
 		CompilerUtils(m_context).copyToStackTop(sizeOnStack(), sizeOnStack());
-	if (m_dataType.getStorageBytes() == 32)
+	if (m_dataType.storageBytes() == 32)
 		m_context << eth::Instruction::POP << eth::Instruction::SLOAD;
 	else
 	{
 		m_context
 			<< eth::Instruction::SWAP1 << eth::Instruction::SLOAD << eth::Instruction::SWAP1
 			<< u256(0x100) << eth::Instruction::EXP << eth::Instruction::SWAP1 << eth::Instruction::DIV;
-		if (m_dataType.getCategory() == Type::Category::FixedBytes)
-			m_context << (u256(0x1) << (256 - 8 * m_dataType.getStorageBytes())) << eth::Instruction::MUL;
+		if (m_dataType.category() == Type::Category::FixedBytes)
+			m_context << (u256(0x1) << (256 - 8 * m_dataType.storageBytes())) << eth::Instruction::MUL;
 		else if (
-			m_dataType.getCategory() == Type::Category::Integer &&
+			m_dataType.category() == Type::Category::Integer &&
 			dynamic_cast<IntegerType const&>(m_dataType).isSigned()
 		)
-			m_context << u256(m_dataType.getStorageBytes() - 1) << eth::Instruction::SIGNEXTEND;
+			m_context << u256(m_dataType.storageBytes() - 1) << eth::Instruction::SIGNEXTEND;
 		else
-			m_context << ((u256(0x1) << (8 * m_dataType.getStorageBytes())) - 1) << eth::Instruction::AND;
+			m_context << ((u256(0x1) << (8 * m_dataType.storageBytes())) - 1) << eth::Instruction::AND;
 	}
 }
 
@@ -187,9 +187,9 @@ void StorageItem::storeValue(Type const& _sourceType, SourceLocation const& _loc
 	// stack: value storage_key storage_offset
 	if (m_dataType.isValueType())
 	{
-		solAssert(m_dataType.getStorageBytes() <= 32, "Invalid storage bytes size.");
-		solAssert(m_dataType.getStorageBytes() > 0, "Invalid storage bytes size.");
-		if (m_dataType.getStorageBytes() == 32)
+		solAssert(m_dataType.storageBytes() <= 32, "Invalid storage bytes size.");
+		solAssert(m_dataType.storageBytes() > 0, "Invalid storage bytes size.");
+		if (m_dataType.storageBytes() == 32)
 		{
 			// offset should be zero
 			m_context << eth::Instruction::POP;
@@ -207,24 +207,24 @@ void StorageItem::storeValue(Type const& _sourceType, SourceLocation const& _loc
 			// stack: value storege_ref multiplier old_full_value
 			// clear bytes in old value
 			m_context
-				<< eth::Instruction::DUP2 << ((u256(1) << (8 * m_dataType.getStorageBytes())) - 1)
+				<< eth::Instruction::DUP2 << ((u256(1) << (8 * m_dataType.storageBytes())) - 1)
 				<< eth::Instruction::MUL;
 			m_context << eth::Instruction::NOT << eth::Instruction::AND;
 			// stack: value storage_ref multiplier cleared_value
 			m_context
 				<< eth::Instruction::SWAP1 << eth::Instruction::DUP4;
 			// stack: value storage_ref cleared_value multiplier value
-			if (m_dataType.getCategory() == Type::Category::FixedBytes)
+			if (m_dataType.category() == Type::Category::FixedBytes)
 				m_context
 					<< (u256(0x1) << (256 - 8 * dynamic_cast<FixedBytesType const&>(m_dataType).numBytes()))
 					<< eth::Instruction::SWAP1 << eth::Instruction::DIV;
 			else if (
-				m_dataType.getCategory() == Type::Category::Integer &&
+				m_dataType.category() == Type::Category::Integer &&
 				dynamic_cast<IntegerType const&>(m_dataType).isSigned()
 			)
 				// remove the higher order bits
 				m_context
-					<< (u256(1) << (8 * (32 - m_dataType.getStorageBytes())))
+					<< (u256(1) << (8 * (32 - m_dataType.storageBytes())))
 					<< eth::Instruction::SWAP1
 					<< eth::Instruction::DUP2
 					<< eth::Instruction::MUL
@@ -239,9 +239,9 @@ void StorageItem::storeValue(Type const& _sourceType, SourceLocation const& _loc
 	else
 	{
 		solAssert(
-			_sourceType.getCategory() == m_dataType.getCategory(),
+			_sourceType.category() == m_dataType.category(),
 			"Wrong type conversation for assignment.");
-		if (m_dataType.getCategory() == Type::Category::Array)
+		if (m_dataType.category() == Type::Category::Array)
 		{
 			m_context << eth::Instruction::POP; // remove byte offset
 			ArrayUtils(m_context).copyArrayToStorage(
@@ -250,7 +250,7 @@ void StorageItem::storeValue(Type const& _sourceType, SourceLocation const& _loc
 			if (_move)
 				m_context << eth::Instruction::POP;
 		}
-		else if (m_dataType.getCategory() == Type::Category::Struct)
+		else if (m_dataType.category() == Type::Category::Struct)
 		{
 			// stack layout: source_ref target_ref target_offset
 			// note that we have structs, so offset should be zero and are ignored
@@ -262,17 +262,17 @@ void StorageItem::storeValue(Type const& _sourceType, SourceLocation const& _loc
 				"Struct assignment with conversion."
 			);
 			solAssert(sourceType.location() != DataLocation::CallData, "Structs in calldata not supported.");
-			for (auto const& member: structType.getMembers())
+			for (auto const& member: structType.members())
 			{
 				// assign each member that is not a mapping
 				TypePointer const& memberType = member.type;
-				if (memberType->getCategory() == Type::Category::Mapping)
+				if (memberType->category() == Type::Category::Mapping)
 					continue;
-				TypePointer sourceMemberType = sourceType.getMemberType(member.name);
+				TypePointer sourceMemberType = sourceType.memberType(member.name);
 				if (sourceType.location() == DataLocation::Storage)
 				{
 					// stack layout: source_ref target_ref
-					pair<u256, unsigned> const& offsets = sourceType.getStorageOffsetsOfMember(member.name);
+					pair<u256, unsigned> const& offsets = sourceType.storageOffsetsOfMember(member.name);
 					m_context << offsets.first << eth::Instruction::DUP3 << eth::Instruction::ADD;
 					m_context << u256(offsets.second);
 					// stack: source_ref target_ref source_member_ref source_member_off
@@ -283,21 +283,21 @@ void StorageItem::storeValue(Type const& _sourceType, SourceLocation const& _loc
 				{
 					solAssert(sourceType.location() == DataLocation::Memory, "");
 					// stack layout: source_ref target_ref
-					TypePointer sourceMemberType = sourceType.getMemberType(member.name);
+					TypePointer sourceMemberType = sourceType.memberType(member.name);
 					m_context << sourceType.memoryOffsetOfMember(member.name);
 					m_context << eth::Instruction::DUP3 << eth::Instruction::ADD;
 					MemoryItem(m_context, *sourceMemberType).retrieveValue(_location, true);
 					// stack layout: source_ref target_ref source_value...
 				}
-				unsigned stackSize = sourceMemberType->getSizeOnStack();
-				pair<u256, unsigned> const& offsets = structType.getStorageOffsetsOfMember(member.name);
+				unsigned stackSize = sourceMemberType->sizeOnStack();
+				pair<u256, unsigned> const& offsets = structType.storageOffsetsOfMember(member.name);
 				m_context << eth::dupInstruction(1 + stackSize) << offsets.first << eth::Instruction::ADD;
 				m_context << u256(offsets.second);
 				// stack: source_ref target_ref target_off source_value... target_member_ref target_member_byte_off
 				StorageItem(m_context, *memberType).storeValue(*sourceMemberType, _location, true);
 			}
 			// stack layout: source_ref target_ref
-			solAssert(sourceType.getSizeOnStack() == 1, "Unexpected source size.");
+			solAssert(sourceType.sizeOnStack() == 1, "Unexpected source size.");
 			if (_move)
 				utils.popStackSlots(2);
 			else
@@ -313,25 +313,25 @@ void StorageItem::storeValue(Type const& _sourceType, SourceLocation const& _loc
 
 void StorageItem::setToZero(SourceLocation const&, bool _removeReference) const
 {
-	if (m_dataType.getCategory() == Type::Category::Array)
+	if (m_dataType.category() == Type::Category::Array)
 	{
 		if (!_removeReference)
 			CompilerUtils(m_context).copyToStackTop(sizeOnStack(), sizeOnStack());
 		ArrayUtils(m_context).clearArray(dynamic_cast<ArrayType const&>(m_dataType));
 	}
-	else if (m_dataType.getCategory() == Type::Category::Struct)
+	else if (m_dataType.category() == Type::Category::Struct)
 	{
 		// stack layout: storage_key storage_offset
 		// @todo this can be improved: use StorageItem for non-value types, and just store 0 in
 		// all slots that contain value types later.
 		auto const& structType = dynamic_cast<StructType const&>(m_dataType);
-		for (auto const& member: structType.getMembers())
+		for (auto const& member: structType.members())
 		{
 			// zero each member that is not a mapping
 			TypePointer const& memberType = member.type;
-			if (memberType->getCategory() == Type::Category::Mapping)
+			if (memberType->category() == Type::Category::Mapping)
 				continue;
-			pair<u256, unsigned> const& offsets = structType.getStorageOffsetsOfMember(member.name);
+			pair<u256, unsigned> const& offsets = structType.storageOffsetsOfMember(member.name);
 			m_context
 				<< offsets.first << eth::Instruction::DUP3 << eth::Instruction::ADD
 				<< u256(offsets.second);
@@ -345,7 +345,7 @@ void StorageItem::setToZero(SourceLocation const&, bool _removeReference) const
 		solAssert(m_dataType.isValueType(), "Clearing of unsupported type requested: " + m_dataType.toString());
 		if (!_removeReference)
 			CompilerUtils(m_context).copyToStackTop(sizeOnStack(), sizeOnStack());
-		if (m_dataType.getStorageBytes() == 32)
+		if (m_dataType.storageBytes() == 32)
 		{
 			// offset should be zero
 			m_context
@@ -361,7 +361,7 @@ void StorageItem::setToZero(SourceLocation const&, bool _removeReference) const
 			// stack: storege_ref multiplier old_full_value
 			// clear bytes in old value
 			m_context
-				<< eth::Instruction::SWAP1 << ((u256(1) << (8 * m_dataType.getStorageBytes())) - 1)
+				<< eth::Instruction::SWAP1 << ((u256(1) << (8 * m_dataType.storageBytes())) - 1)
 				<< eth::Instruction::MUL;
 			m_context << eth::Instruction::NOT << eth::Instruction::AND;
 			// stack: storage_ref cleared_value
@@ -427,7 +427,7 @@ void StorageByteArrayElement::setToZero(SourceLocation const&, bool _removeRefer
 }
 
 StorageArrayLength::StorageArrayLength(CompilerContext& _compilerContext, const ArrayType& _arrayType):
-	LValue(_compilerContext, *_arrayType.getMemberType("length")),
+	LValue(_compilerContext, *_arrayType.memberType("length")),
 	m_arrayType(_arrayType)
 {
 	solAssert(m_arrayType.isDynamicallySized(), "");
diff --git a/libsolidity/LValue.h b/libsolidity/LValue.h
index a93df9f9..f02d8ad1 100644
--- a/libsolidity/LValue.h
+++ b/libsolidity/LValue.h
@@ -91,7 +91,7 @@ public:
 	) const override;
 
 private:
-	/// Base stack offset (@see CompilerContext::getBaseStackOffsetOfVariable) of the local variable.
+	/// Base stack offset (@see CompilerContext::baseStackOffsetOfVariable) of the local variable.
 	unsigned m_baseStackOffset;
 	/// Number of stack elements occupied by the value (not the reference).
 	unsigned m_size;
diff --git a/libsolidity/NameAndTypeResolver.cpp b/libsolidity/NameAndTypeResolver.cpp
index 87f9da7e..c3b49abd 100644
--- a/libsolidity/NameAndTypeResolver.cpp
+++ b/libsolidity/NameAndTypeResolver.cpp
@@ -47,58 +47,62 @@ void NameAndTypeResolver::resolveNamesAndTypes(ContractDefinition& _contract)
 {
 	m_currentScope = &m_scopes[nullptr];
 
-	for (ASTPointer<InheritanceSpecifier> const& baseContract: _contract.getBaseContracts())
+	for (ASTPointer<InheritanceSpecifier> const& baseContract: _contract.baseContracts())
 		ReferencesResolver resolver(*baseContract, *this, &_contract, nullptr);
 
 	m_currentScope = &m_scopes[&_contract];
 
 	linearizeBaseContracts(_contract);
 	std::vector<ContractDefinition const*> properBases(
-		++_contract.getLinearizedBaseContracts().begin(),
-		_contract.getLinearizedBaseContracts().end()
+		++_contract.linearizedBaseContracts().begin(),
+		_contract.linearizedBaseContracts().end()
 	);
 
 	for (ContractDefinition const* base: properBases)
 		importInheritedScope(*base);
 
-	for (ASTPointer<StructDefinition> const& structDef: _contract.getDefinedStructs())
+	for (ASTPointer<StructDefinition> const& structDef: _contract.definedStructs())
 		ReferencesResolver resolver(*structDef, *this, &_contract, nullptr);
-	for (ASTPointer<EnumDefinition> const& enumDef: _contract.getDefinedEnums())
+	for (ASTPointer<EnumDefinition> const& enumDef: _contract.definedEnums())
 		ReferencesResolver resolver(*enumDef, *this, &_contract, nullptr);
-	for (ASTPointer<VariableDeclaration> const& variable: _contract.getStateVariables())
+	for (ASTPointer<VariableDeclaration> const& variable: _contract.stateVariables())
 		ReferencesResolver resolver(*variable, *this, &_contract, nullptr);
-	for (ASTPointer<EventDefinition> const& event: _contract.getEvents())
+	for (ASTPointer<EventDefinition> const& event: _contract.events())
 		ReferencesResolver resolver(*event, *this, &_contract, nullptr);
 
 	// these can contain code, only resolve parameters for now
-	for (ASTPointer<ModifierDefinition> const& modifier: _contract.getFunctionModifiers())
+	for (ASTPointer<ModifierDefinition> const& modifier: _contract.functionModifiers())
 	{
 		m_currentScope = &m_scopes[modifier.get()];
 		ReferencesResolver resolver(*modifier, *this, &_contract, nullptr);
 	}
-	for (ASTPointer<FunctionDefinition> const& function: _contract.getDefinedFunctions())
+	for (ASTPointer<FunctionDefinition> const& function: _contract.definedFunctions())
 	{
 		m_currentScope = &m_scopes[function.get()];
-		ReferencesResolver referencesResolver(*function, *this, &_contract,
-											  function->getReturnParameterList().get());
+		ReferencesResolver referencesResolver(
+			*function,
+			*this,
+			&_contract,
+			function->returnParameterList().get()
+		);
 	}
 
 	m_currentScope = &m_scopes[&_contract];
 
 	// now resolve references inside the code
-	for (ASTPointer<ModifierDefinition> const& modifier: _contract.getFunctionModifiers())
+	for (ASTPointer<ModifierDefinition> const& modifier: _contract.functionModifiers())
 	{
 		m_currentScope = &m_scopes[modifier.get()];
 		ReferencesResolver resolver(*modifier, *this, &_contract, nullptr, true);
 	}
-	for (ASTPointer<FunctionDefinition> const& function: _contract.getDefinedFunctions())
+	for (ASTPointer<FunctionDefinition> const& function: _contract.definedFunctions())
 	{
 		m_currentScope = &m_scopes[function.get()];
 		ReferencesResolver referencesResolver(
 			*function,
 			*this,
 			&_contract,
-			function->getReturnParameterList().get(),
+			function->returnParameterList().get(),
 			true
 		);
 	}
@@ -106,7 +110,7 @@ void NameAndTypeResolver::resolveNamesAndTypes(ContractDefinition& _contract)
 
 void NameAndTypeResolver::checkTypeRequirements(ContractDefinition& _contract)
 {
-	for (ASTPointer<StructDefinition> const& structDef: _contract.getDefinedStructs())
+	for (ASTPointer<StructDefinition> const& structDef: _contract.definedStructs())
 		structDef->checkValidityOfMembers();
 	_contract.checkTypeRequirements();
 }
@@ -114,7 +118,7 @@ void NameAndTypeResolver::checkTypeRequirements(ContractDefinition& _contract)
 void NameAndTypeResolver::updateDeclaration(Declaration const& _declaration)
 {
 	m_scopes[nullptr].registerDeclaration(_declaration, false, true);
-	solAssert(_declaration.getScope() == nullptr, "Updated declaration outside global scope.");
+	solAssert(_declaration.scope() == nullptr, "Updated declaration outside global scope.");
 }
 
 vector<Declaration const*> NameAndTypeResolver::resolveName(ASTString const& _name, Declaration const* _scope) const
@@ -125,7 +129,7 @@ vector<Declaration const*> NameAndTypeResolver::resolveName(ASTString const& _na
 	return iterator->second.resolveName(_name, false);
 }
 
-vector<Declaration const*> NameAndTypeResolver::getNameFromCurrentScope(ASTString const& _name, bool _recursive)
+vector<Declaration const*> NameAndTypeResolver::nameFromCurrentScope(ASTString const& _name, bool _recursive)
 {
 	return m_currentScope->resolveName(_name, _recursive);
 }
@@ -144,11 +148,11 @@ vector<Declaration const*> NameAndTypeResolver::cleanedDeclarations(
 		// the declaration is functionDefinition while declarations > 1
 		FunctionDefinition const& functionDefinition = dynamic_cast<FunctionDefinition const&>(**it);
 		FunctionType functionType(functionDefinition);
-		for (auto parameter: functionType.getParameterTypes() + functionType.getReturnParameterTypes())
+		for (auto parameter: functionType.parameterTypes() + functionType.returnParameterTypes())
 			if (!parameter)
 				BOOST_THROW_EXCEPTION(
 					DeclarationError() <<
-					errinfo_sourceLocation(_identifier.getLocation()) <<
+					errinfo_sourceLocation(_identifier.location()) <<
 					errinfo_comment("Function type can not be used in this context")
 				);
 		if (uniqueFunctions.end() == find_if(
@@ -169,10 +173,10 @@ void NameAndTypeResolver::importInheritedScope(ContractDefinition const& _base)
 {
 	auto iterator = m_scopes.find(&_base);
 	solAssert(iterator != end(m_scopes), "");
-	for (auto const& nameAndDeclaration: iterator->second.getDeclarations())
+	for (auto const& nameAndDeclaration: iterator->second.declarations())
 		for (auto const& declaration: nameAndDeclaration.second)
 			// Import if it was declared in the base, is not the constructor and is visible in derived classes
-			if (declaration->getScope() == &_base && declaration->isVisibleInDerivedContracts())
+			if (declaration->scope() == &_base && declaration->isVisibleInDerivedContracts())
 				m_currentScope->registerDeclaration(*declaration);
 }
 
@@ -181,16 +185,16 @@ void NameAndTypeResolver::linearizeBaseContracts(ContractDefinition& _contract)
 	// order in the lists is from derived to base
 	// list of lists to linearize, the last element is the list of direct bases
 	list<list<ContractDefinition const*>> input(1, {});
-	for (ASTPointer<InheritanceSpecifier> const& baseSpecifier: _contract.getBaseContracts())
+	for (ASTPointer<InheritanceSpecifier> const& baseSpecifier: _contract.baseContracts())
 	{
-		ASTPointer<Identifier> baseName = baseSpecifier->getName();
-		auto base = dynamic_cast<ContractDefinition const*>(&baseName->getReferencedDeclaration());
+		ASTPointer<Identifier> baseName = baseSpecifier->name();
+		auto base = dynamic_cast<ContractDefinition const*>(&baseName->referencedDeclaration());
 		if (!base)
 			BOOST_THROW_EXCEPTION(baseName->createTypeError("Contract expected."));
 		// "push_front" has the effect that bases mentioned later can overwrite members of bases
 		// mentioned earlier
 		input.back().push_front(base);
-		vector<ContractDefinition const*> const& basesBases = base->getLinearizedBaseContracts();
+		vector<ContractDefinition const*> const& basesBases = base->linearizedBaseContracts();
 		if (basesBases.empty())
 			BOOST_THROW_EXCEPTION(baseName->createTypeError("Definition of base has to precede definition of derived contract"));
 		input.push_front(list<ContractDefinition const*>(basesBases.begin(), basesBases.end()));
@@ -330,7 +334,7 @@ void DeclarationRegistrationHelper::endVisit(VariableDeclarationStatement& _vari
 	// Register the local variables with the function
 	// This does not fit here perfectly, but it saves us another AST visit.
 	solAssert(m_currentFunction, "Variable declaration without function.");
-	m_currentFunction->addLocalVariable(_variableDeclarationStatement.getDeclaration());
+	m_currentFunction->addLocalVariable(_variableDeclarationStatement.declaration());
 }
 
 bool DeclarationRegistrationHelper::visit(VariableDeclaration& _declaration)
@@ -362,7 +366,7 @@ void DeclarationRegistrationHelper::enterNewSubScope(Declaration const& _declara
 void DeclarationRegistrationHelper::closeCurrentScope()
 {
 	solAssert(m_currentScope, "Closed non-existing scope.");
-	m_currentScope = m_scopes[m_currentScope].getEnclosingDeclaration();
+	m_currentScope = m_scopes[m_currentScope].enclosingDeclaration();
 }
 
 void DeclarationRegistrationHelper::registerDeclaration(Declaration& _declaration, bool _opensScope)
@@ -374,15 +378,15 @@ void DeclarationRegistrationHelper::registerDeclaration(Declaration& _declaratio
 		Declaration const* conflictingDeclaration = m_scopes[m_currentScope].conflictingDeclaration(_declaration);
 		solAssert(conflictingDeclaration, "");
 
-		if (_declaration.getLocation().start < conflictingDeclaration->getLocation().start)
+		if (_declaration.location().start < conflictingDeclaration->location().start)
 		{
-			firstDeclarationLocation = _declaration.getLocation();
-			secondDeclarationLocation = conflictingDeclaration->getLocation();
+			firstDeclarationLocation = _declaration.location();
+			secondDeclarationLocation = conflictingDeclaration->location();
 		}
 		else
 		{
-			firstDeclarationLocation = conflictingDeclaration->getLocation();
-			secondDeclarationLocation = _declaration.getLocation();
+			firstDeclarationLocation = conflictingDeclaration->location();
+			secondDeclarationLocation = _declaration.location();
 		}
 
 		BOOST_THROW_EXCEPTION(
@@ -421,9 +425,9 @@ void ReferencesResolver::endVisit(VariableDeclaration& _variable)
 {
 	// endVisit because the internal type needs resolving if it is a user defined type
 	// or mapping
-	if (_variable.getTypeName())
+	if (_variable.typeName())
 	{
-		TypePointer type = _variable.getTypeName()->toType();
+		TypePointer type = _variable.typeName()->toType();
 		using Location = VariableDeclaration::Location;
 		Location loc = _variable.referenceLocation();
 		// References are forced to calldata for external function parameters (not return)
@@ -441,7 +445,7 @@ void ReferencesResolver::endVisit(VariableDeclaration& _variable)
 					));
 				type = ref->copyForLocation(DataLocation::CallData, true);
 			}
-			else if (_variable.isCallableParameter() && _variable.getScope()->isPublic())
+			else if (_variable.isCallableParameter() && _variable.scope()->isPublic())
 			{
 				// force locations of public or external function (return) parameters to memory
 				if (loc == VariableDeclaration::Location::Storage)
@@ -453,6 +457,14 @@ void ReferencesResolver::endVisit(VariableDeclaration& _variable)
 			}
 			else
 			{
+				if (_variable.isConstant())
+				{
+					if (loc != Location::Default && loc != Location::Memory)
+						BOOST_THROW_EXCEPTION(_variable.createTypeError(
+							"Storage location has to be \"memory\" (or unspecified) for constants."
+						));
+					loc = Location::Memory;
+				}
 				if (loc == Location::Default)
 					loc = _variable.isCallableParameter() ? Location::Memory : Location::Storage;
 				bool isPointer = !_variable.isStateVariable();
@@ -471,8 +483,8 @@ void ReferencesResolver::endVisit(VariableDeclaration& _variable)
 
 		_variable.setType(type);
 
-		if (!_variable.getType())
-			BOOST_THROW_EXCEPTION(_variable.getTypeName()->createTypeError("Invalid type name"));
+		if (!_variable.type())
+			BOOST_THROW_EXCEPTION(_variable.typeName()->createTypeError("Invalid type name"));
 	}
 	else if (!m_allowLazyTypes)
 		BOOST_THROW_EXCEPTION(_variable.createTypeError("Explicit type needed."));
@@ -492,17 +504,17 @@ bool ReferencesResolver::visit(Mapping&)
 
 bool ReferencesResolver::visit(UserDefinedTypeName& _typeName)
 {
-	auto declarations = m_resolver.getNameFromCurrentScope(_typeName.getName());
+	auto declarations = m_resolver.nameFromCurrentScope(_typeName.name());
 	if (declarations.empty())
 		BOOST_THROW_EXCEPTION(
 			DeclarationError() <<
-			errinfo_sourceLocation(_typeName.getLocation()) <<
+			errinfo_sourceLocation(_typeName.location()) <<
 			errinfo_comment("Undeclared identifier.")
 		);
 	else if (declarations.size() > 1)
 		BOOST_THROW_EXCEPTION(
 			DeclarationError() <<
-			errinfo_sourceLocation(_typeName.getLocation()) <<
+			errinfo_sourceLocation(_typeName.location()) <<
 			errinfo_comment("Duplicate identifier.")
 		);
 	else
@@ -512,11 +524,11 @@ bool ReferencesResolver::visit(UserDefinedTypeName& _typeName)
 
 bool ReferencesResolver::visit(Identifier& _identifier)
 {
-	auto declarations = m_resolver.getNameFromCurrentScope(_identifier.getName());
+	auto declarations = m_resolver.nameFromCurrentScope(_identifier.name());
 	if (declarations.empty())
 		BOOST_THROW_EXCEPTION(
 			DeclarationError() <<
-			errinfo_sourceLocation(_identifier.getLocation()) <<
+			errinfo_sourceLocation(_identifier.location()) <<
 			errinfo_comment("Undeclared identifier.")
 		);
 	else if (declarations.size() == 1)
diff --git a/libsolidity/NameAndTypeResolver.h b/libsolidity/NameAndTypeResolver.h
index d7a0a3b2..101787ea 100644
--- a/libsolidity/NameAndTypeResolver.h
+++ b/libsolidity/NameAndTypeResolver.h
@@ -60,7 +60,7 @@ public:
 
 	/// Resolves a name in the "current" scope. Should only be called during the initial
 	/// resolving phase.
-	std::vector<Declaration const*> getNameFromCurrentScope(ASTString const& _name, bool _recursive = true);
+	std::vector<Declaration const*> nameFromCurrentScope(ASTString const& _name, bool _recursive = true);
 
 	/// returns the vector of declarations without repetitions
 	static std::vector<Declaration const*> cleanedDeclarations(
diff --git a/libsolidity/Parser.cpp b/libsolidity/Parser.cpp
index fbf8478d..3fbe4d68 100644
--- a/libsolidity/Parser.cpp
+++ b/libsolidity/Parser.cpp
@@ -41,15 +41,15 @@ class Parser::ASTNodeFactory
 {
 public:
 	ASTNodeFactory(Parser const& _parser):
-		m_parser(_parser), m_location(_parser.getPosition(), -1, _parser.getSourceName()) {}
+		m_parser(_parser), m_location(_parser.position(), -1, _parser.sourceName()) {}
 	ASTNodeFactory(Parser const& _parser, ASTPointer<ASTNode> const& _childNode):
-		m_parser(_parser), m_location(_childNode->getLocation()) {}
+		m_parser(_parser), m_location(_childNode->location()) {}
 
-	void markEndPosition() { m_location.end = m_parser.getEndPosition(); }
+	void markEndPosition() { m_location.end = m_parser.endPosition(); }
 	void setLocation(SourceLocation const& _location) { m_location = _location; }
 	void setLocationEmpty() { m_location.end = m_location.start; }
 	/// Set the end position to the one of the given node.
-	void setEndPositionFromNode(ASTPointer<ASTNode> const& _node) { m_location.end = _node->getLocation().end; }
+	void setEndPositionFromNode(ASTPointer<ASTNode> const& _node) { m_location.end = _node->location().end; }
 
 	template <class NodeType, typename... Args>
 	ASTPointer<NodeType> createNode(Args&& ... _args)
@@ -69,15 +69,16 @@ ASTPointer<SourceUnit> Parser::parse(shared_ptr<Scanner> const& _scanner)
 	m_scanner = _scanner;
 	ASTNodeFactory nodeFactory(*this);
 	vector<ASTPointer<ASTNode>> nodes;
-	while (_scanner->getCurrentToken() != Token::EOS)
+	while (m_scanner->currentToken() != Token::EOS)
 	{
-		switch (m_scanner->getCurrentToken())
+		switch (auto token = m_scanner->currentToken())
 		{
 		case Token::Import:
 			nodes.push_back(parseImportDirective());
 			break;
 		case Token::Contract:
-			nodes.push_back(parseContractDefinition());
+		case Token::Library:
+			nodes.push_back(parseContractDefinition(token == Token::Library));
 			break;
 		default:
 			BOOST_THROW_EXCEPTION(createParserError(std::string("Expected import directive or contract definition.")));
@@ -86,26 +87,26 @@ ASTPointer<SourceUnit> Parser::parse(shared_ptr<Scanner> const& _scanner)
 	return nodeFactory.createNode<SourceUnit>(nodes);
 }
 
-std::shared_ptr<const string> const& Parser::getSourceName() const
+std::shared_ptr<const string> const& Parser::sourceName() const
 {
-	return m_scanner->getSourceName();
+	return m_scanner->sourceName();
 }
 
-int Parser::getPosition() const
+int Parser::position() const
 {
-	return m_scanner->getCurrentLocation().start;
+	return m_scanner->currentLocation().start;
 }
 
-int Parser::getEndPosition() const
+int Parser::endPosition() const
 {
-	return m_scanner->getCurrentLocation().end;
+	return m_scanner->currentLocation().end;
 }
 
 ASTPointer<ImportDirective> Parser::parseImportDirective()
 {
 	ASTNodeFactory nodeFactory(*this);
 	expectToken(Token::Import);
-	if (m_scanner->getCurrentToken() != Token::StringLiteral)
+	if (m_scanner->currentToken() != Token::StringLiteral)
 		BOOST_THROW_EXCEPTION(createParserError("Expected string literal (URL)."));
 	ASTPointer<ASTString> url = getLiteralAndAdvance();
 	nodeFactory.markEndPosition();
@@ -113,13 +114,13 @@ ASTPointer<ImportDirective> Parser::parseImportDirective()
 	return nodeFactory.createNode<ImportDirective>(url);
 }
 
-ASTPointer<ContractDefinition> Parser::parseContractDefinition()
+ASTPointer<ContractDefinition> Parser::parseContractDefinition(bool _isLibrary)
 {
 	ASTNodeFactory nodeFactory(*this);
 	ASTPointer<ASTString> docString;
-	if (m_scanner->getCurrentCommentLiteral() != "")
-		docString = make_shared<ASTString>(m_scanner->getCurrentCommentLiteral());
-	expectToken(Token::Contract);
+	if (m_scanner->currentCommentLiteral() != "")
+		docString = make_shared<ASTString>(m_scanner->currentCommentLiteral());
+	expectToken(_isLibrary ? Token::Library : Token::Contract);
 	ASTPointer<ASTString> name = expectIdentifierToken();
 	vector<ASTPointer<InheritanceSpecifier>> baseContracts;
 	vector<ASTPointer<StructDefinition>> structs;
@@ -128,27 +129,30 @@ ASTPointer<ContractDefinition> Parser::parseContractDefinition()
 	vector<ASTPointer<FunctionDefinition>> functions;
 	vector<ASTPointer<ModifierDefinition>> modifiers;
 	vector<ASTPointer<EventDefinition>> events;
-	if (m_scanner->getCurrentToken() == Token::Is)
+	if (m_scanner->currentToken() == Token::Is)
 		do
 		{
 			m_scanner->next();
 			baseContracts.push_back(parseInheritanceSpecifier());
 		}
-		while (m_scanner->getCurrentToken() == Token::Comma);
+		while (m_scanner->currentToken() == Token::Comma);
 	expectToken(Token::LBrace);
 	while (true)
 	{
-		Token::Value currentToken = m_scanner->getCurrentToken();
-		if (currentToken == Token::RBrace)
+		Token::Value currentTokenValue= m_scanner->currentToken();
+		if (currentTokenValue == Token::RBrace)
 			break;
-		else if (currentToken == Token::Function)
+		else if (currentTokenValue == Token::Function)
 			functions.push_back(parseFunctionDefinition(name.get()));
-		else if (currentToken == Token::Struct)
+		else if (currentTokenValue == Token::Struct)
 			structs.push_back(parseStructDefinition());
-		else if (currentToken == Token::Enum)
+		else if (currentTokenValue == Token::Enum)
 			enums.push_back(parseEnumDefinition());
-		else if (currentToken == Token::Identifier || currentToken == Token::Mapping ||
-				 Token::isElementaryTypeName(currentToken))
+		else if (
+			currentTokenValue == Token::Identifier ||
+			currentTokenValue == Token::Mapping ||
+			Token::isElementaryTypeName(currentTokenValue)
+		)
 		{
 			VarDeclParserOptions options;
 			options.isStateVariable = true;
@@ -156,9 +160,9 @@ ASTPointer<ContractDefinition> Parser::parseContractDefinition()
 			stateVariables.push_back(parseVariableDeclaration(options));
 			expectToken(Token::Semicolon);
 		}
-		else if (currentToken == Token::Modifier)
+		else if (currentTokenValue == Token::Modifier)
 			modifiers.push_back(parseModifierDefinition());
-		else if (currentToken == Token::Event)
+		else if (currentTokenValue == Token::Event)
 			events.push_back(parseEventDefinition());
 		else
 			BOOST_THROW_EXCEPTION(createParserError("Function, variable, struct or modifier declaration expected."));
@@ -174,7 +178,8 @@ ASTPointer<ContractDefinition> Parser::parseContractDefinition()
 		stateVariables,
 		functions,
 		modifiers,
-		events
+		events,
+		_isLibrary
 	);
 }
 
@@ -183,7 +188,7 @@ ASTPointer<InheritanceSpecifier> Parser::parseInheritanceSpecifier()
 	ASTNodeFactory nodeFactory(*this);
 	ASTPointer<Identifier> name(parseIdentifier());
 	vector<ASTPointer<Expression>> arguments;
-	if (m_scanner->getCurrentToken() == Token::LParen)
+	if (m_scanner->currentToken() == Token::LParen)
 	{
 		m_scanner->next();
 		arguments = parseFunctionCallListArguments();
@@ -216,12 +221,12 @@ ASTPointer<FunctionDefinition> Parser::parseFunctionDefinition(ASTString const*
 {
 	ASTNodeFactory nodeFactory(*this);
 	ASTPointer<ASTString> docstring;
-	if (m_scanner->getCurrentCommentLiteral() != "")
-		docstring = make_shared<ASTString>(m_scanner->getCurrentCommentLiteral());
+	if (m_scanner->currentCommentLiteral() != "")
+		docstring = make_shared<ASTString>(m_scanner->currentCommentLiteral());
 
 	expectToken(Token::Function);
 	ASTPointer<ASTString> name;
-	if (m_scanner->getCurrentToken() == Token::LParen)
+	if (m_scanner->currentToken() == Token::LParen)
 		name = make_shared<ASTString>(); // anonymous function
 	else
 		name = expectIdentifierToken();
@@ -233,7 +238,7 @@ ASTPointer<FunctionDefinition> Parser::parseFunctionDefinition(ASTString const*
 	vector<ASTPointer<ModifierInvocation>> modifiers;
 	while (true)
 	{
-		Token::Value token = m_scanner->getCurrentToken();
+		Token::Value token = m_scanner->currentToken();
 		if (token == Token::Const)
 		{
 			isDeclaredConst = true;
@@ -251,7 +256,7 @@ ASTPointer<FunctionDefinition> Parser::parseFunctionDefinition(ASTString const*
 			break;
 	}
 	ASTPointer<ParameterList> returnParameters;
-	if (m_scanner->getCurrentToken() == Token::Returns)
+	if (m_scanner->currentToken() == Token::Returns)
 	{
 		bool const permitEmptyParameterList = false;
 		m_scanner->next();
@@ -261,7 +266,7 @@ ASTPointer<FunctionDefinition> Parser::parseFunctionDefinition(ASTString const*
 		returnParameters = createEmptyParameterList();
 	ASTPointer<Block> block = ASTPointer<Block>();
 	nodeFactory.markEndPosition();
-	if (m_scanner->getCurrentToken() != Token::Semicolon)
+	if (m_scanner->currentToken() != Token::Semicolon)
 	{
 		block = parseBlock();
 		nodeFactory.setEndPositionFromNode(block);
@@ -281,7 +286,7 @@ ASTPointer<StructDefinition> Parser::parseStructDefinition()
 	ASTPointer<ASTString> name = expectIdentifierToken();
 	vector<ASTPointer<VariableDeclaration>> members;
 	expectToken(Token::LBrace);
-	while (m_scanner->getCurrentToken() != Token::RBrace)
+	while (m_scanner->currentToken() != Token::RBrace)
 	{
 		members.push_back(parseVariableDeclaration());
 		expectToken(Token::Semicolon);
@@ -306,13 +311,13 @@ ASTPointer<EnumDefinition> Parser::parseEnumDefinition()
 	vector<ASTPointer<EnumValue>> members;
 	expectToken(Token::LBrace);
 
-	while (m_scanner->getCurrentToken() != Token::RBrace)
+	while (m_scanner->currentToken() != Token::RBrace)
 	{
 		members.push_back(parseEnumValue());
-		if (m_scanner->getCurrentToken() == Token::RBrace)
+		if (m_scanner->currentToken() == Token::RBrace)
 			break;
 		expectToken(Token::Comma);
-		if (m_scanner->getCurrentToken() != Token::Identifier)
+		if (m_scanner->currentToken() != Token::Identifier)
 			BOOST_THROW_EXCEPTION(createParserError("Expected Identifier after ','"));
 	}
 
@@ -345,7 +350,7 @@ ASTPointer<VariableDeclaration> Parser::parseVariableDeclaration(
 
 	while (true)
 	{
-		Token::Value token = m_scanner->getCurrentToken();
+		Token::Value token = m_scanner->currentToken();
 		if (_options.isStateVariable && Token::isVariableVisibilitySpecifier(token))
 		{
 			if (visibility != Declaration::Visibility::Default)
@@ -377,7 +382,7 @@ ASTPointer<VariableDeclaration> Parser::parseVariableDeclaration(
 	}
 	nodeFactory.markEndPosition();
 
-	if (_options.allowEmptyName && m_scanner->getCurrentToken() != Token::Identifier)
+	if (_options.allowEmptyName && m_scanner->currentToken() != Token::Identifier)
 	{
 		identifier = make_shared<ASTString>("");
 		solAssert(type != nullptr, "");
@@ -388,7 +393,7 @@ ASTPointer<VariableDeclaration> Parser::parseVariableDeclaration(
 	ASTPointer<Expression> value;
 	if (_options.allowInitialValue)
 	{
-		if (m_scanner->getCurrentToken() == Token::Assign)
+		if (m_scanner->currentToken() == Token::Assign)
 		{
 			m_scanner->next();
 			value = parseExpression();
@@ -414,13 +419,13 @@ ASTPointer<ModifierDefinition> Parser::parseModifierDefinition()
 
 	ASTNodeFactory nodeFactory(*this);
 	ASTPointer<ASTString> docstring;
-	if (m_scanner->getCurrentCommentLiteral() != "")
-		docstring = make_shared<ASTString>(m_scanner->getCurrentCommentLiteral());
+	if (m_scanner->currentCommentLiteral() != "")
+		docstring = make_shared<ASTString>(m_scanner->currentCommentLiteral());
 
 	expectToken(Token::Modifier);
 	ASTPointer<ASTString> name(expectIdentifierToken());
 	ASTPointer<ParameterList> parameters;
-	if (m_scanner->getCurrentToken() == Token::LParen)
+	if (m_scanner->currentToken() == Token::LParen)
 	{
 		VarDeclParserOptions options;
 		options.allowIndexed = true;
@@ -438,13 +443,13 @@ ASTPointer<EventDefinition> Parser::parseEventDefinition()
 {
 	ASTNodeFactory nodeFactory(*this);
 	ASTPointer<ASTString> docstring;
-	if (m_scanner->getCurrentCommentLiteral() != "")
-		docstring = make_shared<ASTString>(m_scanner->getCurrentCommentLiteral());
+	if (m_scanner->currentCommentLiteral() != "")
+		docstring = make_shared<ASTString>(m_scanner->currentCommentLiteral());
 
 	expectToken(Token::Event);
 	ASTPointer<ASTString> name(expectIdentifierToken());
 	ASTPointer<ParameterList> parameters;
-	if (m_scanner->getCurrentToken() == Token::LParen)
+	if (m_scanner->currentToken() == Token::LParen)
 	{
 		VarDeclParserOptions options;
 		options.allowIndexed = true;
@@ -453,7 +458,7 @@ ASTPointer<EventDefinition> Parser::parseEventDefinition()
 	else
 		parameters = createEmptyParameterList();
 	bool anonymous = false;
-	if (m_scanner->getCurrentToken() == Token::Anonymous)
+	if (m_scanner->currentToken() == Token::Anonymous)
 	{
 		anonymous = true;
 		m_scanner->next();
@@ -468,7 +473,7 @@ ASTPointer<ModifierInvocation> Parser::parseModifierInvocation()
 	ASTNodeFactory nodeFactory(*this);
 	ASTPointer<Identifier> name(parseIdentifier());
 	vector<ASTPointer<Expression>> arguments;
-	if (m_scanner->getCurrentToken() == Token::LParen)
+	if (m_scanner->currentToken() == Token::LParen)
 	{
 		m_scanner->next();
 		arguments = parseFunctionCallListArguments();
@@ -491,7 +496,7 @@ ASTPointer<TypeName> Parser::parseTypeName(bool _allowVar)
 {
 	ASTNodeFactory nodeFactory(*this);
 	ASTPointer<TypeName> type;
-	Token::Value token = m_scanner->getCurrentToken();
+	Token::Value token = m_scanner->currentToken();
 	if (Token::isElementaryTypeName(token))
 	{
 		type = ASTNodeFactory(*this).createNode<ElementaryTypeName>(token);
@@ -516,11 +521,11 @@ ASTPointer<TypeName> Parser::parseTypeName(bool _allowVar)
 
 	if (type)
 		// Parse "[...]" postfixes for arrays.
-		while (m_scanner->getCurrentToken() == Token::LBrack)
+		while (m_scanner->currentToken() == Token::LBrack)
 		{
 			m_scanner->next();
 			ASTPointer<Expression> length;
-			if (m_scanner->getCurrentToken() != Token::RBrack)
+			if (m_scanner->currentToken() != Token::RBrack)
 				length = parseExpression();
 			nodeFactory.markEndPosition();
 			expectToken(Token::RBrack);
@@ -534,10 +539,10 @@ ASTPointer<Mapping> Parser::parseMapping()
 	ASTNodeFactory nodeFactory(*this);
 	expectToken(Token::Mapping);
 	expectToken(Token::LParen);
-	if (!Token::isElementaryTypeName(m_scanner->getCurrentToken()))
+	if (!Token::isElementaryTypeName(m_scanner->currentToken()))
 		BOOST_THROW_EXCEPTION(createParserError("Expected elementary type name for mapping key type"));
 	ASTPointer<ElementaryTypeName> keyType;
-	keyType = ASTNodeFactory(*this).createNode<ElementaryTypeName>(m_scanner->getCurrentToken());
+	keyType = ASTNodeFactory(*this).createNode<ElementaryTypeName>(m_scanner->currentToken());
 	m_scanner->next();
 	expectToken(Token::Arrow);
 	bool const allowVar = false;
@@ -557,10 +562,10 @@ ASTPointer<ParameterList> Parser::parseParameterList(
 	VarDeclParserOptions options(_options);
 	options.allowEmptyName = true;
 	expectToken(Token::LParen);
-	if (!_allowEmpty || m_scanner->getCurrentToken() != Token::RParen)
+	if (!_allowEmpty || m_scanner->currentToken() != Token::RParen)
 	{
 		parameters.push_back(parseVariableDeclaration(options));
-		while (m_scanner->getCurrentToken() != Token::RParen)
+		while (m_scanner->currentToken() != Token::RParen)
 		{
 			expectToken(Token::Comma);
 			parameters.push_back(parseVariableDeclaration(options));
@@ -576,7 +581,7 @@ ASTPointer<Block> Parser::parseBlock()
 	ASTNodeFactory nodeFactory(*this);
 	expectToken(Token::LBrace);
 	vector<ASTPointer<Statement>> statements;
-	while (m_scanner->getCurrentToken() != Token::RBrace)
+	while (m_scanner->currentToken() != Token::RBrace)
 		statements.push_back(parseStatement());
 	nodeFactory.markEndPosition();
 	expectToken(Token::RBrace);
@@ -586,7 +591,7 @@ ASTPointer<Block> Parser::parseBlock()
 ASTPointer<Statement> Parser::parseStatement()
 {
 	ASTPointer<Statement> statement;
-	switch (m_scanner->getCurrentToken())
+	switch (m_scanner->currentToken())
 	{
 	case Token::If:
 		return parseIfStatement();
@@ -617,8 +622,14 @@ ASTPointer<Statement> Parser::parseStatement()
 		statement = nodeFactory.createNode<Return>(expression);
 		break;
 	}
+	case Token::Throw:
+	{
+		statement = ASTNodeFactory(*this).createNode<Throw>();
+		m_scanner->next();
+		break;
+	}
 	case Token::Identifier:
-		if (m_insideModifier && m_scanner->getCurrentLiteral() == "_")
+		if (m_insideModifier && m_scanner->currentLiteral() == "_")
 		{
 			statement = ASTNodeFactory(*this).createNode<PlaceholderStatement>();
 			m_scanner->next();
@@ -641,7 +652,7 @@ ASTPointer<IfStatement> Parser::parseIfStatement()
 	expectToken(Token::RParen);
 	ASTPointer<Statement> trueBody = parseStatement();
 	ASTPointer<Statement> falseBody;
-	if (m_scanner->getCurrentToken() == Token::Else)
+	if (m_scanner->currentToken() == Token::Else)
 	{
 		m_scanner->next();
 		falseBody = parseStatement();
@@ -674,15 +685,15 @@ ASTPointer<ForStatement> Parser::parseForStatement()
 	expectToken(Token::LParen);
 
 	// LTODO: Maybe here have some predicate like peekExpression() instead of checking for semicolon and RParen?
-	if (m_scanner->getCurrentToken() != Token::Semicolon)
+	if (m_scanner->currentToken() != Token::Semicolon)
 		initExpression = parseSimpleStatement();
 	expectToken(Token::Semicolon);
 
-	if (m_scanner->getCurrentToken() != Token::Semicolon)
+	if (m_scanner->currentToken() != Token::Semicolon)
 		conditionExpression = parseExpression();
 	expectToken(Token::Semicolon);
 
-	if (m_scanner->getCurrentToken() != Token::RParen)
+	if (m_scanner->currentToken() != Token::RParen)
 		loopExpression = parseExpressionStatement();
 	expectToken(Token::RParen);
 
@@ -713,29 +724,29 @@ ASTPointer<Statement> Parser::parseSimpleStatement()
 	// We parse '(Identifier|ElementaryTypeName) ( "[" Expression "]" )+' and then decide whether to hand this over
 	// to ExpressionStatement or create a VariableDeclarationStatement out of it.
 	ASTPointer<PrimaryExpression> primary;
-	if (m_scanner->getCurrentToken() == Token::Identifier)
+	if (m_scanner->currentToken() == Token::Identifier)
 		primary = parseIdentifier();
 	else
 	{
-		primary = ASTNodeFactory(*this).createNode<ElementaryTypeNameExpression>(m_scanner->getCurrentToken());
+		primary = ASTNodeFactory(*this).createNode<ElementaryTypeNameExpression>(m_scanner->currentToken());
 		m_scanner->next();
 	}
 	vector<pair<ASTPointer<Expression>, SourceLocation>> indices;
-	solAssert(m_scanner->getCurrentToken() == Token::LBrack, "");
-	SourceLocation indexLocation = primary->getLocation();
+	solAssert(m_scanner->currentToken() == Token::LBrack, "");
+	SourceLocation indexLocation = primary->location();
 	do
 	{
 		expectToken(Token::LBrack);
 		ASTPointer<Expression> index;
-		if (m_scanner->getCurrentToken() != Token::RBrack)
+		if (m_scanner->currentToken() != Token::RBrack)
 			index = parseExpression();
-		indexLocation.end = getEndPosition();
+		indexLocation.end = endPosition();
 		indices.push_back(make_pair(index, indexLocation));
 		expectToken(Token::RBrack);
 	}
-	while (m_scanner->getCurrentToken() == Token::LBrack);
+	while (m_scanner->currentToken() == Token::LBrack);
 
-	if (m_scanner->getCurrentToken() == Token::Identifier || Token::isLocationSpecifier(m_scanner->getCurrentToken()))
+	if (m_scanner->currentToken() == Token::Identifier || Token::isLocationSpecifier(m_scanner->currentToken()))
 		return parseVariableDeclarationStatement(typeNameIndexAccessStructure(primary, indices));
 	else
 		return parseExpressionStatement(expressionFromIndexAccessStructure(primary, indices));
@@ -764,7 +775,7 @@ ASTPointer<Expression> Parser::parseExpression(
 		ASTPointer<Expression> const& _lookAheadIndexAccessStructure)
 {
 	ASTPointer<Expression> expression = parseBinaryExpression(4, _lookAheadIndexAccessStructure);
-	if (!Token::isAssignmentOp(m_scanner->getCurrentToken()))
+	if (!Token::isAssignmentOp(m_scanner->currentToken()))
 		return expression;
 	Token::Value assignmentOperator = expectAssignmentOperator();
 	ASTPointer<Expression> rightHandSide = parseExpression();
@@ -778,11 +789,11 @@ ASTPointer<Expression> Parser::parseBinaryExpression(int _minPrecedence,
 {
 	ASTPointer<Expression> expression = parseUnaryExpression(_lookAheadIndexAccessStructure);
 	ASTNodeFactory nodeFactory(*this, expression);
-	int precedence = Token::precedence(m_scanner->getCurrentToken());
+	int precedence = Token::precedence(m_scanner->currentToken());
 	for (; precedence >= _minPrecedence; --precedence)
-		while (Token::precedence(m_scanner->getCurrentToken()) == precedence)
+		while (Token::precedence(m_scanner->currentToken()) == precedence)
 		{
-			Token::Value op = m_scanner->getCurrentToken();
+			Token::Value op = m_scanner->currentToken();
 			m_scanner->next();
 			ASTPointer<Expression> right = parseBinaryExpression(precedence + 1);
 			nodeFactory.setEndPositionFromNode(right);
@@ -796,7 +807,7 @@ ASTPointer<Expression> Parser::parseUnaryExpression(
 {
 	ASTNodeFactory nodeFactory = _lookAheadIndexAccessStructure ?
 		ASTNodeFactory(*this, _lookAheadIndexAccessStructure) : ASTNodeFactory(*this);
-	Token::Value token = m_scanner->getCurrentToken();
+	Token::Value token = m_scanner->currentToken();
 	if (!_lookAheadIndexAccessStructure && (Token::isUnaryOp(token) || Token::isCountOp(token)))
 	{
 		// prefix expression
@@ -809,7 +820,7 @@ ASTPointer<Expression> Parser::parseUnaryExpression(
 	{
 		// potential postfix expression
 		ASTPointer<Expression> subExpression = parseLeftHandSideExpression(_lookAheadIndexAccessStructure);
-		token = m_scanner->getCurrentToken();
+		token = m_scanner->currentToken();
 		if (!Token::isCountOp(token))
 			return subExpression;
 		nodeFactory.markEndPosition();
@@ -827,7 +838,7 @@ ASTPointer<Expression> Parser::parseLeftHandSideExpression(
 	ASTPointer<Expression> expression;
 	if (_lookAheadIndexAccessStructure)
 		expression = _lookAheadIndexAccessStructure;
-	else if (m_scanner->getCurrentToken() == Token::New)
+	else if (m_scanner->currentToken() == Token::New)
 	{
 		expectToken(Token::New);
 		ASTPointer<Identifier> contractName(parseIdentifier());
@@ -839,13 +850,13 @@ ASTPointer<Expression> Parser::parseLeftHandSideExpression(
 
 	while (true)
 	{
-		switch (m_scanner->getCurrentToken())
+		switch (m_scanner->currentToken())
 		{
 		case Token::LBrack:
 		{
 			m_scanner->next();
 			ASTPointer<Expression> index;
-			if (m_scanner->getCurrentToken() != Token::RBrack)
+			if (m_scanner->currentToken() != Token::RBrack)
 				index = parseExpression();
 			nodeFactory.markEndPosition();
 			expectToken(Token::RBrack);
@@ -879,7 +890,7 @@ ASTPointer<Expression> Parser::parseLeftHandSideExpression(
 ASTPointer<Expression> Parser::parsePrimaryExpression()
 {
 	ASTNodeFactory nodeFactory(*this);
-	Token::Value token = m_scanner->getCurrentToken();
+	Token::Value token = m_scanner->currentToken();
 	ASTPointer<Expression> expression;
 	switch (token)
 	{
@@ -892,7 +903,7 @@ ASTPointer<Expression> Parser::parsePrimaryExpression()
 		{
 			ASTPointer<ASTString> literal = getLiteralAndAdvance();
 			nodeFactory.markEndPosition();
-			Literal::SubDenomination subdenomination = static_cast<Literal::SubDenomination>(m_scanner->getCurrentToken());
+			Literal::SubDenomination subdenomination = static_cast<Literal::SubDenomination>(m_scanner->currentToken());
 			m_scanner->next();
 			expression = nodeFactory.createNode<Literal>(token, literal, subdenomination);
 			break;
@@ -901,7 +912,7 @@ ASTPointer<Expression> Parser::parsePrimaryExpression()
 		{
 			ASTPointer<ASTString> literal = getLiteralAndAdvance();
 			nodeFactory.markEndPosition();
-			Literal::SubDenomination subdenomination = static_cast<Literal::SubDenomination>(m_scanner->getCurrentToken());
+			Literal::SubDenomination subdenomination = static_cast<Literal::SubDenomination>(m_scanner->currentToken());
 			m_scanner->next();
 			expression = nodeFactory.createNode<Literal>(token, literal, subdenomination);
 			break;
@@ -939,10 +950,10 @@ ASTPointer<Expression> Parser::parsePrimaryExpression()
 vector<ASTPointer<Expression>> Parser::parseFunctionCallListArguments()
 {
 	vector<ASTPointer<Expression>> arguments;
-	if (m_scanner->getCurrentToken() != Token::RParen)
+	if (m_scanner->currentToken() != Token::RParen)
 	{
 		arguments.push_back(parseExpression());
-		while (m_scanner->getCurrentToken() != Token::RParen)
+		while (m_scanner->currentToken() != Token::RParen)
 		{
 			expectToken(Token::Comma);
 			arguments.push_back(parseExpression());
@@ -954,18 +965,18 @@ vector<ASTPointer<Expression>> Parser::parseFunctionCallListArguments()
 pair<vector<ASTPointer<Expression>>, vector<ASTPointer<ASTString>>> Parser::parseFunctionCallArguments()
 {
 	pair<vector<ASTPointer<Expression>>, vector<ASTPointer<ASTString>>> ret;
-	Token::Value token = m_scanner->getCurrentToken();
+	Token::Value token = m_scanner->currentToken();
 	if (token == Token::LBrace)
 	{
 		// call({arg1 : 1, arg2 : 2 })
 		expectToken(Token::LBrace);
-		while (m_scanner->getCurrentToken() != Token::RBrace)
+		while (m_scanner->currentToken() != Token::RBrace)
 		{
 			ret.second.push_back(expectIdentifierToken());
 			expectToken(Token::Colon);
 			ret.first.push_back(parseExpression());
 
-			if (m_scanner->getCurrentToken() == Token::Comma)
+			if (m_scanner->currentToken() == Token::Comma)
 				expectToken(Token::Comma);
 			else
 				break;
@@ -986,7 +997,7 @@ Parser::LookAheadInfo Parser::peekStatementType() const
 	// a variable declaration.
 	// If we get an identifier followed by a "[", it can be both ("type[9] a;" or "arr[9] = 7;").
 	// In all other cases, we have an expression statement.
-	Token::Value token(m_scanner->getCurrentToken());
+	Token::Value token(m_scanner->currentToken());
 	bool mightBeTypeName = (Token::isElementaryTypeName(token) || token == Token::Identifier);
 
 	if (token == Token::Mapping || token == Token::Var)
@@ -1008,9 +1019,9 @@ ASTPointer<TypeName> Parser::typeNameIndexAccessStructure(
 	ASTNodeFactory nodeFactory(*this, _primary);
 	ASTPointer<TypeName> type;
 	if (auto identifier = dynamic_cast<Identifier const*>(_primary.get()))
-		type = nodeFactory.createNode<UserDefinedTypeName>(make_shared<ASTString>(identifier->getName()));
+		type = nodeFactory.createNode<UserDefinedTypeName>(make_shared<ASTString>(identifier->name()));
 	else if (auto typeName = dynamic_cast<ElementaryTypeNameExpression const*>(_primary.get()))
-		type = nodeFactory.createNode<ElementaryTypeName>(typeName->getTypeToken());
+		type = nodeFactory.createNode<ElementaryTypeName>(typeName->typeToken());
 	else
 		solAssert(false, "Invalid type name for array look-ahead.");
 	for (auto const& lengthExpression: _indices)
@@ -1036,14 +1047,14 @@ ASTPointer<Expression> Parser::expressionFromIndexAccessStructure(
 
 void Parser::expectToken(Token::Value _value)
 {
-	if (m_scanner->getCurrentToken() != _value)
-		BOOST_THROW_EXCEPTION(createParserError(string("Expected token ") + string(Token::getName(_value))));
+	if (m_scanner->currentToken() != _value)
+		BOOST_THROW_EXCEPTION(createParserError(string("Expected token ") + string(Token::name(_value))));
 	m_scanner->next();
 }
 
 Token::Value Parser::expectAssignmentOperator()
 {
-	Token::Value op = m_scanner->getCurrentToken();
+	Token::Value op = m_scanner->currentToken();
 	if (!Token::isAssignmentOp(op))
 		BOOST_THROW_EXCEPTION(createParserError("Expected assignment operator"));
 	m_scanner->next();
@@ -1052,14 +1063,14 @@ Token::Value Parser::expectAssignmentOperator()
 
 ASTPointer<ASTString> Parser::expectIdentifierToken()
 {
-	if (m_scanner->getCurrentToken() != Token::Identifier)
+	if (m_scanner->currentToken() != Token::Identifier)
 		BOOST_THROW_EXCEPTION(createParserError("Expected identifier"));
 	return getLiteralAndAdvance();
 }
 
 ASTPointer<ASTString> Parser::getLiteralAndAdvance()
 {
-	ASTPointer<ASTString> identifier = make_shared<ASTString>(m_scanner->getCurrentLiteral());
+	ASTPointer<ASTString> identifier = make_shared<ASTString>(m_scanner->currentLiteral());
 	m_scanner->next();
 	return identifier;
 }
@@ -1073,8 +1084,9 @@ ASTPointer<ParameterList> Parser::createEmptyParameterList()
 
 ParserError Parser::createParserError(string const& _description) const
 {
-	return ParserError() << errinfo_sourceLocation(SourceLocation(getPosition(), getPosition(), getSourceName()))
-						 << errinfo_comment(_description);
+	return ParserError() <<
+		errinfo_sourceLocation(SourceLocation(position(), position(), sourceName())) <<
+		errinfo_comment(_description);
 }
 
 
diff --git a/libsolidity/Parser.h b/libsolidity/Parser.h
index d667aa3e..79eb73f0 100644
--- a/libsolidity/Parser.h
+++ b/libsolidity/Parser.h
@@ -37,15 +37,15 @@ public:
 	Parser() {}
 
 	ASTPointer<SourceUnit> parse(std::shared_ptr<Scanner> const& _scanner);
-	std::shared_ptr<std::string const> const& getSourceName() const;
+	std::shared_ptr<std::string const> const& sourceName() const;
 
 private:
 	class ASTNodeFactory;
 
 	/// Start position of the current token
-	int getPosition() const;
+	int position() const;
 	/// End position of the current token
-	int getEndPosition() const;
+	int endPosition() const;
 
 	struct VarDeclParserOptions
 	{
@@ -61,15 +61,17 @@ private:
 	///@{
 	///@name Parsing functions for the AST nodes
 	ASTPointer<ImportDirective> parseImportDirective();
-	ASTPointer<ContractDefinition> parseContractDefinition();
+	ASTPointer<ContractDefinition> parseContractDefinition(bool _isLibrary);
 	ASTPointer<InheritanceSpecifier> parseInheritanceSpecifier();
 	Declaration::Visibility parseVisibilitySpecifier(Token::Value _token);
 	ASTPointer<FunctionDefinition> parseFunctionDefinition(ASTString const* _contractName);
 	ASTPointer<StructDefinition> parseStructDefinition();
 	ASTPointer<EnumDefinition> parseEnumDefinition();
 	ASTPointer<EnumValue> parseEnumValue();
-	ASTPointer<VariableDeclaration> parseVariableDeclaration(VarDeclParserOptions const& _options = VarDeclParserOptions(),
-		ASTPointer<TypeName> const& _lookAheadArrayType = ASTPointer<TypeName>());
+	ASTPointer<VariableDeclaration> parseVariableDeclaration(
+		VarDeclParserOptions const& _options = VarDeclParserOptions(),
+		ASTPointer<TypeName> const& _lookAheadArrayType = ASTPointer<TypeName>()
+	);
 	ASTPointer<ModifierDefinition> parseModifierDefinition();
 	ASTPointer<EventDefinition> parseEventDefinition();
 	ASTPointer<ModifierInvocation> parseModifierInvocation();
diff --git a/libsolidity/Scanner.cpp b/libsolidity/Scanner.cpp
index fbe3ea97..d67b6423 100644
--- a/libsolidity/Scanner.cpp
+++ b/libsolidity/Scanner.cpp
@@ -202,20 +202,20 @@ Token::Value Scanner::selectToken(char _next, Token::Value _then, Token::Value _
 
 bool Scanner::skipWhitespace()
 {
-	int const startPosition = getSourcePos();
+	int const startPosition = sourcePos();
 	while (isWhiteSpace(m_char))
 		advance();
 	// Return whether or not we skipped any characters.
-	return getSourcePos() != startPosition;
+	return sourcePos() != startPosition;
 }
 
 bool Scanner::skipWhitespaceExceptLF()
 {
-	int const startPosition = getSourcePos();
+	int const startPosition = sourcePos();
 	while (isWhiteSpace(m_char) && !isLineTerminator(m_char))
 		advance();
 	// Return whether or not we skipped any characters.
-	return getSourcePos() != startPosition;
+	return sourcePos() != startPosition;
 }
 
 Token::Value Scanner::skipSingleLineComment()
@@ -224,7 +224,9 @@ Token::Value Scanner::skipSingleLineComment()
 	// to be part of the single-line comment; it is recognized
 	// separately by the lexical grammar and becomes part of the
 	// stream of input elements for the syntactic grammar
-	while (advance() && !isLineTerminator(m_char)) { };
+	while (!isLineTerminator(m_char))
+		if (!advance()) break;
+
 	return Token::Whitespace;
 }
 
@@ -326,7 +328,7 @@ Token::Value Scanner::scanMultiLineDocComment()
 
 Token::Value Scanner::scanSlash()
 {
-	int firstSlashPosition = getSourcePos();
+	int firstSlashPosition = sourcePos();
 	advance();
 	if (m_char == '/')
 	{
@@ -338,7 +340,7 @@ Token::Value Scanner::scanSlash()
 			Token::Value comment;
 			m_nextSkippedComment.location.start = firstSlashPosition;
 			comment = scanSingleLineDocComment();
-			m_nextSkippedComment.location.end = getSourcePos();
+			m_nextSkippedComment.location.end = sourcePos();
 			m_nextSkippedComment.token = comment;
 			return Token::Whitespace;
 		}
@@ -363,7 +365,7 @@ Token::Value Scanner::scanSlash()
 				Token::Value comment;
 				m_nextSkippedComment.location.start = firstSlashPosition;
 				comment = scanMultiLineDocComment();
-				m_nextSkippedComment.location.end = getSourcePos();
+				m_nextSkippedComment.location.end = sourcePos();
 				m_nextSkippedComment.token = comment;
 			}
 			return Token::Whitespace;
@@ -385,7 +387,7 @@ void Scanner::scanToken()
 	do
 	{
 		// Remember the position of the next token
-		m_nextToken.location.start = getSourcePos();
+		m_nextToken.location.start = sourcePos();
 		switch (m_char)
 		{
 		case '\n': // fall-through
@@ -564,7 +566,7 @@ void Scanner::scanToken()
 		// whitespace.
 	}
 	while (token == Token::Whitespace);
-	m_nextToken.location.end = getSourcePos();
+	m_nextToken.location.end = sourcePos();
 	m_nextToken.token = token;
 }
 
@@ -719,20 +721,20 @@ char CharStream::advanceAndGet(size_t _chars)
 {
 	if (isPastEndOfInput())
 		return 0;
-	m_pos += _chars;
+	m_position += _chars;
 	if (isPastEndOfInput())
 		return 0;
-	return m_source[m_pos];
+	return m_source[m_position];
 }
 
 char CharStream::rollback(size_t _amount)
 {
-	solAssert(m_pos >= _amount, "");
-	m_pos -= _amount;
+	solAssert(m_position >= _amount, "");
+	m_position -= _amount;
 	return get();
 }
 
-string CharStream::getLineAtPosition(int _position) const
+string CharStream::lineAtPosition(int _position) const
 {
 	// if _position points to \n, it returns the line before the \n
 	using size_type = string::size_type;
diff --git a/libsolidity/Scanner.h b/libsolidity/Scanner.h
index 43fcd133..29b44d15 100644
--- a/libsolidity/Scanner.h
+++ b/libsolidity/Scanner.h
@@ -71,27 +71,27 @@ class ParserRecorder;
 class CharStream
 {
 public:
-	CharStream(): m_pos(0) {}
-	explicit CharStream(std::string const& _source): m_source(_source), m_pos(0) {}
-	int getPos() const { return m_pos; }
-	bool isPastEndOfInput(size_t _charsForward = 0) const { return (m_pos + _charsForward) >= m_source.size(); }
-	char get(size_t _charsForward = 0) const { return m_source[m_pos + _charsForward]; }
+	CharStream(): m_position(0) {}
+	explicit CharStream(std::string const& _source): m_source(_source), m_position(0) {}
+	int position() const { return m_position; }
+	bool isPastEndOfInput(size_t _charsForward = 0) const { return (m_position + _charsForward) >= m_source.size(); }
+	char get(size_t _charsForward = 0) const { return m_source[m_position + _charsForward]; }
 	char advanceAndGet(size_t _chars=1);
 	char rollback(size_t _amount);
 
-	void reset() { m_pos = 0; }
+	void reset() { m_position = 0; }
 
 	///@{
 	///@name Error printing helper functions
 	/// Functions that help pretty-printing parse errors
 	/// Do only use in error cases, they are quite expensive.
-	std::string getLineAtPosition(int _position) const;
+	std::string lineAtPosition(int _position) const;
 	std::tuple<int, int> translatePositionToLineColumn(int _position) const;
 	///@}
 
 private:
 	std::string m_source;
-	size_t m_pos;
+	size_t m_position;
 };
 
 
@@ -115,20 +115,20 @@ public:
 	///@name Information about the current token
 
 	/// Returns the current token
-	Token::Value getCurrentToken()
+	Token::Value currentToken()
 	{
 		return m_currentToken.token;
 	}
 
-	SourceLocation getCurrentLocation() const { return m_currentToken.location; }
-	std::string const& getCurrentLiteral() const { return m_currentToken.literal; }
+	SourceLocation currentLocation() const { return m_currentToken.location; }
+	std::string const& currentLiteral() const { return m_currentToken.literal; }
 	///@}
 
 	///@{
 	///@name Information about the current comment token
 
-	SourceLocation getCurrentCommentLocation() const { return m_skippedComment.location; }
-	std::string const& getCurrentCommentLiteral() const { return m_skippedComment.literal; }
+	SourceLocation currentCommentLocation() const { return m_skippedComment.location; }
+	std::string const& currentCommentLiteral() const { return m_skippedComment.literal; }
 	/// Called by the parser during FunctionDefinition parsing to clear the current comment
 	void clearCurrentCommentLiteral() { m_skippedComment.literal.clear(); }
 
@@ -143,13 +143,13 @@ public:
 	std::string const& peekLiteral() const { return m_nextToken.literal; }
 	///@}
 
-	std::shared_ptr<std::string const> const& getSourceName() const { return m_sourceName; }
+	std::shared_ptr<std::string const> const& sourceName() const { return m_sourceName; }
 
 	///@{
 	///@name Error printing helper functions
 	/// Functions that help pretty-printing parse errors
 	/// Do only use in error cases, they are quite expensive.
-	std::string getLineAtPosition(int _position) const { return m_source.getLineAtPosition(_position); }
+	std::string lineAtPosition(int _position) const { return m_source.lineAtPosition(_position); }
 	std::tuple<int, int> translatePositionToLineColumn(int _position) const { return m_source.translatePositionToLineColumn(_position); }
 	///@}
 
@@ -204,7 +204,7 @@ private:
 	bool scanEscape();
 
 	/// Return the current source position.
-	int getSourcePos() { return m_source.getPos(); }
+	int sourcePos() { return m_source.position(); }
 	bool isSourcePastEndOfInput() { return m_source.isPastEndOfInput(); }
 
 	TokenDesc m_skippedComment;  // desc for current skipped comment
diff --git a/libsolidity/SourceReferenceFormatter.cpp b/libsolidity/SourceReferenceFormatter.cpp
index 77805efc..339d5b23 100644
--- a/libsolidity/SourceReferenceFormatter.cpp
+++ b/libsolidity/SourceReferenceFormatter.cpp
@@ -46,7 +46,7 @@ void SourceReferenceFormatter::printSourceLocation(
 	tie(endLine, endColumn) = _scanner.translatePositionToLineColumn(_location.end);
 	if (startLine == endLine)
 	{
-		string line = _scanner.getLineAtPosition(_location.start);
+		string line = _scanner.lineAtPosition(_location.start);
 		_stream << line << endl;
 		for_each(
 			line.cbegin(),
@@ -62,7 +62,7 @@ void SourceReferenceFormatter::printSourceLocation(
 	}
 	else
 		_stream <<
-			_scanner.getLineAtPosition(_location.start) <<
+			_scanner.lineAtPosition(_location.start) <<
 			endl <<
 			string(startColumn, ' ') <<
 			"^\n" <<
@@ -90,12 +90,12 @@ void SourceReferenceFormatter::printExceptionInformation(
 {
 	SourceLocation const* location = boost::get_error_info<errinfo_sourceLocation>(_exception);
 	auto secondarylocation = boost::get_error_info<errinfo_secondarySourceLocation>(_exception);
-	Scanner const* scanner = nullptr;
+	Scanner const* scannerPtr = nullptr;
 
 	if (location)
 	{
-		scanner = &_compiler.getScanner(*location->sourceName);
-		printSourceName(_stream, *location, *scanner);
+		scannerPtr = &_compiler.scanner(*location->sourceName);
+		printSourceName(_stream, *location, *scannerPtr);
 	}
 
 	_stream << _name;
@@ -104,19 +104,19 @@ void SourceReferenceFormatter::printExceptionInformation(
 
 	if (location)
 	{
-		scanner = &_compiler.getScanner(*location->sourceName);
-		printSourceLocation(_stream, *location, *scanner);
+		scannerPtr = &_compiler.scanner(*location->sourceName);
+		printSourceLocation(_stream, *location, *scannerPtr);
 	}
 
 	if (secondarylocation && !secondarylocation->infos.empty())
 	{
 		for (auto info: secondarylocation->infos)
 		{
-			scanner = &_compiler.getScanner(*info.second.sourceName);
+			scannerPtr = &_compiler.scanner(*info.second.sourceName);
 			_stream << info.first << " ";
-			printSourceName(_stream, info.second, *scanner);
+			printSourceName(_stream, info.second, *scannerPtr);
 			_stream << endl;
-			printSourceLocation(_stream, info.second, *scanner);
+			printSourceLocation(_stream, info.second, *scannerPtr);
 		}
 		_stream << endl;
 	}
diff --git a/libsolidity/Token.h b/libsolidity/Token.h
index 7c7b1c7f..2ea7eb01 100644
--- a/libsolidity/Token.h
+++ b/libsolidity/Token.h
@@ -160,6 +160,7 @@ namespace solidity
 	K(Internal, "internal", 0)                                         \
 	K(Import, "import", 0)                                             \
 	K(Is, "is", 0)                                                     \
+	K(Library, "library", 0)                                           \
 	K(Mapping, "mapping", 0)                                           \
 	K(Memory, "memory", 0)                                             \
 	K(Modifier, "modifier", 0)                                         \
@@ -170,6 +171,7 @@ namespace solidity
 	K(Returns, "returns", 0)                                           \
 	K(Storage, "storage", 0)                                           \
 	K(Struct, "struct", 0)                                             \
+	K(Throw, "throw", 0)                                               \
 	K(Var, "var", 0)                                                   \
 	K(While, "while", 0)                                               \
 	\
@@ -305,7 +307,7 @@ namespace solidity
 	/* Identifiers (not keywords or future reserved words). */         \
 	T(Identifier, NULL, 0)                                             \
 	\
-	/* Keywords reserved for future. use. */                           \
+	/* Keywords reserved for future use. */                            \
 	K(As, "as", 0)                                                     \
 	K(Case, "case", 0)                                                 \
 	K(Catch, "catch", 0)                                               \
@@ -315,7 +317,6 @@ namespace solidity
 	K(Of, "of", 0)                                                     \
 	K(Relocatable, "relocatable", 0)                                   \
 	K(Switch, "switch", 0)                                             \
-	K(Throw, "throw", 0)                                               \
 	K(Try, "try", 0)                                                   \
 	K(Type, "type", 0)                                                 \
 	K(TypeOf, "typeof", 0)                                             \
@@ -344,7 +345,7 @@ public:
 
 	// Returns a string corresponding to the C++ token name
 	// (e.g. "LT" for the token LT).
-	static char const* getName(Value tok)
+	static char const* name(Value tok)
 	{
 		solAssert(tok < NUM_TOKENS, "");
 		return m_name[tok];
diff --git a/libsolidity/Types.cpp b/libsolidity/Types.cpp
index bda68356..beb5becd 100644
--- a/libsolidity/Types.cpp
+++ b/libsolidity/Types.cpp
@@ -43,7 +43,7 @@ void StorageOffsets::computeOffsets(TypePointers const& _types)
 		TypePointer const& type = _types[i];
 		if (!type->canBeStored())
 			continue;
-		if (byteOffset + type->getStorageBytes() > 32)
+		if (byteOffset + type->storageBytes() > 32)
 		{
 			// would overflow, go to next slot
 			++slotOffset;
@@ -52,12 +52,12 @@ void StorageOffsets::computeOffsets(TypePointers const& _types)
 		if (slotOffset >= bigint(1) << 256)
 			BOOST_THROW_EXCEPTION(TypeError() << errinfo_comment("Object too large for storage."));
 		offsets[i] = make_pair(u256(slotOffset), byteOffset);
-		solAssert(type->getStorageSize() >= 1, "Invalid storage size.");
-		if (type->getStorageSize() == 1 && byteOffset + type->getStorageBytes() <= 32)
-			byteOffset += type->getStorageBytes();
+		solAssert(type->storageSize() >= 1, "Invalid storage size.");
+		if (type->storageSize() == 1 && byteOffset + type->storageBytes() <= 32)
+			byteOffset += type->storageBytes();
 		else
 		{
-			slotOffset += type->getStorageSize();
+			slotOffset += type->storageSize();
 			byteOffset = 0;
 		}
 	}
@@ -69,7 +69,7 @@ void StorageOffsets::computeOffsets(TypePointers const& _types)
 	swap(m_offsets, offsets);
 }
 
-pair<u256, unsigned> const* StorageOffsets::getOffset(size_t _index) const
+pair<u256, unsigned> const* StorageOffsets::offset(size_t _index) const
 {
 	if (m_offsets.count(_index))
 		return &m_offsets.at(_index);
@@ -86,7 +86,7 @@ MemberList& MemberList::operator=(MemberList&& _other)
 	return *this;
 }
 
-std::pair<u256, unsigned> const* MemberList::getMemberStorageOffset(string const& _name) const
+std::pair<u256, unsigned> const* MemberList::memberStorageOffset(string const& _name) const
 {
 	if (!m_storageOffsets)
 	{
@@ -99,15 +99,15 @@ std::pair<u256, unsigned> const* MemberList::getMemberStorageOffset(string const
 	}
 	for (size_t index = 0; index < m_memberTypes.size(); ++index)
 		if (m_memberTypes[index].name == _name)
-			return m_storageOffsets->getOffset(index);
+			return m_storageOffsets->offset(index);
 	return nullptr;
 }
 
-u256 const& MemberList::getStorageSize() const
+u256 const& MemberList::storageSize() const
 {
 	// trigger lazy computation
-	getMemberStorageOffset("");
-	return m_storageOffsets->getStorageSize();
+	memberStorageOffset("");
+	return m_storageOffsets->storageSize();
 }
 
 TypePointer Type::fromElementaryTypeName(Token::Value _typeToken)
@@ -159,7 +159,7 @@ TypePointer Type::fromElementaryTypeName(string const& _name)
 
 TypePointer Type::fromUserDefinedTypeName(UserDefinedTypeName const& _typeName)
 {
-	Declaration const* declaration = _typeName.getReferencedDeclaration();
+	Declaration const* declaration = _typeName.referencedDeclaration();
 	if (StructDefinition const* structDef = dynamic_cast<StructDefinition const*>(declaration))
 		return make_shared<StructType>(*structDef);
 	else if (EnumDefinition const* enumDef = dynamic_cast<EnumDefinition const*>(declaration))
@@ -191,13 +191,13 @@ TypePointer Type::fromArrayTypeName(TypeName& _baseTypeName, Expression* _length
 	TypePointer baseType = _baseTypeName.toType();
 	if (!baseType)
 		BOOST_THROW_EXCEPTION(_baseTypeName.createTypeError("Invalid type name."));
-	if (baseType->getStorageBytes() == 0)
+	if (baseType->storageBytes() == 0)
 		BOOST_THROW_EXCEPTION(_baseTypeName.createTypeError("Illegal base type of storage size zero for array."));
 	if (_length)
 	{
-		if (!_length->getType())
+		if (!_length->type())
 			_length->checkTypeRequirements(nullptr);
-		auto const* length = dynamic_cast<IntegerConstantType const*>(_length->getType().get());
+		auto const* length = dynamic_cast<IntegerConstantType const*>(_length->type().get());
 		if (!length)
 			BOOST_THROW_EXCEPTION(_length->createTypeError("Invalid array length."));
 		return make_shared<ArrayType>(DataLocation::Storage, baseType, length->literalValue(nullptr));
@@ -208,7 +208,7 @@ TypePointer Type::fromArrayTypeName(TypeName& _baseTypeName, Expression* _length
 
 TypePointer Type::forLiteral(Literal const& _literal)
 {
-	switch (_literal.getToken())
+	switch (_literal.token())
 	{
 	case Token::TrueLiteral:
 	case Token::FalseLiteral:
@@ -247,7 +247,7 @@ IntegerType::IntegerType(int _bits, IntegerType::Modifier _modifier):
 
 bool IntegerType::isImplicitlyConvertibleTo(Type const& _convertTo) const
 {
-	if (_convertTo.getCategory() != getCategory())
+	if (_convertTo.category() != category())
 		return false;
 	IntegerType const& convertTo = dynamic_cast<IntegerType const&>(_convertTo);
 	if (convertTo.m_bits < m_bits)
@@ -262,10 +262,10 @@ bool IntegerType::isImplicitlyConvertibleTo(Type const& _convertTo) const
 
 bool IntegerType::isExplicitlyConvertibleTo(Type const& _convertTo) const
 {
-	return _convertTo.getCategory() == getCategory() ||
-		_convertTo.getCategory() == Category::Contract ||
-		_convertTo.getCategory() == Category::Enum ||
-		_convertTo.getCategory() == Category::FixedBytes;
+	return _convertTo.category() == category() ||
+		_convertTo.category() == Category::Contract ||
+		_convertTo.category() == Category::Enum ||
+		_convertTo.category() == Category::FixedBytes;
 }
 
 TypePointer IntegerType::unaryOperatorResult(Token::Value _operator) const
@@ -287,7 +287,7 @@ TypePointer IntegerType::unaryOperatorResult(Token::Value _operator) const
 
 bool IntegerType::operator==(Type const& _other) const
 {
-	if (_other.getCategory() != getCategory())
+	if (_other.category() != category())
 		return false;
 	IntegerType const& other = dynamic_cast<IntegerType const&>(_other);
 	return other.m_bits == m_bits && other.m_modifier == m_modifier;
@@ -303,7 +303,7 @@ string IntegerType::toString(bool) const
 
 TypePointer IntegerType::binaryOperatorResult(Token::Value _operator, TypePointer const& _other) const
 {
-	if (_other->getCategory() != Category::IntegerConstant && _other->getCategory() != getCategory())
+	if (_other->category() != Category::IntegerConstant && _other->category() != category())
 		return TypePointer();
 	auto commonType = dynamic_pointer_cast<IntegerType const>(Type::commonType(shared_from_this(), _other));
 
@@ -333,7 +333,7 @@ bool IntegerConstantType::isValidLiteral(const Literal& _literal)
 {
 	try
 	{
-		bigint x(_literal.getValue());
+		bigint x(_literal.value());
 	}
 	catch (...)
 	{
@@ -344,9 +344,9 @@ bool IntegerConstantType::isValidLiteral(const Literal& _literal)
 
 IntegerConstantType::IntegerConstantType(Literal const& _literal)
 {
-	m_value = bigint(_literal.getValue());
+	m_value = bigint(_literal.value());
 
-	switch (_literal.getSubDenomination())
+	switch (_literal.subDenomination())
 	{
 	case Literal::SubDenomination::Wei:
 	case Literal::SubDenomination::Second:
@@ -388,17 +388,17 @@ bool IntegerConstantType::isImplicitlyConvertibleTo(Type const& _convertTo) cons
 		int forSignBit = (targetType->isSigned() ? 1 : 0);
 		if (m_value > 0)
 		{
-			if (m_value <= (u256(-1) >> (256 - targetType->getNumBits() + forSignBit)))
+			if (m_value <= (u256(-1) >> (256 - targetType->numBits() + forSignBit)))
 				return true;
 		}
-		else if (targetType->isSigned() && -m_value <= (u256(1) << (targetType->getNumBits() - forSignBit)))
+		else if (targetType->isSigned() && -m_value <= (u256(1) << (targetType->numBits() - forSignBit)))
 			return true;
 		return false;
 	}
-	else if (_convertTo.getCategory() == Category::FixedBytes)
+	else if (_convertTo.category() == Category::FixedBytes)
 	{
 		FixedBytesType const& fixedBytes = dynamic_cast<FixedBytesType const&>(_convertTo);
-		return fixedBytes.numBytes() * 8 >= getIntegerType()->getNumBits();
+		return fixedBytes.numBytes() * 8 >= integerType()->numBits();
 	}
 	else
 		return false;
@@ -406,8 +406,8 @@ bool IntegerConstantType::isImplicitlyConvertibleTo(Type const& _convertTo) cons
 
 bool IntegerConstantType::isExplicitlyConvertibleTo(Type const& _convertTo) const
 {
-	TypePointer integerType = getIntegerType();
-	return integerType && integerType->isExplicitlyConvertibleTo(_convertTo);
+	TypePointer intType = integerType();
+	return intType && intType->isExplicitlyConvertibleTo(_convertTo);
 }
 
 TypePointer IntegerConstantType::unaryOperatorResult(Token::Value _operator) const
@@ -434,21 +434,21 @@ TypePointer IntegerConstantType::unaryOperatorResult(Token::Value _operator) con
 
 TypePointer IntegerConstantType::binaryOperatorResult(Token::Value _operator, TypePointer const& _other) const
 {
-	if (_other->getCategory() == Category::Integer)
+	if (_other->category() == Category::Integer)
 	{
-		shared_ptr<IntegerType const> integerType = getIntegerType();
-		if (!integerType)
+		shared_ptr<IntegerType const> intType = integerType();
+		if (!intType)
 			return TypePointer();
-		return integerType->binaryOperatorResult(_operator, _other);
+		return intType->binaryOperatorResult(_operator, _other);
 	}
-	else if (_other->getCategory() != getCategory())
+	else if (_other->category() != category())
 		return TypePointer();
 
 	IntegerConstantType const& other = dynamic_cast<IntegerConstantType const&>(*_other);
 	if (Token::isCompareOp(_operator))
 	{
-		shared_ptr<IntegerType const> thisIntegerType = getIntegerType();
-		shared_ptr<IntegerType const> otherIntegerType = other.getIntegerType();
+		shared_ptr<IntegerType const> thisIntegerType = integerType();
+		shared_ptr<IntegerType const> otherIntegerType = other.integerType();
 		if (!thisIntegerType || !otherIntegerType)
 			return TypePointer();
 		return thisIntegerType->binaryOperatorResult(_operator, otherIntegerType);
@@ -503,7 +503,7 @@ TypePointer IntegerConstantType::binaryOperatorResult(Token::Value _operator, Ty
 
 bool IntegerConstantType::operator==(Type const& _other) const
 {
-	if (_other.getCategory() != getCategory())
+	if (_other.category() != category())
 		return false;
 	return m_value == dynamic_cast<IntegerConstantType const&>(_other).m_value;
 }
@@ -530,12 +530,12 @@ u256 IntegerConstantType::literalValue(Literal const*) const
 
 TypePointer IntegerConstantType::mobileType() const
 {
-	auto intType = getIntegerType();
+	auto intType = integerType();
 	solAssert(!!intType, "mobileType called with invalid integer constant " + toString(false));
 	return intType;
 }
 
-shared_ptr<IntegerType const> IntegerConstantType::getIntegerType() const
+shared_ptr<IntegerType const> IntegerConstantType::integerType() const
 {
 	bigint value = m_value;
 	bool negative = (value < 0);
@@ -551,7 +551,7 @@ shared_ptr<IntegerType const> IntegerConstantType::getIntegerType() const
 }
 
 StringLiteralType::StringLiteralType(Literal const& _literal):
-	m_value(_literal.getValue())
+	m_value(_literal.value())
 {
 }
 
@@ -567,7 +567,7 @@ bool StringLiteralType::isImplicitlyConvertibleTo(Type const& _convertTo) const
 
 bool StringLiteralType::operator==(const Type& _other) const
 {
-	if (_other.getCategory() != getCategory())
+	if (_other.category() != category())
 		return false;
 	return m_value == dynamic_cast<StringLiteralType const&>(_other).m_value;
 }
@@ -592,7 +592,7 @@ FixedBytesType::FixedBytesType(int _bytes): m_bytes(_bytes)
 
 bool FixedBytesType::isImplicitlyConvertibleTo(Type const& _convertTo) const
 {
-	if (_convertTo.getCategory() != getCategory())
+	if (_convertTo.category() != category())
 		return false;
 	FixedBytesType const& convertTo = dynamic_cast<FixedBytesType const&>(_convertTo);
 	return convertTo.m_bytes >= m_bytes;
@@ -600,9 +600,9 @@ bool FixedBytesType::isImplicitlyConvertibleTo(Type const& _convertTo) const
 
 bool FixedBytesType::isExplicitlyConvertibleTo(Type const& _convertTo) const
 {
-	return _convertTo.getCategory() == Category::Integer ||
-		_convertTo.getCategory() == Category::Contract ||
-		_convertTo.getCategory() == getCategory();
+	return _convertTo.category() == Category::Integer ||
+		_convertTo.category() == Category::Contract ||
+		_convertTo.category() == category();
 }
 
 TypePointer FixedBytesType::unaryOperatorResult(Token::Value _operator) const
@@ -631,7 +631,7 @@ TypePointer FixedBytesType::binaryOperatorResult(Token::Value _operator, TypePoi
 
 bool FixedBytesType::operator==(Type const& _other) const
 {
-	if (_other.getCategory() != getCategory())
+	if (_other.category() != category())
 		return false;
 	FixedBytesType const& other = dynamic_cast<FixedBytesType const&>(_other);
 	return other.m_bytes == m_bytes;
@@ -641,7 +641,7 @@ bool BoolType::isExplicitlyConvertibleTo(Type const& _convertTo) const
 {
 	// conversion to integer is fine, but not to address
 	// this is an example of explicit conversions being not transitive (though implicit should be)
-	if (_convertTo.getCategory() == getCategory())
+	if (_convertTo.category() == category())
 	{
 		IntegerType const& convertTo = dynamic_cast<IntegerType const&>(_convertTo);
 		if (!convertTo.isAddress())
@@ -653,9 +653,9 @@ bool BoolType::isExplicitlyConvertibleTo(Type const& _convertTo) const
 u256 BoolType::literalValue(Literal const* _literal) const
 {
 	solAssert(_literal, "");
-	if (_literal->getToken() == Token::TrueLiteral)
+	if (_literal->token() == Token::TrueLiteral)
 		return u256(1);
-	else if (_literal->getToken() == Token::FalseLiteral)
+	else if (_literal->token() == Token::FalseLiteral)
 		return u256(0);
 	else
 		BOOST_THROW_EXCEPTION(InternalCompilerError() << errinfo_comment("Bool type constructed from non-boolean literal."));
@@ -670,7 +670,7 @@ TypePointer BoolType::unaryOperatorResult(Token::Value _operator) const
 
 TypePointer BoolType::binaryOperatorResult(Token::Value _operator, TypePointer const& _other) const
 {
-	if (getCategory() != _other->getCategory())
+	if (category() != _other->category())
 		return TypePointer();
 	if (Token::isCompareOp(_operator) || _operator == Token::And || _operator == Token::Or)
 		return _other;
@@ -682,23 +682,25 @@ bool ContractType::isImplicitlyConvertibleTo(Type const& _convertTo) const
 {
 	if (*this == _convertTo)
 		return true;
-	if (_convertTo.getCategory() == Category::Integer)
+	if (_convertTo.category() == Category::Integer)
 		return dynamic_cast<IntegerType const&>(_convertTo).isAddress();
-	if (_convertTo.getCategory() == Category::Contract)
+	if (_convertTo.category() == Category::Contract)
 	{
-		auto const& bases = getContractDefinition().getLinearizedBaseContracts();
+		auto const& bases = contractDefinition().linearizedBaseContracts();
 		if (m_super && bases.size() <= 1)
 			return false;
 		return find(m_super ? ++bases.begin() : bases.begin(), bases.end(),
-					&dynamic_cast<ContractType const&>(_convertTo).getContractDefinition()) != bases.end();
+					&dynamic_cast<ContractType const&>(_convertTo).contractDefinition()) != bases.end();
 	}
 	return false;
 }
 
 bool ContractType::isExplicitlyConvertibleTo(Type const& _convertTo) const
 {
-	return isImplicitlyConvertibleTo(_convertTo) || _convertTo.getCategory() == Category::Integer ||
-			_convertTo.getCategory() == Category::Contract;
+	return
+		isImplicitlyConvertibleTo(_convertTo) ||
+		_convertTo.category() == Category::Integer ||
+		_convertTo.category() == Category::Contract;
 }
 
 TypePointer ContractType::unaryOperatorResult(Token::Value _operator) const
@@ -755,7 +757,7 @@ string ReferenceType::stringForReferencePart() const
 
 bool ArrayType::isImplicitlyConvertibleTo(const Type& _convertTo) const
 {
-	if (_convertTo.getCategory() != getCategory())
+	if (_convertTo.category() != category())
 		return false;
 	auto& convertTo = dynamic_cast<ArrayType const&>(_convertTo);
 	if (convertTo.isByteArray() != isByteArray() || convertTo.isString() != isString())
@@ -768,11 +770,11 @@ bool ArrayType::isImplicitlyConvertibleTo(const Type& _convertTo) const
 	if (convertTo.location() == DataLocation::Storage && !convertTo.isPointer())
 	{
 		// Less restrictive conversion, since we need to copy anyway.
-		if (!getBaseType()->isImplicitlyConvertibleTo(*convertTo.getBaseType()))
+		if (!baseType()->isImplicitlyConvertibleTo(*convertTo.baseType()))
 			return false;
 		if (convertTo.isDynamicallySized())
 			return true;
-		return !isDynamicallySized() && convertTo.getLength() >= getLength();
+		return !isDynamicallySized() && convertTo.length() >= length();
 	}
 	else
 	{
@@ -780,14 +782,14 @@ bool ArrayType::isImplicitlyConvertibleTo(const Type& _convertTo) const
 		// require that the base type is the same, not only convertible.
 		// This disallows assignment of nested dynamic arrays from storage to memory for now.
 		if (
-			*copyForLocationIfReference(location(), getBaseType()) !=
-			*copyForLocationIfReference(location(), convertTo.getBaseType())
+			*copyForLocationIfReference(location(), baseType()) !=
+			*copyForLocationIfReference(location(), convertTo.baseType())
 		)
 			return false;
 		if (isDynamicallySized() != convertTo.isDynamicallySized())
 			return false;
 		// We also require that the size is the same.
-		if (!isDynamicallySized() && getLength() != convertTo.getLength())
+		if (!isDynamicallySized() && length() != convertTo.length())
 			return false;
 		return true;
 	}
@@ -798,7 +800,7 @@ bool ArrayType::isExplicitlyConvertibleTo(const Type& _convertTo) const
 	if (isImplicitlyConvertibleTo(_convertTo))
 		return true;
 	// allow conversion bytes <-> string
-	if (_convertTo.getCategory() != getCategory())
+	if (_convertTo.category() != category())
 		return false;
 	auto& convertTo = dynamic_cast<ArrayType const&>(_convertTo);
 	if (convertTo.location() != location())
@@ -810,7 +812,7 @@ bool ArrayType::isExplicitlyConvertibleTo(const Type& _convertTo) const
 
 bool ArrayType::operator==(Type const& _other) const
 {
-	if (_other.getCategory() != getCategory())
+	if (_other.category() != category())
 		return false;
 	ArrayType const& other = dynamic_cast<ArrayType const&>(_other);
 	if (
@@ -820,41 +822,41 @@ bool ArrayType::operator==(Type const& _other) const
 		other.isDynamicallySized() != isDynamicallySized()
 	)
 		return false;
-	return isDynamicallySized() || getLength()  == other.getLength();
+	return isDynamicallySized() || length()  == other.length();
 }
 
-unsigned ArrayType::getCalldataEncodedSize(bool _padded) const
+unsigned ArrayType::calldataEncodedSize(bool _padded) const
 {
 	if (isDynamicallySized())
 		return 0;
-	bigint size = bigint(getLength()) * (isByteArray() ? 1 : getBaseType()->getCalldataEncodedSize(_padded));
+	bigint size = bigint(length()) * (isByteArray() ? 1 : baseType()->calldataEncodedSize(_padded));
 	size = ((size + 31) / 32) * 32;
 	solAssert(size <= numeric_limits<unsigned>::max(), "Array size does not fit unsigned.");
 	return unsigned(size);
 }
 
-u256 ArrayType::getStorageSize() const
+u256 ArrayType::storageSize() const
 {
 	if (isDynamicallySized())
 		return 1;
 
 	bigint size;
-	unsigned baseBytes = getBaseType()->getStorageBytes();
+	unsigned baseBytes = baseType()->storageBytes();
 	if (baseBytes == 0)
 		size = 1;
 	else if (baseBytes < 32)
 	{
 		unsigned itemsPerSlot = 32 / baseBytes;
-		size = (bigint(getLength()) + (itemsPerSlot - 1)) / itemsPerSlot;
+		size = (bigint(length()) + (itemsPerSlot - 1)) / itemsPerSlot;
 	}
 	else
-		size = bigint(getLength()) * getBaseType()->getStorageSize();
+		size = bigint(length()) * baseType()->storageSize();
 	if (size >= bigint(1) << 256)
 		BOOST_THROW_EXCEPTION(TypeError() << errinfo_comment("Array too large for storage."));
 	return max<u256>(1, u256(size));
 }
 
-unsigned ArrayType::getSizeOnStack() const
+unsigned ArrayType::sizeOnStack() const
 {
 	if (m_location == DataLocation::CallData)
 		// offset [length] (stack top)
@@ -874,9 +876,9 @@ string ArrayType::toString(bool _short) const
 		ret = "bytes";
 	else
 	{
-		ret = getBaseType()->toString(_short) + "[";
+		ret = baseType()->toString(_short) + "[";
 		if (!isDynamicallySized())
-			ret += getLength().str();
+			ret += length().str();
 		ret += "]";
 	}
 	if (!_short)
@@ -891,7 +893,7 @@ TypePointer ArrayType::externalType() const
 	TypePointer baseExt = m_baseType->externalType();
 	if (!baseExt)
 		return TypePointer();
-	if (m_baseType->getCategory() == Category::Array && m_baseType->isDynamicallySized())
+	if (m_baseType->category() == Category::Array && m_baseType->isDynamicallySized())
 		return TypePointer();
 
 	if (isDynamicallySized())
@@ -915,7 +917,7 @@ const MemberList ArrayType::s_arrayTypeMemberList({{"length", make_shared<Intege
 
 bool ContractType::operator==(Type const& _other) const
 {
-	if (_other.getCategory() != getCategory())
+	if (_other.category() != category())
 		return false;
 	ContractType const& other = dynamic_cast<ContractType const&>(_other);
 	return other.m_contract == m_contract && other.m_super == m_super;
@@ -923,10 +925,13 @@ bool ContractType::operator==(Type const& _other) const
 
 string ContractType::toString(bool) const
 {
-	return "contract " + string(m_super ? "super " : "") + m_contract.getName();
+	return
+		string(m_contract.isLibrary() ? "library " : "contract ") +
+		string(m_super ? "super " : "") +
+		m_contract.name();
 }
 
-MemberList const& ContractType::getMembers() const
+MemberList const& ContractType::members() const
 {
 	// We need to lazy-initialize it because of recursive references.
 	if (!m_members)
@@ -939,8 +944,8 @@ MemberList const& ContractType::getMembers() const
 		if (m_super)
 		{
 			// add the most derived of all functions which are visible in derived contracts
-			for (ContractDefinition const* base: m_contract.getLinearizedBaseContracts())
-				for (ASTPointer<FunctionDefinition> const& function: base->getDefinedFunctions())
+			for (ContractDefinition const* base: m_contract.linearizedBaseContracts())
+				for (ASTPointer<FunctionDefinition> const& function: base->definedFunctions())
 				{
 					if (!function->isVisibleInDerivedContracts())
 						continue;
@@ -948,7 +953,7 @@ MemberList const& ContractType::getMembers() const
 					bool functionWithEqualArgumentsFound = false;
 					for (auto const& member: members)
 					{
-						if (member.name != function->getName())
+						if (member.name != function->name())
 							continue;
 						auto memberType = dynamic_cast<FunctionType const*>(member.type.get());
 						solAssert(!!memberType, "Override changes type.");
@@ -959,29 +964,29 @@ MemberList const& ContractType::getMembers() const
 					}
 					if (!functionWithEqualArgumentsFound)
 						members.push_back(MemberList::Member(
-							function->getName(),
+							function->name(),
 							functionType,
 							function.get()
 						));
 				}
 		}
 		else
-			for (auto const& it: m_contract.getInterfaceFunctions())
+			for (auto const& it: m_contract.interfaceFunctions())
 				members.push_back(MemberList::Member(
-					it.second->getDeclaration().getName(),
-					it.second->asMemberFunction(),
-					&it.second->getDeclaration()
+					it.second->declaration().name(),
+					it.second->asMemberFunction(m_contract.isLibrary()),
+					&it.second->declaration()
 				));
 		m_members.reset(new MemberList(members));
 	}
 	return *m_members;
 }
 
-shared_ptr<FunctionType const> const& ContractType::getConstructorType() const
+shared_ptr<FunctionType const> const& ContractType::constructorType() const
 {
 	if (!m_constructorType)
 	{
-		FunctionDefinition const* constructor = m_contract.getConstructor();
+		FunctionDefinition const* constructor = m_contract.constructor();
 		if (constructor)
 			m_constructorType = make_shared<FunctionType>(*constructor);
 		else
@@ -990,29 +995,29 @@ shared_ptr<FunctionType const> const& ContractType::getConstructorType() const
 	return m_constructorType;
 }
 
-vector<tuple<VariableDeclaration const*, u256, unsigned>> ContractType::getStateVariables() const
+vector<tuple<VariableDeclaration const*, u256, unsigned>> ContractType::stateVariables() const
 {
 	vector<VariableDeclaration const*> variables;
-	for (ContractDefinition const* contract: boost::adaptors::reverse(m_contract.getLinearizedBaseContracts()))
-		for (ASTPointer<VariableDeclaration> const& variable: contract->getStateVariables())
+	for (ContractDefinition const* contract: boost::adaptors::reverse(m_contract.linearizedBaseContracts()))
+		for (ASTPointer<VariableDeclaration> const& variable: contract->stateVariables())
 			if (!variable->isConstant())
 				variables.push_back(variable.get());
 	TypePointers types;
 	for (auto variable: variables)
-		types.push_back(variable->getType());
+		types.push_back(variable->type());
 	StorageOffsets offsets;
 	offsets.computeOffsets(types);
 
 	vector<tuple<VariableDeclaration const*, u256, unsigned>> variablesAndOffsets;
 	for (size_t index = 0; index < variables.size(); ++index)
-		if (auto const* offset = offsets.getOffset(index))
+		if (auto const* offset = offsets.offset(index))
 			variablesAndOffsets.push_back(make_tuple(variables[index], offset->first, offset->second));
 	return variablesAndOffsets;
 }
 
 bool StructType::isImplicitlyConvertibleTo(const Type& _convertTo) const
 {
-	if (_convertTo.getCategory() != getCategory())
+	if (_convertTo.category() != category())
 		return false;
 	auto& convertTo = dynamic_cast<StructType const&>(_convertTo);
 	// memory/calldata to storage can be converted, but only to a direct storage reference
@@ -1025,21 +1030,21 @@ bool StructType::isImplicitlyConvertibleTo(const Type& _convertTo) const
 
 bool StructType::operator==(Type const& _other) const
 {
-	if (_other.getCategory() != getCategory())
+	if (_other.category() != category())
 		return false;
 	StructType const& other = dynamic_cast<StructType const&>(_other);
 	return ReferenceType::operator==(other) && other.m_struct == m_struct;
 }
 
-unsigned StructType::getCalldataEncodedSize(bool _padded) const
+unsigned StructType::calldataEncodedSize(bool _padded) const
 {
 	unsigned size = 0;
-	for (auto const& member: getMembers())
+	for (auto const& member: members())
 		if (!member.type->canLiveOutsideStorage())
 			return 0;
 		else
 		{
-			unsigned memberSize = member.type->getCalldataEncodedSize(_padded);
+			unsigned memberSize = member.type->calldataEncodedSize(_padded);
 			if (memberSize == 0)
 				return 0;
 			size += memberSize;
@@ -1050,39 +1055,39 @@ unsigned StructType::getCalldataEncodedSize(bool _padded) const
 u256 StructType::memorySize() const
 {
 	u256 size;
-	for (auto const& member: getMembers())
+	for (auto const& member: members())
 		if (member.type->canLiveOutsideStorage())
 			size += member.type->memoryHeadSize();
 	return size;
 }
 
-u256 StructType::getStorageSize() const
+u256 StructType::storageSize() const
 {
-	return max<u256>(1, getMembers().getStorageSize());
+	return max<u256>(1, members().storageSize());
 }
 
 string StructType::toString(bool _short) const
 {
-	string ret = "struct " + m_struct.getName();
+	string ret = "struct " + m_struct.name();
 	if (!_short)
 		ret += " " + stringForReferencePart();
 	return ret;
 }
 
-MemberList const& StructType::getMembers() const
+MemberList const& StructType::members() const
 {
 	// We need to lazy-initialize it because of recursive references.
 	if (!m_members)
 	{
 		MemberList::MemberMap members;
-		for (ASTPointer<VariableDeclaration> const& variable: m_struct.getMembers())
+		for (ASTPointer<VariableDeclaration> const& variable: m_struct.members())
 		{
-			TypePointer type = variable->getType();
+			TypePointer type = variable->type();
 			// Skip all mapping members if we are not in storage.
 			if (location() != DataLocation::Storage && !type->canLiveOutsideStorage())
 				continue;
 			members.push_back(MemberList::Member(
-				variable->getName(),
+				variable->name(),
 				copyForLocationIfReference(type),
 				variable.get())
 			);
@@ -1103,7 +1108,7 @@ FunctionTypePointer StructType::constructorType() const
 {
 	TypePointers paramTypes;
 	strings paramNames;
-	for (auto const& member: getMembers())
+	for (auto const& member: members())
 	{
 		if (!member.type->canLiveOutsideStorage())
 			continue;
@@ -1119,9 +1124,9 @@ FunctionTypePointer StructType::constructorType() const
 	);
 }
 
-pair<u256, unsigned> const& StructType::getStorageOffsetsOfMember(string const& _name) const
+pair<u256, unsigned> const& StructType::storageOffsetsOfMember(string const& _name) const
 {
-	auto const* offsets = getMembers().getMemberStorageOffset(_name);
+	auto const* offsets = members().memberStorageOffset(_name);
 	solAssert(offsets, "Storage offset of non-existing member requested.");
 	return *offsets;
 }
@@ -1129,7 +1134,7 @@ pair<u256, unsigned> const& StructType::getStorageOffsetsOfMember(string const&
 u256 StructType::memoryOffsetOfMember(string const& _name) const
 {
 	u256 offset;
-	for (auto const& member: getMembers())
+	for (auto const& member: members())
 		if (member.name == _name)
 			return offset;
 		else
@@ -1141,9 +1146,9 @@ u256 StructType::memoryOffsetOfMember(string const& _name) const
 set<string> StructType::membersMissingInMemory() const
 {
 	set<string> missing;
-	for (ASTPointer<VariableDeclaration> const& variable: m_struct.getMembers())
-		if (!variable->getType()->canLiveOutsideStorage())
-			missing.insert(variable->getName());
+	for (ASTPointer<VariableDeclaration> const& variable: m_struct.members())
+		if (!variable->type()->canLiveOutsideStorage())
+			missing.insert(variable->name());
 	return missing;
 }
 
@@ -1154,15 +1159,15 @@ TypePointer EnumType::unaryOperatorResult(Token::Value _operator) const
 
 bool EnumType::operator==(Type const& _other) const
 {
-	if (_other.getCategory() != getCategory())
+	if (_other.category() != category())
 		return false;
 	EnumType const& other = dynamic_cast<EnumType const&>(_other);
 	return other.m_enum == m_enum;
 }
 
-unsigned EnumType::getStorageBytes() const
+unsigned EnumType::storageBytes() const
 {
-	size_t elements = m_enum.getMembers().size();
+	size_t elements = m_enum.members().size();
 	if (elements <= 1)
 		return 1;
 	else
@@ -1171,20 +1176,20 @@ unsigned EnumType::getStorageBytes() const
 
 string EnumType::toString(bool) const
 {
-	return string("enum ") + m_enum.getName();
+	return string("enum ") + m_enum.name();
 }
 
 bool EnumType::isExplicitlyConvertibleTo(Type const& _convertTo) const
 {
-	return _convertTo.getCategory() == getCategory() || _convertTo.getCategory() == Category::Integer;
+	return _convertTo.category() == category() || _convertTo.category() == Category::Integer;
 }
 
-unsigned int EnumType::getMemberValue(ASTString const& _member) const
+unsigned int EnumType::memberValue(ASTString const& _member) const
 {
 	unsigned int index = 0;
-	for (ASTPointer<EnumValue> const& decl: m_enum.getMembers())
+	for (ASTPointer<EnumValue> const& decl: m_enum.members())
 	{
-		if (decl->getName() == _member)
+		if (decl->name() == _member)
 			return index;
 		++index;
 	}
@@ -1201,19 +1206,19 @@ FunctionType::FunctionType(FunctionDefinition const& _function, bool _isInternal
 	TypePointers retParams;
 	vector<string> retParamNames;
 
-	params.reserve(_function.getParameters().size());
-	paramNames.reserve(_function.getParameters().size());
-	for (ASTPointer<VariableDeclaration> const& var: _function.getParameters())
+	params.reserve(_function.parameters().size());
+	paramNames.reserve(_function.parameters().size());
+	for (ASTPointer<VariableDeclaration> const& var: _function.parameters())
 	{
-		paramNames.push_back(var->getName());
-		params.push_back(var->getType());
+		paramNames.push_back(var->name());
+		params.push_back(var->type());
 	}
-	retParams.reserve(_function.getReturnParameters().size());
-	retParamNames.reserve(_function.getReturnParameters().size());
-	for (ASTPointer<VariableDeclaration> const& var: _function.getReturnParameters())
+	retParams.reserve(_function.returnParameters().size());
+	retParamNames.reserve(_function.returnParameters().size());
+	for (ASTPointer<VariableDeclaration> const& var: _function.returnParameters())
 	{
-		retParamNames.push_back(var->getName());
-		retParams.push_back(var->getType());
+		retParamNames.push_back(var->name());
+		retParams.push_back(var->type());
 	}
 	swap(params, m_parameterTypes);
 	swap(paramNames, m_parameterNames);
@@ -1226,22 +1231,22 @@ FunctionType::FunctionType(VariableDeclaration const& _varDecl):
 {
 	TypePointers paramTypes;
 	vector<string> paramNames;
-	auto returnType = _varDecl.getType();
+	auto returnType = _varDecl.type();
 
 	while (true)
 	{
 		if (auto mappingType = dynamic_cast<MappingType const*>(returnType.get()))
 		{
-			paramTypes.push_back(mappingType->getKeyType());
+			paramTypes.push_back(mappingType->keyType());
 			paramNames.push_back("");
-			returnType = mappingType->getValueType();
+			returnType = mappingType->valueType();
 		}
 		else if (auto arrayType = dynamic_cast<ArrayType const*>(returnType.get()))
 		{
 			if (arrayType->isByteArray())
 				// Return byte arrays as as whole.
 				break;
-			returnType = arrayType->getBaseType();
+			returnType = arrayType->baseType();
 			paramNames.push_back("");
 			paramTypes.push_back(make_shared<IntegerType>(256));
 		}
@@ -1253,8 +1258,8 @@ FunctionType::FunctionType(VariableDeclaration const& _varDecl):
 	vector<string> retParamNames;
 	if (auto structType = dynamic_cast<StructType const*>(returnType.get()))
 	{
-		for (auto const& member: structType->getMembers())
-			if (member.type->getCategory() != Category::Mapping)
+		for (auto const& member: structType->members())
+			if (member.type->category() != Category::Mapping)
 			{
 				if (auto arrayType = dynamic_cast<ArrayType const*>(member.type.get()))
 					if (!arrayType->isByteArray())
@@ -1283,12 +1288,12 @@ FunctionType::FunctionType(const EventDefinition& _event):
 {
 	TypePointers params;
 	vector<string> paramNames;
-	params.reserve(_event.getParameters().size());
-	paramNames.reserve(_event.getParameters().size());
-	for (ASTPointer<VariableDeclaration> const& var: _event.getParameters())
+	params.reserve(_event.parameters().size());
+	paramNames.reserve(_event.parameters().size());
+	for (ASTPointer<VariableDeclaration> const& var: _event.parameters())
 	{
-		paramNames.push_back(var->getName());
-		params.push_back(var->getType());
+		paramNames.push_back(var->name());
+		params.push_back(var->type());
 	}
 	swap(params, m_parameterTypes);
 	swap(paramNames, m_parameterNames);
@@ -1296,7 +1301,7 @@ FunctionType::FunctionType(const EventDefinition& _event):
 
 bool FunctionType::operator==(Type const& _other) const
 {
-	if (_other.getCategory() != getCategory())
+	if (_other.category() != category())
 		return false;
 	FunctionType const& other = dynamic_cast<FunctionType const&>(_other);
 
@@ -1333,14 +1338,14 @@ string FunctionType::toString(bool _short) const
 	return name + ")";
 }
 
-u256 FunctionType::getStorageSize() const
+u256 FunctionType::storageSize() const
 {
 	BOOST_THROW_EXCEPTION(
 		InternalCompilerError()
 			<< errinfo_comment("Storage size of non-storable function type requested."));
 }
 
-unsigned FunctionType::getSizeOnStack() const
+unsigned FunctionType::sizeOnStack() const
 {
 	Location location = m_location;
 	if (m_location == Location::SetGas || m_location == Location::SetValue)
@@ -1385,7 +1390,7 @@ FunctionTypePointer FunctionType::externalFunctionType() const
 	return make_shared<FunctionType>(paramTypes, retParamTypes, m_parameterNames, m_returnParameterNames, m_location, m_arbitraryParameters);
 }
 
-MemberList const& FunctionType::getMembers() const
+MemberList const& FunctionType::members() const
 {
 	switch (m_location)
 	{
@@ -1441,16 +1446,16 @@ MemberList const& FunctionType::getMembers() const
 
 bool FunctionType::canTakeArguments(TypePointers const& _argumentTypes) const
 {
-	TypePointers const& parameterTypes = getParameterTypes();
+	TypePointers const& paramTypes = parameterTypes();
 	if (takesArbitraryParameters())
 		return true;
-	else if (_argumentTypes.size() != parameterTypes.size())
+	else if (_argumentTypes.size() != paramTypes.size())
 		return false;
 	else
 		return std::equal(
 			_argumentTypes.cbegin(),
 			_argumentTypes.cend(),
-			parameterTypes.cbegin(),
+			paramTypes.cbegin(),
 			[](TypePointer const& argumentType, TypePointer const& parameterType)
 			{
 				return argumentType->isImplicitlyConvertibleTo(*parameterType);
@@ -1491,13 +1496,13 @@ string FunctionType::externalSignature(std::string const& _name) const
 	if (_name == "")
 	{
 		solAssert(m_declaration != nullptr, "Function type without name needs a declaration");
-		funcName = m_declaration->getName();
+		funcName = m_declaration->name();
 	}
 	string ret = funcName + "(";
 
 	FunctionTypePointer external = externalFunctionType();
 	solAssert(!!external, "External function type requested.");
-	TypePointers externalParameterTypes = external->getParameterTypes();
+	TypePointers externalParameterTypes = external->parameterTypes();
 	for (auto it = externalParameterTypes.cbegin(); it != externalParameterTypes.cend(); ++it)
 	{
 		solAssert(!!(*it), "Parameter should have external type");
@@ -1536,7 +1541,7 @@ TypePointer FunctionType::copyAndSetGasOrValue(bool _setGas, bool _setValue) con
 	);
 }
 
-FunctionTypePointer FunctionType::asMemberFunction() const
+FunctionTypePointer FunctionType::asMemberFunction(bool _inLibrary) const
 {
 	TypePointers parameterTypes;
 	for (auto const& t: m_parameterTypes)
@@ -1551,7 +1556,7 @@ FunctionTypePointer FunctionType::asMemberFunction() const
 	//@todo make this more intelligent once we support destructuring assignments
 	TypePointers returnParameterTypes;
 	vector<string> returnParameterNames;
-	if (!m_returnParameterTypes.empty() && m_returnParameterTypes.front()->getCalldataEncodedSize() > 0)
+	if (!m_returnParameterTypes.empty() && m_returnParameterTypes.front()->calldataEncodedSize() > 0)
 	{
 		returnParameterTypes.push_back(m_returnParameterTypes.front());
 		returnParameterNames.push_back(m_returnParameterNames.front());
@@ -1561,7 +1566,7 @@ FunctionTypePointer FunctionType::asMemberFunction() const
 		returnParameterTypes,
 		m_parameterNames,
 		returnParameterNames,
-		m_location,
+		_inLibrary ? Location::CallCode : m_location,
 		m_arbitraryParameters,
 		m_declaration,
 		m_gasSet,
@@ -1569,7 +1574,7 @@ FunctionTypePointer FunctionType::asMemberFunction() const
 	);
 }
 
-vector<string> const FunctionType::getParameterTypeNames() const
+vector<string> const FunctionType::parameterTypeNames() const
 {
 	vector<string> names;
 	for (TypePointer const& t: m_parameterTypes)
@@ -1578,7 +1583,7 @@ vector<string> const FunctionType::getParameterTypeNames() const
 	return names;
 }
 
-vector<string> const FunctionType::getReturnParameterTypeNames() const
+vector<string> const FunctionType::returnParameterTypeNames() const
 {
 	vector<string> names;
 	for (TypePointer const& t: m_returnParameterTypes)
@@ -1587,18 +1592,18 @@ vector<string> const FunctionType::getReturnParameterTypeNames() const
 	return names;
 }
 
-ASTPointer<ASTString> FunctionType::getDocumentation() const
+ASTPointer<ASTString> FunctionType::documentation() const
 {
 	auto function = dynamic_cast<Documented const*>(m_declaration);
 	if (function)
-		return function->getDocumentation();
+		return function->documentation();
 
 	return ASTPointer<ASTString>();
 }
 
 bool MappingType::operator==(Type const& _other) const
 {
-	if (_other.getCategory() != getCategory())
+	if (_other.category() != category())
 		return false;
 	MappingType const& other = dynamic_cast<MappingType const&>(_other);
 	return *other.m_keyType == *m_keyType && *other.m_valueType == *m_valueType;
@@ -1606,10 +1611,10 @@ bool MappingType::operator==(Type const& _other) const
 
 string MappingType::toString(bool _short) const
 {
-	return "mapping(" + getKeyType()->toString(_short) + " => " + getValueType()->toString(_short) + ")";
+	return "mapping(" + keyType()->toString(_short) + " => " + valueType()->toString(_short) + ")";
 }
 
-u256 VoidType::getStorageSize() const
+u256 VoidType::storageSize() const
 {
 	BOOST_THROW_EXCEPTION(
 		InternalCompilerError()
@@ -1618,41 +1623,59 @@ u256 VoidType::getStorageSize() const
 
 bool TypeType::operator==(Type const& _other) const
 {
-	if (_other.getCategory() != getCategory())
+	if (_other.category() != category())
 		return false;
 	TypeType const& other = dynamic_cast<TypeType const&>(_other);
-	return *getActualType() == *other.getActualType();
+	return *actualType() == *other.actualType();
 }
 
-u256 TypeType::getStorageSize() const
+u256 TypeType::storageSize() const
 {
 	BOOST_THROW_EXCEPTION(
 		InternalCompilerError()
 			<< errinfo_comment("Storage size of non-storable type type requested."));
 }
 
-MemberList const& TypeType::getMembers() const
+unsigned TypeType::sizeOnStack() const
+{
+	if (auto contractType = dynamic_cast<ContractType const*>(m_actualType.get()))
+		if (contractType->contractDefinition().isLibrary())
+			return 1;
+	return 0;
+}
+
+MemberList const& TypeType::members() const
 {
 	// We need to lazy-initialize it because of recursive references.
 	if (!m_members)
 	{
 		MemberList::MemberMap members;
-		if (m_actualType->getCategory() == Category::Contract && m_currentContract != nullptr)
+		if (m_actualType->category() == Category::Contract)
 		{
-			ContractDefinition const& contract = dynamic_cast<ContractType const&>(*m_actualType).getContractDefinition();
-			vector<ContractDefinition const*> currentBases = m_currentContract->getLinearizedBaseContracts();
-			if (find(currentBases.begin(), currentBases.end(), &contract) != currentBases.end())
-				// We are accessing the type of a base contract, so add all public and protected
-				// members. Note that this does not add inherited functions on purpose.
-				for (Declaration const* decl: contract.getInheritableMembers())
-					members.push_back(MemberList::Member(decl->getName(), decl->getType(), decl));
+			ContractDefinition const& contract = dynamic_cast<ContractType const&>(*m_actualType).contractDefinition();
+			if (contract.isLibrary())
+				for (auto const& it: contract.interfaceFunctions())
+					members.push_back(MemberList::Member(
+						it.second->declaration().name(),
+						it.second->asMemberFunction(true), // use callcode
+						&it.second->declaration()
+					));
+			else if (m_currentContract != nullptr)
+			{
+				vector<ContractDefinition const*> currentBases = m_currentContract->linearizedBaseContracts();
+				if (find(currentBases.begin(), currentBases.end(), &contract) != currentBases.end())
+					// We are accessing the type of a base contract, so add all public and protected
+					// members. Note that this does not add inherited functions on purpose.
+					for (Declaration const* decl: contract.inheritableMembers())
+						members.push_back(MemberList::Member(decl->name(), decl->type(), decl));
+			}
 		}
-		else if (m_actualType->getCategory() == Category::Enum)
+		else if (m_actualType->category() == Category::Enum)
 		{
-			EnumDefinition const& enumDef = dynamic_cast<EnumType const&>(*m_actualType).getEnumDefinition();
+			EnumDefinition const& enumDef = dynamic_cast<EnumType const&>(*m_actualType).enumDefinition();
 			auto enumType = make_shared<EnumType>(enumDef);
-			for (ASTPointer<EnumValue> const& enumValue: enumDef.getMembers())
-				members.push_back(MemberList::Member(enumValue->getName(), enumType));
+			for (ASTPointer<EnumValue> const& enumValue: enumDef.members())
+				members.push_back(MemberList::Member(enumValue->name(), enumType));
 		}
 		m_members.reset(new MemberList(members));
 	}
@@ -1662,13 +1685,13 @@ MemberList const& TypeType::getMembers() const
 ModifierType::ModifierType(const ModifierDefinition& _modifier)
 {
 	TypePointers params;
-	params.reserve(_modifier.getParameters().size());
-	for (ASTPointer<VariableDeclaration> const& var: _modifier.getParameters())
-		params.push_back(var->getType());
+	params.reserve(_modifier.parameters().size());
+	for (ASTPointer<VariableDeclaration> const& var: _modifier.parameters())
+		params.push_back(var->type());
 	swap(params, m_parameterTypes);
 }
 
-u256 ModifierType::getStorageSize() const
+u256 ModifierType::storageSize() const
 {
 	BOOST_THROW_EXCEPTION(
 		InternalCompilerError()
@@ -1677,7 +1700,7 @@ u256 ModifierType::getStorageSize() const
 
 bool ModifierType::operator==(Type const& _other) const
 {
-	if (_other.getCategory() != getCategory())
+	if (_other.category() != category())
 		return false;
 	ModifierType const& other = dynamic_cast<ModifierType const&>(_other);
 
@@ -1736,7 +1759,7 @@ MagicType::MagicType(MagicType::Kind _kind):
 
 bool MagicType::operator==(Type const& _other) const
 {
-	if (_other.getCategory() != getCategory())
+	if (_other.category() != category())
 		return false;
 	MagicType const& other = dynamic_cast<MagicType const&>(_other);
 	return other.m_kind == m_kind;
diff --git a/libsolidity/Types.h b/libsolidity/Types.h
index c4992cfd..11218b7a 100644
--- a/libsolidity/Types.h
+++ b/libsolidity/Types.h
@@ -56,9 +56,9 @@ public:
 	/// of the elements of @a _types.
 	void computeOffsets(TypePointers const& _types);
 	/// @returns the offset of the given member, might be null if the member is not part of storage.
-	std::pair<u256, unsigned> const* getOffset(size_t _index) const;
+	std::pair<u256, unsigned> const* offset(size_t _index) const;
 	/// @returns the total number of slots occupied by all members.
-	u256 const& getStorageSize() const { return m_storageSize; }
+	u256 const& storageSize() const { return m_storageSize; }
 
 private:
 	u256 m_storageSize;
@@ -90,7 +90,7 @@ public:
 	MemberList() {}
 	explicit MemberList(MemberMap const& _members): m_memberTypes(_members) {}
 	MemberList& operator=(MemberList&& _other);
-	TypePointer getMemberType(std::string const& _name) const
+	TypePointer memberType(std::string const& _name) const
 	{
 		TypePointer type;
 		for (auto const& it: m_memberTypes)
@@ -111,9 +111,9 @@ public:
 	}
 	/// @returns the offset of the given member in storage slots and bytes inside a slot or
 	/// a nullptr if the member is not part of storage.
-	std::pair<u256, unsigned> const* getMemberStorageOffset(std::string const& _name) const;
+	std::pair<u256, unsigned> const* memberStorageOffset(std::string const& _name) const;
 	/// @returns the number of storage slots occupied by the members.
-	u256 const& getStorageSize() const;
+	u256 const& storageSize() const;
 
 	MemberMap::const_iterator begin() const { return m_memberTypes.begin(); }
 	MemberMap::const_iterator end() const { return m_memberTypes.end(); }
@@ -154,7 +154,7 @@ public:
 
 	/// Calculates the
 
-	virtual Category getCategory() const = 0;
+	virtual Category category() const = 0;
 	virtual bool isImplicitlyConvertibleTo(Type const& _other) const { return *this == _other; }
 	virtual bool isExplicitlyConvertibleTo(Type const& _convertTo) const
 	{
@@ -172,29 +172,29 @@ public:
 		return Token::isCompareOp(_operator) ? commonType(shared_from_this(), _other) : TypePointer();
 	}
 
-	virtual bool operator==(Type const& _other) const { return getCategory() == _other.getCategory(); }
+	virtual bool operator==(Type const& _other) const { return category() == _other.category(); }
 	virtual bool operator!=(Type const& _other) const { return !this->operator ==(_other); }
 
 	/// @returns number of bytes used by this type when encoded for CALL, or 0 if the encoding
 	/// is not a simple big-endian encoding or the type cannot be stored in calldata.
 	/// If @a _padded then it is assumed that each element is padded to a multiple of 32 bytes.
-	virtual unsigned getCalldataEncodedSize(bool _padded) const { (void)_padded; return 0; }
+	virtual unsigned calldataEncodedSize(bool _padded) const { (void)_padded; return 0; }
 	/// @returns the size of this data type in bytes when stored in memory. For memory-reference
 	/// types, this is the size of the memory pointer.
-	virtual unsigned memoryHeadSize() const { return getCalldataEncodedSize(); }
-	/// Convenience version of @see getCalldataEncodedSize(bool)
-	unsigned getCalldataEncodedSize() const { return getCalldataEncodedSize(true); }
+	virtual unsigned memoryHeadSize() const { return calldataEncodedSize(); }
+	/// Convenience version of @see calldataEncodedSize(bool)
+	unsigned calldataEncodedSize() const { return calldataEncodedSize(true); }
 	/// @returns true if the type is dynamically encoded in calldata
 	virtual bool isDynamicallySized() const { return false; }
 	/// @returns the number of storage slots required to hold this value in storage.
 	/// For dynamically "allocated" types, it returns the size of the statically allocated head,
-	virtual u256 getStorageSize() const { return 1; }
+	virtual u256 storageSize() const { return 1; }
 	/// Multiple small types can be packed into a single storage slot. If such a packing is possible
 	/// this function @returns the size in bytes smaller than 32. Data is moved to the next slot if
 	/// it does not fit.
 	/// In order to avoid computation at runtime of whether such moving is necessary, structs and
 	/// array data (not each element) always start a new slot.
-	virtual unsigned getStorageBytes() const { return 32; }
+	virtual unsigned storageBytes() const { return 32; }
 	/// Returns true if the type can be stored in storage.
 	virtual bool canBeStored() const { return true; }
 	/// Returns false if the type cannot live outside the storage, i.e. if it includes some mapping.
@@ -202,7 +202,7 @@ public:
 	/// Returns true if the type can be stored as a value (as opposed to a reference) on the stack,
 	/// i.e. it behaves differently in lvalue context and in value context.
 	virtual bool isValueType() const { return false; }
-	virtual unsigned getSizeOnStack() const { return 1; }
+	virtual unsigned sizeOnStack() const { return 1; }
 	/// @returns the mobile (in contrast to static) type corresponding to the given type.
 	/// This returns the corresponding integer type for IntegerConstantTypes and the pointer type
 	/// for storage reference types.
@@ -212,9 +212,9 @@ public:
 	virtual bool dataStoredIn(DataLocation) const { return false; }
 
 	/// Returns the list of all members of this type. Default implementation: no members.
-	virtual MemberList const& getMembers() const { return EmptyMemberList; }
+	virtual MemberList const& members() const { return EmptyMemberList; }
 	/// Convenience method, returns the type of the given named member or an empty pointer if no such member exists.
-	TypePointer getMemberType(std::string const& _name) const { return getMembers().getMemberType(_name); }
+	TypePointer memberType(std::string const& _name) const { return members().memberType(_name); }
 
 	virtual std::string toString(bool _short) const = 0;
 	std::string toString() const { return toString(false); }
@@ -245,7 +245,7 @@ public:
 	{
 		Unsigned, Signed, Address
 	};
-	virtual Category getCategory() const override { return Category::Integer; }
+	virtual Category category() const override { return Category::Integer; }
 
 	explicit IntegerType(int _bits, Modifier _modifier = Modifier::Unsigned);
 
@@ -256,17 +256,17 @@ public:
 
 	virtual bool operator==(Type const& _other) const override;
 
-	virtual unsigned getCalldataEncodedSize(bool _padded = true) const override { return _padded ? 32 : m_bits / 8; }
-	virtual unsigned getStorageBytes() const override { return m_bits / 8; }
+	virtual unsigned calldataEncodedSize(bool _padded = true) const override { return _padded ? 32 : m_bits / 8; }
+	virtual unsigned storageBytes() const override { return m_bits / 8; }
 	virtual bool isValueType() const override { return true; }
 
-	virtual MemberList const& getMembers() const override { return isAddress() ? AddressMemberList : EmptyMemberList; }
+	virtual MemberList const& members() const override { return isAddress() ? AddressMemberList : EmptyMemberList; }
 
 	virtual std::string toString(bool _short) const override;
 
 	virtual TypePointer externalType() const override { return shared_from_this(); }
 
-	int getNumBits() const { return m_bits; }
+	int numBits() const { return m_bits; }
 	bool isAddress() const { return m_modifier == Modifier::Address; }
 	bool isSigned() const { return m_modifier == Modifier::Signed; }
 
@@ -284,7 +284,7 @@ private:
 class IntegerConstantType: public Type
 {
 public:
-	virtual Category getCategory() const override { return Category::IntegerConstant; }
+	virtual Category category() const override { return Category::IntegerConstant; }
 
 	/// @returns true if the literal is a valid integer.
 	static bool isValidLiteral(Literal const& _literal);
@@ -307,7 +307,7 @@ public:
 	virtual TypePointer mobileType() const override;
 
 	/// @returns the smallest integer type that can hold the value or an empty pointer if not possible.
-	std::shared_ptr<IntegerType const> getIntegerType() const;
+	std::shared_ptr<IntegerType const> integerType() const;
 
 private:
 	bigint m_value;
@@ -319,7 +319,7 @@ private:
 class StringLiteralType: public Type
 {
 public:
-	virtual Category getCategory() const override { return Category::StringLiteral; }
+	virtual Category category() const override { return Category::StringLiteral; }
 
 	explicit StringLiteralType(Literal const& _literal);
 
@@ -333,7 +333,7 @@ public:
 
 	virtual bool canBeStored() const override { return false; }
 	virtual bool canLiveOutsideStorage() const override { return false; }
-	virtual unsigned getSizeOnStack() const override { return 0; }
+	virtual unsigned sizeOnStack() const override { return 0; }
 
 	virtual std::string toString(bool) const override { return "literal_string \"" + m_value + "\""; }
 	virtual TypePointer mobileType() const override;
@@ -350,7 +350,7 @@ private:
 class FixedBytesType: public Type
 {
 public:
-	virtual Category getCategory() const override { return Category::FixedBytes; }
+	virtual Category category() const override { return Category::FixedBytes; }
 
 	/// @returns the smallest bytes type for the given literal or an empty pointer
 	/// if no type fits.
@@ -364,8 +364,8 @@ public:
 	virtual TypePointer unaryOperatorResult(Token::Value _operator) const override;
 	virtual TypePointer binaryOperatorResult(Token::Value _operator, TypePointer const& _other) const override;
 
-	virtual unsigned getCalldataEncodedSize(bool _padded) const override { return _padded && m_bytes > 0 ? 32 : m_bytes; }
-	virtual unsigned getStorageBytes() const override { return m_bytes; }
+	virtual unsigned calldataEncodedSize(bool _padded) const override { return _padded && m_bytes > 0 ? 32 : m_bytes; }
+	virtual unsigned storageBytes() const override { return m_bytes; }
 	virtual bool isValueType() const override { return true; }
 
 	virtual std::string toString(bool) const override { return "bytes" + dev::toString(m_bytes); }
@@ -384,13 +384,13 @@ class BoolType: public Type
 {
 public:
 	BoolType() {}
-	virtual Category getCategory() const override { return Category::Bool; }
+	virtual Category category() const override { return Category::Bool; }
 	virtual bool isExplicitlyConvertibleTo(Type const& _convertTo) const override;
 	virtual TypePointer unaryOperatorResult(Token::Value _operator) const override;
 	virtual TypePointer binaryOperatorResult(Token::Value _operator, TypePointer const& _other) const override;
 
-	virtual unsigned getCalldataEncodedSize(bool _padded) const override{ return _padded ? 32 : 1; }
-	virtual unsigned getStorageBytes() const override { return 1; }
+	virtual unsigned calldataEncodedSize(bool _padded) const override{ return _padded ? 32 : 1; }
+	virtual unsigned storageBytes() const override { return 1; }
 	virtual bool isValueType() const override { return true; }
 
 	virtual std::string toString(bool) const override { return "bool"; }
@@ -457,7 +457,7 @@ protected:
 class ArrayType: public ReferenceType
 {
 public:
-	virtual Category getCategory() const override { return Category::Array; }
+	virtual Category category() const override { return Category::Array; }
 
 	/// Constructor for a byte array ("bytes") and string.
 	explicit ArrayType(DataLocation _location, bool _isString = false):
@@ -483,13 +483,13 @@ public:
 	virtual bool isImplicitlyConvertibleTo(Type const& _convertTo) const override;
 	virtual bool isExplicitlyConvertibleTo(Type const& _convertTo) const override;
 	virtual bool operator==(const Type& _other) const override;
-	virtual unsigned getCalldataEncodedSize(bool _padded) const override;
+	virtual unsigned calldataEncodedSize(bool _padded) const override;
 	virtual bool isDynamicallySized() const override { return m_hasDynamicLength; }
-	virtual u256 getStorageSize() const override;
+	virtual u256 storageSize() const override;
 	virtual bool canLiveOutsideStorage() const override { return m_baseType->canLiveOutsideStorage(); }
-	virtual unsigned getSizeOnStack() const override;
+	virtual unsigned sizeOnStack() const override;
 	virtual std::string toString(bool _short) const override;
-	virtual MemberList const& getMembers() const override
+	virtual MemberList const& members() const override
 	{
 		return isString() ? EmptyMemberList : s_arrayTypeMemberList;
 	}
@@ -499,8 +499,8 @@ public:
 	bool isByteArray() const { return m_arrayKind != ArrayKind::Ordinary; }
 	/// @returns true if this is a string
 	bool isString() const { return m_arrayKind == ArrayKind::String; }
-	TypePointer const& getBaseType() const { solAssert(!!m_baseType, ""); return m_baseType;}
-	u256 const& getLength() const { return m_length; }
+	TypePointer const& baseType() const { solAssert(!!m_baseType, ""); return m_baseType;}
+	u256 const& length() const { return m_length; }
 
 	TypePointer copyForLocation(DataLocation _location, bool _isPointer) const override;
 
@@ -517,12 +517,12 @@ private:
 };
 
 /**
- * The type of a contract instance, there is one distinct type for each contract definition.
+ * The type of a contract instance or library, there is one distinct type for each contract definition.
  */
 class ContractType: public Type
 {
 public:
-	virtual Category getCategory() const override { return Category::Contract; }
+	virtual Category category() const override { return Category::Contract; }
 	explicit ContractType(ContractDefinition const& _contract, bool _super = false):
 		m_contract(_contract), m_super(_super) {}
 	/// Contracts can be implicitly converted to super classes and to addresses.
@@ -531,42 +531,42 @@ public:
 	virtual bool isExplicitlyConvertibleTo(Type const& _convertTo) const override;
 	virtual TypePointer unaryOperatorResult(Token::Value _operator) const override;
 	virtual bool operator==(Type const& _other) const override;
-	virtual unsigned getCalldataEncodedSize(bool _padded ) const override
+	virtual unsigned calldataEncodedSize(bool _padded ) const override
 	{
-		return externalType()->getCalldataEncodedSize(_padded);
+		return externalType()->calldataEncodedSize(_padded);
 	}
-	virtual unsigned getStorageBytes() const override { return 20; }
+	virtual unsigned storageBytes() const override { return 20; }
 	virtual bool canLiveOutsideStorage() const override { return true; }
 	virtual bool isValueType() const override { return true; }
 	virtual std::string toString(bool _short) const override;
 
-	virtual MemberList const& getMembers() const override;
+	virtual MemberList const& members() const override;
 	virtual TypePointer externalType() const override
 	{
 		return std::make_shared<IntegerType>(160, IntegerType::Modifier::Address);
 	}
 
 	bool isSuper() const { return m_super; }
-	ContractDefinition const& getContractDefinition() const { return m_contract; }
+	ContractDefinition const& contractDefinition() const { return m_contract; }
 
 	/// Returns the function type of the constructor. Note that the location part of the function type
 	/// is not used, as this type cannot be the type of a variable or expression.
-	FunctionTypePointer const& getConstructorType() const;
+	FunctionTypePointer const& constructorType() const;
 
 	/// @returns the identifier of the function with the given name or Invalid256 if such a name does
 	/// not exist.
-	u256 getFunctionIdentifier(std::string const& _functionName) const;
+	u256 functionIdentifier(std::string const& _functionName) const;
 
 	/// @returns a list of all state variables (including inherited) of the contract and their
 	/// offsets in storage.
-	std::vector<std::tuple<VariableDeclaration const*, u256, unsigned>> getStateVariables() const;
+	std::vector<std::tuple<VariableDeclaration const*, u256, unsigned>> stateVariables() const;
 
 private:
 	ContractDefinition const& m_contract;
 	/// If true, it is the "super" type of the current contract, i.e. it contains only inherited
 	/// members.
 	bool m_super;
-	/// Type of the constructor, @see getConstructorType. Lazily initialized.
+	/// Type of the constructor, @see constructorType. Lazily initialized.
 	mutable FunctionTypePointer m_constructorType;
 	/// List of member types, will be lazy-initialized because of recursive references.
 	mutable std::unique_ptr<MemberList> m_members;
@@ -578,18 +578,18 @@ private:
 class StructType: public ReferenceType
 {
 public:
-	virtual Category getCategory() const override { return Category::Struct; }
+	virtual Category category() const override { return Category::Struct; }
 	explicit StructType(StructDefinition const& _struct, DataLocation _location = DataLocation::Storage):
 		ReferenceType(_location), m_struct(_struct) {}
 	virtual bool isImplicitlyConvertibleTo(const Type& _convertTo) const override;
 	virtual bool operator==(Type const& _other) const override;
-	virtual unsigned getCalldataEncodedSize(bool _padded) const override;
+	virtual unsigned calldataEncodedSize(bool _padded) const override;
 	u256 memorySize() const;
-	virtual u256 getStorageSize() const override;
+	virtual u256 storageSize() const override;
 	virtual bool canLiveOutsideStorage() const override { return true; }
 	virtual std::string toString(bool _short) const override;
 
-	virtual MemberList const& getMembers() const override;
+	virtual MemberList const& members() const override;
 
 	TypePointer copyForLocation(DataLocation _location, bool _isPointer) const override;
 
@@ -597,7 +597,7 @@ public:
 	/// and a memory struct of this type.
 	FunctionTypePointer constructorType() const;
 
-	std::pair<u256, unsigned> const& getStorageOffsetsOfMember(std::string const& _name) const;
+	std::pair<u256, unsigned> const& storageOffsetsOfMember(std::string const& _name) const;
 	u256 memoryOffsetOfMember(std::string const& _name) const;
 
 	StructDefinition const& structDefinition() const { return m_struct; }
@@ -617,15 +617,15 @@ private:
 class EnumType: public Type
 {
 public:
-	virtual Category getCategory() const override { return Category::Enum; }
+	virtual Category category() const override { return Category::Enum; }
 	explicit EnumType(EnumDefinition const& _enum): m_enum(_enum) {}
 	virtual TypePointer unaryOperatorResult(Token::Value _operator) const override;
 	virtual bool operator==(Type const& _other) const override;
-	virtual unsigned getCalldataEncodedSize(bool _padded) const override
+	virtual unsigned calldataEncodedSize(bool _padded) const override
 	{
-		return externalType()->getCalldataEncodedSize(_padded);
+		return externalType()->calldataEncodedSize(_padded);
 	}
-	virtual unsigned getStorageBytes() const override;
+	virtual unsigned storageBytes() const override;
 	virtual bool canLiveOutsideStorage() const override { return true; }
 	virtual std::string toString(bool _short) const override;
 	virtual bool isValueType() const override { return true; }
@@ -633,12 +633,12 @@ public:
 	virtual bool isExplicitlyConvertibleTo(Type const& _convertTo) const override;
 	virtual TypePointer externalType() const override
 	{
-		return std::make_shared<IntegerType>(8 * int(getStorageBytes()));
+		return std::make_shared<IntegerType>(8 * int(storageBytes()));
 	}
 
-	EnumDefinition const& getEnumDefinition() const { return m_enum; }
+	EnumDefinition const& enumDefinition() const { return m_enum; }
 	/// @returns the value that the string has in the Enum
-	unsigned int getMemberValue(ASTString const& _member) const;
+	unsigned int memberValue(ASTString const& _member) const;
 
 private:
 	EnumDefinition const& m_enum;
@@ -681,7 +681,7 @@ public:
 		BlockHash ///< BLOCKHASH
 	};
 
-	virtual Category getCategory() const override { return Category::Function; }
+	virtual Category category() const override { return Category::Function; }
 
 	/// @returns TypePointer of a new FunctionType object. All input/return parameters are an
 	/// appropriate external types of input/return parameters of current function.
@@ -733,20 +733,20 @@ public:
 		m_declaration(_declaration)
 	{}
 
-	TypePointers const& getParameterTypes() const { return m_parameterTypes; }
-	std::vector<std::string> const& getParameterNames() const { return m_parameterNames; }
-	std::vector<std::string> const getParameterTypeNames() const;
-	TypePointers const& getReturnParameterTypes() const { return m_returnParameterTypes; }
-	std::vector<std::string> const& getReturnParameterNames() const { return m_returnParameterNames; }
-	std::vector<std::string> const getReturnParameterTypeNames() const;
+	TypePointers const& parameterTypes() const { return m_parameterTypes; }
+	std::vector<std::string> const& parameterNames() const { return m_parameterNames; }
+	std::vector<std::string> const parameterTypeNames() const;
+	TypePointers const& returnParameterTypes() const { return m_returnParameterTypes; }
+	std::vector<std::string> const& returnParameterNames() const { return m_returnParameterNames; }
+	std::vector<std::string> const returnParameterTypeNames() const;
 
 	virtual bool operator==(Type const& _other) const override;
 	virtual std::string toString(bool _short) const override;
 	virtual bool canBeStored() const override { return false; }
-	virtual u256 getStorageSize() const override;
+	virtual u256 storageSize() const override;
 	virtual bool canLiveOutsideStorage() const override { return false; }
-	virtual unsigned getSizeOnStack() const override;
-	virtual MemberList const& getMembers() const override;
+	virtual unsigned sizeOnStack() const override;
+	virtual MemberList const& members() const override;
 
 	/// @returns true if this function can take the given argument types (possibly
 	/// after implicit conversion).
@@ -756,14 +756,14 @@ public:
 
 	/// @returns true if the ABI is used for this call (only meaningful for external calls)
 	bool isBareCall() const;
-	Location const& getLocation() const { return m_location; }
+	Location const& location() const { return m_location; }
 	/// @returns the external signature of this function type given the function name
 	/// If @a _name is not provided (empty string) then the @c m_declaration member of the
 	/// function type is used
 	std::string externalSignature(std::string const& _name = "") const;
 	/// @returns the external identifier of this function (the hash of the signature).
 	u256 externalIdentifier() const;
-	Declaration const& getDeclaration() const
+	Declaration const& declaration() const
 	{
 		solAssert(m_declaration, "Requested declaration from a FunctionType that has none");
 		return *m_declaration;
@@ -772,7 +772,7 @@ public:
 	bool isConstant() const { return m_isConstant; }
 	/// @return A shared pointer of an ASTString.
 	/// Can contain a nullptr in which case indicates absence of documentation
-	ASTPointer<ASTString> getDocumentation() const;
+	ASTPointer<ASTString> documentation() const;
 
 	/// true iff arguments are to be padded to multiples of 32 bytes for external calls
 	bool padArguments() const { return !(m_location == Location::SHA3 || m_location == Location::SHA256 || m_location == Location::RIPEMD160); }
@@ -788,7 +788,8 @@ public:
 	/// removed and the location of reference types is changed from CallData to Memory.
 	/// This is needed if external functions are called on other contracts, as they cannot return
 	/// dynamic values.
-	FunctionTypePointer asMemberFunction() const;
+	/// @param _inLibrary if true, uses CallCode as location.
+	FunctionTypePointer asMemberFunction(bool _inLibrary) const;
 
 private:
 	static TypePointers parseElementaryTypeVector(strings const& _types);
@@ -814,7 +815,7 @@ private:
 class MappingType: public Type
 {
 public:
-	virtual Category getCategory() const override { return Category::Mapping; }
+	virtual Category category() const override { return Category::Mapping; }
 	MappingType(TypePointer const& _keyType, TypePointer const& _valueType):
 		m_keyType(_keyType), m_valueType(_valueType) {}
 
@@ -822,8 +823,8 @@ public:
 	virtual std::string toString(bool _short) const override;
 	virtual bool canLiveOutsideStorage() const override { return false; }
 
-	TypePointer const& getKeyType() const { return m_keyType; }
-	TypePointer const& getValueType() const { return m_valueType; }
+	TypePointer const& keyType() const { return m_keyType; }
+	TypePointer const& valueType() const { return m_valueType; }
 
 private:
 	TypePointer m_keyType;
@@ -837,37 +838,38 @@ private:
 class VoidType: public Type
 {
 public:
-	virtual Category getCategory() const override { return Category::Void; }
+	virtual Category category() const override { return Category::Void; }
 	VoidType() {}
 
 	virtual TypePointer binaryOperatorResult(Token::Value, TypePointer const&) const override { return TypePointer(); }
 	virtual std::string toString(bool) const override { return "void"; }
 	virtual bool canBeStored() const override { return false; }
-	virtual u256 getStorageSize() const override;
+	virtual u256 storageSize() const override;
 	virtual bool canLiveOutsideStorage() const override { return false; }
-	virtual unsigned getSizeOnStack() const override { return 0; }
+	virtual unsigned sizeOnStack() const override { return 0; }
 };
 
 /**
  * The type of a type reference. The type of "uint32" when used in "a = uint32(2)" is an example
  * of a TypeType.
+ * For super contracts or libraries, this has members directly.
  */
 class TypeType: public Type
 {
 public:
-	virtual Category getCategory() const override { return Category::TypeType; }
+	virtual Category category() const override { return Category::TypeType; }
 	explicit TypeType(TypePointer const& _actualType, ContractDefinition const* _currentContract = nullptr):
 		m_actualType(_actualType), m_currentContract(_currentContract) {}
-	TypePointer const& getActualType() const { return m_actualType; }
+	TypePointer const& actualType() const { return m_actualType; }
 
 	virtual TypePointer binaryOperatorResult(Token::Value, TypePointer const&) const override { return TypePointer(); }
 	virtual bool operator==(Type const& _other) const override;
 	virtual bool canBeStored() const override { return false; }
-	virtual u256 getStorageSize() const override;
+	virtual u256 storageSize() const override;
 	virtual bool canLiveOutsideStorage() const override { return false; }
-	virtual unsigned getSizeOnStack() const override { return 0; }
+	virtual unsigned sizeOnStack() const override;
 	virtual std::string toString(bool _short) const override { return "type(" + m_actualType->toString(_short) + ")"; }
-	virtual MemberList const& getMembers() const override;
+	virtual MemberList const& members() const override;
 
 private:
 	TypePointer m_actualType;
@@ -884,14 +886,14 @@ private:
 class ModifierType: public Type
 {
 public:
-	virtual Category getCategory() const override { return Category::Modifier; }
+	virtual Category category() const override { return Category::Modifier; }
 	explicit ModifierType(ModifierDefinition const& _modifier);
 
 	virtual TypePointer binaryOperatorResult(Token::Value, TypePointer const&) const override { return TypePointer(); }
 	virtual bool canBeStored() const override { return false; }
-	virtual u256 getStorageSize() const override;
+	virtual u256 storageSize() const override;
 	virtual bool canLiveOutsideStorage() const override { return false; }
-	virtual unsigned getSizeOnStack() const override { return 0; }
+	virtual unsigned sizeOnStack() const override { return 0; }
 	virtual bool operator==(Type const& _other) const override;
 	virtual std::string toString(bool _short) const override;
 
@@ -908,7 +910,7 @@ class MagicType: public Type
 {
 public:
 	enum class Kind { Block, Message, Transaction };
-	virtual Category getCategory() const override { return Category::Magic; }
+	virtual Category category() const override { return Category::Magic; }
 
 	explicit MagicType(Kind _kind);
 
@@ -920,8 +922,8 @@ public:
 	virtual bool operator==(Type const& _other) const override;
 	virtual bool canBeStored() const override { return false; }
 	virtual bool canLiveOutsideStorage() const override { return true; }
-	virtual unsigned getSizeOnStack() const override { return 0; }
-	virtual MemberList const& getMembers() const override { return m_members; }
+	virtual unsigned sizeOnStack() const override { return 0; }
+	virtual MemberList const& members() const override { return m_members; }
 
 	virtual std::string toString(bool _short) const override;
 
diff --git a/libsolidity/Version.cpp b/libsolidity/Version.cpp
index 61b2e95a..c6b5c509 100644
--- a/libsolidity/Version.cpp
+++ b/libsolidity/Version.cpp
@@ -22,18 +22,20 @@
 
 #include <libsolidity/Version.h>
 #include <string>
-#include <BuildInfo.h>
+#include <libevmasm/Version.h>
+#include <solidity/BuildInfo.h>
 #include <libdevcore/Common.h>
 
 using namespace dev;
 using namespace dev::solidity;
 using namespace std;
 
-char const* dev::solidity::VersionNumber = "0.1.2";
+char const* dev::solidity::VersionNumber = ETH_PROJECT_VERSION;
 extern string const dev::solidity::VersionString =
 	string(dev::solidity::VersionNumber) +
 	"-" +
 	string(DEV_QUOTED(ETH_COMMIT_HASH)).substr(0, 8) +
 	(ETH_CLEAN_REPO ? "" : "*") +
-	"/" DEV_QUOTED(ETH_BUILD_TYPE) "-" DEV_QUOTED(ETH_BUILD_PLATFORM);
+	"/" DEV_QUOTED(ETH_BUILD_TYPE) "-" DEV_QUOTED(ETH_BUILD_PLATFORM)
+	" linked to libethereum-" + eth::VersionStringLibEvmAsm;
 
diff --git a/libsolidity/grammar.txt b/libsolidity/grammar.txt
index 6503516c..08a74f45 100644
--- a/libsolidity/grammar.txt
+++ b/libsolidity/grammar.txt
@@ -1,4 +1,4 @@
-ContractDefinition = 'contract' Identifier
+ContractDefinition = ( 'contract' | 'library' ) Identifier
                      ( 'is' InheritanceSpecifier (',' InheritanceSpecifier )* )?
                      '{' ContractPart* '}'
 ContractPart = StateVariableDeclaration | StructDefinition | ModifierDefinition | FunctionDefinition | EnumDefinition
@@ -34,6 +34,7 @@ ForStatement = 'for' '(' (VardefOrExprStmt)? ';' (Expression)? ';' (ExpressionSt
 Continue = 'continue' ';'
 Break = 'break' ';'
 Return = 'return' Expression? ';'
+Throw = 'throw' Expression? ';'
 VariableDefinition = VariableDeclaration ( = Expression )? ';'
 
 Expression = Assignment | UnaryOperation | BinaryOperation | FunctionCall | NewExpression | IndexAccess |
diff --git a/solc/CMakeLists.txt b/solc/CMakeLists.txt
index df72f52d..40ab0e21 100644
--- a/solc/CMakeLists.txt
+++ b/solc/CMakeLists.txt
@@ -1,23 +1,15 @@
-cmake_policy(SET CMP0015 NEW)
-set(CMAKE_AUTOMOC OFF)
-
 aux_source_directory(. SRC_LIST)
 list(REMOVE_ITEM SRC_LIST "./jsonCompiler.cpp")
 
-include_directories(BEFORE ${JSONCPP_INCLUDE_DIRS})
 include_directories(BEFORE ..)
-include_directories(${Boost_INCLUDE_DIRS})
 
 set(EXECUTABLE solc)
 
 file(GLOB HEADERS "*.h")
 add_executable(${EXECUTABLE} ${SRC_LIST} ${HEADERS})
 
-add_dependencies(${EXECUTABLE} BuildInfo.h)
-
-target_link_libraries(${EXECUTABLE} ${Boost_FILESYSTEM_LIBRARIES})
+eth_use(${EXECUTABLE} REQUIRED Solidity)
 target_link_libraries(${EXECUTABLE} ${Boost_PROGRAM_OPTIONS_LIBRARIES})
-target_link_libraries(${EXECUTABLE} solidity)
 
 if (APPLE)
 	install(TARGETS ${EXECUTABLE} DESTINATION bin)
@@ -25,5 +17,11 @@ else()
 	eth_install_executable(${EXECUTABLE})
 endif()
 
-add_library(soljson jsonCompiler.cpp ${HEADERS})
-target_link_libraries(soljson solidity)
+if (EMSCRIPTEN)
+	set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -s EXPORTED_FUNCTIONS='[\"_compileJSON\",\"_version\"]'")
+	add_executable(soljson jsonCompiler.cpp ${HEADERS})
+	eth_use(soljson REQUIRED Solidity)
+else()
+	add_library(soljson jsonCompiler.cpp ${HEADERS})
+	target_link_libraries(soljson solidity)
+endif()
diff --git a/solc/CommandLineInterface.cpp b/solc/CommandLineInterface.cpp
index 8c8ff03e..cfc8a5e0 100644
--- a/solc/CommandLineInterface.cpp
+++ b/solc/CommandLineInterface.cpp
@@ -29,7 +29,7 @@
 #include <boost/filesystem.hpp>
 #include <boost/algorithm/string.hpp>
 
-#include "BuildInfo.h"
+#include "solidity/BuildInfo.h"
 #include <libdevcore/Common.h>
 #include <libdevcore/CommonData.h>
 #include <libdevcore/CommonIO.h>
@@ -63,11 +63,13 @@ static string const g_argAsmJsonStr = "asm-json";
 static string const g_argAstStr = "ast";
 static string const g_argAstJson = "ast-json";
 static string const g_argBinaryStr = "bin";
+static string const g_argRuntimeBinaryStr = "bin-runtime";
 static string const g_argCloneBinaryStr = "clone-bin";
 static string const g_argOpcodesStr = "opcodes";
 static string const g_argNatspecDevStr = "devdoc";
 static string const g_argNatspecUserStr = "userdoc";
 static string const g_argAddStandard = "add-std";
+static string const g_stdinFileName = "<stdin>";
 
 /// Possible arguments to for --combined-json
 static set<string> const g_combinedJsonArgs{
@@ -113,6 +115,7 @@ static bool needsHumanTargetedStdout(po::variables_map const& _args)
 		humanTargetedStdout(_args, g_argAsmJsonStr) ||
 		humanTargetedStdout(_args, g_argOpcodesStr) ||
 		humanTargetedStdout(_args, g_argBinaryStr) ||
+		humanTargetedStdout(_args, g_argRuntimeBinaryStr) ||
 		humanTargetedStdout(_args, g_argCloneBinaryStr);
 }
 
@@ -121,21 +124,31 @@ void CommandLineInterface::handleBinary(string const& _contract)
 	if (m_args.count(g_argBinaryStr))
 	{
 		if (m_args.count("output-dir"))
-			createFile(_contract + ".bin", toHex(m_compiler->getBytecode(_contract)));
+			createFile(_contract + ".bin", m_compiler->object(_contract).toHex());
 		else
 		{
 			cout << "Binary: " << endl;
-			cout << toHex(m_compiler->getBytecode(_contract)) << endl;
+			cout << m_compiler->object(_contract).toHex() << endl;
 		}
 	}
 	if (m_args.count(g_argCloneBinaryStr))
 	{
 		if (m_args.count("output-dir"))
-			createFile(_contract + ".clone_bin", toHex(m_compiler->getCloneBytecode(_contract)));
+			createFile(_contract + ".clone_bin", m_compiler->cloneObject(_contract).toHex());
 		else
 		{
 			cout << "Clone Binary: " << endl;
-			cout << toHex(m_compiler->getCloneBytecode(_contract)) << endl;
+			cout << m_compiler->cloneObject(_contract).toHex() << endl;
+		}
+	}
+	if (m_args.count(g_argRuntimeBinaryStr))
+	{
+		if (m_args.count("output-dir"))
+			createFile(_contract + ".bin", m_compiler->runtimeObject(_contract).toHex());
+		else
+		{
+			cout << "Binary of the runtime part: " << endl;
+			cout << m_compiler->runtimeObject(_contract).toHex() << endl;
 		}
 	}
 }
@@ -143,11 +156,11 @@ void CommandLineInterface::handleBinary(string const& _contract)
 void CommandLineInterface::handleOpcode(string const& _contract)
 {
 	if (m_args.count("output-dir"))
-		createFile(_contract + ".opcode", eth::disassemble(m_compiler->getBytecode(_contract)));
+		createFile(_contract + ".opcode", eth::disassemble(m_compiler->object(_contract).bytecode));
 	else
 	{
 		cout << "Opcodes: " << endl;
-		cout << eth::disassemble(m_compiler->getBytecode(_contract));
+		cout << eth::disassemble(m_compiler->object(_contract).bytecode);
 		cout << endl;
 	}
 
@@ -157,7 +170,7 @@ void CommandLineInterface::handleBytecode(string const& _contract)
 {
 	if (m_args.count(g_argOpcodesStr))
 		handleOpcode(_contract);
-	if (m_args.count(g_argBinaryStr) || m_args.count(g_argCloneBinaryStr))
+	if (m_args.count(g_argBinaryStr) || m_args.count(g_argCloneBinaryStr) || m_args.count(g_argRuntimeBinaryStr))
 		handleBinary(_contract);
 }
 
@@ -167,7 +180,7 @@ void CommandLineInterface::handleSignatureHashes(string const& _contract)
 		return;
 
 	string out;
-	for (auto const& it: m_compiler->getContractDefinition(_contract).getInterfaceFunctions())
+	for (auto const& it: m_compiler->contractDefinition(_contract).interfaceFunctions())
 		out += toHex(it.first.ref()) + ": " + it.second->externalSignature() + "\n";
 
 	if (m_args.count("output-dir"))
@@ -211,11 +224,11 @@ void CommandLineInterface::handleMeta(DocumentationType _type, string const& _co
 	if (m_args.count(argName))
 	{
 		if (m_args.count("output-dir"))
-			createFile(_contract + suffix, m_compiler->getMetadata(_contract, _type));
+			createFile(_contract + suffix, m_compiler->metadata(_contract, _type));
 		else
 		{
 			cout << title << endl;
-			cout << m_compiler->getMetadata(_contract, _type) << endl;
+			cout << m_compiler->metadata(_contract, _type) << endl;
 		}
 
 	}
@@ -224,52 +237,85 @@ void CommandLineInterface::handleMeta(DocumentationType _type, string const& _co
 void CommandLineInterface::handleGasEstimation(string const& _contract)
 {
 	using Gas = GasEstimator::GasConsumption;
-	if (!m_compiler->getAssemblyItems(_contract) && !m_compiler->getRuntimeAssemblyItems(_contract))
+	if (!m_compiler->assemblyItems(_contract) && !m_compiler->runtimeAssemblyItems(_contract))
 		return;
 	cout << "Gas estimation:" << endl;
-	if (eth::AssemblyItems const* items = m_compiler->getAssemblyItems(_contract))
+	if (eth::AssemblyItems const* items = m_compiler->assemblyItems(_contract))
 	{
 		Gas gas = GasEstimator::functionalEstimation(*items);
-		u256 bytecodeSize(m_compiler->getRuntimeBytecode(_contract).size());
+		u256 bytecodeSize(m_compiler->runtimeObject(_contract).bytecode.size());
 		cout << "construction:" << endl;
 		cout << "   " << gas << " + " << (bytecodeSize * eth::c_createDataGas) << " = ";
 		gas += bytecodeSize * eth::c_createDataGas;
 		cout << gas << endl;
 	}
-	if (eth::AssemblyItems const* items = m_compiler->getRuntimeAssemblyItems(_contract))
+	if (eth::AssemblyItems const* items = m_compiler->runtimeAssemblyItems(_contract))
 	{
-		ContractDefinition const& contract = m_compiler->getContractDefinition(_contract);
+		ContractDefinition const& contract = m_compiler->contractDefinition(_contract);
 		cout << "external:" << endl;
-		for (auto it: contract.getInterfaceFunctions())
+		for (auto it: contract.interfaceFunctions())
 		{
 			string sig = it.second->externalSignature();
 			GasEstimator::GasConsumption gas = GasEstimator::functionalEstimation(*items, sig);
 			cout << "   " << sig << ":\t" << gas << endl;
 		}
-		if (contract.getFallbackFunction())
+		if (contract.fallbackFunction())
 		{
 			GasEstimator::GasConsumption gas = GasEstimator::functionalEstimation(*items, "INVALID");
 			cout << "   fallback:\t" << gas << endl;
 		}
 		cout << "internal:" << endl;
-		for (auto const& it: contract.getDefinedFunctions())
+		for (auto const& it: contract.definedFunctions())
 		{
 			if (it->isPartOfExternalInterface() || it->isConstructor())
 				continue;
-			size_t entry = m_compiler->getFunctionEntryPoint(_contract, *it);
+			size_t entry = m_compiler->functionEntryPoint(_contract, *it);
 			GasEstimator::GasConsumption gas = GasEstimator::GasConsumption::infinite();
 			if (entry > 0)
 				gas = GasEstimator::functionalEstimation(*items, entry, *it);
 			FunctionType type(*it);
-			cout << "   " << it->getName() << "(";
-			auto end = type.getParameterTypes().end();
-			for (auto it = type.getParameterTypes().begin(); it != end; ++it)
+			cout << "   " << it->name() << "(";
+			auto end = type.parameterTypes().end();
+			for (auto it = type.parameterTypes().begin(); it != end; ++it)
 				cout << (*it)->toString() << (it + 1 == end ? "" : ",");
 			cout << "):\t" << gas << endl;
 		}
 	}
 }
 
+bool CommandLineInterface::parseLibraryOption(string const& _input)
+{
+	namespace fs = boost::filesystem;
+	string data = fs::is_regular_file(_input) ? contentsString(_input) : _input;
+
+	vector<string> libraries;
+	boost::split(libraries, data, boost::is_space() || boost::is_any_of(","), boost::token_compress_on);
+	for (string const& lib: libraries)
+		if (!lib.empty())
+		{
+			auto colon = lib.find(':');
+			if (colon == string::npos)
+			{
+				cerr << "Colon separator missing in library address specifier \"" << lib << "\"" << endl;
+				return false;
+			}
+			string libName(lib.begin(), lib.begin() + colon);
+			string addrString(lib.begin() + colon + 1, lib.end());
+			boost::trim(libName);
+			boost::trim(addrString);
+			bytes binAddr = fromHex(addrString);
+			h160 address(binAddr, h160::AlignRight);
+			if (binAddr.size() > 20 || address == h160())
+			{
+				cerr << "Invalid address for library \"" << libName << "\": " << addrString << endl;
+				return false;
+			}
+			m_libraries[libName] = address;
+		}
+
+	return true;
+}
+
 void CommandLineInterface::createFile(string const& _fileName, string const& _data)
 {
 	namespace fs = boost::filesystem;
@@ -307,6 +353,13 @@ Allowed options)",
 			"Estimated number of contract runs for optimizer tuning."
 		)
 		(g_argAddStandard.c_str(), "Add standard contracts.")
+		(
+			"libraries",
+			po::value<vector<string>>()->value_name("libs"),
+			"Direct string or file containing library addresses. Syntax: "
+			"<libraryName>: <address> [, or whitespace] ...\n"
+			"Address is interpreted as a hex string optionally prefixed by 0x."
+		)
 		(
 			"output-dir,o",
 			po::value<string>()->value_name("path"),
@@ -317,7 +370,12 @@ Allowed options)",
 			po::value<string>()->value_name(boost::join(g_combinedJsonArgs, ",")),
 			"Output a single json document containing the specified information."
 		)
-		(g_argGas.c_str(), "Print an estimate of the maximal gas usage for each function.");
+		(g_argGas.c_str(), "Print an estimate of the maximal gas usage for each function.")
+		(
+			"link",
+			"Switch to linker mode, ignoring all options apart from --libraries "
+			"and modify binaries in place."
+		);
 	po::options_description outputComponents("Output Components");
 	outputComponents.add_options()
 		(g_argAstStr.c_str(), "AST of all source files.")
@@ -326,6 +384,7 @@ Allowed options)",
 		(g_argAsmJsonStr.c_str(), "EVM assembly of the contracts in JSON format.")
 		(g_argOpcodesStr.c_str(), "Opcodes of the contracts.")
 		(g_argBinaryStr.c_str(), "Binary of the contracts in hex.")
+		(g_argRuntimeBinaryStr.c_str(), "Binary of the runtime part of the contracts in hex.")
 		(g_argCloneBinaryStr.c_str(), "Binary of the clone contracts in hex.")
 		(g_argAbiStr.c_str(), "ABI specification of the contracts.")
 		(g_argSolInterfaceStr.c_str(), "Solidity interface of the contracts.")
@@ -389,7 +448,7 @@ bool CommandLineInterface::processInput()
 		while (!cin.eof())
 		{
 			getline(cin, s);
-			m_sourceCodes["<stdin>"].append(s + '\n');
+			m_sourceCodes[g_stdinFileName].append(s + '\n');
 		}
 	}
 	else
@@ -411,6 +470,18 @@ bool CommandLineInterface::processInput()
 			m_sourceCodes[infile] = dev::contentsString(infile);
 		}
 
+	if (m_args.count("libraries"))
+		for (string const& library: m_args["libraries"].as<vector<string>>())
+			if (!parseLibraryOption(library))
+				return false;
+
+	if (m_args.count("link"))
+	{
+		// switch to linker mode
+		m_onlyLink = true;
+		return link();
+	}
+
 	m_compiler.reset(new CompilerStack(m_args.count(g_argAddStandard) > 0));
 	try
 	{
@@ -420,6 +491,7 @@ bool CommandLineInterface::processInput()
 		bool optimize = m_args.count("optimize") > 0;
 		unsigned runs = m_args["optimize-runs"].as<unsigned>();
 		m_compiler->compile(optimize, runs);
+		m_compiler->link(m_libraries);
 	}
 	catch (ParserError const& _exception)
 	{
@@ -475,7 +547,7 @@ void CommandLineInterface::handleCombinedJSON()
 
 	set<string> requests;
 	boost::split(requests, m_args["combined-json"].as<string>(), boost::is_any_of(","));
-	vector<string> contracts = m_compiler->getContractNames();
+	vector<string> contracts = m_compiler->contractNames();
 
 	if (!contracts.empty())
 		output["contracts"] = Json::Value(Json::objectValue);
@@ -483,24 +555,24 @@ void CommandLineInterface::handleCombinedJSON()
 	{
 		Json::Value contractData(Json::objectValue);
 		if (requests.count("interface"))
-			contractData["interface"] = m_compiler->getSolidityInterface(contractName);
+			contractData["interface"] = m_compiler->solidityInterface(contractName);
 		if (requests.count("abi"))
-			contractData["abi"] = m_compiler->getInterface(contractName);
+			contractData["abi"] = m_compiler->interface(contractName);
 		if (requests.count("bin"))
-			contractData["bin"] = toHex(m_compiler->getBytecode(contractName));
+			contractData["bin"] = m_compiler->runtimeObject(contractName).toHex();
 		if (requests.count("clone-bin"))
-			contractData["clone-bin"] = toHex(m_compiler->getCloneBytecode(contractName));
+			contractData["clone-bin"] = m_compiler->cloneObject(contractName).toHex();
 		if (requests.count("opcodes"))
-			contractData["opcodes"] = eth::disassemble(m_compiler->getBytecode(contractName));
+			contractData["opcodes"] = eth::disassemble(m_compiler->object(contractName).bytecode);
 		if (requests.count("asm"))
 		{
 			ostringstream unused;
 			contractData["asm"] = m_compiler->streamAssembly(unused, contractName, m_sourceCodes, true);
 		}
 		if (requests.count("devdoc"))
-			contractData["devdoc"] = m_compiler->getMetadata(contractName, DocumentationType::NatspecDev);
+			contractData["devdoc"] = m_compiler->metadata(contractName, DocumentationType::NatspecDev);
 		if (requests.count("userdoc"))
-			contractData["userdoc"] = m_compiler->getMetadata(contractName, DocumentationType::NatspecUser);
+			contractData["userdoc"] = m_compiler->metadata(contractName, DocumentationType::NatspecUser);
 		output["contracts"][contractName] = contractData;
 	}
 
@@ -509,7 +581,7 @@ void CommandLineInterface::handleCombinedJSON()
 		output["sources"] = Json::Value(Json::objectValue);
 		for (auto const& sourceCode: m_sourceCodes)
 		{
-			ASTJsonConverter converter(m_compiler->getAST(sourceCode.first));
+			ASTJsonConverter converter(m_compiler->ast(sourceCode.first));
 			output["sources"][sourceCode.first] = Json::Value(Json::objectValue);
 			output["sources"][sourceCode.first]["AST"] = converter.json();
 		}
@@ -533,11 +605,11 @@ void CommandLineInterface::handleAst(string const& _argStr)
 	{
 		vector<ASTNode const*> asts;
 		for (auto const& sourceCode: m_sourceCodes)
-			asts.push_back(&m_compiler->getAST(sourceCode.first));
+			asts.push_back(&m_compiler->ast(sourceCode.first));
 		map<ASTNode const*, eth::GasMeter::GasConsumption> gasCosts;
-		if (m_compiler->getRuntimeAssemblyItems())
+		if (m_compiler->runtimeAssemblyItems())
 			gasCosts = GasEstimator::breakToStatementLevel(
-				GasEstimator::structuralEstimation(*m_compiler->getRuntimeAssemblyItems(), asts),
+				GasEstimator::structuralEstimation(*m_compiler->runtimeAssemblyItems(), asts),
 				asts
 			);
 
@@ -549,12 +621,12 @@ void CommandLineInterface::handleAst(string const& _argStr)
 				string postfix = "";
 				if (_argStr == g_argAstStr)
 				{
-					ASTPrinter printer(m_compiler->getAST(sourceCode.first), sourceCode.second);
+					ASTPrinter printer(m_compiler->ast(sourceCode.first), sourceCode.second);
 					printer.print(data);
 				}
 				else
 				{
-					ASTJsonConverter converter(m_compiler->getAST(sourceCode.first));
+					ASTJsonConverter converter(m_compiler->ast(sourceCode.first));
 					converter.print(data);
 					postfix += "_json";
 				}
@@ -571,7 +643,7 @@ void CommandLineInterface::handleAst(string const& _argStr)
 				if (_argStr == g_argAstStr)
 				{
 					ASTPrinter printer(
-						m_compiler->getAST(sourceCode.first),
+						m_compiler->ast(sourceCode.first),
 						sourceCode.second,
 						gasCosts
 					);
@@ -579,7 +651,7 @@ void CommandLineInterface::handleAst(string const& _argStr)
 				}
 				else
 				{
-					ASTJsonConverter converter(m_compiler->getAST(sourceCode.first));
+					ASTJsonConverter converter(m_compiler->ast(sourceCode.first));
 					converter.print(cout);
 				}
 			}
@@ -588,6 +660,61 @@ void CommandLineInterface::handleAst(string const& _argStr)
 }
 
 void CommandLineInterface::actOnInput()
+{
+	if (m_onlyLink)
+		writeLinkedFiles();
+	else
+		outputCompilationResults();
+}
+
+bool CommandLineInterface::link()
+{
+	for (auto& src: m_sourceCodes)
+	{
+		auto end = src.second.end();
+		for (auto it = src.second.begin(); it != end;)
+		{
+			while (it != end && *it != '_') ++it;
+			auto insertStart = it;
+			while (it != end && *it == '_') ++it;
+			auto nameStart = it;
+			while (it != end && *it != '_') ++it;
+			auto nameEnd = it;
+			while (it != end && *it == '_') ++it;
+			auto insertEnd = it;
+
+			if (insertStart == end)
+				break;
+
+			if (insertEnd - insertStart != 40)
+			{
+				cerr << "Error in binary object file " << src.first << " at position " << (insertStart - src.second.begin()) << endl;
+				return false;
+			}
+
+			string name(nameStart, nameEnd);
+			if (m_libraries.count(name))
+			{
+				string hexStr(toHex(m_libraries.at(name).asBytes()));
+				copy(hexStr.begin(), hexStr.end(), insertStart);
+			}
+			else
+				cerr << "Reference \"" << name << "\" in file \"" << src.first << "\" still unresolved." << endl;
+		}
+	}
+	return true;
+}
+
+void CommandLineInterface::writeLinkedFiles()
+{
+	for (auto const& src: m_sourceCodes)
+		if (src.first == g_stdinFileName)
+			cout << src.second << endl;
+		else
+			writeFile(src.first, src.second);
+}
+
+void CommandLineInterface::outputCompilationResults()
 {
 	handleCombinedJSON();
 
@@ -595,7 +722,7 @@ void CommandLineInterface::actOnInput()
 	handleAst(g_argAstStr);
 	handleAst(g_argAstJson);
 
-	vector<string> contracts = m_compiler->getContractNames();
+	vector<string> contracts = m_compiler->contractNames();
 	for (string const& contract: contracts)
 	{
 		if (needsHumanTargetedStdout(m_args))
diff --git a/solc/CommandLineInterface.h b/solc/CommandLineInterface.h
index f79bc0be..2af5a5e9 100644
--- a/solc/CommandLineInterface.h
+++ b/solc/CommandLineInterface.h
@@ -46,6 +46,11 @@ public:
 	void actOnInput();
 
 private:
+	bool link();
+	void writeLinkedFiles();
+
+	void outputCompilationResults();
+
 	void handleCombinedJSON();
 	void handleAst(std::string const& _argStr);
 	void handleBinary(std::string const& _contract);
@@ -56,16 +61,23 @@ private:
 					std::string const& _contract);
 	void handleGasEstimation(std::string const& _contract);
 
+	/// Tries to read from the file @a _input or interprets _input literally if that fails.
+	/// It then tries to parse the contents and appends to m_libraries.
+	bool parseLibraryOption(std::string const& _input);
 
 	/// Create a file in the given directory
 	/// @arg _fileName the name of the file
 	/// @arg _data to be written
 	void createFile(std::string const& _fileName, std::string const& _data);
 
+	bool m_onlyLink = false;
+
 	/// Compiler arguments variable map
 	boost::program_options::variables_map m_args;
 	/// map of input files to source code strings
 	std::map<std::string, std::string> m_sourceCodes;
+	/// map of library names to addresses
+	std::map<std::string, h160> m_libraries;
 	/// Solidity compiler stack
 	std::unique_ptr<dev::solidity::CompilerStack> m_compiler;
 };
diff --git a/solc/jsonCompiler.cpp b/solc/jsonCompiler.cpp
index bde13762..d265ed9c 100644
--- a/solc/jsonCompiler.cpp
+++ b/solc/jsonCompiler.cpp
@@ -36,6 +36,7 @@
 #include <libsolidity/CompilerStack.h>
 #include <libsolidity/SourceReferenceFormatter.h>
 #include <libsolidity/ASTJsonConverter.h>
+#include <libsolidity/Version.h>
 
 using namespace std;
 using namespace dev;
@@ -54,7 +55,7 @@ string formatError(Exception const& _exception, string const& _name, CompilerSta
 Json::Value functionHashes(ContractDefinition const& _contract)
 {
 	Json::Value functionHashes(Json::objectValue);
-	for (auto const& it: _contract.getInterfaceFunctions())
+	for (auto const& it: _contract.interfaceFunctions())
 		functionHashes[it.second->externalSignature()] = toHex(it.first.ref());
 	return functionHashes;
 }
@@ -71,42 +72,42 @@ Json::Value estimateGas(CompilerStack const& _compiler, string const& _contract)
 {
 	Json::Value gasEstimates(Json::objectValue);
 	using Gas = GasEstimator::GasConsumption;
-	if (!_compiler.getAssemblyItems(_contract) && !_compiler.getRuntimeAssemblyItems(_contract))
+	if (!_compiler.assemblyItems(_contract) && !_compiler.runtimeAssemblyItems(_contract))
 		return gasEstimates;
-	if (eth::AssemblyItems const* items = _compiler.getAssemblyItems(_contract))
+	if (eth::AssemblyItems const* items = _compiler.assemblyItems(_contract))
 	{
 		Gas gas = GasEstimator::functionalEstimation(*items);
-		u256 bytecodeSize(_compiler.getRuntimeBytecode(_contract).size());
+		u256 bytecodeSize(_compiler.runtimeObject(_contract).bytecode.size());
 		Json::Value creationGas(Json::arrayValue);
 		creationGas[0] = gasToJson(gas);
 		creationGas[1] = gasToJson(bytecodeSize * eth::c_createDataGas);
 		gasEstimates["creation"] = creationGas;
 	}
-	if (eth::AssemblyItems const* items = _compiler.getRuntimeAssemblyItems(_contract))
+	if (eth::AssemblyItems const* items = _compiler.runtimeAssemblyItems(_contract))
 	{
-		ContractDefinition const& contract = _compiler.getContractDefinition(_contract);
+		ContractDefinition const& contract = _compiler.contractDefinition(_contract);
 		Json::Value externalFunctions(Json::objectValue);
-		for (auto it: contract.getInterfaceFunctions())
+		for (auto it: contract.interfaceFunctions())
 		{
 			string sig = it.second->externalSignature();
 			externalFunctions[sig] = gasToJson(GasEstimator::functionalEstimation(*items, sig));
 		}
-		if (contract.getFallbackFunction())
+		if (contract.fallbackFunction())
 			externalFunctions[""] = gasToJson(GasEstimator::functionalEstimation(*items, "INVALID"));
 		gasEstimates["external"] = externalFunctions;
 		Json::Value internalFunctions(Json::objectValue);
-		for (auto const& it: contract.getDefinedFunctions())
+		for (auto const& it: contract.definedFunctions())
 		{
 			if (it->isPartOfExternalInterface() || it->isConstructor())
 				continue;
-			size_t entry = _compiler.getFunctionEntryPoint(_contract, *it);
+			size_t entry = _compiler.functionEntryPoint(_contract, *it);
 			GasEstimator::GasConsumption gas = GasEstimator::GasConsumption::infinite();
 			if (entry > 0)
 				gas = GasEstimator::functionalEstimation(*items, entry, *it);
 			FunctionType type(*it);
-			string sig = it->getName() + "(";
-			auto end = type.getParameterTypes().end();
-			for (auto it = type.getParameterTypes().begin(); it != end; ++it)
+			string sig = it->name() + "(";
+			auto end = type.parameterTypes().end();
+			for (auto it = type.parameterTypes().begin(); it != end; ++it)
 				sig += (*it)->toString() + (it + 1 == end ? "" : ",");
 			sig += ")";
 			internalFunctions[sig] = gasToJson(gas);
@@ -163,14 +164,15 @@ string compile(string _input, bool _optimize)
 	}
 
 	output["contracts"] = Json::Value(Json::objectValue);
-	for (string const& contractName: compiler.getContractNames())
+	for (string const& contractName: compiler.contractNames())
 	{
 		Json::Value contractData(Json::objectValue);
-		contractData["solidity_interface"] = compiler.getSolidityInterface(contractName);
-		contractData["interface"] = compiler.getInterface(contractName);
-		contractData["bytecode"] = toHex(compiler.getBytecode(contractName));
-		contractData["opcodes"] = eth::disassemble(compiler.getBytecode(contractName));
-		contractData["functionHashes"] = functionHashes(compiler.getContractDefinition(contractName));
+		contractData["solidity_interface"] = compiler.solidityInterface(contractName);
+		contractData["interface"] = compiler.interface(contractName);
+		contractData["bytecode"] = compiler.object(contractName).toHex();
+		contractData["runtimeBytecode"] = compiler.runtimeObject(contractName).toHex();
+		contractData["opcodes"] = eth::disassemble(compiler.object(contractName).bytecode);
+		contractData["functionHashes"] = functionHashes(compiler.contractDefinition(contractName));
 		contractData["gasEstimates"] = estimateGas(compiler, contractName);
 		ostringstream unused;
 		contractData["assembly"] = compiler.streamAssembly(unused, contractName, sources, true);
@@ -179,7 +181,7 @@ string compile(string _input, bool _optimize)
 
 	output["sources"] = Json::Value(Json::objectValue);
 	output["sources"][""] = Json::Value(Json::objectValue);
-	output["sources"][""]["AST"] = ASTJsonConverter(compiler.getAST("")).json();
+	output["sources"][""]["AST"] = ASTJsonConverter(compiler.ast("")).json();
 
 	return Json::FastWriter().write(output);
 }
@@ -188,6 +190,10 @@ static string outputBuffer;
 
 extern "C"
 {
+extern char const* version()
+{
+	return VersionString.c_str();
+}
 extern char const* compileJSON(char const* _input, bool _optimize)
 {
 	outputBuffer = compile(_input, _optimize);
diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt
index f7475112..9c6e2944 100644
--- a/test/CMakeLists.txt
+++ b/test/CMakeLists.txt
@@ -2,8 +2,10 @@ cmake_policy(SET CMP0015 NEW)
 
 aux_source_directory(. SRC_LIST)
 
+get_filename_component(TESTS_DIR "${CMAKE_CURRENT_SOURCE_DIR}" ABSOLUTE)
+
 macro (add_sources)
-	file (RELATIVE_PATH _relPath "${CMAKE_SOURCE_DIR}/test" "${CMAKE_CURRENT_SOURCE_DIR}")
+	file (RELATIVE_PATH _relPath ${TESTS_DIR} ${CMAKE_CURRENT_SOURCE_DIR})
 	foreach (_src ${ARGN})
 		if (_relPath)
 			list (APPEND SRC "${_relPath}/${_src}")
@@ -17,41 +19,11 @@ macro (add_sources)
 	endif()
 endmacro()
 
-add_subdirectory(fuzzTesting)
-add_subdirectory(libdevcore)
-add_subdirectory(libdevcrypto)
-add_subdirectory(libethcore)
-add_subdirectory(libethereum)
-add_subdirectory(libevm)
-add_subdirectory(libnatspec)
-add_subdirectory(libp2p)
-add_subdirectory(external-dependencies)
-
-if (JSCONSOLE)
-	add_subdirectory(libjsengine)
-endif()
-
-if (SOLIDITY)
-	add_subdirectory(libsolidity)
-	add_subdirectory(contracts)
-endif ()
-if (JSONRPC)
-add_subdirectory(libweb3jsonrpc)
-endif ()
-add_subdirectory(libwhisper)
+add_subdirectory(contracts)
+add_subdirectory(libsolidity)
 
 set(SRC_LIST ${SRC_LIST} ${SRC})
 
-include_directories(BEFORE ${JSONCPP_INCLUDE_DIRS})
-include_directories(BEFORE ..)
-include_directories(${Boost_INCLUDE_DIRS})
-include_directories(${CRYPTOPP_INCLUDE_DIRS})
-include_directories(${JSON_RPC_CPP_INCLUDE_DIRS})
-
-if (JSCONSOLE)
-	include_directories(${V8_INCLUDE_DIRS})
-endif()
-
 # search for test names and create ctest tests
 enable_testing()
 foreach(file ${SRC_LIST})
@@ -63,59 +35,19 @@ foreach(file ${SRC_LIST})
 			string(SUBSTRING ${test} 6 -1 TestSuite)
 		elseif(test MATCHES "^CASE .*")
 			string(SUBSTRING ${test} 5 -1 TestCase)
-			add_test(NAME ${TestSuite}/${TestCase} WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/test COMMAND testeth -t ${TestSuite}/${TestCase})
+			add_test(NAME ${TestSuite}/${TestCase} WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/test COMMAND test -t ${TestSuite}/${TestCase})
 		endif(test MATCHES "^SUITE .*")
 	endforeach(test_raw)
 endforeach(file)
 
 file(GLOB HEADERS "*.h")
-add_executable(testeth ${SRC_LIST} ${HEADERS})
-
-target_link_libraries(testeth ${Boost_UNIT_TEST_FRAMEWORK_LIBRARIES})
-target_link_libraries(testeth ${CURL_LIBRARIES})
-target_link_libraries(testeth ${CRYPTOPP_LIBRARIES})
-target_link_libraries(testeth ethereum)
-target_link_libraries(testeth ethcore)
-if (NOT WIN32)
-	target_link_libraries(testeth secp256k1)
-endif ()
-
-if (JSCONSOLE)
-	target_link_libraries(testeth jsengine)
-endif()
+set(EXECUTABLE soltest)
+add_executable(${EXECUTABLE} ${SRC_LIST} ${HEADERS})
 
-if (SOLIDITY)
-	target_link_libraries(testeth solidity)
-endif ()
+eth_use(${EXECUTABLE} REQUIRED Solidity Eth::ethereum)
 
-target_link_libraries(testeth testutils)
-
-if (GUI AND NOT JUSTTESTS)
-	target_link_libraries(testeth webthree)
-	target_link_libraries(testeth natspec)
-endif()
-
-if (JSONRPC)
-	target_link_libraries(testeth web3jsonrpc)
-	target_link_libraries(testeth ${JSON_RPC_CPP_CLIENT_LIBRARIES})
-endif()
+include_directories(BEFORE ..)
+target_link_libraries(${EXECUTABLE} ${Boost_UNIT_TEST_FRAMEWORK_LIBRARIES})
 
 enable_testing()
 set(CTEST_OUTPUT_ON_FAILURE TRUE)
-
-include(EthUtils)
-
-eth_add_test(ClientBase
-	ARGS --eth_testfile=BlockTests/bcJS_API_Test --eth_threads=1
-	ARGS --eth_testfile=BlockTests/bcJS_API_Test --eth_threads=3
-	ARGS --eth_testfile=BlockTests/bcJS_API_Test --eth_threads=10
-	ARGS --eth_testfile=BlockTests/bcValidBlockTest --eth_threads=1
-	ARGS --eth_testfile=BlockTests/bcValidBlockTest --eth_threads=3
-	ARGS --eth_testfile=BlockTests/bcValidBlockTest --eth_threads=10
-)
-
-eth_add_test(JsonRpc
-	ARGS --eth_testfile=BlockTests/bcJS_API_Test 
-	ARGS --eth_testfile=BlockTests/bcValidBlockTest
-)
-
diff --git a/test/TestHelper.cpp b/test/TestHelper.cpp
index e7633c5e..79242f83 100644
--- a/test/TestHelper.cpp
+++ b/test/TestHelper.cpp
@@ -21,846 +21,13 @@
 
 #include "TestHelper.h"
 
-#include <thread>
-#include <chrono>
-#include <libethcore/EthashAux.h>
-#include <libethereum/Client.h>
-#include <libevm/ExtVMFace.h>
-#include <liblll/Compiler.h>
-#include <libevm/VMFactory.h>
-#include "Stats.h"
-
 using namespace std;
-using namespace dev::eth;
 
 namespace dev
 {
-namespace eth
-{
-
-void mine(Client& c, int numBlocks)
-{
-	auto startBlock = c.blockChain().details().number;
-
-	c.startMining();
-	while(c.blockChain().details().number < startBlock + numBlocks)
-		std::this_thread::sleep_for(std::chrono::milliseconds(100));
-	c.stopMining();
-}
-
-void connectClients(Client& c1, Client& c2)
-{
-	(void)c1;
-	(void)c2;
-	// TODO: Move to WebThree. eth::Client no longer handles networking.
-#if 0
-	short c1Port = 20000;
-	short c2Port = 21000;
-	c1.startNetwork(c1Port);
-	c2.startNetwork(c2Port);
-	c2.connect("127.0.0.1", c1Port);
-#endif
-}
-
-void mine(Block& s, BlockChain const& _bc)
-{
-	std::unique_ptr<SealEngineFace> sealer(Ethash::createSealEngine());
-	s.commitToSeal(_bc);
-	Notified<bytes> sealed;
-	sealer->onSealGenerated([&](bytes const& sealedHeader){ sealed = sealedHeader; });
-	sealer->generateSeal(s.info());
-	sealed.waitNot({});
-	sealer.reset();
-	s.sealBlock(sealed);
-}
-
-void mine(Ethash::BlockHeader& _bi)
-{
-	std::unique_ptr<SealEngineFace> sealer(Ethash::createSealEngine());
-	Notified<bytes> sealed;
-	sealer->onSealGenerated([&](bytes const& sealedHeader){ sealed = sealedHeader; });
-	sealer->generateSeal(_bi);
-	sealed.waitNot({});
-	sealer.reset();
-	_bi = Ethash::BlockHeader(sealed, CheckNothing, h256{}, HeaderData);
-}
-
-}
-
 namespace test
 {
 
-struct ValueTooLarge: virtual Exception {};
-struct MissingFields : virtual Exception {};
-
-bigint const c_max256plus1 = bigint(1) << 256;
-
-ImportTest::ImportTest(json_spirit::mObject& _o, bool isFiller, testType testTemplate):
-	m_statePre(OverlayDB(), eth::BaseState::Empty),
-	m_statePost(OverlayDB(), eth::BaseState::Empty),
-	m_testObject(_o)
-{
-	if (testTemplate == testType::StateTests)
-	{
-		importEnv(_o["env"].get_obj());
-		importTransaction(_o["transaction"].get_obj());
-		importState(_o["pre"].get_obj(), m_statePre);
-		if (!isFiller)
-		{
-			if (_o.count("post"))
-				importState(_o["post"].get_obj(), m_statePost);
-			else
-				importState(_o["postState"].get_obj(), m_statePost);
-			m_logsExpected = importLog(_o["logs"].get_array());
-		}
-	}
-}
-
-//executes an imported transacton on preState
-bytes ImportTest::executeTest()
-{
-	ExecutionResult res;
-	eth::State tmpState = m_statePre;
-	try
-	{
-		std::pair<ExecutionResult, TransactionReceipt>  execOut = m_statePre.execute(m_envInfo, m_transaction);
-		res = execOut.first;
-		m_logs = execOut.second.log();
-	}
-	catch (Exception const& _e)
-	{
-		cnote << "Exception: " << diagnostic_information(_e);
-	}
-	catch (std::exception const& _e)
-	{
-		cnote << "state execution exception: " << _e.what();
-	}
-
-	m_statePre.commit();
-	m_statePost = m_statePre;
-	m_statePre = tmpState;
-
-	return res.output;
-}
-
-json_spirit::mObject& ImportTest::makeAllFieldsHex(json_spirit::mObject& _o)
-{
-	static const set<string> hashes {"bloom" , "coinbase", "hash", "mixHash", "parentHash", "receiptTrie",
-									 "stateRoot", "transactionsTrie", "uncleHash", "currentCoinbase",
-									 "previousHash", "to", "address", "caller", "origin", "secretKey", "data"};
-
-	for (auto& i: _o)
-	{
-		std::string key = i.first;
-		if (hashes.count(key))
-			continue;
-
-		std::string str;
-		json_spirit::mValue value = i.second;
-
-		if (value.type() == json_spirit::int_type)
-			str = toString(value.get_int());
-		else if (value.type() == json_spirit::str_type)
-			str = value.get_str();
-		else continue;
-
-		_o[key] = (str.substr(0, 2) == "0x") ? str : toCompactHex(toInt(str), HexPrefix::Add, 1);
-	}
-	return _o;
-}
-
-void ImportTest::importEnv(json_spirit::mObject& _o)
-{
-	assert(_o.count("currentGasLimit") > 0);
-	assert(_o.count("currentDifficulty") > 0);	
-	assert(_o.count("currentNumber") > 0);
-	assert(_o.count("currentTimestamp") > 0);
-	assert(_o.count("currentCoinbase") > 0);
-	m_envInfo.setGasLimit(toInt(_o["currentGasLimit"]));
-	m_envInfo.setDifficulty(toInt(_o["currentDifficulty"]));
-	m_envInfo.setNumber(toInt(_o["currentNumber"]));
-	m_envInfo.setTimestamp(toInt(_o["currentTimestamp"]));
-	m_envInfo.setBeneficiary(Address(_o["currentCoinbase"].get_str()));
-	m_envInfo.setLastHashes( lastHashes( m_envInfo.number() ) );
-}
-
-// import state from not fully declared json_spirit::mObject, writing to _stateOptionsMap which fields were defined in json
-
-void ImportTest::importState(json_spirit::mObject& _o, State& _state, AccountMaskMap& o_mask)
-{		
-	std::string jsondata = json_spirit::write_string((json_spirit::mValue)_o, false);
-	_state.populateFrom(jsonToAccountMap(jsondata, &o_mask));
-}
-
-void ImportTest::importState(json_spirit::mObject& _o, State& _state)
-{
-	AccountMaskMap mask;
-	importState(_o, _state, mask);
-	for (auto const& i: mask)
-		//check that every parameter was declared in state object
-		if (!i.second.allSet())
-			BOOST_THROW_EXCEPTION(MissingFields() << errinfo_comment("Import State: Missing state fields!"));
-}
-
-void ImportTest::importTransaction (json_spirit::mObject const& _o, eth::Transaction& o_tr)
-{
-	if (_o.count("secretKey") > 0)
-	{
-		assert(_o.count("nonce") > 0);
-		assert(_o.count("gasPrice") > 0);
-		assert(_o.count("gasLimit") > 0);
-		assert(_o.count("to") > 0);
-		assert(_o.count("value") > 0);
-		assert(_o.count("data") > 0);
-
-		if (bigint(_o.at("nonce").get_str()) >= c_max256plus1)
-			BOOST_THROW_EXCEPTION(ValueTooLarge() << errinfo_comment("Transaction 'nonce' is equal or greater than 2**256") );
-		if (bigint(_o.at("gasPrice").get_str()) >= c_max256plus1)
-			BOOST_THROW_EXCEPTION(ValueTooLarge() << errinfo_comment("Transaction 'gasPrice' is equal or greater than 2**256") );
-		if (bigint(_o.at("gasLimit").get_str()) >= c_max256plus1)
-			BOOST_THROW_EXCEPTION(ValueTooLarge() << errinfo_comment("Transaction 'gasLimit' is equal or greater than 2**256") );
-		if (bigint(_o.at("value").get_str()) >= c_max256plus1)
-			BOOST_THROW_EXCEPTION(ValueTooLarge() << errinfo_comment("Transaction 'value' is equal or greater than 2**256") );
-
-		o_tr = _o.at("to").get_str().empty() ?
-			Transaction(toInt(_o.at("value")), toInt(_o.at("gasPrice")), toInt(_o.at("gasLimit")), importData(_o), toInt(_o.at("nonce")), Secret(_o.at("secretKey").get_str())) :
-			Transaction(toInt(_o.at("value")), toInt(_o.at("gasPrice")), toInt(_o.at("gasLimit")), Address(_o.at("to").get_str()), importData(_o), toInt(_o.at("nonce")), Secret(_o.at("secretKey").get_str()));
-	}
-	else
-	{
-		RLPStream transactionRLPStream = createRLPStreamFromTransactionFields(_o);
-		RLP transactionRLP(transactionRLPStream.out());
-		try
-		{
-			o_tr = Transaction(transactionRLP.data(), CheckTransaction::Everything);
-		}
-		catch (InvalidSignature)
-		{
-			// create unsigned transaction
-			o_tr = _o.at("to").get_str().empty() ?
-				Transaction(toInt(_o.at("value")), toInt(_o.at("gasPrice")), toInt(_o.at("gasLimit")), importData(_o), toInt(_o.at("nonce"))) :
-				Transaction(toInt(_o.at("value")), toInt(_o.at("gasPrice")), toInt(_o.at("gasLimit")), Address(_o.at("to").get_str()), importData(_o), toInt(_o.at("nonce")));
-		}
-		catch (Exception& _e)
-		{
-			cnote << "invalid transaction" << boost::diagnostic_information(_e);
-		}
-	}
-}
-
-void ImportTest::importTransaction(json_spirit::mObject const& o_tr)
-{	
-	importTransaction(o_tr, m_transaction);
-}
-
-int ImportTest::compareStates(State const& _stateExpect, State const& _statePost, AccountMaskMap const _expectedStateOptions, WhenError _throw)
-{
-	#define CHECK(a,b)						\
-		{									\
-			if (_throw == WhenError::Throw) \
-			{								\
-				TBOOST_CHECK_MESSAGE(a, b);	\
-				if (!a)						\
-					return 1;				\
-			}								\
-			else							\
-				{TBOOST_WARN_MESSAGE(a,b);}	\
-		}
-
-	for (auto const& a: _stateExpect.addresses())
-	{
-		CHECK(_statePost.addressInUse(a.first), "Check State: " << a.first << " missing expected address!");
-		if (_statePost.addressInUse(a.first))
-		{
-			AccountMask addressOptions(true);
-			if(_expectedStateOptions.size())
-			{
-				try
-				{
-					addressOptions = _expectedStateOptions.at(a.first);
-				}
-				catch(std::out_of_range const&)
-				{
-					TBOOST_ERROR("expectedStateOptions map does not match expectedState in checkExpectedState!");
-					break;
-				}
-			}
-
-			if (addressOptions.hasBalance())
-				CHECK((_stateExpect.balance(a.first) == _statePost.balance(a.first)),
-						"Check State: " << a.first <<  ": incorrect balance " << _statePost.balance(a.first) << ", expected " << _stateExpect.balance(a.first));
-
-			if (addressOptions.hasNonce())
-				CHECK((_stateExpect.transactionsFrom(a.first) == _statePost.transactionsFrom(a.first)),
-						"Check State: " << a.first <<  ": incorrect nonce " << _statePost.transactionsFrom(a.first) << ", expected " << _stateExpect.transactionsFrom(a.first));
-
-			if (addressOptions.hasStorage())
-			{
-				unordered_map<u256, u256> stateStorage = _statePost.storage(a.first);
-				for (auto const& s: _stateExpect.storage(a.first))
-					CHECK((stateStorage[s.first] == s.second),
-							"Check State: " << a.first <<  ": incorrect storage [" << s.first << "] = " << toHex(stateStorage[s.first]) << ", expected [" << s.first << "] = " << toHex(s.second));
-
-				//Check for unexpected storage values
-				stateStorage = _stateExpect.storage(a.first);
-				for (auto const& s: _statePost.storage(a.first))
-					CHECK((stateStorage[s.first] == s.second),
-							"Check State: " << a.first <<  ": incorrect storage [" << s.first << "] = " << toHex(s.second) << ", expected [" << s.first << "] = " << toHex(stateStorage[s.first]));
-			}
-
-			if (addressOptions.hasCode())
-				CHECK((_stateExpect.code(a.first) == _statePost.code(a.first)),
-						"Check State: " << a.first <<  ": incorrect code '" << toHex(_statePost.code(a.first)) << "', expected '" << toHex(_stateExpect.code(a.first)) << "'");
-		}
-	}
-	return 0;
-}
-
-int ImportTest::exportTest(bytes const& _output)
-{
-	int err = 0;
-	// export output
-	m_testObject["out"] = (_output.size() > 4096 && !Options::get().fulloutput) ? "#" + toString(_output.size()) : toHex(_output, 2, HexPrefix::Add);
-
-	// compare expected output with post output
-	if (m_testObject.count("expectOut") > 0)
-	{
-		std::string warning = "Check State: Error! Unexpected output: " + m_testObject["out"].get_str() + " Expected: " + m_testObject["expectOut"].get_str();
-		if (Options::get().checkState)
-		{
-			bool statement = (m_testObject["out"].get_str() == m_testObject["expectOut"].get_str());
-			TBOOST_CHECK_MESSAGE(statement, warning);
-			if (!statement)
-				err = 1;
-		}
-		else
-			TBOOST_WARN_MESSAGE((m_testObject["out"].get_str() == m_testObject["expectOut"].get_str()), warning);
-
-		m_testObject.erase(m_testObject.find("expectOut"));
-	}
-
-	// export logs	
-	m_testObject["logs"] = exportLog(m_logs);
-
-	// compare expected state with post state
-	if (m_testObject.count("expect") > 0)
-	{
-		eth::AccountMaskMap stateMap;
-		State expectState(OverlayDB(), eth::BaseState::Empty);
-		importState(m_testObject["expect"].get_obj(), expectState, stateMap);
-		compareStates(expectState, m_statePost, stateMap, Options::get().checkState ? WhenError::Throw : WhenError::DontThrow);
-		m_testObject.erase(m_testObject.find("expect"));
-	}
-
-	// export post state
-	m_testObject["post"] = fillJsonWithState(m_statePost);
-	m_testObject["postStateRoot"] = toHex(m_statePost.rootHash().asBytes());
-
-	// export pre state
-	m_testObject["pre"] = fillJsonWithState(m_statePre);
-	m_testObject["env"] = makeAllFieldsHex(m_testObject["env"].get_obj());
-	m_testObject["transaction"] = makeAllFieldsHex(m_testObject["transaction"].get_obj());
-	return err;
-}
-
-json_spirit::mObject fillJsonWithTransaction(Transaction _txn)
-{
-	json_spirit::mObject txObject;
-	txObject["nonce"] = toCompactHex(_txn.nonce(), HexPrefix::Add, 1);
-	txObject["data"] = toHex(_txn.data(), 2, HexPrefix::Add);
-	txObject["gasLimit"] = toCompactHex(_txn.gas(), HexPrefix::Add, 1);
-	txObject["gasPrice"] = toCompactHex(_txn.gasPrice(), HexPrefix::Add, 1);
-	txObject["r"] = toCompactHex(_txn.signature().r, HexPrefix::Add, 1);
-	txObject["s"] = toCompactHex(_txn.signature().s, HexPrefix::Add, 1);
-	txObject["v"] = toCompactHex(_txn.signature().v + 27, HexPrefix::Add, 1);
-	txObject["to"] = _txn.isCreation() ? "" : toString(_txn.receiveAddress());
-	txObject["value"] = toCompactHex(_txn.value(), HexPrefix::Add, 1);
-	return txObject;
-}
-
-json_spirit::mObject fillJsonWithState(State _state)
-{
-	json_spirit::mObject oState;
-	for (auto const& a: _state.addresses())
-	{
-		json_spirit::mObject o;
-		o["balance"] = toCompactHex(_state.balance(a.first), HexPrefix::Add, 1);
-		o["nonce"] = toCompactHex(_state.transactionsFrom(a.first), HexPrefix::Add, 1);
-		{
-			json_spirit::mObject store;
-			for (auto const& s: _state.storage(a.first))
-				store[toCompactHex(s.first, HexPrefix::Add, 1)] = toCompactHex(s.second, HexPrefix::Add, 1);
-			o["storage"] = store;
-		}
-		o["code"] = toHex(_state.code(a.first), 2, HexPrefix::Add);
-		oState[toString(a.first)] = o;
-	}
-	return oState;
-}
-
-json_spirit::mArray exportLog(eth::LogEntries _logs)
-{
-	json_spirit::mArray ret;
-	if (_logs.size() == 0) return ret;
-	for (LogEntry const& l: _logs)
-	{
-		json_spirit::mObject o;
-		o["address"] = toString(l.address);
-		json_spirit::mArray topics;
-		for (auto const& t: l.topics)
-			topics.push_back(toString(t));
-		o["topics"] = topics;
-		o["data"] = toHex(l.data, 2, HexPrefix::Add);
-		o["bloom"] = toString(l.bloom());
-		ret.push_back(o);
-	}
-	return ret;
-}
-
-u256 toInt(json_spirit::mValue const& _v)
-{
-	switch (_v.type())
-	{
-	case json_spirit::str_type: return u256(_v.get_str());
-	case json_spirit::int_type: return (u256)_v.get_uint64();
-	case json_spirit::bool_type: return (u256)(uint64_t)_v.get_bool();
-	case json_spirit::real_type: return (u256)(uint64_t)_v.get_real();
-	default: cwarn << "Bad type for scalar: " << _v.type();
-	}
-	return 0;
-}
-
-byte toByte(json_spirit::mValue const& _v)
-{
-	switch (_v.type())
-	{
-	case json_spirit::str_type: return (byte)stoi(_v.get_str());
-	case json_spirit::int_type: return (byte)_v.get_uint64();
-	case json_spirit::bool_type: return (byte)_v.get_bool();
-	case json_spirit::real_type: return (byte)_v.get_real();
-	default: cwarn << "Bad type for scalar: " << _v.type();
-	}
-	return 0;
-}
-
-bytes importByteArray(std::string const& _str)
-{
-	return fromHex(_str.substr(0, 2) == "0x" ? _str.substr(2) : _str, WhenError::Throw);
-}
-
-bytes importData(json_spirit::mObject const& _o)
-{
-	bytes data;
-	if (_o.at("data").type() == json_spirit::str_type)
-		data = importByteArray(_o.at("data").get_str());
-	else
-		for (auto const& j: _o.at("data").get_array())
-			data.push_back(toByte(j));
-	return data;
-}
-
-bytes importCode(json_spirit::mObject& _o)
-{
-	bytes code;
-	if (_o["code"].type() == json_spirit::str_type)
-		if (_o["code"].get_str().find("0x") != 0)
-			code = compileLLL(_o["code"].get_str(), false);
-		else
-			code = fromHex(_o["code"].get_str().substr(2));
-	else if (_o["code"].type() == json_spirit::array_type)
-	{
-		code.clear();
-		for (auto const& j: _o["code"].get_array())
-			code.push_back(toByte(j));
-	}
-	return code;
-}
-
-LogEntries importLog(json_spirit::mArray& _a)
-{
-	LogEntries logEntries;
-	for (auto const& l: _a)
-	{
-		json_spirit::mObject o = l.get_obj();
-		// cant use BOOST_REQUIRE, because this function is used outside boost test (createRandomTest)
-		assert(o.count("address") > 0);
-		assert(o.count("topics") > 0);
-		assert(o.count("data") > 0);
-		assert(o.count("bloom") > 0);
-		LogEntry log;
-		log.address = Address(o["address"].get_str());
-		for (auto const& t: o["topics"].get_array())
-			log.topics.push_back(h256(t.get_str()));
-		log.data = importData(o);
-		logEntries.push_back(log);
-	}
-	return logEntries;
-}
-
-void checkOutput(bytes const& _output, json_spirit::mObject& _o)
-{
-	int j = 0;
-
-	if (_o["out"].get_str().find("#") == 0)
-		{TBOOST_CHECK(((u256)_output.size() == toInt(_o["out"].get_str().substr(1))));}
-	else if (_o["out"].type() == json_spirit::array_type)
-		for (auto const& d: _o["out"].get_array())
-		{
-			TBOOST_CHECK_MESSAGE((_output[j] == toInt(d)), "Output byte [" << j << "] different!");
-			++j;
-		}
-	else if (_o["out"].get_str().find("0x") == 0)
-		{TBOOST_CHECK((_output == fromHex(_o["out"].get_str().substr(2))));}
-	else
-		TBOOST_CHECK((_output == fromHex(_o["out"].get_str())));
-}
-
-void checkStorage(map<u256, u256> _expectedStore, map<u256, u256> _resultStore, Address _expectedAddr)
-{
-	_expectedAddr = _expectedAddr; //unsed parametr when macro
-	for (auto&& expectedStorePair : _expectedStore)
-	{
-		auto& expectedStoreKey = expectedStorePair.first;
-		auto resultStoreIt = _resultStore.find(expectedStoreKey);
-		if (resultStoreIt == _resultStore.end())
-			{TBOOST_ERROR(_expectedAddr << ": missing store key " << expectedStoreKey);}
-		else
-		{
-			auto& expectedStoreValue = expectedStorePair.second;
-			auto& resultStoreValue = resultStoreIt->second;
-			TBOOST_CHECK_MESSAGE((expectedStoreValue == resultStoreValue), _expectedAddr << ": store[" << expectedStoreKey << "] = " << resultStoreValue << ", expected " << expectedStoreValue);
-		}
-	}
-	TBOOST_CHECK_EQUAL(_resultStore.size(), _expectedStore.size());
-	for (auto&& resultStorePair: _resultStore)
-	{
-		if (!_expectedStore.count(resultStorePair.first))
-			TBOOST_ERROR(_expectedAddr << ": unexpected store key " << resultStorePair.first);
-	}
-}
-
-void checkLog(LogEntries _resultLogs, LogEntries _expectedLogs)
-{
-	TBOOST_REQUIRE_EQUAL(_resultLogs.size(), _expectedLogs.size());
-
-	for (size_t i = 0; i < _resultLogs.size(); ++i)
-	{
-		TBOOST_CHECK_EQUAL(_resultLogs[i].address, _expectedLogs[i].address);
-		TBOOST_CHECK_EQUAL(_resultLogs[i].topics, _expectedLogs[i].topics);
-		TBOOST_CHECK((_resultLogs[i].data == _expectedLogs[i].data));
-	}
-}
-
-void checkCallCreates(eth::Transactions _resultCallCreates, eth::Transactions _expectedCallCreates)
-{
-	TBOOST_REQUIRE_EQUAL(_resultCallCreates.size(), _expectedCallCreates.size());
-
-	for (size_t i = 0; i < _resultCallCreates.size(); ++i)
-	{
-		TBOOST_CHECK((_resultCallCreates[i].data() == _expectedCallCreates[i].data()));
-		TBOOST_CHECK((_resultCallCreates[i].receiveAddress() == _expectedCallCreates[i].receiveAddress()));
-		TBOOST_CHECK((_resultCallCreates[i].gas() == _expectedCallCreates[i].gas()));
-		TBOOST_CHECK((_resultCallCreates[i].value() == _expectedCallCreates[i].value()));
-	}
-}
-
-void userDefinedTest(std::function<void(json_spirit::mValue&, bool)> doTests)
-{
-	if (!Options::get().singleTest)
-		return;
-
-	if (Options::get().singleTestFile.empty() || Options::get().singleTestName.empty())
-	{
-		cnote << "Missing user test specification\nUsage: testeth --singletest <filename> <testname>\n";
-		return;
-	}
-
-	auto& filename = Options::get().singleTestFile;
-	auto& testname = Options::get().singleTestName;
-
-	if (g_logVerbosity != -1)
-		VerbosityHolder sentinel(12);
-
-	try
-	{
-		cnote << "Testing user defined test: " << filename;
-		json_spirit::mValue v;
-		string s = contentsString(filename);
-		TBOOST_REQUIRE_MESSAGE((s.length() > 0), "Contents of " + filename + " is empty. ");
-		json_spirit::read_string(s, v);
-		json_spirit::mObject oSingleTest;
-
-		json_spirit::mObject::const_iterator pos = v.get_obj().find(testname);
-		if (pos == v.get_obj().end())
-		{
-			cnote << "Could not find test: " << testname << " in " << filename << "\n";
-			return;
-		}
-		else
-			oSingleTest[pos->first] = pos->second;
-
-		json_spirit::mValue v_singleTest(oSingleTest);
-		doTests(v_singleTest, test::Options::get().fillTests);
-	}
-	catch (Exception const& _e)
-	{
-		TBOOST_ERROR("Failed Test with Exception: " << diagnostic_information(_e));
-	}
-	catch (std::exception const& _e)
-	{
-		TBOOST_ERROR("Failed Test with Exception: " << _e.what());
-	}
-}
-
-void executeTests(const string& _name, const string& _testPathAppendix, const boost::filesystem::path _pathToFiller, std::function<void(json_spirit::mValue&, bool)> doTests)
-{
-	string testPath = getTestPath();
-	testPath += _testPathAppendix;
-
-	if (Options::get().stats)
-		Listener::registerListener(Stats::get());
-
-	if (Options::get().fillTests)
-	{
-		try
-		{
-			cnote << "Populating tests...";
-			json_spirit::mValue v;
-			boost::filesystem::path p(__FILE__);
-			string s = asString(dev::contents(_pathToFiller.string() + "/" + _name + "Filler.json"));
-			TBOOST_REQUIRE_MESSAGE((s.length() > 0), "Contents of " + _pathToFiller.string() + "/" + _name + "Filler.json is empty.");
-			json_spirit::read_string(s, v);
-			doTests(v, true);
-			writeFile(testPath + "/" + _name + ".json", asBytes(json_spirit::write_string(v, true)));
-		}
-		catch (Exception const& _e)
-		{
-			TBOOST_ERROR("Failed filling test with Exception: " << diagnostic_information(_e));
-		}
-		catch (std::exception const& _e)
-		{
-			TBOOST_ERROR("Failed filling test with Exception: " << _e.what());
-		}
-	}
-
-	try
-	{
-		cnote << "TEST " << _name << ":";
-		json_spirit::mValue v;
-		string s = asString(dev::contents(testPath + "/" + _name + ".json"));
-		TBOOST_REQUIRE_MESSAGE((s.length() > 0), "Contents of " + testPath + "/" + _name + ".json is empty. Have you cloned the 'tests' repo branch develop and set ETHEREUM_TEST_PATH to its path?");
-		json_spirit::read_string(s, v);
-		Listener::notifySuiteStarted(_name);
-		doTests(v, false);
-	}
-	catch (Exception const& _e)
-	{
-		TBOOST_ERROR("Failed test with Exception: " << diagnostic_information(_e));
-	}
-	catch (std::exception const& _e)
-	{
-		TBOOST_ERROR("Failed test with Exception: " << _e.what());
-	}
-}
-
-RLPStream createRLPStreamFromTransactionFields(json_spirit::mObject const& _tObj)
-{
-	//Construct Rlp of the given transaction
-	RLPStream rlpStream;
-	rlpStream.appendList(_tObj.size());
-
-	if (_tObj.count("nonce"))
-		rlpStream << bigint(_tObj.at("nonce").get_str());
-
-	if (_tObj.count("gasPrice"))
-		rlpStream << bigint(_tObj.at("gasPrice").get_str());
-
-	if (_tObj.count("gasLimit"))
-		rlpStream << bigint(_tObj.at("gasLimit").get_str());
-
-	if (_tObj.count("to"))
-	{
-		if (_tObj.at("to").get_str().empty())
-			rlpStream << "";
-		else
-			rlpStream << importByteArray(_tObj.at("to").get_str());
-	}
-
-	if (_tObj.count("value"))
-		rlpStream << bigint(_tObj.at("value").get_str());
-
-	if (_tObj.count("data"))
-		rlpStream << importData(_tObj);
-
-	if (_tObj.count("v"))
-		rlpStream << bigint(_tObj.at("v").get_str());
-
-	if (_tObj.count("r"))
-		rlpStream << bigint(_tObj.at("r").get_str());
-
-	if (_tObj.count("s"))
-		rlpStream <<  bigint(_tObj.at("s").get_str());
-
-	if (_tObj.count("extrafield"))
-		rlpStream << bigint(_tObj.at("extrafield").get_str());
-
-	return rlpStream;
-}
-
-Options::Options()
-{
-	auto argc = boost::unit_test::framework::master_test_suite().argc;
-	auto argv = boost::unit_test::framework::master_test_suite().argv;
-
-	for (auto i = 0; i < argc; ++i)
-	{
-		auto arg = std::string{argv[i]};
-		if (arg == "--vm" && i + 1 < argc)
-		{
-			string vmKind = argv[++i];
-			if (vmKind == "interpreter")
-				VMFactory::setKind(VMKind::Interpreter);
-			else if (vmKind == "jit")
-				VMFactory::setKind(VMKind::JIT);
-			else if (vmKind == "smart")
-				VMFactory::setKind(VMKind::Smart);
-			else
-				cerr << "Unknown VM kind: " << vmKind << endl;
-		}
-		else if (arg == "--jit") // TODO: Remove deprecated option "--jit"
-			VMFactory::setKind(VMKind::JIT);
-		else if (arg == "--vmtrace")
-			vmtrace = true;
-		else if (arg == "--filltests")
-			fillTests = true;
-		else if (arg == "--stats" && i + 1 < argc)
-		{
-			stats = true;
-			statsOutFile = argv[i + 1];
-		}
-		else if (arg == "--performance")
-			performance = true;
-		else if (arg == "--quadratic")
-			quadratic = true;
-		else if (arg == "--memory")
-			memory = true;
-		else if (arg == "--inputlimits")
-			inputLimits = true;
-		else if (arg == "--bigdata")
-			bigData = true;
-		else if (arg == "--checkstate")
-			checkState = true;
-		else if (arg == "--wallet")
-			wallet = true;
-		else if (arg == "--nonetwork")
-			nonetwork = true;
-		else if (arg == "--network")
-			nonetwork = false;
-		else if (arg == "--nodag")
-			nodag = true;
-		else if (arg == "--all")
-		{
-			performance = true;
-			quadratic = true;
-			memory = true;
-			inputLimits = true;
-			bigData = true;
-			wallet = true;
-		}
-		else if (arg == "--singletest" && i + 1 < argc)
-		{
-			singleTest = true;
-			auto name1 = std::string{argv[i + 1]};
-			if (i + 1 < argc) // two params
-			{
-				auto name2 = std::string{argv[i + 2]};
-				if (name2[0] == '-') // not param, another option
-					singleTestName = std::move(name1);
-				else
-				{
-					singleTestFile = std::move(name1);
-					singleTestName = std::move(name2);
-				}
-			}
-			else
-				singleTestName = std::move(name1);
-		}
-		else if (arg == "--fulloutput")
-			fulloutput = true;
-		else if (arg == "--verbosity" && i + 1 < argc)
-		{
-			static std::ostringstream strCout; //static string to redirect logs to
-			std::string indentLevel = std::string{argv[i + 1]};
-			if (indentLevel == "0")
-			{
-				logVerbosity = Verbosity::None;
-				std::cout.rdbuf(strCout.rdbuf());
-				std::cerr.rdbuf(strCout.rdbuf());
-			}
-			else if (indentLevel == "1")
-				logVerbosity = Verbosity::NiceReport;
-			else
-				logVerbosity = Verbosity::Full;
-		}
-	}
-
-	//Default option
-	if (logVerbosity == Verbosity::NiceReport)
-		g_logVerbosity = -1;	//disable cnote but leave cerr and cout
-}
-
-Options const& Options::get()
-{
-	static Options instance;
-	return instance;
-}
-
-LastHashes lastHashes(u256 _currentBlockNumber)
-{
-	LastHashes ret;
-	for (u256 i = 1; i <= 256 && i <= _currentBlockNumber; ++i)
-		ret.push_back(sha3(toString(_currentBlockNumber - i)));
-	return ret;
-}
-
-dev::eth::Ethash::BlockHeader constructHeader(
-	h256 const& _parentHash,
-	h256 const& _sha3Uncles,
-	Address const& _coinbaseAddress,
-	h256 const& _stateRoot,
-	h256 const& _transactionsRoot,
-	h256 const& _receiptsRoot,
-	dev::eth::LogBloom const& _logBloom,
-	u256 const& _difficulty,
-	u256 const& _number,
-	u256 const& _gasLimit,
-	u256 const& _gasUsed,
-	u256 const& _timestamp,
-	bytes const& _extraData)
-{
-	RLPStream rlpStream;
-	rlpStream.appendList(Ethash::BlockHeader::Fields);
-
-	rlpStream << _parentHash << _sha3Uncles << _coinbaseAddress << _stateRoot << _transactionsRoot << _receiptsRoot << _logBloom
-		<< _difficulty << _number << _gasLimit << _gasUsed << _timestamp << _extraData << h256{} << Nonce{};
-
-	return Ethash::BlockHeader(rlpStream.out(), CheckNothing, h256{}, HeaderData);
-}
-
-void updateEthashSeal(dev::eth::Ethash::BlockHeader& _header, h256 const& _mixHash, dev::eth::Nonce const& _nonce)
-{
-	RLPStream source;
-	_header.streamRLP(source);
-	RLP sourceRlp(source.out());
-	RLPStream header;
-	header.appendList(Ethash::BlockHeader::Fields);
-	for (size_t i = 0; i < BlockInfo::BasicFields; i++)
-		header << sourceRlp[i];
-
-	header << _mixHash << _nonce;
-	_header = Ethash::BlockHeader(header.out(), CheckNothing, h256{}, HeaderData);
-}
-
 namespace
 {
 	Listener* g_listener;
diff --git a/test/TestHelper.h b/test/TestHelper.h
index e5cf1323..0bf62224 100644
--- a/test/TestHelper.h
+++ b/test/TestHelper.h
@@ -25,47 +25,8 @@
 #include <boost/test/unit_test.hpp>
 #include <boost/filesystem.hpp>
 
-#include "JsonSpiritHeaders.h"
-#include <libethcore/Ethash.h>
-#include <libethereum/State.h>
-#include <libevm/ExtVMFace.h>
-#include <libtestutils/Common.h>
-
-#ifdef NOBOOST
-	#define TBOOST_REQUIRE(arg) if(arg == false) throw dev::Exception();
-	#define TBOOST_REQUIRE_EQUAL(arg1, arg2) if(arg1 != arg2) throw dev::Exception();
-	#define TBOOST_CHECK_EQUAL(arg1, arg2) if(arg1 != arg2) throw dev::Exception();
-	#define TBOOST_CHECK(arg) if(arg == false) throw dev::Exception();
-	#define TBOOST_REQUIRE_MESSAGE(arg1, arg2) if(arg1 == false) throw dev::Exception();
-	#define TBOOST_CHECK_MESSAGE(arg1, arg2) if(arg1 == false) throw dev::Exception();
-	#define TBOOST_WARN_MESSAGE(arg1, arg2) throw dev::Exception();
-	#define TBOOST_ERROR(arg) throw dev::Exception();
-#else
-	#define TBOOST_REQUIRE(arg) BOOST_REQUIRE(arg)
-	#define TBOOST_REQUIRE_EQUAL(arg1, arg2) BOOST_REQUIRE_EQUAL(arg1, arg2)
-	#define TBOOST_CHECK(arg) BOOST_CHECK(arg)
-	#define TBOOST_CHECK_EQUAL(arg1, arg2) BOOST_CHECK_EQUAL(arg1, arg2)
-	#define TBOOST_CHECK_MESSAGE(arg1, arg2) BOOST_CHECK_MESSAGE(arg1, arg2)
-	#define TBOOST_REQUIRE_MESSAGE(arg1, arg2) BOOST_REQUIRE_MESSAGE(arg1, arg2)
-	#define TBOOST_WARN_MESSAGE(arg1, arg2) BOOST_WARN_MESSAGE(arg1, arg2)
-	#define TBOOST_ERROR(arg) BOOST_ERROR(arg)
-#endif
-
 namespace dev
 {
-namespace eth
-{
-
-class Client;
-class State;
-
-void mine(Client& c, int numBlocks);
-void connectClients(Client& c1, Client& c2);
-void mine(Block& _s, BlockChain const& _bc);
-void mine(Ethash::BlockHeader& _bi);
-
-}
-
 namespace test
 {
 
@@ -121,144 +82,6 @@ namespace test
 	}																	\
 	while (0)
 
-enum class testType
-{
-	StateTests,
-	BlockChainTests,
-	Other
-};
-
-class ImportTest
-{
-public:
-	ImportTest(json_spirit::mObject& _o, bool isFiller, testType testTemplate = testType::StateTests);
-
-	// imports
-	void importEnv(json_spirit::mObject& _o);
-	static void importState(json_spirit::mObject& _o, eth::State& _state);
-	static void importState(json_spirit::mObject& _o, eth::State& _state, eth::AccountMaskMap& o_mask);
-	static void importTransaction (json_spirit::mObject const& _o, eth::Transaction& o_tr);
-	void importTransaction(json_spirit::mObject const& _o);
-	static json_spirit::mObject& makeAllFieldsHex(json_spirit::mObject& _o);
-
-	bytes executeTest();
-	int exportTest(bytes const& _output);
-	static int compareStates(eth::State const& _stateExpect, eth::State const& _statePost, eth::AccountMaskMap const _expectedStateOptions = eth::AccountMaskMap(), WhenError _throw = WhenError::Throw);
-
-	eth::State m_statePre;
-	eth::State m_statePost;
-	eth::EnvInfo m_envInfo;
-	eth::Transaction m_transaction;	
-	eth::LogEntries m_logs;
-	eth::LogEntries m_logsExpected;
-
-private:
-	json_spirit::mObject& m_testObject;
-};
-
-class ZeroGasPricer: public eth::GasPricer
-{
-protected:
-	u256 ask(eth::Block const&) const override { return 0; }
-	u256 bid(eth::TransactionPriority = eth::TransactionPriority::Medium) const override { return 0; }
-};
-
-// helping functions
-u256 toInt(json_spirit::mValue const& _v);
-byte toByte(json_spirit::mValue const& _v);
-bytes importCode(json_spirit::mObject& _o);
-bytes importData(json_spirit::mObject const& _o);
-bytes importByteArray(std::string const& _str);
-eth::LogEntries importLog(json_spirit::mArray& _o);
-json_spirit::mArray exportLog(eth::LogEntries _logs);
-void checkOutput(bytes const& _output, json_spirit::mObject& _o);
-void checkStorage(std::map<u256, u256> _expectedStore, std::map<u256, u256> _resultStore, Address _expectedAddr);
-void checkLog(eth::LogEntries _resultLogs, eth::LogEntries _expectedLogs);
-void checkCallCreates(eth::Transactions _resultCallCreates, eth::Transactions _expectedCallCreates);
-dev::eth::Ethash::BlockHeader constructHeader(
-	h256 const& _parentHash,
-	h256 const& _sha3Uncles,
-	Address const& _coinbaseAddress,
-	h256 const& _stateRoot,
-	h256 const& _transactionsRoot,
-	h256 const& _receiptsRoot,
-	dev::eth::LogBloom const& _logBloom,
-	u256 const& _difficulty,
-	u256 const& _number,
-	u256 const& _gasLimit,
-	u256 const& _gasUsed,
-	u256 const& _timestamp,
-	bytes const& _extraData);
-void updateEthashSeal(dev::eth::Ethash::BlockHeader& _header, h256 const& _mixHash, dev::eth::Nonce const& _nonce);
-void executeTests(const std::string& _name, const std::string& _testPathAppendix, const boost::filesystem::path _pathToFiller, std::function<void(json_spirit::mValue&, bool)> doTests);
-void userDefinedTest(std::function<void(json_spirit::mValue&, bool)> doTests);
-RLPStream createRLPStreamFromTransactionFields(json_spirit::mObject const& _tObj);
-eth::LastHashes lastHashes(u256 _currentBlockNumber);
-json_spirit::mObject fillJsonWithState(eth::State _state);
-json_spirit::mObject fillJsonWithTransaction(eth::Transaction _txn);
-
-//Fill Test Functions
-void doTransactionTests(json_spirit::mValue& _v, bool _fillin);
-void doStateTests(json_spirit::mValue& v, bool _fillin);
-void doVMTests(json_spirit::mValue& v, bool _fillin);
-void doBlockchainTests(json_spirit::mValue& _v, bool _fillin);
-void doRlpTests(json_spirit::mValue& v, bool _fillin);
-
-/*template<typename mapType>
-void checkAddresses(mapType& _expectedAddrs, mapType& _resultAddrs)
-{
-	for (auto& resultPair : _resultAddrs)
-	{
-		auto& resultAddr = resultPair.first;
-		auto expectedAddrIt = _expectedAddrs.find(resultAddr);
-		if (expectedAddrIt == _expectedAddrs.end())
-			TBOOST_ERROR("Missing result address " << resultAddr);
-	}
-	TBOOST_CHECK((_expectedAddrs == _resultAddrs));
-}*/
-
-enum class Verbosity
-{
-	Full,
-	NiceReport,
-	None
-};
-
-class Options
-{
-public:
-	bool vmtrace = false;	///< Create EVM execution tracer // TODO: Link with log verbosity?
-	bool fillTests = false; ///< Create JSON test files from execution results
-	bool stats = false;		///< Execution time stats
-	std::string statsOutFile; ///< Stats output file. "out" for standard output
-	bool checkState = false;///< Throw error when checking test states
-	bool fulloutput = false;///< Replace large output to just it's length
-	Verbosity logVerbosity = Verbosity::NiceReport;
-
-	/// Test selection
-	/// @{
-	bool singleTest = false;
-	std::string singleTestFile;
-	std::string singleTestName;
-	bool performance = false;
-	bool quadratic = false;
-	bool memory = false;
-	bool inputLimits = false;
-	bool bigData = false;
-	bool wallet = false;
-	bool nonetwork = true;
-	bool nodag = true;
-	/// @}
-
-	/// Get reference to options
-	/// The first time used, options are parsed
-	static Options const& get();
-
-private:
-	Options();
-	Options(Options const&) = delete;
-};
-
 /// Allows observing test execution process.
 /// This class also provides methods for registering and notifying the listener
 class Listener
diff --git a/test/TestUtils.cpp b/test/TestUtils.cpp
deleted file mode 100644
index 5e0619c0..00000000
--- a/test/TestUtils.cpp
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
-	This file is part of cpp-ethereum.
-
-	cpp-ethereum is free software: you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation, either version 3 of the License, or
-	(at your option) any later version.
-
-	cpp-ethereum is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.
- */
-/** @file TestUtils.cpp
- * @author Marek Kotewicz <marek@ethdev.com>
- * @date 2015
- */
-
-#include <thread>
-#include <boost/test/unit_test.hpp>
-#include <boost/filesystem.hpp>
-#include <libdevcrypto/Common.h>
-#include <libtestutils/Common.h>
-#include <libtestutils/BlockChainLoader.h>
-#include <libtestutils/FixedClient.h>
-#include "TestUtils.h"
-
-using namespace std;
-using namespace dev;
-using namespace dev::eth;
-using namespace dev::test;
-
-namespace dev
-{
-namespace test
-{
-
-bool getCommandLineOption(std::string const& _name);
-std::string getCommandLineArgument(std::string const& _name, bool _require = false);
-
-}
-}
-
-bool dev::test::getCommandLineOption(string const& _name)
-{
-	auto argc = boost::unit_test::framework::master_test_suite().argc;
-	auto argv = boost::unit_test::framework::master_test_suite().argv;
-	bool result = false;
-	for (auto i = 0; !result && i < argc; ++i)
-		result = _name == argv[i];
-	return result;
-}
-
-std::string dev::test::getCommandLineArgument(string const& _name, bool _require)
-{
-	auto argc = boost::unit_test::framework::master_test_suite().argc;
-	auto argv = boost::unit_test::framework::master_test_suite().argv;
-	for (auto i = 1; i < argc; ++i)
-	{
-		string str = argv[i];
-		if (_name == str.substr(0, _name.size()))
-			return str.substr(str.find("=") + 1);
-	}
-	if (_require)
-		BOOST_ERROR("Failed getting command line argument: " << _name << " from: " << argv);
-	return "";
-}
-
-LoadTestFileFixture::LoadTestFileFixture()
-{
-	m_json = loadJsonFromFile(toTestFilePath(getCommandLineArgument("--eth_testfile")));
-}
-
-void ParallelFixture::enumerateThreads(std::function<void()> callback) const
-{
-	size_t threadsCount = std::stoul(getCommandLineArgument("--eth_threads"), nullptr, 10);
-	
-	vector<thread> workers;
-	for (size_t i = 0; i < threadsCount; i++)
-		workers.emplace_back(callback);
-	
-	for_each(workers.begin(), workers.end(), [](thread &t)
-	{
-		t.join();
-	});
-}
-
-void BlockChainFixture::enumerateBlockchains(std::function<void(Json::Value const&, dev::eth::BlockChain const&, State state)> callback) const
-{
-	for (string const& name: m_json.getMemberNames())
-	{
-		BlockChainLoader bcl(m_json[name]);
-		callback(m_json[name], bcl.bc(), bcl.state());
-	}
-}
-
-void ClientBaseFixture::enumerateClients(std::function<void(Json::Value const&, dev::eth::ClientBase&)> callback) const
-{
-	enumerateBlockchains([&callback](Json::Value const& _json, BlockChain const& _bc, State _state) -> void
-	{
-		cerr << "void ClientBaseFixture::enumerateClients. FixedClient now accepts block not sate!" << endl;
-		_state.commit(); //unused variable. remove this line
-		FixedClient client(_bc, eth::Block {});
-		callback(_json, client);
-	});
-}
-
-void ParallelClientBaseFixture::enumerateClients(std::function<void(Json::Value const&, dev::eth::ClientBase&)> callback) const
-{
-	ClientBaseFixture::enumerateClients([this, &callback](Json::Value const& _json, dev::eth::ClientBase& _client) -> void
-	{
-		// json is being copied here
-		enumerateThreads([callback, _json, &_client]() -> void
-		{
-			callback(_json, _client);
-		});
-	});
-}
-
diff --git a/test/TestUtils.h b/test/TestUtils.h
deleted file mode 100644
index a7a0eacf..00000000
--- a/test/TestUtils.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
-	This file is part of cpp-ethereum.
-
-	cpp-ethereum is free software: you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation, either version 3 of the License, or
-	(at your option) any later version.
-
-	cpp-ethereum is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.
- */
-/** @file TestUtils.h
- * @author Marek Kotewicz <marek@ethdev.com>
- * @date 2015
- */
-
-#pragma once
-
-#include <functional>
-#include <string>
-#include <json/json.h>
-#include <libdevcore/TransientDirectory.h>
-#include <libethereum/BlockChain.h>
-#include <libethereum/ClientBase.h>
-
-namespace dev
-{
-namespace test
-{
-
-// should be used for multithread tests
-static SharedMutex x_boostTest;
-#define ETH_CHECK_EQUAL(x, y) { dev::WriteGuard(x_boostTest); BOOST_CHECK_EQUAL(x, y); }
-#define ETH_CHECK_EQUAL_COLLECTIONS(xb, xe, yb, ye) { dev::WriteGuard(x_boostTest); BOOST_CHECK_EQUAL_COLLECTIONS(xb, xe, yb, ye); }
-#define ETH_REQUIRE(x) { dev::WriteGuard(x_boostTest); BOOST_REQUIRE(x); }
-
-struct LoadTestFileFixture
-{
-	LoadTestFileFixture();
-
-protected:
-	Json::Value m_json;
-};
-
-struct ParallelFixture
-{
-	void enumerateThreads(std::function<void()> callback) const;
-};
-
-struct BlockChainFixture: public LoadTestFileFixture
-{
-	void enumerateBlockchains(std::function<void(Json::Value const&, dev::eth::BlockChain const&, dev::eth::State state)> callback) const;
-};
-
-struct ClientBaseFixture: public BlockChainFixture
-{
-	void enumerateClients(std::function<void(Json::Value const&, dev::eth::ClientBase&)> callback) const;
-};
-
-// important BOOST TEST do have problems with thread safety!!!
-// BOOST_CHECK is not thread safe
-// BOOST_MESSAGE is not thread safe
-// http://boost.2283326.n4.nabble.com/Is-boost-test-thread-safe-td3471644.html
-// http://lists.boost.org/boost-users/2010/03/57691.php
-// worth reading
-// https://codecrafter.wordpress.com/2012/11/01/c-unit-test-framework-adapter-part-3/
-struct ParallelClientBaseFixture: public ClientBaseFixture, public ParallelFixture
-{
-	void enumerateClients(std::function<void(Json::Value const&, dev::eth::ClientBase&)> callback) const;
-};
-
-struct JsonRpcFixture: public ClientBaseFixture
-{
-	
-};
-
-}
-}
diff --git a/test/boostTest.cpp b/test/boostTest.cpp
index f448c48e..f3400a31 100644
--- a/test/boostTest.cpp
+++ b/test/boostTest.cpp
@@ -25,68 +25,9 @@
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wunused-parameter"
 //#define BOOST_DISABLE_WIN32 //disables SEH warning
-#define BOOST_TEST_NO_MAIN
 #include <boost/test/included/unit_test.hpp>
 #pragma GCC diagnostic pop
 
 #include <test/TestHelper.h>
 using namespace boost::unit_test;
 
-//Custom Boost Initialization
-test_suite* init_func( int argc, char* argv[] )
-{
-	if (argc == 0)
-		argv[1]=(char*)"a";
-
-	dev::test::Options::get();
-
-	return 0;
-}
-
-//Custom Boost Unit Test Main
-int main( int argc, char* argv[] )
-{
-	try
-	{
-		framework::init( init_func, argc, argv );
-
-		if( !runtime_config::test_to_run().is_empty() )
-		{
-			test_case_filter filter( runtime_config::test_to_run() );
-
-			traverse_test_tree( framework::master_test_suite().p_id, filter );
-		}
-
-		framework::run();
-
-		results_reporter::make_report();
-
-		return runtime_config::no_result_code()
-					? boost::exit_success
-					: results_collector.results( framework::master_test_suite().p_id ).result_code();
-	}
-	catch (framework::nothing_to_test const&)
-	{
-		return boost::exit_success;
-	}
-	catch (framework::internal_error const& ex)
-	{
-		results_reporter::get_stream() << "Boost.Test framework internal error: " << ex.what() << std::endl;
-
-		return boost::exit_exception_failure;
-	}
-	catch (framework::setup_error const& ex)
-	{
-		results_reporter::get_stream() << "Test setup error: " << ex.what() << std::endl;
-
-		return boost::exit_exception_failure;
-	}
-	catch (...)
-	{
-		results_reporter::get_stream() << "Boost.Test framework internal error: unknown reason" << std::endl;
-
-		return boost::exit_exception_failure;
-	}
-
-	return 0;
-}
diff --git a/test/contracts/AuctionRegistrar.cpp b/test/contracts/AuctionRegistrar.cpp
index 7c5d9fa3..a8b57f2f 100644
--- a/test/contracts/AuctionRegistrar.cpp
+++ b/test/contracts/AuctionRegistrar.cpp
@@ -233,7 +233,7 @@ protected:
 			m_compiler.reset(false, m_addStandardSources);
 			m_compiler.addSource("", registrarCode);
 			ETH_TEST_REQUIRE_NO_THROW(m_compiler.compile(m_optimize, m_optimizeRuns), "Compiling contract failed");
-			s_compiledRegistrar.reset(new bytes(m_compiler.getBytecode("GlobalRegistrar")));
+			s_compiledRegistrar.reset(new bytes(m_compiler.object("GlobalRegistrar").bytecode));
 		}
 		sendMessage(*s_compiledRegistrar, true);
 		BOOST_REQUIRE(!m_output.empty());
diff --git a/test/contracts/FixedFeeRegistrar.cpp b/test/contracts/FixedFeeRegistrar.cpp
index ed2ecf0a..f42f4492 100644
--- a/test/contracts/FixedFeeRegistrar.cpp
+++ b/test/contracts/FixedFeeRegistrar.cpp
@@ -125,7 +125,7 @@ protected:
 			m_compiler.reset(false, m_addStandardSources);
 			m_compiler.addSource("", registrarCode);
 			ETH_TEST_REQUIRE_NO_THROW(m_compiler.compile(m_optimize, m_optimizeRuns), "Compiling contract failed");
-			s_compiledRegistrar.reset(new bytes(m_compiler.getBytecode("FixedFeeRegistrar")));
+			s_compiledRegistrar.reset(new bytes(m_compiler.object("FixedFeeRegistrar").bytecode));
 		}
 		sendMessage(*s_compiledRegistrar, true);
 		BOOST_REQUIRE(!m_output.empty());
diff --git a/test/contracts/Wallet.cpp b/test/contracts/Wallet.cpp
index 5f9febd4..4a4848f1 100644
--- a/test/contracts/Wallet.cpp
+++ b/test/contracts/Wallet.cpp
@@ -440,7 +440,7 @@ protected:
 			m_compiler.reset(false, m_addStandardSources);
 			m_compiler.addSource("", walletCode);
 			ETH_TEST_REQUIRE_NO_THROW(m_compiler.compile(m_optimize, m_optimizeRuns), "Compiling contract failed");
-			s_compiledWallet.reset(new bytes(m_compiler.getBytecode("Wallet")));
+			s_compiledWallet.reset(new bytes(m_compiler.object("Wallet").bytecode));
 		}
 		bytes args = encodeArgs(u256(0x60), _required, _dailyLimit, u256(_owners.size()), _owners);
 		sendMessage(*s_compiledWallet + args, true, _value);
diff --git a/test/libsolidity/Assembly.cpp b/test/libsolidity/Assembly.cpp
index 8d316a97..5bd6fed3 100644
--- a/test/libsolidity/Assembly.cpp
+++ b/test/libsolidity/Assembly.cpp
@@ -52,23 +52,23 @@ eth::AssemblyItems compileContract(const string& _sourceCode)
 	BOOST_REQUIRE_NO_THROW(sourceUnit = parser.parse(make_shared<Scanner>(CharStream(_sourceCode))));
 	NameAndTypeResolver resolver({});
 	resolver.registerDeclarations(*sourceUnit);
-	for (ASTPointer<ASTNode> const& node: sourceUnit->getNodes())
+	for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
 		if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
 		{
 			BOOST_REQUIRE_NO_THROW(resolver.resolveNamesAndTypes(*contract));
 		}
-	for (ASTPointer<ASTNode> const& node: sourceUnit->getNodes())
+	for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
 		if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
 		{
 			BOOST_REQUIRE_NO_THROW(resolver.checkTypeRequirements(*contract));
 		}
-	for (ASTPointer<ASTNode> const& node: sourceUnit->getNodes())
+	for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
 		if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
 		{
 			Compiler compiler;
-			compiler.compileContract(*contract, map<ContractDefinition const*, bytes const*>{});
+			compiler.compileContract(*contract, map<ContractDefinition const*, Assembly const*>{});
 
-			return compiler.getRuntimeAssemblyItems();
+			return compiler.runtimeAssemblyItems();
 		}
 	BOOST_FAIL("No contract found in source.");
 	return AssemblyItems();
@@ -80,10 +80,10 @@ void checkAssemblyLocations(AssemblyItems const& _items, vector<SourceLocation>
 	for (size_t i = 0; i < min(_items.size(), _locations.size()); ++i)
 	{
 		BOOST_CHECK_MESSAGE(
-			_items[i].getLocation() == _locations[i],
+			_items[i].location() == _locations[i],
 			"Location mismatch for assembly item " + to_string(i) + ". Found: " +
-					to_string(_items[i].getLocation().start) + "-" +
-					to_string(_items[i].getLocation().end) + ", expected: " +
+					to_string(_items[i].location().start) + "-" +
+					to_string(_items[i].location().end) + ", expected: " +
 					to_string(_locations[i].start) + "-" +
 					to_string(_locations[i].end));
 	}
diff --git a/test/libsolidity/GasMeter.cpp b/test/libsolidity/GasMeter.cpp
index 5f442654..6d7c06a3 100644
--- a/test/libsolidity/GasMeter.cpp
+++ b/test/libsolidity/GasMeter.cpp
@@ -48,8 +48,8 @@ public:
 		m_compiler.setSource(_sourceCode);
 		ETH_TEST_REQUIRE_NO_THROW(m_compiler.compile(), "Compiling contract failed");
 
-		AssemblyItems const* items = m_compiler.getRuntimeAssemblyItems("");
-		ASTNode const& sourceUnit = m_compiler.getAST();
+		AssemblyItems const* items = m_compiler.runtimeAssemblyItems("");
+		ASTNode const& sourceUnit = m_compiler.ast();
 		BOOST_REQUIRE(items != nullptr);
 		m_gasCosts = GasEstimator::breakToStatementLevel(
 			GasEstimator::structuralEstimation(*items, vector<ASTNode const*>({&sourceUnit})),
@@ -61,9 +61,9 @@ public:
 	{
 		compileAndRun(_sourceCode);
 		auto state = make_shared<KnownState>();
-		PathGasMeter meter(*m_compiler.getAssemblyItems());
+		PathGasMeter meter(*m_compiler.assemblyItems());
 		GasMeter::GasConsumption gas = meter.estimateMax(0, state);
-		u256 bytecodeSize(m_compiler.getRuntimeBytecode().size());
+		u256 bytecodeSize(m_compiler.runtimeObject().bytecode.size());
 		gas += bytecodeSize * c_createDataGas;
 		BOOST_REQUIRE(!gas.isInfinite);
 		BOOST_CHECK(gas.value == m_gasUsed);
@@ -82,7 +82,7 @@ public:
 		}
 
 		GasMeter::GasConsumption gas = GasEstimator::functionalEstimation(
-			*m_compiler.getRuntimeAssemblyItems(),
+			*m_compiler.runtimeAssemblyItems(),
 			_sig
 		);
 		BOOST_REQUIRE(!gas.isInfinite);
@@ -115,11 +115,11 @@ BOOST_AUTO_TEST_CASE(non_overlapping_filtered_costs)
 	{
 		auto second = first;
 		for (++second; second != m_gasCosts.cend(); ++second)
-			if (first->first->getLocation().intersects(second->first->getLocation()))
+			if (first->first->location().intersects(second->first->location()))
 			{
 				BOOST_CHECK_MESSAGE(false, "Source locations should not overlap!");
-				SourceReferenceFormatter::printSourceLocation(cout, first->first->getLocation(), m_compiler.getScanner());
-				SourceReferenceFormatter::printSourceLocation(cout, second->first->getLocation(), m_compiler.getScanner());
+				SourceReferenceFormatter::printSourceLocation(cout, first->first->location(), m_compiler.scanner());
+				SourceReferenceFormatter::printSourceLocation(cout, second->first->location(), m_compiler.scanner());
 			}
 	}
 }
diff --git a/test/libsolidity/SolidityABIJSON.cpp b/test/libsolidity/SolidityABIJSON.cpp
index f7390dc9..69504e3d 100644
--- a/test/libsolidity/SolidityABIJSON.cpp
+++ b/test/libsolidity/SolidityABIJSON.cpp
@@ -40,7 +40,7 @@ public:
 	void checkInterface(std::string const& _code, std::string const& _expectedInterfaceString)
 	{
 		ETH_TEST_REQUIRE_NO_THROW(m_compilerStack.parse(_code), "Parsing contract failed");
-		std::string generatedInterfaceString = m_compilerStack.getMetadata("", DocumentationType::ABIInterface);
+		std::string generatedInterfaceString = m_compilerStack.metadata("", DocumentationType::ABIInterface);
 		Json::Value generatedInterface;
 		m_reader.parse(generatedInterfaceString, generatedInterface);
 		Json::Value expectedInterface;
diff --git a/test/libsolidity/SolidityEndToEndTest.cpp b/test/libsolidity/SolidityEndToEndTest.cpp
index ae2fc6dc..98da1e27 100644
--- a/test/libsolidity/SolidityEndToEndTest.cpp
+++ b/test/libsolidity/SolidityEndToEndTest.cpp
@@ -1248,6 +1248,7 @@ BOOST_AUTO_TEST_CASE(convert_fixed_bytes_to_fixed_bytes_same_size)
 	compileAndRun(sourceCode);
 	BOOST_CHECK(callContractFunction("bytesToBytes(bytes4)", "abcd") == encodeArgs("abcd"));
 }
+
 // fixed bytes to uint conversion tests
 BOOST_AUTO_TEST_CASE(convert_fixed_bytes_to_uint_same_size)
 {
@@ -1300,6 +1301,7 @@ BOOST_AUTO_TEST_CASE(convert_fixed_bytes_to_uint_greater_size)
 	BOOST_CHECK(callContractFunction("bytesToUint(bytes4)", string("abcd")) ==
 		encodeArgs(u256("0x61626364")));
 }
+
 // uint fixed bytes conversion tests
 BOOST_AUTO_TEST_CASE(convert_uint_to_fixed_bytes_same_size)
 {
@@ -3700,7 +3702,7 @@ BOOST_AUTO_TEST_CASE(simple_constant_variables_test)
 
 BOOST_AUTO_TEST_CASE(constant_variables)
 {
-	//for now constant specifier is valid only for uint bytesXX and enums
+	//for now constant specifier is valid only for uint, bytesXX, string and enums
 	char const* sourceCode = R"(
 		contract Foo {
 			uint constant x = 56;
@@ -4188,7 +4190,8 @@ BOOST_AUTO_TEST_CASE(evm_exceptions_in_constructor_out_of_baund)
 			uint[3] arr;
 			function A()
 			{
-				test = arr[5];
+				uint index = 5;
+				test = arr[index];
 				++test;
 			}
 		}
@@ -5161,6 +5164,167 @@ BOOST_AUTO_TEST_CASE(string_as_mapping_key)
 		) == encodeArgs(u256(7 + i)));
 }
 
+BOOST_AUTO_TEST_CASE(accessor_for_state_variable)
+{
+	char const* sourceCode = R"(
+		contract Lotto{
+			uint public ticketPrice = 500;
+		})";
+
+		compileAndRun(sourceCode);
+		BOOST_CHECK(callContractFunction("ticketPrice()") == encodeArgs(u256(500)));
+}
+
+BOOST_AUTO_TEST_CASE(accessor_for_const_state_variable)
+{
+	char const* sourceCode = R"(
+		contract Lotto{
+			uint constant public ticketPrice = 555;
+		})";
+
+		compileAndRun(sourceCode);
+		BOOST_CHECK(callContractFunction("ticketPrice()") == encodeArgs(u256(555)));
+}
+
+BOOST_AUTO_TEST_CASE(constant_string_literal)
+{
+	char const* sourceCode = R"(
+		contract Test {
+			bytes32 constant public b = "abcdefghijklmnopq";
+			string constant public x = "abefghijklmnopqabcdefghijklmnopqabcdefghijklmnopqabca";
+
+			function Test() {
+				var xx = x;
+				var bb = b;
+			}
+			function getB() returns (bytes32) { return b; }
+			function getX() returns (string) { return x; }
+			function getX2() returns (string r) { r = x; }
+			function unused() returns (uint) {
+				"unusedunusedunusedunusedunusedunusedunusedunusedunusedunusedunusedunused";
+				return 2;
+			}
+		}
+	)";
+
+	compileAndRun(sourceCode);
+	string longStr = "abefghijklmnopqabcdefghijklmnopqabcdefghijklmnopqabca";
+	string shortStr = "abcdefghijklmnopq";
+	BOOST_CHECK(callContractFunction("b()") == encodeArgs(shortStr));
+	BOOST_CHECK(callContractFunction("x()") == encodeDyn(longStr));
+	BOOST_CHECK(callContractFunction("getB()") == encodeArgs(shortStr));
+	BOOST_CHECK(callContractFunction("getX()") == encodeDyn(longStr));
+	BOOST_CHECK(callContractFunction("getX2()") == encodeDyn(longStr));
+	BOOST_CHECK(callContractFunction("unused()") == encodeArgs(2));
+}
+
+BOOST_AUTO_TEST_CASE(storage_string_as_mapping_key_without_variable)
+{
+	char const* sourceCode = R"(
+		contract Test {
+			mapping(string => uint) data;
+			function f() returns (uint) {
+				data["abc"] = 2;
+				return data["abc"];
+			}
+		}
+	)";
+	compileAndRun(sourceCode, 0, "Test");
+	BOOST_CHECK(callContractFunction("f()") == encodeArgs(u256(2)));
+}
+
+BOOST_AUTO_TEST_CASE(library_call)
+{
+	char const* sourceCode = R"(
+		library Lib { function m(uint x, uint y) returns (uint) { return x * y; } }
+		contract Test {
+			function f(uint x) returns (uint) {
+				return Lib.m(x, 9);
+			}
+		}
+	)";
+	compileAndRun(sourceCode, 0, "Lib");
+	compileAndRun(sourceCode, 0, "Test", bytes(), map<string, Address>{{"Lib", m_contractAddress}});
+	BOOST_CHECK(callContractFunction("f(uint256)", u256(33)) == encodeArgs(u256(33) * 9));
+}
+
+BOOST_AUTO_TEST_CASE(library_stray_values)
+{
+	char const* sourceCode = R"(
+		library Lib { function m(uint x, uint y) returns (uint) { return x * y; } }
+		contract Test {
+			function f(uint x) returns (uint) {
+				Lib;
+				Lib.m;
+				return x + 9;
+			}
+		}
+	)";
+	compileAndRun(sourceCode, 0, "Lib");
+	compileAndRun(sourceCode, 0, "Test", bytes(), map<string, Address>{{"Lib", m_contractAddress}});
+	BOOST_CHECK(callContractFunction("f(uint256)", u256(33)) == encodeArgs(u256(42)));
+}
+
+BOOST_AUTO_TEST_CASE(simple_throw)
+{
+	char const* sourceCode = R"(
+		contract Test {
+			function f(uint x) returns (uint) {
+				if (x > 10)
+					return x + 10;
+				else
+					throw;
+				return 2;
+			}
+		}
+	)";
+	compileAndRun(sourceCode);
+	BOOST_CHECK(callContractFunction("f(uint256)", u256(11)) == encodeArgs(u256(21)));
+	BOOST_CHECK(callContractFunction("f(uint256)", u256(1)) == encodeArgs());
+}
+
+BOOST_AUTO_TEST_CASE(strings_in_struct)
+{
+	char const* sourceCode = R"(
+		contract buggystruct {
+			Buggy public bug;
+
+			struct Buggy {
+				uint first;
+				uint second;
+				uint third;
+				string last;
+			}
+
+			function buggystruct(){
+				bug = Buggy(10, 20, 30, "asdfghjkl");
+			}
+			function getFirst() returns (uint)
+			{
+				return bug.first;
+			}
+			function getSecond() returns (uint)
+			{
+				return bug.second;
+			}
+			function getThird() returns (uint)
+			{
+				return bug.third;
+			}
+			function getLast() returns (string)
+			{
+				return bug.last;
+			}
+		}
+		)";
+	compileAndRun(sourceCode);
+	string s = "asdfghjkl";
+	BOOST_CHECK(callContractFunction("getFirst()") == encodeArgs(u256(10)));
+	BOOST_CHECK(callContractFunction("getSecond()") == encodeArgs(u256(20)));
+	BOOST_CHECK(callContractFunction("getThird()") == encodeArgs(u256(30)));
+	BOOST_CHECK(callContractFunction("getLast()") == encodeDyn(s));
+}
+
 BOOST_AUTO_TEST_SUITE_END()
 
 }
diff --git a/test/libsolidity/SolidityExpressionCompiler.cpp b/test/libsolidity/SolidityExpressionCompiler.cpp
index ee631197..747668b0 100644
--- a/test/libsolidity/SolidityExpressionCompiler.cpp
+++ b/test/libsolidity/SolidityExpressionCompiler.cpp
@@ -48,7 +48,7 @@ class FirstExpressionExtractor: private ASTVisitor
 {
 public:
 	FirstExpressionExtractor(ASTNode& _node): m_expression(nullptr) { _node.accept(*this); }
-	Expression* getExpression() const { return m_expression; }
+	Expression* expression() const { return m_expression; }
 private:
 	virtual bool visit(Assignment& _expression) override { return checkExpression(_expression); }
 	virtual bool visit(UnaryOperation& _expression) override { return checkExpression(_expression); }
@@ -108,22 +108,22 @@ bytes compileFirstExpression(const string& _sourceCode, vector<vector<string>> _
 	resolver.registerDeclarations(*sourceUnit);
 
 	vector<ContractDefinition const*> inheritanceHierarchy;
-	for (ASTPointer<ASTNode> const& node: sourceUnit->getNodes())
+	for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
 		if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
 		{
 			ETH_TEST_REQUIRE_NO_THROW(resolver.resolveNamesAndTypes(*contract), "Resolving names failed");
 			inheritanceHierarchy = vector<ContractDefinition const*>(1, contract);
 		}
-	for (ASTPointer<ASTNode> const& node: sourceUnit->getNodes())
+	for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
 		if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
 		{
 			ETH_TEST_REQUIRE_NO_THROW(resolver.checkTypeRequirements(*contract), "Checking type Requirements failed");
 		}
-	for (ASTPointer<ASTNode> const& node: sourceUnit->getNodes())
+	for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
 		if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
 		{
 			FirstExpressionExtractor extractor(*contract);
-			BOOST_REQUIRE(extractor.getExpression() != nullptr);
+			BOOST_REQUIRE(extractor.expression() != nullptr);
 
 			CompilerContext context;
 			context.resetVisitedNodes(contract);
@@ -134,11 +134,11 @@ bytes compileFirstExpression(const string& _sourceCode, vector<vector<string>> _
 				context.addVariable(dynamic_cast<VariableDeclaration const&>(resolveDeclaration(variable, resolver)),
 									parametersSize--);
 
-			ExpressionCompiler(context).compile(*extractor.getExpression());
+			ExpressionCompiler(context).compile(*extractor.expression());
 
 			for (vector<string> const& function: _functions)
-				context << context.getFunctionEntryLabel(dynamic_cast<FunctionDefinition const&>(resolveDeclaration(function, resolver)));
-			bytes instructions = context.getAssembledBytecode();
+				context << context.functionEntryLabel(dynamic_cast<FunctionDefinition const&>(resolveDeclaration(function, resolver)));
+			bytes instructions = context.assembledObject().bytecode;
 			// debug
 			// cout << eth::disassemble(instructions) << endl;
 			return instructions;
diff --git a/test/libsolidity/SolidityInterface.cpp b/test/libsolidity/SolidityInterface.cpp
index 9c9373f0..d77bccbd 100644
--- a/test/libsolidity/SolidityInterface.cpp
+++ b/test/libsolidity/SolidityInterface.cpp
@@ -43,14 +43,14 @@ public:
 	{
 		m_code = _code;
 		ETH_TEST_REQUIRE_NO_THROW(m_compilerStack.parse(_code), "Parsing failed");
-		m_interface = m_compilerStack.getMetadata("", DocumentationType::ABISolidityInterface);
+		m_interface = m_compilerStack.metadata("", DocumentationType::ABISolidityInterface);
 		ETH_TEST_REQUIRE_NO_THROW(m_reCompiler.parse(m_interface), "Interface parsing failed");
-		return m_reCompiler.getContractDefinition(_contractName);
+		return m_reCompiler.contractDefinition(_contractName);
 	}
 
-	string getSourcePart(ASTNode const& _node) const
+	string sourcePart(ASTNode const& _node) const
 	{
-		SourceLocation location = _node.getLocation();
+		SourceLocation location = _node.location();
 		BOOST_REQUIRE(!location.isEmpty());
 		return m_interface.substr(location.start, location.end - location.start);
 	}
@@ -67,7 +67,7 @@ BOOST_FIXTURE_TEST_SUITE(SolidityInterface, SolidityInterfaceChecker)
 BOOST_AUTO_TEST_CASE(empty_contract)
 {
 	ContractDefinition const& contract = checkInterface("contract test {}");
-	BOOST_CHECK_EQUAL(getSourcePart(contract), "contract test{}");
+	BOOST_CHECK_EQUAL(sourcePart(contract), "contract test{}");
 }
 
 BOOST_AUTO_TEST_CASE(single_function)
@@ -76,8 +76,8 @@ BOOST_AUTO_TEST_CASE(single_function)
 		"contract test {\n"
 		"  function f(uint a) returns(uint d) { return a * 7; }\n"
 		"}\n");
-	BOOST_REQUIRE_EQUAL(1, contract.getDefinedFunctions().size());
-	BOOST_CHECK_EQUAL(getSourcePart(*contract.getDefinedFunctions().front()),
+	BOOST_REQUIRE_EQUAL(1, contract.definedFunctions().size());
+	BOOST_CHECK_EQUAL(sourcePart(*contract.definedFunctions().front()),
 					  "function f(uint256 a)returns(uint256 d);");
 }
 
@@ -85,8 +85,8 @@ BOOST_AUTO_TEST_CASE(single_constant_function)
 {
 	ContractDefinition const& contract = checkInterface(
 			"contract test { function f(uint a) constant returns(bytes1 x) { 1==2; } }");
-	BOOST_REQUIRE_EQUAL(1, contract.getDefinedFunctions().size());
-	BOOST_CHECK_EQUAL(getSourcePart(*contract.getDefinedFunctions().front()),
+	BOOST_REQUIRE_EQUAL(1, contract.definedFunctions().size());
+	BOOST_CHECK_EQUAL(sourcePart(*contract.definedFunctions().front()),
 					  "function f(uint256 a)constant returns(bytes1 x);");
 }
 
@@ -99,16 +99,16 @@ BOOST_AUTO_TEST_CASE(multiple_functions)
 	ContractDefinition const& contract = checkInterface(sourceCode);
 	set<string> expectation({"function f(uint256 a)returns(uint256 d);",
 							 "function g(uint256 b)returns(uint256 e);"});
-	BOOST_REQUIRE_EQUAL(2, contract.getDefinedFunctions().size());
-	BOOST_CHECK(expectation == set<string>({getSourcePart(*contract.getDefinedFunctions().at(0)),
-											getSourcePart(*contract.getDefinedFunctions().at(1))}));
+	BOOST_REQUIRE_EQUAL(2, contract.definedFunctions().size());
+	BOOST_CHECK(expectation == set<string>({sourcePart(*contract.definedFunctions().at(0)),
+											sourcePart(*contract.definedFunctions().at(1))}));
 }
 
 BOOST_AUTO_TEST_CASE(exclude_fallback_function)
 {
 	char const* sourceCode = "contract test { function() {} }";
 	ContractDefinition const& contract = checkInterface(sourceCode);
-	BOOST_CHECK_EQUAL(getSourcePart(contract), "contract test{}");
+	BOOST_CHECK_EQUAL(sourcePart(contract), "contract test{}");
 }
 
 BOOST_AUTO_TEST_CASE(events)
@@ -120,7 +120,7 @@ BOOST_AUTO_TEST_CASE(events)
 	"}\n";
 	ContractDefinition const& contract = checkInterface(sourceCode);
 	// events should not appear in the Solidity Interface
-	BOOST_REQUIRE_EQUAL(0, contract.getEvents().size());
+	BOOST_REQUIRE_EQUAL(0, contract.events().size());
 }
 
 BOOST_AUTO_TEST_CASE(inheritance)
@@ -137,9 +137,9 @@ BOOST_AUTO_TEST_CASE(inheritance)
 	ContractDefinition const& contract = checkInterface(sourceCode);
 	set<string> expectedFunctions({"function baseFunction(uint256 p)returns(uint256 i);",
 								   "function derivedFunction(bytes32 p)returns(bytes32 i);"});
-	BOOST_REQUIRE_EQUAL(2, contract.getDefinedFunctions().size());
-	BOOST_CHECK(expectedFunctions == set<string>({getSourcePart(*contract.getDefinedFunctions().at(0)),
-												  getSourcePart(*contract.getDefinedFunctions().at(1))}));
+	BOOST_REQUIRE_EQUAL(2, contract.definedFunctions().size());
+	BOOST_CHECK(expectedFunctions == set<string>({sourcePart(*contract.definedFunctions().at(0)),
+												  sourcePart(*contract.definedFunctions().at(1))}));
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/test/libsolidity/SolidityNameAndTypeResolution.cpp b/test/libsolidity/SolidityNameAndTypeResolution.cpp
index 3daabc85..2a720494 100644
--- a/test/libsolidity/SolidityNameAndTypeResolution.cpp
+++ b/test/libsolidity/SolidityNameAndTypeResolution.cpp
@@ -51,19 +51,19 @@ ASTPointer<SourceUnit> parseTextAndResolveNames(std::string const& _source)
 	resolver.registerDeclarations(*sourceUnit);
 	std::shared_ptr<GlobalContext> globalContext = make_shared<GlobalContext>();
 
-	for (ASTPointer<ASTNode> const& node: sourceUnit->getNodes())
+	for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
 		if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
 		{
 			globalContext->setCurrentContract(*contract);
-			resolver.updateDeclaration(*globalContext->getCurrentThis());
-			resolver.updateDeclaration(*globalContext->getCurrentSuper());
+			resolver.updateDeclaration(*globalContext->currentThis());
+			resolver.updateDeclaration(*globalContext->currentSuper());
 			resolver.resolveNamesAndTypes(*contract);
 		}
-	for (ASTPointer<ASTNode> const& node: sourceUnit->getNodes())
+	for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
 		if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
 		{
 			globalContext->setCurrentContract(*contract);
-			resolver.updateDeclaration(*globalContext->getCurrentThis());
+			resolver.updateDeclaration(*globalContext->currentThis());
 			resolver.checkTypeRequirements(*contract);
 		}
 
@@ -75,7 +75,7 @@ static ContractDefinition const* retrieveContract(ASTPointer<SourceUnit> _source
 {
 	ContractDefinition* contract;
 	unsigned counter = 0;
-	for (ASTPointer<ASTNode> const& node: _source->getNodes())
+	for (ASTPointer<ASTNode> const& node: _source->nodes())
 		if ((contract = dynamic_cast<ContractDefinition*>(node.get())) && counter == index)
 			return contract;
 
@@ -86,7 +86,7 @@ static FunctionTypePointer const& retrieveFunctionBySignature(ContractDefinition
 															  std::string const& _signature)
 {
 	FixedHash<4> hash(dev::sha3(_signature));
-	return _contract->getInterfaceFunctions()[hash];
+	return _contract->interfaceFunctions()[hash];
 }
 
 }
@@ -377,11 +377,11 @@ BOOST_AUTO_TEST_CASE(function_no_implementation)
 		"  function functionName(bytes32 input) returns (bytes32 out);\n"
 		"}\n";
 	ETH_TEST_REQUIRE_NO_THROW(sourceUnit = parseTextAndResolveNames(text), "Parsing and name Resolving failed");
-	std::vector<ASTPointer<ASTNode>> nodes = sourceUnit->getNodes();
+	std::vector<ASTPointer<ASTNode>> nodes = sourceUnit->nodes();
 	ContractDefinition* contract = dynamic_cast<ContractDefinition*>(nodes[0].get());
 	BOOST_CHECK(contract);
 	BOOST_CHECK(!contract->isFullyImplemented());
-	BOOST_CHECK(!contract->getDefinedFunctions()[0]->isFullyImplemented());
+	BOOST_CHECK(!contract->definedFunctions()[0]->isFullyImplemented());
 }
 
 BOOST_AUTO_TEST_CASE(abstract_contract)
@@ -392,15 +392,15 @@ BOOST_AUTO_TEST_CASE(abstract_contract)
 		contract derived is base { function foo() {} }
 		)";
 	ETH_TEST_REQUIRE_NO_THROW(sourceUnit = parseTextAndResolveNames(text), "Parsing and name Resolving failed");
-	std::vector<ASTPointer<ASTNode>> nodes = sourceUnit->getNodes();
+	std::vector<ASTPointer<ASTNode>> nodes = sourceUnit->nodes();
 	ContractDefinition* base = dynamic_cast<ContractDefinition*>(nodes[0].get());
 	ContractDefinition* derived = dynamic_cast<ContractDefinition*>(nodes[1].get());
 	BOOST_CHECK(base);
 	BOOST_CHECK(!base->isFullyImplemented());
-	BOOST_CHECK(!base->getDefinedFunctions()[0]->isFullyImplemented());
+	BOOST_CHECK(!base->definedFunctions()[0]->isFullyImplemented());
 	BOOST_CHECK(derived);
 	BOOST_CHECK(derived->isFullyImplemented());
-	BOOST_CHECK(derived->getDefinedFunctions()[0]->isFullyImplemented());
+	BOOST_CHECK(derived->definedFunctions()[0]->isFullyImplemented());
 }
 
 BOOST_AUTO_TEST_CASE(abstract_contract_with_overload)
@@ -411,7 +411,7 @@ BOOST_AUTO_TEST_CASE(abstract_contract_with_overload)
 		contract derived is base { function foo(uint) {} }
 		)";
 	ETH_TEST_REQUIRE_NO_THROW(sourceUnit = parseTextAndResolveNames(text), "Parsing and name Resolving failed");
-	std::vector<ASTPointer<ASTNode>> nodes = sourceUnit->getNodes();
+	std::vector<ASTPointer<ASTNode>> nodes = sourceUnit->nodes();
 	ContractDefinition* base = dynamic_cast<ContractDefinition*>(nodes[0].get());
 	ContractDefinition* derived = dynamic_cast<ContractDefinition*>(nodes[1].get());
 	BOOST_REQUIRE(base);
@@ -459,7 +459,7 @@ BOOST_AUTO_TEST_CASE(abstract_contract_constructor_args_not_provided)
 		}
 		)";
 	ETH_TEST_REQUIRE_NO_THROW(sourceUnit = parseTextAndResolveNames(text), "Parsing and name resolving failed");
-	std::vector<ASTPointer<ASTNode>> nodes = sourceUnit->getNodes();
+	std::vector<ASTPointer<ASTNode>> nodes = sourceUnit->nodes();
 	BOOST_CHECK_EQUAL(nodes.size(), 3);
 	ContractDefinition* derived = dynamic_cast<ContractDefinition*>(nodes[2].get());
 	BOOST_CHECK(derived);
@@ -486,10 +486,10 @@ BOOST_AUTO_TEST_CASE(function_canonical_signature)
 					   "  }\n"
 					   "}\n";
 	ETH_TEST_REQUIRE_NO_THROW(sourceUnit = parseTextAndResolveNames(text), "Parsing and name Resolving failed");
-	for (ASTPointer<ASTNode> const& node: sourceUnit->getNodes())
+	for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
 		if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
 		{
-			auto functions = contract->getDefinedFunctions();
+			auto functions = contract->definedFunctions();
 			BOOST_CHECK_EQUAL("foo(uint256,uint64,bool)", functions[0]->externalSignature());
 		}
 }
@@ -503,10 +503,10 @@ BOOST_AUTO_TEST_CASE(function_canonical_signature_type_aliases)
 					   "  }\n"
 					   "}\n";
 	ETH_TEST_REQUIRE_NO_THROW(sourceUnit = parseTextAndResolveNames(text), "Parsing and name Resolving failed");
-	for (ASTPointer<ASTNode> const& node: sourceUnit->getNodes())
+	for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
 		if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
 		{
-			auto functions = contract->getDefinedFunctions();
+			auto functions = contract->definedFunctions();
 			if (functions.empty())
 				continue;
 			BOOST_CHECK_EQUAL("boo(uint256,bytes32,address)", functions[0]->externalSignature());
@@ -526,10 +526,10 @@ BOOST_AUTO_TEST_CASE(function_external_types)
 			}
 		})";
 	ETH_TEST_REQUIRE_NO_THROW(sourceUnit = parseTextAndResolveNames(text), "Parsing and name Resolving failed");
-	for (ASTPointer<ASTNode> const& node: sourceUnit->getNodes())
+	for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
 		if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
 		{
-			auto functions = contract->getDefinedFunctions();
+			auto functions = contract->definedFunctions();
 			if (functions.empty())
 				continue;
 			BOOST_CHECK_EQUAL("boo(uint256,bool,bytes8,bool[2],uint256[],address,address[])", functions[0]->externalSignature());
@@ -548,10 +548,10 @@ BOOST_AUTO_TEST_CASE(enum_external_type)
 			}
 		})";
 	ETH_TEST_REQUIRE_NO_THROW(sourceUnit = parseTextAndResolveNames(text), "Parsing and name Resolving failed");
-	for (ASTPointer<ASTNode> const& node: sourceUnit->getNodes())
+	for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
 		if (ContractDefinition* contract = dynamic_cast<ContractDefinition*>(node.get()))
 		{
-			auto functions = contract->getDefinedFunctions();
+			auto functions = contract->definedFunctions();
 			if (functions.empty())
 				continue;
 			BOOST_CHECK_EQUAL("boo(uint8)", functions[0]->externalSignature());
@@ -880,24 +880,24 @@ BOOST_AUTO_TEST_CASE(state_variable_accessors)
 	BOOST_REQUIRE((contract = retrieveContract(source, 0)) != nullptr);
 	FunctionTypePointer function = retrieveFunctionBySignature(contract, "foo()");
 	BOOST_REQUIRE(function && function->hasDeclaration());
-	auto returnParams = function->getReturnParameterTypeNames();
+	auto returnParams = function->returnParameterTypeNames();
 	BOOST_CHECK_EQUAL(returnParams.at(0), "uint256");
 	BOOST_CHECK(function->isConstant());
 
 	function = retrieveFunctionBySignature(contract, "map(uint256)");
 	BOOST_REQUIRE(function && function->hasDeclaration());
-	auto params = function->getParameterTypeNames();
+	auto params = function->parameterTypeNames();
 	BOOST_CHECK_EQUAL(params.at(0), "uint256");
-	returnParams = function->getReturnParameterTypeNames();
+	returnParams = function->returnParameterTypeNames();
 	BOOST_CHECK_EQUAL(returnParams.at(0), "bytes4");
 	BOOST_CHECK(function->isConstant());
 
 	function = retrieveFunctionBySignature(contract, "multiple_map(uint256,uint256)");
 	BOOST_REQUIRE(function && function->hasDeclaration());
-	params = function->getParameterTypeNames();
+	params = function->parameterTypeNames();
 	BOOST_CHECK_EQUAL(params.at(0), "uint256");
 	BOOST_CHECK_EQUAL(params.at(1), "uint256");
-	returnParams = function->getReturnParameterTypeNames();
+	returnParams = function->returnParameterTypeNames();
 	BOOST_CHECK_EQUAL(returnParams.at(0), "bytes4");
 	BOOST_CHECK(function->isConstant());
 }
@@ -1050,7 +1050,6 @@ BOOST_AUTO_TEST_CASE(event_too_many_indexed)
 	char const* text = R"(
 		contract c {
 			event e(uint indexed a, bytes3 indexed b, bool indexed c, uint indexed d);
-			function f() { e(2, "abc", true); }
 		})";
 	BOOST_CHECK_THROW(parseTextAndResolveNames(text), TypeError);
 }
@@ -2194,6 +2193,80 @@ BOOST_AUTO_TEST_CASE(string_bytes_conversion)
 	BOOST_CHECK_NO_THROW(parseTextAndResolveNames(text));
 }
 
+BOOST_AUTO_TEST_CASE(inheriting_from_library)
+{
+	char const* text = R"(
+		library Lib {}
+		contract Test is Lib {}
+	)";
+	BOOST_CHECK_THROW(parseTextAndResolveNames(text), TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(inheriting_library)
+{
+	char const* text = R"(
+		contract Test {}
+		library Lib is Test {}
+	)";
+	BOOST_CHECK_THROW(parseTextAndResolveNames(text), TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(library_having_variables)
+{
+	char const* text = R"(
+		library Lib { uint x; }
+	)";
+	BOOST_CHECK_THROW(parseTextAndResolveNames(text), TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(valid_library)
+{
+	char const* text = R"(
+		library Lib { uint constant x = 9; }
+	)";
+	BOOST_CHECK_NO_THROW(parseTextAndResolveNames(text));
+}
+
+BOOST_AUTO_TEST_CASE(call_to_library_function)
+{
+	char const* text = R"(
+		library Lib {
+			uint constant public pimil = 3141592;
+			function min(uint x, uint y) returns (uint);
+		}
+		contract Test {
+			function f() {
+				uint t = Lib.min(Lib.pimil(), 7);
+			}
+		}
+	)";
+	BOOST_CHECK_NO_THROW(parseTextAndResolveNames(text));
+}
+
+BOOST_AUTO_TEST_CASE(creating_contract_within_the_contract)
+{
+	char const* sourceCode = R"(
+		contract Test {
+			function f() { var x = new Test(); }
+		}
+	)";
+	BOOST_CHECK_THROW(parseTextAndResolveNames(sourceCode), TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(array_out_of_bound_access)
+{
+	char const* text = R"(
+		contract c {
+			uint[2] dataArray;
+			function set5th() returns (bool) {
+				dataArray[5] = 2;
+				return true;
+			}
+		}
+	)";
+	BOOST_CHECK_THROW(parseTextAndResolveNames(text), TypeError);
+}
+
 BOOST_AUTO_TEST_SUITE_END()
 
 }
diff --git a/test/libsolidity/SolidityNatspecJSON.cpp b/test/libsolidity/SolidityNatspecJSON.cpp
index 73c080f7..5d20fe7b 100644
--- a/test/libsolidity/SolidityNatspecJSON.cpp
+++ b/test/libsolidity/SolidityNatspecJSON.cpp
@@ -49,9 +49,9 @@ public:
 		ETH_TEST_REQUIRE_NO_THROW(m_compilerStack.parse(_code), "Parsing failed");
 
 		if (_userDocumentation)
-			generatedDocumentationString = m_compilerStack.getMetadata("", DocumentationType::NatspecUser);
+			generatedDocumentationString = m_compilerStack.metadata("", DocumentationType::NatspecUser);
 		else
-			generatedDocumentationString = m_compilerStack.getMetadata("", DocumentationType::NatspecDev);
+			generatedDocumentationString = m_compilerStack.metadata("", DocumentationType::NatspecDev);
 		Json::Value generatedDocumentation;
 		m_reader.parse(generatedDocumentationString, generatedDocumentation);
 		Json::Value expectedDocumentation;
@@ -527,6 +527,22 @@ BOOST_AUTO_TEST_CASE(natspec_multiline_notice_without_tag)
 	checkNatspec(sourceCode, natspec, true);
 }
 
+BOOST_AUTO_TEST_CASE(empty_comment)
+{
+	char const* sourceCode = R"(
+		//
+		contract test
+		{}
+	)";
+	char const* natspec = R"ABCDEF(
+	{
+	   "methods" : {}
+	}
+	)ABCDEF";
+
+	checkNatspec(sourceCode, natspec, true);
+}
+
 BOOST_AUTO_TEST_SUITE_END()
 
 }
diff --git a/test/libsolidity/SolidityOptimizer.cpp b/test/libsolidity/SolidityOptimizer.cpp
index 85a88c03..20d59a04 100644
--- a/test/libsolidity/SolidityOptimizer.cpp
+++ b/test/libsolidity/SolidityOptimizer.cpp
@@ -101,7 +101,7 @@ public:
 		return state;
 	}
 
-	AssemblyItems getCSE(AssemblyItems const& _input, eth::KnownState const& _state = eth::KnownState())
+	AssemblyItems CSE(AssemblyItems const& _input, eth::KnownState const& _state = eth::KnownState())
 	{
 		AssemblyItems input = addDummyLocations(_input);
 
@@ -111,7 +111,7 @@ public:
 
 		for (AssemblyItem const& item: output)
 		{
-			BOOST_CHECK(item == Instruction::POP || !item.getLocation().isEmpty());
+			BOOST_CHECK(item == Instruction::POP || !item.location().isEmpty());
 		}
 		return output;
 	}
@@ -122,11 +122,11 @@ public:
 		KnownState const& _state = eth::KnownState()
 	)
 	{
-		AssemblyItems output = getCSE(_input, _state);
+		AssemblyItems output = CSE(_input, _state);
 		BOOST_CHECK_EQUAL_COLLECTIONS(_expectation.begin(), _expectation.end(), output.begin(), output.end());
 	}
 
-	AssemblyItems getCFG(AssemblyItems const& _input)
+	AssemblyItems CFG(AssemblyItems const& _input)
 	{
 		AssemblyItems output = _input;
 		// Running it four times should be enough for these tests.
@@ -144,7 +144,7 @@ public:
 
 	void checkCFG(AssemblyItems const& _input, AssemblyItems const& _expectation)
 	{
-		AssemblyItems output = getCFG(_input);
+		AssemblyItems output = CFG(_input);
 		BOOST_CHECK_EQUAL_COLLECTIONS(_expectation.begin(), _expectation.end(), output.begin(), output.end());
 	}
 
@@ -890,7 +890,7 @@ BOOST_AUTO_TEST_CASE(cse_sha3_twice_same_content_noninterfering_store_in_between
 		Instruction::SHA3 // sha3(m[12..(12+32)])
 	};
 	// if this changes too often, only count the number of SHA3 and MSTORE instructions
-	AssemblyItems output = getCSE(input);
+	AssemblyItems output = CSE(input);
 	BOOST_CHECK_EQUAL(4, count(output.begin(), output.end(), AssemblyItem(Instruction::MSTORE)));
 	BOOST_CHECK_EQUAL(1, count(output.begin(), output.end(), AssemblyItem(Instruction::SHA3)));
 }
@@ -914,7 +914,7 @@ BOOST_AUTO_TEST_CASE(cse_equality_on_initially_known_stack)
 	AssemblyItems input{
 		Instruction::EQ
 	};
-	AssemblyItems output = getCSE(input, state);
+	AssemblyItems output = CSE(input, state);
 	// check that it directly pushes 1 (true)
 	BOOST_CHECK(find(output.begin(), output.end(), AssemblyItem(u256(1))) != output.end());
 }
@@ -938,7 +938,7 @@ BOOST_AUTO_TEST_CASE(cse_access_previous_sequence)
 		u256(0),
 		Instruction::SLOAD,
 	};
-	BOOST_CHECK_THROW(getCSE(input, state), StackTooDeepException);
+	BOOST_CHECK_THROW(CSE(input, state), StackTooDeepException);
 	// @todo for now, this throws an exception, but it should recover to the following
 	// (or an even better version) at some point:
 	// 0, SLOAD, 1, ADD, SSTORE, 0 SLOAD
diff --git a/test/libsolidity/SolidityParser.cpp b/test/libsolidity/SolidityParser.cpp
index 438e650b..1e034863 100644
--- a/test/libsolidity/SolidityParser.cpp
+++ b/test/libsolidity/SolidityParser.cpp
@@ -43,7 +43,7 @@ ASTPointer<ContractDefinition> parseText(std::string const& _source)
 {
 	Parser parser;
 	ASTPointer<SourceUnit> sourceUnit = parser.parse(std::make_shared<Scanner>(CharStream(_source)));
-	for (ASTPointer<ASTNode> const& node: sourceUnit->getNodes())
+	for (ASTPointer<ASTNode> const& node: sourceUnit->nodes())
 		if (ASTPointer<ContractDefinition> contract = dynamic_pointer_cast<ContractDefinition>(node))
 			return contract;
 	BOOST_FAIL("No contract found in source.");
@@ -53,7 +53,7 @@ ASTPointer<ContractDefinition> parseText(std::string const& _source)
 static void checkFunctionNatspec(ASTPointer<FunctionDefinition> _function,
 								 std::string const& _expectedDoc)
 {
-	auto doc = _function->getDocumentation();
+	auto doc = _function->documentation();
 	BOOST_CHECK_MESSAGE(doc != nullptr, "Function does not have Natspec Doc as expected");
 	BOOST_CHECK_EQUAL(*doc, _expectedDoc);
 }
@@ -169,7 +169,7 @@ BOOST_AUTO_TEST_CASE(function_natspec_documentation)
 					   "  function functionName(bytes32 input) returns (bytes32 out) {}\n"
 					   "}\n";
 	ETH_TEST_REQUIRE_NO_THROW(contract = parseText(text), "Parsing failed");
-	auto functions = contract->getDefinedFunctions();
+	auto functions = contract->definedFunctions();
 	ETH_TEST_REQUIRE_NO_THROW(function = functions.at(0), "Failed to retrieve function");
 	checkFunctionNatspec(function, "This is a test function");
 }
@@ -184,9 +184,9 @@ BOOST_AUTO_TEST_CASE(function_normal_comments)
 					   "  function functionName(bytes32 input) returns (bytes32 out) {}\n"
 					   "}\n";
 	ETH_TEST_REQUIRE_NO_THROW(contract = parseText(text), "Parsing failed");
-	auto functions = contract->getDefinedFunctions();
+	auto functions = contract->definedFunctions();
 	ETH_TEST_REQUIRE_NO_THROW(function = functions.at(0), "Failed to retrieve function");
-	BOOST_CHECK_MESSAGE(function->getDocumentation() == nullptr,
+	BOOST_CHECK_MESSAGE(function->documentation() == nullptr,
 						"Should not have gotten a Natspecc comment for this function");
 }
 
@@ -206,7 +206,7 @@ BOOST_AUTO_TEST_CASE(multiple_functions_natspec_documentation)
 					   "  function functionName4(bytes32 input) returns (bytes32 out) {}\n"
 					   "}\n";
 	ETH_TEST_REQUIRE_NO_THROW(contract = parseText(text), "Parsing failed");
-	auto functions = contract->getDefinedFunctions();
+	auto functions = contract->definedFunctions();
 
 	ETH_TEST_REQUIRE_NO_THROW(function = functions.at(0), "Failed to retrieve function");
 	checkFunctionNatspec(function, "This is test function 1");
@@ -215,7 +215,7 @@ BOOST_AUTO_TEST_CASE(multiple_functions_natspec_documentation)
 	checkFunctionNatspec(function, "This is test function 2");
 
 	ETH_TEST_REQUIRE_NO_THROW(function = functions.at(2), "Failed to retrieve function");
-	BOOST_CHECK_MESSAGE(function->getDocumentation() == nullptr,
+	BOOST_CHECK_MESSAGE(function->documentation() == nullptr,
 						"Should not have gotten natspec comment for functionName3()");
 
 	ETH_TEST_REQUIRE_NO_THROW(function = functions.at(3), "Failed to retrieve function");
@@ -233,7 +233,7 @@ BOOST_AUTO_TEST_CASE(multiline_function_documentation)
 					   "  function functionName1(bytes32 input) returns (bytes32 out) {}\n"
 					   "}\n";
 	ETH_TEST_REQUIRE_NO_THROW(contract = parseText(text), "Parsing failed");
-	auto functions = contract->getDefinedFunctions();
+	auto functions = contract->definedFunctions();
 
 	ETH_TEST_REQUIRE_NO_THROW(function = functions.at(0), "Failed to retrieve function");
 	checkFunctionNatspec(function, "This is a test function\n"
@@ -258,7 +258,7 @@ BOOST_AUTO_TEST_CASE(natspec_comment_in_function_body)
 					   "  function fun(bytes32 input) returns (bytes32 out) {}\n"
 					   "}\n";
 	ETH_TEST_REQUIRE_NO_THROW(contract = parseText(text), "Parsing failed");
-	auto functions = contract->getDefinedFunctions();
+	auto functions = contract->definedFunctions();
 
 	ETH_TEST_REQUIRE_NO_THROW(function = functions.at(0), "Failed to retrieve function");
 	checkFunctionNatspec(function, "fun1 description");
@@ -284,10 +284,10 @@ BOOST_AUTO_TEST_CASE(natspec_docstring_between_keyword_and_signature)
 					   "  }\n"
 					   "}\n";
 	ETH_TEST_REQUIRE_NO_THROW(contract = parseText(text), "Parsing failed");
-	auto functions = contract->getDefinedFunctions();
+	auto functions = contract->definedFunctions();
 
 	ETH_TEST_REQUIRE_NO_THROW(function = functions.at(0), "Failed to retrieve function");
-	BOOST_CHECK_MESSAGE(!function->getDocumentation(),
+	BOOST_CHECK_MESSAGE(!function->documentation(),
 						"Shouldn't get natspec docstring for this function");
 }
 
@@ -307,10 +307,10 @@ BOOST_AUTO_TEST_CASE(natspec_docstring_after_signature)
 					   "  }\n"
 					   "}\n";
 	ETH_TEST_REQUIRE_NO_THROW(contract = parseText(text), "Parsing failed");
-	auto functions = contract->getDefinedFunctions();
+	auto functions = contract->definedFunctions();
 
 	ETH_TEST_REQUIRE_NO_THROW(function = functions.at(0), "Failed to retrieve function");
-	BOOST_CHECK_MESSAGE(!function->getDocumentation(),
+	BOOST_CHECK_MESSAGE(!function->documentation(),
 						"Shouldn't get natspec docstring for this function");
 }
 
@@ -914,6 +914,26 @@ BOOST_AUTO_TEST_CASE(location_specifiers_with_var)
 	BOOST_CHECK_THROW(parseText(text), ParserError);
 }
 
+BOOST_AUTO_TEST_CASE(empty_comment)
+{
+	char const* text = R"(
+		//
+		contract test
+		{}
+	)";
+	BOOST_CHECK_NO_THROW(parseText(text));
+}
+
+BOOST_AUTO_TEST_CASE(library_simple)
+{
+	char const* text = R"(
+		library Lib {
+			function f() { }
+		}
+	)";
+	BOOST_CHECK_NO_THROW(parseText(text));
+}
+
 BOOST_AUTO_TEST_SUITE_END()
 
 }
diff --git a/test/libsolidity/SolidityScanner.cpp b/test/libsolidity/SolidityScanner.cpp
index 8d3e5392..dadcd903 100644
--- a/test/libsolidity/SolidityScanner.cpp
+++ b/test/libsolidity/SolidityScanner.cpp
@@ -35,49 +35,49 @@ BOOST_AUTO_TEST_SUITE(SolidityScanner)
 BOOST_AUTO_TEST_CASE(test_empty)
 {
 	Scanner scanner(CharStream(""));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::EOS);
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::EOS);
 }
 
 BOOST_AUTO_TEST_CASE(smoke_test)
 {
 	Scanner scanner(CharStream("function break;765  \t  \"string1\",'string2'\nidentifier1"));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::Function);
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::Function);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Break);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Semicolon);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Number);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLiteral(), "765");
+	BOOST_CHECK_EQUAL(scanner.currentLiteral(), "765");
 	BOOST_CHECK_EQUAL(scanner.next(), Token::StringLiteral);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLiteral(), "string1");
+	BOOST_CHECK_EQUAL(scanner.currentLiteral(), "string1");
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Comma);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::StringLiteral);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLiteral(), "string2");
+	BOOST_CHECK_EQUAL(scanner.currentLiteral(), "string2");
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Identifier);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLiteral(), "identifier1");
+	BOOST_CHECK_EQUAL(scanner.currentLiteral(), "identifier1");
 	BOOST_CHECK_EQUAL(scanner.next(), Token::EOS);
 }
 
 BOOST_AUTO_TEST_CASE(string_escapes)
 {
 	Scanner scanner(CharStream("  { \"a\\x61\""));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::LBrace);
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::LBrace);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::StringLiteral);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLiteral(), "aa");
+	BOOST_CHECK_EQUAL(scanner.currentLiteral(), "aa");
 }
 
 BOOST_AUTO_TEST_CASE(string_escapes_with_zero)
 {
 	Scanner scanner(CharStream("  { \"a\\x61\\x00abc\""));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::LBrace);
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::LBrace);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::StringLiteral);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLiteral(), std::string("aa\0abc", 6));
+	BOOST_CHECK_EQUAL(scanner.currentLiteral(), std::string("aa\0abc", 6));
 }
 
 BOOST_AUTO_TEST_CASE(string_escape_illegal)
 {
 	Scanner scanner(CharStream(" bla \"\\x6rf\" (illegalescape)"));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::Identifier);
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::Identifier);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Illegal);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLiteral(), "");
+	BOOST_CHECK_EQUAL(scanner.currentLiteral(), "");
 	// TODO recovery from illegal tokens should be improved
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Illegal);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Identifier);
@@ -88,11 +88,11 @@ BOOST_AUTO_TEST_CASE(string_escape_illegal)
 BOOST_AUTO_TEST_CASE(hex_numbers)
 {
 	Scanner scanner(CharStream("var x = 0x765432536763762734623472346;"));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::Var);
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::Var);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Identifier);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Assign);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Number);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLiteral(), "0x765432536763762734623472346");
+	BOOST_CHECK_EQUAL(scanner.currentLiteral(), "0x765432536763762734623472346");
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Semicolon);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::EOS);
 }
@@ -100,23 +100,23 @@ BOOST_AUTO_TEST_CASE(hex_numbers)
 BOOST_AUTO_TEST_CASE(negative_numbers)
 {
 	Scanner scanner(CharStream("var x = -.2 + -0x78 + -7.3 + 8.9;"));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::Var);
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::Var);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Identifier);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Assign);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Sub);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Number);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLiteral(), ".2");
+	BOOST_CHECK_EQUAL(scanner.currentLiteral(), ".2");
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Add);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Sub);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Number);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLiteral(), "0x78");
+	BOOST_CHECK_EQUAL(scanner.currentLiteral(), "0x78");
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Add);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Sub);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Number);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLiteral(), "7.3");
+	BOOST_CHECK_EQUAL(scanner.currentLiteral(), "7.3");
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Add);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Number);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLiteral(), "8.9");
+	BOOST_CHECK_EQUAL(scanner.currentLiteral(), "8.9");
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Semicolon);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::EOS);
 }
@@ -124,22 +124,22 @@ BOOST_AUTO_TEST_CASE(negative_numbers)
 BOOST_AUTO_TEST_CASE(locations)
 {
 	Scanner scanner(CharStream("function_identifier has ; -0x743/*comment*/\n ident //comment"));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::Identifier);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLocation().start, 0);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLocation().end, 19);
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::Identifier);
+	BOOST_CHECK_EQUAL(scanner.currentLocation().start, 0);
+	BOOST_CHECK_EQUAL(scanner.currentLocation().end, 19);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Identifier);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLocation().start, 20);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLocation().end, 23);
+	BOOST_CHECK_EQUAL(scanner.currentLocation().start, 20);
+	BOOST_CHECK_EQUAL(scanner.currentLocation().end, 23);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Semicolon);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLocation().start, 24);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLocation().end, 25);
+	BOOST_CHECK_EQUAL(scanner.currentLocation().start, 24);
+	BOOST_CHECK_EQUAL(scanner.currentLocation().end, 25);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Sub);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Number);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLocation().start, 27);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLocation().end, 32);
+	BOOST_CHECK_EQUAL(scanner.currentLocation().start, 27);
+	BOOST_CHECK_EQUAL(scanner.currentLocation().end, 32);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Identifier);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLocation().start, 45);
-	BOOST_CHECK_EQUAL(scanner.getCurrentLocation().end, 50);
+	BOOST_CHECK_EQUAL(scanner.currentLocation().start, 45);
+	BOOST_CHECK_EQUAL(scanner.currentLocation().end, 50);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::EOS);
 }
 
@@ -147,7 +147,7 @@ BOOST_AUTO_TEST_CASE(ambiguities)
 {
 	// test scanning of some operators which need look-ahead
 	Scanner scanner(CharStream("<=""<""+ +=a++ =>""<<"));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::LessThanOrEqual);
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::LessThanOrEqual);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::LessThan);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Add);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::AssignAdd);
@@ -160,25 +160,25 @@ BOOST_AUTO_TEST_CASE(ambiguities)
 BOOST_AUTO_TEST_CASE(documentation_comments_parsed_begin)
 {
 	Scanner scanner(CharStream("/// Send $(value / 1000) chocolates to the user"));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::EOS);
-	BOOST_CHECK_EQUAL(scanner.getCurrentCommentLiteral(), "Send $(value / 1000) chocolates to the user");
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::EOS);
+	BOOST_CHECK_EQUAL(scanner.currentCommentLiteral(), "Send $(value / 1000) chocolates to the user");
 }
 
 BOOST_AUTO_TEST_CASE(multiline_documentation_comments_parsed_begin)
 {
 	Scanner scanner(CharStream("/** Send $(value / 1000) chocolates to the user*/"));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::EOS);
-	BOOST_CHECK_EQUAL(scanner.getCurrentCommentLiteral(), "Send $(value / 1000) chocolates to the user");
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::EOS);
+	BOOST_CHECK_EQUAL(scanner.currentCommentLiteral(), "Send $(value / 1000) chocolates to the user");
 }
 
 BOOST_AUTO_TEST_CASE(documentation_comments_parsed)
 {
 	Scanner scanner(CharStream("some other tokens /// Send $(value / 1000) chocolates to the user"));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::Identifier);
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::Identifier);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Identifier);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Identifier);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::EOS);
-	BOOST_CHECK_EQUAL(scanner.getCurrentCommentLiteral(), "Send $(value / 1000) chocolates to the user");
+	BOOST_CHECK_EQUAL(scanner.currentCommentLiteral(), "Send $(value / 1000) chocolates to the user");
 }
 
 BOOST_AUTO_TEST_CASE(multiline_documentation_comments_parsed)
@@ -186,11 +186,11 @@ BOOST_AUTO_TEST_CASE(multiline_documentation_comments_parsed)
 	Scanner scanner(CharStream("some other tokens /**\n"
 							   "* Send $(value / 1000) chocolates to the user\n"
 							   "*/"));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::Identifier);
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::Identifier);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Identifier);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Identifier);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::EOS);
-	BOOST_CHECK_EQUAL(scanner.getCurrentCommentLiteral(), "Send $(value / 1000) chocolates to the user");
+	BOOST_CHECK_EQUAL(scanner.currentCommentLiteral(), "Send $(value / 1000) chocolates to the user");
 }
 
 BOOST_AUTO_TEST_CASE(multiline_documentation_no_stars)
@@ -198,11 +198,11 @@ BOOST_AUTO_TEST_CASE(multiline_documentation_no_stars)
 	Scanner scanner(CharStream("some other tokens /**\n"
 							   " Send $(value / 1000) chocolates to the user\n"
 							   "*/"));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::Identifier);
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::Identifier);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Identifier);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Identifier);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::EOS);
-	BOOST_CHECK_EQUAL(scanner.getCurrentCommentLiteral(), "Send $(value / 1000) chocolates to the user");
+	BOOST_CHECK_EQUAL(scanner.currentCommentLiteral(), "Send $(value / 1000) chocolates to the user");
 }
 
 BOOST_AUTO_TEST_CASE(multiline_documentation_whitespace_hell)
@@ -210,39 +210,39 @@ BOOST_AUTO_TEST_CASE(multiline_documentation_whitespace_hell)
 	Scanner scanner(CharStream("some other tokens /** \t \r \n"
 							   "\t \r  * Send $(value / 1000) chocolates to the user\n"
 							   "*/"));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::Identifier);
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::Identifier);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Identifier);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Identifier);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::EOS);
-	BOOST_CHECK_EQUAL(scanner.getCurrentCommentLiteral(), "Send $(value / 1000) chocolates to the user");
+	BOOST_CHECK_EQUAL(scanner.currentCommentLiteral(), "Send $(value / 1000) chocolates to the user");
 }
 
 BOOST_AUTO_TEST_CASE(comment_before_eos)
 {
 	Scanner scanner(CharStream("//"));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::EOS);
-	BOOST_CHECK_EQUAL(scanner.getCurrentCommentLiteral(), "");
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::EOS);
+	BOOST_CHECK_EQUAL(scanner.currentCommentLiteral(), "");
 }
 
 BOOST_AUTO_TEST_CASE(documentation_comment_before_eos)
 {
 	Scanner scanner(CharStream("///"));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::EOS);
-	BOOST_CHECK_EQUAL(scanner.getCurrentCommentLiteral(), "");
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::EOS);
+	BOOST_CHECK_EQUAL(scanner.currentCommentLiteral(), "");
 }
 
 BOOST_AUTO_TEST_CASE(empty_multiline_comment)
 {
 	Scanner scanner(CharStream("/**/"));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::EOS);
-	BOOST_CHECK_EQUAL(scanner.getCurrentCommentLiteral(), "");
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::EOS);
+	BOOST_CHECK_EQUAL(scanner.currentCommentLiteral(), "");
 }
 
 BOOST_AUTO_TEST_CASE(empty_multiline_documentation_comment_before_eos)
 {
 	Scanner scanner(CharStream("/***/"));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::EOS);
-	BOOST_CHECK_EQUAL(scanner.getCurrentCommentLiteral(), "");
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::EOS);
+	BOOST_CHECK_EQUAL(scanner.currentCommentLiteral(), "");
 }
 
 BOOST_AUTO_TEST_CASE(comments_mixed_in_sequence)
@@ -250,15 +250,15 @@ BOOST_AUTO_TEST_CASE(comments_mixed_in_sequence)
 	Scanner scanner(CharStream("hello_world ///documentation comment \n"
 							   "//simple comment \n"
 							   "<<"));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::Identifier);
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::Identifier);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::SHL);
-	BOOST_CHECK_EQUAL(scanner.getCurrentCommentLiteral(), "documentation comment ");
+	BOOST_CHECK_EQUAL(scanner.currentCommentLiteral(), "documentation comment ");
 }
 
 BOOST_AUTO_TEST_CASE(ether_subdenominations)
 {
 	Scanner scanner(CharStream("wei szabo finney ether"));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::SubWei);
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::SubWei);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::SubSzabo);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::SubFinney);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::SubEther);
@@ -267,7 +267,7 @@ BOOST_AUTO_TEST_CASE(ether_subdenominations)
 BOOST_AUTO_TEST_CASE(time_subdenominations)
 {
 	Scanner scanner(CharStream("seconds minutes hours days weeks years"));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::SubSecond);
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::SubSecond);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::SubMinute);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::SubHour);
 	BOOST_CHECK_EQUAL(scanner.next(), Token::SubDay);
@@ -278,7 +278,17 @@ BOOST_AUTO_TEST_CASE(time_subdenominations)
 BOOST_AUTO_TEST_CASE(time_after)
 {
 	Scanner scanner(CharStream("after 1"));
-	BOOST_CHECK_EQUAL(scanner.getCurrentToken(), Token::After);
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::After);
+}
+
+BOOST_AUTO_TEST_CASE(empty_comment)
+{
+	Scanner scanner(CharStream("//\ncontract{}"));
+	BOOST_CHECK_EQUAL(scanner.currentCommentLiteral(), "");
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::Contract);
+	BOOST_CHECK_EQUAL(scanner.next(), Token::LBrace);
+	BOOST_CHECK_EQUAL(scanner.next(), Token::RBrace);
+
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/test/libsolidity/SolidityTypes.cpp b/test/libsolidity/SolidityTypes.cpp
index 7892de67..fc97667c 100644
--- a/test/libsolidity/SolidityTypes.cpp
+++ b/test/libsolidity/SolidityTypes.cpp
@@ -41,13 +41,13 @@ BOOST_AUTO_TEST_CASE(storage_layout_simple)
 		{string("second"), Type::fromElementaryTypeName("uint120")},
 		{string("wraps"), Type::fromElementaryTypeName("uint16")}
 	}));
-	BOOST_REQUIRE_EQUAL(u256(2), members.getStorageSize());
-	BOOST_REQUIRE(members.getMemberStorageOffset("first") != nullptr);
-	BOOST_REQUIRE(members.getMemberStorageOffset("second") != nullptr);
-	BOOST_REQUIRE(members.getMemberStorageOffset("wraps") != nullptr);
-	BOOST_CHECK(*members.getMemberStorageOffset("first") == make_pair(u256(0), unsigned(0)));
-	BOOST_CHECK(*members.getMemberStorageOffset("second") == make_pair(u256(0), unsigned(16)));
-	BOOST_CHECK(*members.getMemberStorageOffset("wraps") == make_pair(u256(1), unsigned(0)));
+	BOOST_REQUIRE_EQUAL(u256(2), members.storageSize());
+	BOOST_REQUIRE(members.memberStorageOffset("first") != nullptr);
+	BOOST_REQUIRE(members.memberStorageOffset("second") != nullptr);
+	BOOST_REQUIRE(members.memberStorageOffset("wraps") != nullptr);
+	BOOST_CHECK(*members.memberStorageOffset("first") == make_pair(u256(0), unsigned(0)));
+	BOOST_CHECK(*members.memberStorageOffset("second") == make_pair(u256(0), unsigned(16)));
+	BOOST_CHECK(*members.memberStorageOffset("wraps") == make_pair(u256(1), unsigned(0)));
 }
 
 BOOST_AUTO_TEST_CASE(storage_layout_mapping)
@@ -64,26 +64,26 @@ BOOST_AUTO_TEST_CASE(storage_layout_mapping)
 			Type::fromElementaryTypeName("uint8")
 		)},
 	}));
-	BOOST_REQUIRE_EQUAL(u256(4), members.getStorageSize());
-	BOOST_REQUIRE(members.getMemberStorageOffset("first") != nullptr);
-	BOOST_REQUIRE(members.getMemberStorageOffset("second") != nullptr);
-	BOOST_REQUIRE(members.getMemberStorageOffset("third") != nullptr);
-	BOOST_REQUIRE(members.getMemberStorageOffset("final") != nullptr);
-	BOOST_CHECK(*members.getMemberStorageOffset("first") == make_pair(u256(0), unsigned(0)));
-	BOOST_CHECK(*members.getMemberStorageOffset("second") == make_pair(u256(1), unsigned(0)));
-	BOOST_CHECK(*members.getMemberStorageOffset("third") == make_pair(u256(2), unsigned(0)));
-	BOOST_CHECK(*members.getMemberStorageOffset("final") == make_pair(u256(3), unsigned(0)));
+	BOOST_REQUIRE_EQUAL(u256(4), members.storageSize());
+	BOOST_REQUIRE(members.memberStorageOffset("first") != nullptr);
+	BOOST_REQUIRE(members.memberStorageOffset("second") != nullptr);
+	BOOST_REQUIRE(members.memberStorageOffset("third") != nullptr);
+	BOOST_REQUIRE(members.memberStorageOffset("final") != nullptr);
+	BOOST_CHECK(*members.memberStorageOffset("first") == make_pair(u256(0), unsigned(0)));
+	BOOST_CHECK(*members.memberStorageOffset("second") == make_pair(u256(1), unsigned(0)));
+	BOOST_CHECK(*members.memberStorageOffset("third") == make_pair(u256(2), unsigned(0)));
+	BOOST_CHECK(*members.memberStorageOffset("final") == make_pair(u256(3), unsigned(0)));
 }
 
 BOOST_AUTO_TEST_CASE(storage_layout_arrays)
 {
-	BOOST_CHECK(ArrayType(DataLocation::Storage, make_shared<FixedBytesType>(1), 32).getStorageSize() == 1);
-	BOOST_CHECK(ArrayType(DataLocation::Storage, make_shared<FixedBytesType>(1), 33).getStorageSize() == 2);
-	BOOST_CHECK(ArrayType(DataLocation::Storage, make_shared<FixedBytesType>(2), 31).getStorageSize() == 2);
-	BOOST_CHECK(ArrayType(DataLocation::Storage, make_shared<FixedBytesType>(7), 8).getStorageSize() == 2);
-	BOOST_CHECK(ArrayType(DataLocation::Storage, make_shared<FixedBytesType>(7), 9).getStorageSize() == 3);
-	BOOST_CHECK(ArrayType(DataLocation::Storage, make_shared<FixedBytesType>(31), 9).getStorageSize() == 9);
-	BOOST_CHECK(ArrayType(DataLocation::Storage, make_shared<FixedBytesType>(32), 9).getStorageSize() == 9);
+	BOOST_CHECK(ArrayType(DataLocation::Storage, make_shared<FixedBytesType>(1), 32).storageSize() == 1);
+	BOOST_CHECK(ArrayType(DataLocation::Storage, make_shared<FixedBytesType>(1), 33).storageSize() == 2);
+	BOOST_CHECK(ArrayType(DataLocation::Storage, make_shared<FixedBytesType>(2), 31).storageSize() == 2);
+	BOOST_CHECK(ArrayType(DataLocation::Storage, make_shared<FixedBytesType>(7), 8).storageSize() == 2);
+	BOOST_CHECK(ArrayType(DataLocation::Storage, make_shared<FixedBytesType>(7), 9).storageSize() == 3);
+	BOOST_CHECK(ArrayType(DataLocation::Storage, make_shared<FixedBytesType>(31), 9).storageSize() == 9);
+	BOOST_CHECK(ArrayType(DataLocation::Storage, make_shared<FixedBytesType>(32), 9).storageSize() == 9);
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/test/libsolidity/solidityExecutionFramework.h b/test/libsolidity/solidityExecutionFramework.h
index 05f93bb6..3370044c 100644
--- a/test/libsolidity/solidityExecutionFramework.h
+++ b/test/libsolidity/solidityExecutionFramework.h
@@ -53,14 +53,17 @@ public:
 		std::string const& _sourceCode,
 		u256 const& _value = 0,
 		std::string const& _contractName = "",
-		bytes const& _arguments = bytes()
+		bytes const& _arguments = bytes(),
+		std::map<std::string, Address> const& _libraryAddresses = std::map<std::string, Address>()
 	)
 	{
 		m_compiler.reset(false, m_addStandardSources);
 		m_compiler.addSource("", _sourceCode);
 		ETH_TEST_REQUIRE_NO_THROW(m_compiler.compile(m_optimize, m_optimizeRuns), "Compiling contract failed");
-		bytes code = m_compiler.getBytecode(_contractName);
-		sendMessage(code + _arguments, true, _value);
+		eth::LinkerObject obj = m_compiler.object(_contractName);
+		obj.link(_libraryAddresses);
+		BOOST_REQUIRE(obj.linkReferences.empty());
+		sendMessage(obj.bytecode + _arguments, true, _value);
 		return m_output;
 	}
 
@@ -76,10 +79,11 @@ public:
 		std::string const& _sourceCode,
 		u256 const& _value = 0,
 		std::string const& _contractName = "",
-		bytes const& _arguments = bytes()
+		bytes const& _arguments = bytes(),
+		std::map<std::string, Address> const& _libraryAddresses = std::map<std::string, Address>()
 	)
 	{
-		compileAndRunWithoutCheck(_sourceCode, _value, _contractName, _arguments);
+		compileAndRunWithoutCheck(_sourceCode, _value, _contractName, _arguments, _libraryAddresses);
 		BOOST_REQUIRE(!m_output.empty());
 		return m_output;
 	}
