diff --git a/.travis.yml b/.travis.yml
index c476c154..da9bd2f9 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -26,27 +26,47 @@
 
 language: cpp
 branches:
+    # We need to whitelist the branches which we want to have "push" automation.
+    # Pull request automation is not constrained to this set of branches.
     only:
         - develop
         - release
-        - standalone
-    except:
-        - /develop-v[0-9]/
 matrix:
     include:
+        # Ubuntu 14.04 LTS "Trusty Tahr"
+        # https://en.wikipedia.org/wiki/List_of_Ubuntu_releases#Ubuntu_14.04_LTS_.28Trusty_Tahr.29
+        #
+        # TravisCI doesn't directly support any new Ubuntu releases.  These is
+        # some Docker support, which we should probably investigate, at least for
+        # Ubuntu 16.04 LTS "Xenial Xerus"
+        # See https://en.wikipedia.org/wiki/List_of_Ubuntu_releases#Ubuntu_16.04_LTS_.28Xenial_Xerus.29.
         - os: linux
           dist: trusty
           sudo: required
           compiler: gcc
           env:
-              - TRAVIS_BUILD_TYPE=RelWithDebInfo
               - ZIP_SUFFIX=ubuntu-trusty
+
+        - os: linux
+          dist: trusty
+          sudo: required
+          compiler: clang
+          env:
+              - ZIP_SUFFIX=ubuntu-trusty-clang
+
+        # Documentation target, which generates documentation using Phoenix / ReadTheDocs.
         - os: linux
           dist: trusty
           sudo: required
           compiler: gcc
           env:
-              - JOB=docs
+              - TRAVIS_DOCS=On
+              - TRAVIS_RELEASE=Off
+              - TRAVIS_TESTS=Off
+
+        # Emscripten target, which compiles 'solc' to javascript and uploads the resulting .js
+        # files to https://github.com/ethereum/solc-bin.  These binaries are used in Browser-Solidity
+        # and in other Ethereum web-based development contexts.
         - os: linux
           dist: trusty
           sudo: required
@@ -56,31 +76,58 @@ matrix:
           before_install:
               - docker pull trzeci/emscripten:sdk-tag-1.35.4-64bit
           env:
-              - JOB=emscripten
+              - TRAVIS_EMSCRIPTEN=On
+              - TRAVIS_INSTALL_DEPS=Off
+              - TRAVIS_RELEASE=Off
+              - TRAVIS_TESTS=Off
+
+        # OS X Mavericks (10.9)
+        # https://en.wikipedia.org/wiki/OS_X_Mavericks
+        #
         - os: osx
           osx_image: beta-xcode6.2
           env:
-              - TRAVIS_BUILD_TYPE=RelWithDebInfo
               - ZIP_SUFFIX=osx-mavericks
-        - os: osx
-          osx_image: xcode7.1
-          env:
-              - TRAVIS_BUILD_TYPE=RelWithDebInfo
-              - ZIP_SUFFIX=osx-yosemite
-        - os: osx
-          osx_image: xcode7.3
-          env:
-              # The use of Debug config here ONLY for El Capitan is a workaround for "The Heisenbug"
-              # See https://github.com/ethereum/webthree-umbrella/issues/565
-              - TRAVIS_BUILD_TYPE=Debug
-              - ZIP_SUFFIX=osx-elcapitan
-        - os: osx
-          osx_image: xcode8
-          env:
-              # Look like "The Heisenbug" is occurring here too, so we'll do the same workaround.
-              # See https://travis-ci.org/ethereum/solidity/jobs/150240930
-              - TRAVIS_BUILD_TYPE=Debug
-              - ZIP_SUFFIX=macos-sierra
+
+        # OS X Yosemite (10.10)
+        # https://en.wikipedia.org/wiki/OS_X_Yosemite
+        #
+#        - os: osx
+#          osx_image: xcode7.1
+#          env:
+#              # Workaround for "macOS - Yosemite, El Capitan and Sierra hanging?"
+#              # https://github.com/ethereum/solidity/issues/894
+#              - TRAVIS_TESTS=Off
+#              - ZIP_SUFFIX=osx-yosemite
+
+        # OS X El Capitan (10.11)
+        # https://en.wikipedia.org/wiki/OS_X_El_Capitan
+        #
+#        - os: osx
+#          osx_image: xcode7.3
+#          env:
+#              # The use of Debug config here ONLY for El Capitan is a workaround for "The Heisenbug"
+#              # See https://github.com/ethereum/webthree-umbrella/issues/565
+#              - TRAVIS_BUILD_TYPE=Debug
+#              # Workaround for "macOS - Yosemite, El Capitan and Sierra hanging?"
+#              # https://github.com/ethereum/solidity/issues/894
+#              - TRAVIS_TESTS=Off
+#              - ZIP_SUFFIX=osx-elcapitan
+
+        # macOS Sierra (10.12)
+        # https://en.wikipedia.org/wiki/MacOS_Sierra
+        #
+#       - os: osx
+#          osx_image: xcode8
+#          env:
+#              # Look like "The Heisenbug" is occurring here too, so we'll do the same workaround.
+#              # See https://travis-ci.org/ethereum/solidity/jobs/150240930
+#              - TRAVIS_BUILD_TYPE=Debug
+#              # Workaround for "macOS - Yosemite, El Capitan and Sierra hanging?"
+#              # https://github.com/ethereum/solidity/issues/894
+#              - TRAVIS_TESTS=Off
+#              - ZIP_SUFFIX=macos-sierra
+
 git:
     depth: 2
 
@@ -93,16 +140,20 @@ cache:
         - jsoncpp
 
 install:
-    - test $JOB != default -a $JOB != docs || ./scripts/install_deps.sh
+    - test $TRAVIS_INSTALL_DEPS != On || ./scripts/install_deps.sh
+    - echo -n "$TRAVIS_COMMIT" > commit_hash.txt
+    - test "$TRAVIS_PULL_REQUESTS" != "false" || test "$TRAVIS_BRANCH" != release || echo -n > prerelease.txt # this is a proper release
 before_script:
-    - test $JOB != emscripten || ./scripts/build_emscripten.sh
-    - test $JOB != default || (mkdir -p build
+    - test $TRAVIS_EMSCRIPTEN != On || ./scripts/build_emscripten.sh
+    - test $TRAVIS_RELEASE != On || (mkdir -p build
       && cd build
       && cmake .. -DCMAKE_BUILD_TYPE=$TRAVIS_BUILD_TYPE
       && make -j2
       && cd ..
       && ./scripts/release.sh $ZIP_SUFFIX )
 script:
+    - test $TRAVIS_DOCS != On || ./scripts/docs.sh
+
     # There are a variety of reliability issues with the Solidity unit-tests at the time of
     # writing (especially on macOS), so within TravisCI we will try to run the unit-tests
     # up to 3 times before giving up and declaring the tests as broken.
@@ -113,40 +164,68 @@ script:
     # itself is broken from the failure messages which we are seeing.
     #
     # More details on known issues at https://github.com/ethereum/solidity/issues/769    
-    - test $JOB != default || (cd $TRAVIS_BUILD_DIR && (./scripts/tests.sh || ./scripts/tests.sh || ./scripts/tests.sh) )
-    - test $JOB != docs || ./scripts/docs.sh
+    - test $TRAVIS_TESTS != On || (cd $TRAVIS_BUILD_DIR && (./scripts/tests.sh || ./scripts/tests.sh || ./scripts/tests.sh) )
 env:
     global:
         - ENCRYPTION_LABEL="6d4541b72666"
-        - JOB=default
-
-# This is the deploy target for the Emscripten build.
-# It publishes the JS file which was compiled as part of the earlier 'build_emscripten.sh'
-# step to https://github.com/ethereum/solc-bin/tree/gh-pages/bin.
-# Both the build and deploy steps for Emscripten are only run within the Ubuntu
-# configurations (not for macOS).  That is controlled by conditionals within the bash
-# scripts because TravisCI doesn't provide much in the way of conditional logic.
+        - TRAVIS_BUILD_TYPE=RelWithDebInfo
+        - TRAVIS_DOCS=Off
+        - TRAVIS_EMSCRIPTEN=Off
+        - TRAVIS_INSTALL_DEPS=On
+        - TRAVIS_RELEASE=On
+        - TRAVIS_TESTS=On
 
 deploy:
-    provider: script
-    script: test $JOB != emscripten || scripts/release_emscripten.sh
-    skip_cleanup: true
-    on:
-        branch: develop
-
-# This is the deploy target for the native build (Linux and macOS)
-# which generates development ZIPs per commit.  We are in agreement
-# that this is probably noisy overkill, so will want to renable this
-# functionality wrapped in some conditionals so that it only runs
-# when building the 'release' branch.
-#
-#deploy:
-#    provider: releases
-#    api_key:
-#        secure: mGeDrlCbhPNQVqrk5wSqFZe/7C5HUIBWcZECJcFrEldN6ELj3a8mhDX9EWebidyFmZsf3ipKVMycJtXZHlH2kVZ0nZdRulq4bYhLiUFRaFQCHMW35dml5mxO/FPp+jhhZaylDUx+cI6AULbj8DvNFqSCfjx8qimRhJjRY4JHeG71N6g5+LU2/dA01D4Y97BUbQ5dYcmEyuEsriSpXOElIQIIv3+Q6MJNnLzxUA6EXsp4Qt3Qf3R1+EkI/RWOPbQsddpFNJBcBNOscCUFSZV3+ZK9E2RyHbPaL+Da4aJKVpgD7X1TFudq4PClMUTkg8CuJh/kvy9wkpaWyYHbLGQqu1vQ+NQ+vlTAKf8U+1xhC1IkX6nA+g4TlRksZRltRhpkBPnFoaQQGjD9eYyT1V/Htrn8Y/VGbYPBVa0GcEYXG5pDCBPz91RBpYwDcyUg9DEPNI6zYfQY8jA8xqtFwPX79Y22MDXIKhBskK00geuzh7Npy5Rnh4fLqVKMlffvYx3kwp444EFWtQ5jxbRCym2Th6EldkOM8Kble1JvixQtVb4s+DpTuwHCTrXZhwMuJpmwgRx52zyIsGrBPF3MOmdlwl+l0TD8UEJXt0JM1XSF1AROyYwXKDZQ9Qt4sd9ZKSWWaLJMEJf4kkZWYgTEI/FhOWlfshQCt8Z9S9r4fq2ywoo=
-#    file: $TRAVIS_BUILD_DIR/solidity-develop-$ZIP_SUFFIX.zip
-#    skip_cleanup: true
-#    on:
-#        repo: ethereum/solidity
-#        branch: develop
+    # This is the deploy target for the Emscripten build.
+    # It publishes the JS file which was compiled as part of the earlier 'build_emscripten.sh'
+    # step to https://github.com/ethereum/solc-bin/tree/gh-pages/bin.
+    # Both the build and deploy steps for Emscripten are only run within the Ubuntu
+    # configurations (not for macOS).  That is controlled by conditionals within the bash
+    # scripts because TravisCI doesn't provide much in the way of conditional logic.
+    - provider: script
+      script: test $TRAVIS_EMSCRIPTEN != On || scripts/release_emscripten.sh
+      skip_cleanup: true
+      on:
+          branch: develop
 
+    # This is the deploy target for the native build (Linux and macOS)
+    # which generates ZIPs per commit.  We are in agreement that
+    # generating ZIPs per commit for the develop branch is probably
+    # just noise, so we only run this deployment target on 'release'.
+    #
+    # Unlike the Appveyor GitHub Releases target, the support in TravisCI
+    # seemingly doesn't provide a means for passing a description, tag, etc.
+    # In practice, we are letting the Appveyor CI do all that stuff, and
+    # then this deployment flow just seems to find that most recent tag,
+    # and just add our Linux and macOS ZIPs into the same tag, which is
+    # what we want to happen.  But is very accidental and brittle-looking.
+    #
+    # The 'skip_cleanup' stops the workspace being cleaned out prior to
+    # generation of the artifacts.  Strange that we should explicitly
+    # need to do that, but we do.
+    #
+    # Tokens in TravisCI can be generated a few different ways.  Bob had
+    # success using the 'travis' gem, and then using that gem to
+    # create/edit this .travis.yml file, and then cut-and-pasting the
+    # good bits back out of what it generated.  The gem changes all the
+    # whitespace and deletes comments, so cannot be used as-is.  But
+    # it does generate an appropriate auth token.
+    #
+    # TODO - I do not know if the api_key below which work correctly
+    # for ethereum/solidity.   I suspect not, for the same reason as
+    # my auth token does not work for Appveyor.  I don't have enough
+    # permissions to enable this myself.  Christian should be able to.
+    #
+    # See https://docs.travis-ci.com/user/deployment/releases
+    # See https://blog.travis-ci.com/2013-01-28-token-token-token/
+    # See https://github.com/ethereum/webthree-umbrella/issues/658
+    #
+    - provider: releases
+      api_key:
+          secure: PWH37xVBCF0XiSjl+eH7XIdkrfxZXjzvqF4PiBOnD3VnFz+odrdnIwBmCeBYTHTWF8efpp8fmzWJk2UVq1JcpyZiC+SVxO8dx91W2ia1a+wKrEQuDgkUrZBkl5IQNCv0QS81DDQhliyZEaYh8wHO/7RReyMpGpw2U2u85WkFiZ+LdlHEZPfzUeh9lxQ9n8qwFL8Rja+Q05d4cQ8zaVEtofJJT4T6DUWhc3TzuxDYxOmjwg37rC9CkGSLn6VadSh8b3j5R0SZupFsAEvBL/imBLP9r9ewoo7o4p6By3jwiIgH9yNg7LM618xbffcNaYF/KtLBi9uPHfqF7hRD4PlECz+D0PR78nQItOX5HKm1QMg5kCnghRVCA0IVjpV5fiYQnMLM7dCRv34I5b3zLpa69wQ/GLYB2FViqNUfvPeiZTEeIJ2OmATlFx8AH2JoqpY1XJknWb35+vMfa8LSiJJW++SLWeV+ncC92hrvyZ1cy3trepRRZIfyYepxHifnfdWMkddQUJk5b2WS5Fy/TJLZNPeombnpvRhUC38dsYItarKeXTc6k4oADCEDZ2rgGIcEiqRxXV11Y5xHJekLDWzUs+YJNcCuL4pnAP//LOnbnH2w9rLpwhQYSl0anCd097NivAXQJXO2JI/byIYz1kiCVQWnW6EM8+72mLOklf/Qr8k=
+      file: $TRAVIS_BUILD_DIR/solidity-$ZIP_SUFFIX.zip
+      skip_cleanup: true
+      on:
+          repo: ethereum/solidity
+          branch: release
+          condition: $TRAVIS_RELEASE == On
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 46e09926..3c75045a 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -8,7 +8,7 @@ include(EthPolicy)
 eth_policy()
 
 # project name and version should be set after cmake_policy CMP0048
-set(PROJECT_VERSION "0.3.6")
+set(PROJECT_VERSION "0.4.0")
 project(solidity VERSION ${PROJECT_VERSION})
 
 # Let's find our dependencies
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 00000000..2b591f4e
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,5 @@
+# Contribution Guidelines
+
+Please see our contribution guidelines in [the Solidity documentation](http://solidity.readthedocs.io/en/latest/contributing.html).
+
+Thank you for your help!
diff --git a/Changelog.md b/Changelog.md
index 8805498e..1ae18658 100644
--- a/Changelog.md
+++ b/Changelog.md
@@ -1,9 +1,63 @@
+### 0.4.0 (2016-09-08)
+
+This release deliberately breaks backwards compatibility mostly to
+enforce some safety features. The most important change is that you have
+to explicitly specify if functions can receive ether via the ``payable``
+modifier. Furthermore, more situations cause exceptions to be thrown.
+
+Minimal changes to be made for upgrade:
+ - Add ``payable`` to all functions that want to receive Ether
+   (including the constructor and the fallback function).
+ - Change ``_`` to ``_;`` in modifiers.
+ - Add version pragma to each file: ``pragma solidity ^0.4.0;``
+
+Breaking Changes:
+
+ * Source files have to specify the compiler version they are
+   compatible with using e.g. ``pragma solidity ^0.4.0;`` or
+   ``pragma solidity >=0.4.0 <0.4.8;``
+ * Functions that want to receive Ether have to specify the
+   new ``payable`` modifier (otherwise they throw).
+ * Contracts that want to receive Ether with a plain "send"
+   have to implement a fallback function with the ``payable``
+   modifier. Contracts now throw if no payable fallback
+   function is defined and no function matches the signature.
+ * Failing contract creation through "new" throws.
+ * Division / modulus by zero throws.
+ * Function call throws if target contract does not have code
+ * Modifiers are required to contain ``_`` (use ``if (false) _`` as a workaround if needed).
+ * Modifiers: return does not skip part in modifier after ``_``.
+ * Placeholder statement `_` in modifier now requires explicit `;`.
+ * ``ecrecover`` now returns zero if the input is malformed (it previously returned garbage).
+ * The ``constant`` keyword cannot be used for constructors or the fallback function.
+ * Removed ``--interface`` (Solidity interface) output option
+ * JSON AST: General cleanup, renamed many nodes to match their C++ names.
+ * JSON output: ``srcmap-runtime`` renamed to ``srcmapRuntime``.
+ * Moved (and reworked) standard library contracts from inside the compiler to github.com/ethereum/solidity/std
+   (``import "std";`` or ``import owned;`` do not work anymore).
+ * Confusing and undocumented keyword ``after`` was removed.
+ * New reserved words: ``abstract``, ``hex``, ``interface``, ``payable``, ``pure``, ``static``, ``view``.
+
 Features:
 
- * Fixed point types (in progress)
+ * Hexadecimal string literals: ``hex"ab1248fe"``
+ * Internal: Inline assembly usable by the code generator.
+ * Commandline interface: Using ``-`` as filename allows reading from stdin.
+ * Interface JSON: Fallback function is now part of the ABI.
+ * Interface: Version string now *semver* compatible.
+ * Code generator: Do not provide "new account gas" if we know the called account exists.
 
 Bugfixes:
 
+ * JSON AST: Nodes were added at wrong parent
+ * Why3 translator: Crash fix for exponentiation
+ * Commandline Interface: linking libraries with underscores in their name.
+ * Type Checker: Fallback function cannot return data anymore.
+ * Code Generator: Fix crash when ``sha3()`` was used on unsupported types.
+ * Code Generator: Manually set gas stipend for ``.send(0)``.
+
+Lots of changes to the documentation mainly by voluntary external contributors.
+
 ### 0.3.6 (2016-08-10)
 
 Features:
diff --git a/README.md b/README.md
index 9eaae4dd..bda66996 100644
--- a/README.md
+++ b/README.md
@@ -1,23 +1,19 @@
 # The Solidity Contract-Oriented Programming Language
 [![Join the chat at https://gitter.im/ethereum/solidity](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/ethereum/solidity?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
-## Useful links
 
-To get started you can find a basic introduction to the language in the [Solidity Documentation](https://solidity.readthedocs.org).
+## Useful links
+To get started you can find an introduction to the language in the [Solidity documentation](https://solidity.readthedocs.org). In the documentation, you can find [code examples](http://solidity.readthedocs.io/en/latest/solidity-by-example.html) as well as [a reference](http://solidity.readthedocs.io/en/latest/solidity-in-depth.html) of the syntax and details on how to write smart contracts.
 
 You can start using [Solidity in your browser](https://ethereum.github.io/browser-solidity/) with no need to download or compile anything.
 
-[Changelog](https://github.com/ethereum/solidity/blob/develop/Changelog.md)
+The changelog for this project can be found [here](https://github.com/ethereum/solidity/blob/develop/Changelog.md).
 
-The [Solidity Features](https://github.com/ethereum/wiki/wiki/Solidity-Features) page contains a list of already completed Solidity feature stories with explanations and demonstrations, it is being updated continuously. More technical information you can find in the [Pivotal Tracker](https://www.pivotaltracker.com/n/projects/1189488).
-
-Solidity is still under development. So please do not hesitate and open an [issue in github](https://github.com/ethereum/solidity/issues) if you encounter anything strange.
+Solidity is still under development. So please do not hesitate and open an [issue in GitHub](https://github.com/ethereum/solidity/issues) if you encounter anything strange.
 
 ## Building
-
-See the [Wiki](https://github.com/ethereum/webthree-umbrella/wiki) for build instructions, compatibility information and build tips. 
+See the [Solidity documentation](http://solidity.readthedocs.io/en/latest/installing-solidity.html#building-from-source) for build instructions.
 
 ## How to Contribute
+Please see our contribution guidelines in [the Solidity documentation](http://solidity.readthedocs.io/en/latest/contributing.html).
 
-This repository uses the same [coding style](https://github.com/ethereum/webthree-umbrella/blob/develop/CodingStandards.txt) as
-all of the cpp-ethereum projects. Please try to align with us in the gitter channel before making larger changes.
 Any contributions are welcome!
diff --git a/appveyor.yml b/appveyor.yml
index 97f931e3..afc2914f 100644
--- a/appveyor.yml
+++ b/appveyor.yml
@@ -27,12 +27,17 @@
 # (c) 2016 cpp-ethereum contributors.
 #------------------------------------------------------------------------------
 
-version: 0.3.5.{build}
-skip_tags: true
 os: Visual Studio 2015
 configuration:
     - RelWithDebInfo
-cache: build
+# NB: Appveyor cache is disabled, because it is proving very unreliable.
+# We can re-enable it when we find a way to mitigate the unreliability
+# issues.  Have automated builds be reliable is the more important thing.
+#cache: build
+#
+# In case we'd need a RDP detail to login into appveyor
+#init:
+#    - ps: iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))
 install:
     - git submodule update --init --recursive
     - scripts/install_deps.bat
@@ -46,31 +51,45 @@ build_script:
     - cd %APPVEYOR_BUILD_FOLDER%
     - scripts\release.bat %CONFIGURATION%
 
-#test_script:
-#    - cd %APPVEYOR_BUILD_FOLDER%\build\test\%CONFIGURATION%
-#    - copy "C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\redist\x86\Microsoft.VC140.CRT\msvc*.dll" .
-#    - start eth.exe --test -d %TMP%\eth_for_soltest
-#    - soltest.exe --ipc %TMP%\eth_for_soltest\geth.ipc
-#    - pkill eth
+test_script:
+    - cd %APPVEYOR_BUILD_FOLDER%
+    - cd deps\install\x64\eth
+    - ps: $ethProc = Start-Process eth.exe --test
+    - ps: Start-Sleep -s 100
+    - cd %APPVEYOR_BUILD_FOLDER%\build\test\%CONFIGURATION%
+    - copy "C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\redist\x86\Microsoft.VC140.CRT\msvc*.dll" .
+    - soltest.exe -- --ipcpath \\.\pipe\geth.ipc
 
 artifacts:
-    - path: solidity-develop-windows.zip
-      name: solidity-develop-windows-zip
+    - path: solidity-windows.zip
+      name: solidity-windows-zip
 
-# This is the deploy target for Windows
-# which generates development ZIPs per commit.  We are in agreement
-# that this is probably noisy overkill, so will want to renable this
-# functionality wrapped in some conditionals so that it only runs
-# when building the 'release' branch.
+# This is the deploy target for Windows which generates ZIPs per commit.
+# We are in agreement that generating ZIPs per commit for the develop
+# branch is probably just noise, so we only run this deployment target
+# on 'release'.
+#
+# See https://www.appveyor.com/docs/deployment/github for information
+# on GitHub Releases in Appveyor.
 #
-#deploy:
-#    release: solidity-develop-v$(APPVEYOR_BUILD_VERSION)
-#    tag: develop-v$(APPVEYOR_BUILD_VERSION)
-#    description: 'Development build of solidity at commit $(APPVEYOR_REPO_COMMIT).\n\n$(APPVEYOR_REPO_COMMIT_MESSAGE)\n\nCommitted by $(APPVEYOR_REPO_COMMIT_AUTHOR), $(APPVEYOR_REPO_COMMIT_TIMESTAMP).'
-#    prerelease: true
-#    provider: GitHub
-#    auth_token:
-#        secure: yukM9mHUbzuZSS5WSBLKSW0yGJerJEqAXkFhDhSHBBcKJE7GAryjQsdO9Kxh3yRv
-#    artifact: solidity-develop-windows-zip
-#    on:
-#        branch: standalone_changes
+# You need to generate a GitHub personal access token for Appveyor
+# See https://github.com/settings/tokens for more information on that.
+# The token you generate there (in an encrypted form) is what is
+# passed to this deployment target in the 'auth_token' parameter
+# below.
+
+deploy:
+    description: 'Development build of solidity at commit $(APPVEYOR_REPO_COMMIT).\n\n$(APPVEYOR_REPO_COMMIT_MESSAGE)\n\nCommitted by $(APPVEYOR_REPO_COMMIT_AUTHOR), $(APPVEYOR_REPO_COMMIT_TIMESTAMP).'
+    prerelease: true
+    provider: GitHub
+    auth_token:
+        secure: HPjiugbDSCsEFTphj/qwHuSw80/BV1xWoSvj95CPmtb16Ukh2VQbLVB7iFtZSans
+    artifact: solidity-windows-zip
+    on:
+        branch: release
+
+notifications:
+    - provider: GitHubPullRequest
+      on_build_success: false
+      on_build_failure: false
+      on_build_status_changed: false
diff --git a/cmake/EthBuildInfo.cmake b/cmake/EthBuildInfo.cmake
index cbb9dd24..1f70d371 100644
--- a/cmake/EthBuildInfo.cmake
+++ b/cmake/EthBuildInfo.cmake
@@ -19,7 +19,7 @@ function(create_build_info NAME)
 		set(ETH_BUILD_COMPILER "unknown")
 	endif ()
 
-	set(ETH_BUILD_PLATFORM "${ETH_BUILD_OS}/${ETH_BUILD_COMPILER}")
+	set(ETH_BUILD_PLATFORM "${ETH_BUILD_OS}.${ETH_BUILD_COMPILER}")
 
 	#cmake build type may be not speCified when using msvc
 	if (CMAKE_BUILD_TYPE)
@@ -36,8 +36,6 @@ function(create_build_info NAME)
 		-DETH_BUILD_OS="${ETH_BUILD_OS}"
 		-DETH_BUILD_COMPILER="${ETH_BUILD_COMPILER}"
 		-DETH_BUILD_PLATFORM="${ETH_BUILD_PLATFORM}"
-		-DETH_BUILD_NUMBER="${BUILD_NUMBER}"
-		-DETH_VERSION_SUFFIX="${VERSION_SUFFIX}"
 		-DPROJECT_VERSION="${PROJECT_VERSION}"
 		-P "${ETH_SCRIPTS_DIR}/buildinfo.cmake"
 		)
diff --git a/cmake/scripts/buildinfo.cmake b/cmake/scripts/buildinfo.cmake
index 39359486..963c74e4 100644
--- a/cmake/scripts/buildinfo.cmake
+++ b/cmake/scripts/buildinfo.cmake
@@ -5,11 +5,11 @@
 # ETH_DST_DIR - main CMAKE_BINARY_DIR
 # ETH_BUILD_TYPE
 # ETH_BUILD_PLATFORM
-# ETH_BUILD_NUMBER
-# ETH_VERSION_SUFFIX
 #
 # example usage:
-# cmake -DETH_SOURCE_DIR=. -DETH_DST_DIR=build -DETH_BUILD_TYPE=Debug -DETH_BUILD_PLATFORM=Darwin/appleclang -P scripts/buildinfo.cmake
+# cmake -DETH_SOURCE_DIR=. -DETH_DST_DIR=build -DETH_BUILD_TYPE=Debug -DETH_BUILD_PLATFORM=Darwin.appleclang -P scripts/buildinfo.cmake
+#
+# Its main output variables are SOL_VERSION_BUILDINFO and SOL_VERSION_PRERELEASE
 
 if (NOT ETH_BUILD_TYPE)
 	set(ETH_BUILD_TYPE "unknown")
@@ -19,26 +19,45 @@ if (NOT ETH_BUILD_PLATFORM)
 	set(ETH_BUILD_PLATFORM "unknown")
 endif()
 
-execute_process(
-	COMMAND git --git-dir=${ETH_SOURCE_DIR}/.git --work-tree=${ETH_SOURCE_DIR} rev-parse HEAD
-	OUTPUT_VARIABLE ETH_COMMIT_HASH OUTPUT_STRIP_TRAILING_WHITESPACE ERROR_QUIET
-) 
+# Logic here: If prereleases.txt exists but is empty, it is a non-pre release.
+# If it does not exist, create our own prerelease string
+if (EXISTS ${ETH_SOURCE_DIR}/prerelease.txt)
+	file(READ ${ETH_SOURCE_DIR}/prerelease.txt SOL_VERSION_PRERELEASE)
+	string(STRIP "${SOL_VERSION_PRERELEASE}" SOL_VERSION_PRERELEASE)
+else()
+	string(TIMESTAMP SOL_VERSION_PRERELEASE "develop.%Y.%m.%d" UTC)
+endif()
 
-if (NOT ETH_COMMIT_HASH)
-	set(ETH_COMMIT_HASH 0)
+if (EXISTS ${ETH_SOURCE_DIR}/commit_hash.txt)
+	file(READ ${ETH_SOURCE_DIR}/commit_hash.txt SOL_COMMIT_HASH)
+	string(STRIP ${SOL_COMMIT_HASH} SOL_COMMIT_HASH)
+else()
+	execute_process(
+		COMMAND git --git-dir=${ETH_SOURCE_DIR}/.git --work-tree=${ETH_SOURCE_DIR} rev-parse HEAD
+		OUTPUT_VARIABLE SOL_COMMIT_HASH OUTPUT_STRIP_TRAILING_WHITESPACE ERROR_QUIET
+	)
+	execute_process(
+		COMMAND git --git-dir=${ETH_SOURCE_DIR}/.git --work-tree=${ETH_SOURCE_DIR} diff HEAD --shortstat
+		OUTPUT_VARIABLE SOL_LOCAL_CHANGES OUTPUT_STRIP_TRAILING_WHITESPACE ERROR_QUIET
+	)
 endif()
 
-execute_process(
-	COMMAND git --git-dir=${ETH_SOURCE_DIR}/.git --work-tree=${ETH_SOURCE_DIR} diff HEAD --shortstat
-	OUTPUT_VARIABLE ETH_LOCAL_CHANGES OUTPUT_STRIP_TRAILING_WHITESPACE ERROR_QUIET
-)
+if (SOL_COMMIT_HASH)
+	string(STRIP ${SOL_COMMIT_HASH} SOL_COMMIT_HASH)
+	string(SUBSTRING ${SOL_COMMIT_HASH} 0 8 SOL_COMMIT_HASH)
+endif()
 
-if (ETH_LOCAL_CHANGES)
-	set(ETH_CLEAN_REPO 0)
-else()
-	set(ETH_CLEAN_REPO 1)
+if (SOL_COMMIT_HASH AND SOL_LOCAL_CHANGES)
+	set(SOL_COMMIT_HASH "${SOL_COMMIT_HASH}-mod")
+endif()
+
+if (NOT SOL_COMMIT_HASH)
+	message(FATAL_ERROR "Unable to determine commit hash. Either compile from within git repository or "
+		"supply a file called commit_hash.txt")
 endif()
 
+set(SOL_VERSION_BUILDINFO "commit.${SOL_COMMIT_HASH}.${ETH_BUILD_PLATFORM}")
+
 set(TMPFILE "${ETH_DST_DIR}/BuildInfo.h.tmp")
 set(OUTFILE "${ETH_DST_DIR}/BuildInfo.h")
 
diff --git a/cmake/templates/BuildInfo.h.in b/cmake/templates/BuildInfo.h.in
index 6f9baf50..6c16e4ac 100644
--- a/cmake/templates/BuildInfo.h.in
+++ b/cmake/templates/BuildInfo.h.in
@@ -1,11 +1,10 @@
 #pragma once
 
 #define ETH_PROJECT_VERSION "@PROJECT_VERSION@"
-#define ETH_COMMIT_HASH @ETH_COMMIT_HASH@
-#define ETH_CLEAN_REPO @ETH_CLEAN_REPO@
-#define ETH_BUILD_TYPE @ETH_BUILD_TYPE@
-#define ETH_BUILD_OS @ETH_BUILD_OS@
-#define ETH_BUILD_COMPILER @ETH_BUILD_COMPILER@
-#define ETH_BUILD_PLATFORM @ETH_BUILD_PLATFORM@
-#define ETH_BUILD_NUMBER @ETH_BUILD_NUMBER@
-#define ETH_VERSION_SUFFIX "@ETH_VERSION_SUFFIX@"
+#define SOL_COMMIT_HASH "@SOL_COMMIT_HASH@"
+#define ETH_BUILD_TYPE "@ETH_BUILD_TYPE@"
+#define ETH_BUILD_OS "@ETH_BUILD_OS@"
+#define ETH_BUILD_COMPILER "@ETH_BUILD_COMPILER@"
+#define ETH_BUILD_PLATFORM "@ETH_BUILD_PLATFORM@"
+#define SOL_VERSION_PRERELEASE "@SOL_VERSION_PRERELEASE@"
+#define SOL_VERSION_BUILDINFO "@SOL_VERSION_BUILDINFO@"
diff --git a/docs/common-patterns.rst b/docs/common-patterns.rst
index 422e2758..fa5e68a6 100644
--- a/docs/common-patterns.rst
+++ b/docs/common-patterns.rst
@@ -2,6 +2,111 @@
 Common Patterns
 ###############
 
+.. index:: withdrawal
+
+.. _withdrawal_pattern:
+
+*************************
+Withdrawal from Contracts
+*************************
+
+The recommended method of sending funds after an effect
+is using the withdrawal pattern. Although the most intuitive
+method of sending Ether, as a result of an effect, is a
+direct ``send`` call, this is not recommended as it
+introduces a potential security risk. You may read
+more about this on the :ref:`security_considerations` page.
+
+This is an example of the withdrawal pattern in practice in
+a contract where the goal is to send the most money to the
+contract in order to become the "richest", inspired by
+`King of the Ether <https://www.kingoftheether.com/>`_.
+
+In the following contract, if you are usurped as the richest,
+you will recieve the funds of the person who has gone on to
+become the new richest.
+
+::
+
+    pragma solidity ^0.4.0;
+
+    contract WithdrawalContract {
+        address public richest;
+        uint public mostSent;
+
+        mapping (address => uint) pendingWithdrawals;
+
+        function WithdrawalContract() payable {
+            richest = msg.sender;
+            mostSent = msg.value;
+        }
+
+        function becomeRichest() payable returns (bool) {
+            if (msg.value > mostSent) {
+                pendingWithdrawals[richest] += msg.value;
+                richest = msg.sender;
+                mostSent = msg.value;
+                return true;
+            } else {
+                return false;
+            }
+        }
+
+        function withdraw() returns (bool) {
+            uint amount = pendingWithdrawals[msg.sender];
+            // Remember to zero the pending refund before
+            // sending to prevent re-entrancy attacks
+            pendingWithdrawals[msg.sender] = 0;
+            if (msg.sender.send(amount)) {
+                return true;
+            } else {
+                pendingWithdrawals[msg.sender] = amount;
+                return false;
+            }
+        }
+    }
+
+This is as opposed to the more intuitive sending pattern:
+
+::
+
+    pragma solidity ^0.4.0;
+
+    contract SendContract {
+        address public richest;
+        uint public mostSent;
+
+        function SendContract() payable {
+            richest = msg.sender;
+            mostSent = msg.value;
+        }
+
+        function becomeRichest() returns (bool) {
+            if (msg.value > mostSent) {
+                // Check if call succeeds to prevent an attacker
+                // from trapping the previous person's funds in
+                // this contract through a callstack attack
+                if (!richest.send(msg.value)) {
+                    throw;
+                }
+                richest = msg.sender;
+                mostSent = msg.value;
+                return true;
+            } else {
+                return false;
+            }
+        }
+    }
+
+Notice that, in this example, an attacker could trap the
+contract into an unusable state by causing ``richest`` to be
+the address of a  contract that has a fallback function
+which consumes more than the 2300 gas stipend.  That way,
+whenever ``send`` is called to deliver funds to the
+"poisoned" contract, it will cause execution to always fail
+because there will not be enough gas to finish the execution
+of the fallback function.
+
 .. index:: access;restricting
 
 ******************
@@ -30,6 +135,8 @@ restrictions highly readable.
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract AccessRestriction {
         // These will be assigned at the construction
         // phase, where `msg.sender` is the account
@@ -47,10 +154,10 @@ restrictions highly readable.
         {
             if (msg.sender != _account)
                 throw;
-            // Do not forget the "_"! It will
+            // Do not forget the "_;"! It will
             // be replaced by the actual function
-            // body when the modifier is invoked.
-            _
+            // body when the modifier is used.
+            _;
         }
 
         /// Make `_newOwner` the new owner of this
@@ -63,7 +170,7 @@ restrictions highly readable.
 
         modifier onlyAfter(uint _time) {
             if (now < _time) throw;
-            _
+            _;
         }
 
         /// Erase ownership information.
@@ -80,15 +187,14 @@ restrictions highly readable.
         // fee being associated with a function call.
         // If the caller sent too much, he or she is
         // refunded, but only after the function body.
-        // This is dangerous, because if the function
-        // uses `return` explicitly, this will not be
-        // done!
+        // This was dangerous before Solidity version 0.4.0,
+        // where it was possible to skip the part after `_;`.
         modifier costs(uint _amount) {
             if (msg.value < _amount)
                 throw;
-            _
+            _;
             if (msg.value > _amount)
-                msg.sender.send(_amount - msg.value);
+                msg.sender.send(msg.value - _amount);
         }
 
         function forceOwnerChange(address _newOwner)
@@ -97,10 +203,10 @@ restrictions highly readable.
             owner = _newOwner;
             // just some example condition
             if (uint(owner) & 0 == 1)
-                // in this case, overpaid fees will not
-                // be refunded
+                // This did not refund for Solidity
+                // before version 0.4.0.
                 return;
-            // otherwise, refund overpaid fees
+            // refund overpaid fees
         }
     }
 
@@ -158,15 +264,20 @@ function finishes.
 
 .. note::
     **Modifier May be Skipped**.
+    This only applies to Solidity before version 0.4.0:
     Since modifiers are applied by simply replacing
     code and not by using a function call,
     the code in the transitionNext modifier
     can be skipped if the function itself uses
     return. If you want to do that, make sure
     to call nextStage manually from those functions.
+    Starting with version 0.4.0, modifier code
+    will run even if the function explicitly returns.
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract StateMachine {
         enum Stages {
             AcceptingBlindedBids,
@@ -183,7 +294,7 @@ function finishes.
 
         modifier atStage(Stages _stage) {
             if (stage != _stage) throw;
-            _
+            _;
         }
 
         function nextStage() internal {
@@ -201,11 +312,12 @@ function finishes.
                     now >= creationTime + 12 days)
                 nextStage();
             // The other stages transition by transaction
-            _
+            _;
         }
 
         // Order of the modifiers matters here!
         function bid()
+            payable
             timedTransitions
             atStage(Stages.AcceptingBlindedBids)
         {
@@ -220,12 +332,9 @@ function finishes.
 
         // This modifier goes to the next stage
         // after the function is done.
-        // If you use `return` in the function,
-        // `nextStage` will not be called
-        // automatically.
         modifier transitionNext()
         {
-            _
+            _;
             nextStage();
         }
 
@@ -234,8 +343,6 @@ function finishes.
             atStage(Stages.AnotherStage)
             transitionNext
         {
-            // If you want to use `return` here,
-            // you have to call `nextStage()` manually.
         }
 
         function h()
diff --git a/docs/contracts.rst b/docs/contracts.rst
index 3d592ecf..ef29a686 100644
--- a/docs/contracts.rst
+++ b/docs/contracts.rst
@@ -4,7 +4,7 @@
 Contracts
 ##########
 
-Contracts in Solidity are what classes are in object oriented languages. They
+Contracts in Solidity are similar to classes in object-oriented languages. They
 contain persistent data in state variables and functions that can modify these
 variables. Calling a function on a different contract (instance) will perform
 an EVM function call and thus switch the context such that state variables are
@@ -25,7 +25,7 @@ API, this is done as follows::
 
     // Need to specify some source including contract name for the data param below
     var source = "contract CONTRACT_NAME { function CONTRACT_NAME(unit a, uint b) {} }";
-    
+
     // The json abi array generated by the compiler
     var abiArray = [
         {
@@ -65,6 +65,8 @@ This means that cyclic creation dependencies are impossible.
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract OwnedToken {
         // TokenCreator is a contract type that is defined below.
         // It is fine to reference it as long as it is not used
@@ -76,6 +78,11 @@ This means that cyclic creation dependencies are impossible.
         // This is the constructor which registers the
         // creator and the assigned name.
         function OwnedToken(bytes32 _name) {
+            // State variables are accessed via their name
+            // and not via e.g. this.owner. This also applies
+            // to functions and especially in the constructors,
+            // you can only call them like that ("internall"),
+            // because the contract itself does not exist yet.
             owner = msg.sender;
             // We do an explicit type conversion from `address`
             // to `TokenCreator` and assume that the type of
@@ -179,7 +186,7 @@ and the default is ``internal``.
 .. note::
     Everything that is inside a contract is visible to
     all external observers. Making something ``private``
-    only prevents other contract from accessing and modifying
+    only prevents other contracts from accessing and modifying
     the information, but it will still be visible to the
     whole world outside of the blockchain.
 
@@ -189,15 +196,49 @@ return parameter list for functions.
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract C {
         function f(uint a) private returns (uint b) { return a + 1; }
         function setData(uint a) internal { data = a; }
         uint public data;
     }
 
-Other contracts can call ``c.data()`` to retrieve the value of data in state
-storage, but are not able to call ``f``. Contracts derived from ``c`` can call
-``setData`` to alter the value of ``data`` (but only in their own state).
+In the following example, ``D``, can call ``c.getData()`` to retrieve the value of
+``data`` in state storage, but is not able to call ``f``. Contract ``E`` is derived from
+``C`` and, thus, can call ``compute``.
+
+::
+
+    pragma solidity ^0.4.0;
+
+    contract C {
+        uint private data;
+
+        function f(uint a) private returns(uint b) { return a + 1; }
+        function setData(uint a) { data = a; }
+        function getData() public returns(uint) { return data; }
+        function compute(uint a, uint b) internal returns (uint) { return a+b; }
+    }
+
+
+    contract D {
+        function readData() {
+            C c = new C();
+            uint local = c.f(7); // error: member "f" is not visible
+            c.setData(3);
+            local = c.getData();
+            local = c.compute(3, 5); // error: member "compute" is not visible
+        }
+    }
+
+
+    contract E is C {
+        function g() {
+            C c = new C();
+            uint val = compute(3, 5);  // acces to internal member (from derivated to parent contract)
+        }
+    }
 
 .. index:: ! accessor;function, ! function;accessor
 
@@ -205,27 +246,51 @@ Accessor Functions
 ==================
 
 The compiler automatically creates accessor functions for
-all public state variables. The contract given below will
-have a function called ``data`` that does not take any
-arguments and returns a uint, the value of the state
+all **public** state variables. For the contract given below, the compiler will
+generate a function called ``data`` that does not take any
+arguments and returns a ``uint``, the value of the state
 variable ``data``. The initialization of state variables can
 be done at declaration.
 
+::
+
+    pragma solidity ^0.4.0;
+
+    contract C {
+        uint public data = 42;
+    }
+
+
+    contract Caller {
+        C c = new C();
+        function f() {
+            uint local = c.data();
+        }
+    }
+
 The accessor functions have external visibility. If the
 symbol is accessed internally (i.e. without ``this.``),
-it is a state variable and if it is accessed externally
-(i.e. with ``this.``), it is a function.
+it is evaluated as a state variable and if it is accessed externally
+(i.e. with ``this.``), it is evaluated as a function.
 
 ::
 
-    contract Test {
-        uint public data = 42;
+    pragma solidity ^0.4.0;
+
+    contract C {
+        uint public data;
+        function x() {
+            data = 3; // internal access
+            uint val = this.data(); // external access
+        }
     }
 
 The next example is a bit more complex:
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract Complex {
         struct Data {
             uint a;
@@ -259,6 +324,8 @@ inheritable properties of contracts and may be overridden by derived contracts.
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract owned {
         function owned() { owner = msg.sender; }
         address owner;
@@ -266,14 +333,14 @@ inheritable properties of contracts and may be overridden by derived contracts.
         // This contract only defines a modifier but does not use
         // it - it will be used in derived contracts.
         // The function body is inserted where the special symbol
-        // "_" in the definition of a modifier appears.
+        // "_;" in the definition of a modifier appears.
         // This means that if the owner calls this function, the
         // function is executed and otherwise, an exception is
         // thrown.
         modifier onlyOwner {
             if (msg.sender != owner)
                 throw;
-            _
+            _;
         }
     }
 
@@ -293,7 +360,7 @@ inheritable properties of contracts and may be overridden by derived contracts.
         // Modifiers can receive arguments:
         modifier costs(uint price) {
             if (msg.value >= price) {
-                _
+                _;
             }
         }
     }
@@ -305,7 +372,10 @@ inheritable properties of contracts and may be overridden by derived contracts.
 
         function Register(uint initialPrice) { price = initialPrice; }
 
-        function register() costs(price) {
+        // It is important to also provide the
+        // "payable" keyword here, otherwise the function will
+        // automatically reject all Ether sent to it.
+        function register() payable costs(price) {
             registeredAddresses[msg.sender] = true;
         }
 
@@ -314,14 +384,40 @@ inheritable properties of contracts and may be overridden by derived contracts.
         }
     }
 
+    contract Mutex {
+        bool locked;
+        modifier noReentrancy() {
+            if (locked) throw;
+            locked = true;
+            _;
+            locked = false;
+        }
+
+        /// This function is protected by a mutex, which means that
+        /// reentrant calls from within msg.sender.call cannot call f again.
+        /// The `return 7` statement assigns 7 to the return value but still
+        /// executes the statement `locked = false` in the modifier.
+        function f() noReentrancy returns (uint) {
+            if (!msg.sender.call()) throw;
+            return 7;
+        }
+    }
+
 Multiple modifiers can be applied to a function by specifying them in a
-whitespace-separated list and will be evaluated in order. Explicit returns from
-a modifier or function body immediately leave the whole function, while control
-flow reaching the end of a function or modifier body continues after the "_" in
-the preceding modifier. Arbitrary expressions are allowed for modifier
-arguments and in this context, all symbols visible from the function are
-visible in the modifier. Symbols introduced in the modifier are not visible in
-the function (as they might change by overriding).
+whitespace-separated list and will be evaluated in order.
+
+.. warning::
+    In an earlier version of Solidity, ``return`` statements in functions
+    having modifiers behaved differently.
+
+Explicit returns from a modifier or function body only leave the current
+modifier or function body. Return variables are assigned and
+control flow continues after the "_" in the preceding modifier.
+
+Arbitrary expressions are allowed for modifier arguments and in this context,
+all symbols visible from the function are visible in the modifier. Symbols
+introduced in the modifier are not visible in the function (as they might
+change by overriding).
 
 .. index:: ! constant
 
@@ -334,6 +430,8 @@ for array and struct types and not possible for mapping types).
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract C {
         uint constant x = 32**22 + 8;
         string constant text = "abc";
@@ -354,38 +452,61 @@ Fallback Function
 *****************
 
 A contract can have exactly one unnamed function. This function cannot have
-arguments and is executed on a call to the contract if none of the other
+arguments and cannot return anything.
+It is executed on a call to the contract if none of the other
 functions matches the given function identifier (or if no data was supplied at
 all).
 
 Furthermore, this function is executed whenever the contract receives plain
-Ether (without data).  In such a context, there is very little gas available to
+Ether (without data).  In such a context, there is usually very little gas available to
 the function call (to be precise, 2300 gas), so it is important to make fallback functions as cheap as
 possible.
 
+In particular, the following operations will consume more gas than the stipend provided to a fallback function:
+
+- Writing to storage
+- Creating a contract
+- Calling an external function which consumes a large amount of gas
+- Sending Ether
+
+Please ensure you test your fallback function thoroughly to ensure the execution cost is less than 2300 gas before deploying a contract.
+
+.. warning::
+    Contracts that receive Ether but do not define a fallback function
+    throw an exception, sending back the Ether (this was different
+    before Solidity v0.4.0). So if you want your contract to receive Ether,
+    you have to implement a fallback function.
+
 ::
 
+    pragma solidity ^0.4.0;
+
     contract Test {
+        // This function is called for all messages sent to
+        // this contract (there is no other function).
+        // Sending Ether to this contract will cause an exception,
+        // because the fallback function does not have the "payable"
+        // modifier.
         function() { x = 1; }
         uint x;
     }
 
 
-    // This contract rejects any Ether sent to it. It is good
-    // practise to include such a function for every contract
-    // in order not to lose Ether.
-    contract Rejector {
-        function() { throw; }
+    // This contract keeps all Ether sent to it with no way
+    // to get it back.
+    contract Sink {
+        function() payable { }
     }
 
 
     contract Caller {
-        function callTest(address testAddress) {
-            Test(testAddress).call(0xabcdef01); // hash does not exist
-            // results in Test(testAddress).x becoming == 1.
-            Rejector r = Rejector(0x123);
-            r.send(2 ether);
-            // results in r.balance == 0
+        function callTest(Test test) {
+            test.call(0xabcdef01); // hash does not exist
+            // results in test.x becoming == 1.
+
+            // The following call will fail, reject the
+            // Ether and return false:
+            test.send(2 ether);
         }
     }
 
@@ -431,8 +552,15 @@ not possible to filter for specific anonymous events by name.
 
 All non-indexed arguments will be stored in the data part of the log.
 
+.. note::
+    Indexed arguments will not be stored themselves, you can only
+    search for the values, but it is impossible to retrieve the
+    values themselves.
+
 ::
 
+    pragma solidity ^0.4.0;
+
     contract ClientReceipt {
         event Deposit(
             address indexed _from,
@@ -512,7 +640,7 @@ Inheritance
 Solidity supports multiple inheritance by copying code including polymorphism.
 
 All function calls are virtual, which means that the most derived function
-is called, except when the contract is explicitly given.
+is called, except when the contract name is explicitly given.
 
 Even if a contract inherits from multiple other contracts, only a single
 contract is created on the blockchain, the code from the base contracts
@@ -526,6 +654,8 @@ Details are given in the following example.
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract owned {
         function owned() { owner = msg.sender; }
         address owner;
@@ -599,6 +729,8 @@ Note that above, we call ``mortal.kill()`` to "forward" the
 destruction request. The way this is done is problematic, as
 seen in the following example::
 
+    pragma solidity ^0.4.0;
+
     contract mortal is owned {
         function kill() {
             if (msg.sender == owner) selfdestruct(owner);
@@ -624,6 +756,8 @@ derived override, but this function will bypass
 ``Base1.kill``, basically because it does not even know about
 ``Base1``.  The way around this is to use ``super``::
 
+    pragma solidity ^0.4.0;
+
     contract mortal is owned {
         function kill() {
             if (msg.sender == owner) selfdestruct(owner);
@@ -663,6 +797,8 @@ Arguments for Base Constructors
 Derived contracts need to provide all arguments needed for
 the base constructors. This can be done at two places::
 
+    pragma solidity ^0.4.0;
+
     contract Base {
         uint x;
         function Base(uint _x) { x = _x; }
@@ -701,6 +837,8 @@ error "Linearization of inheritance graph impossible".
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract X {}
     contract A is X {}
     contract C is A, X {}
@@ -721,12 +859,16 @@ Abstract Contracts
 
 Contract functions can lack an implementation as in the following example (note that the function declaration header is terminated by ``;``)::
 
+    pragma solidity ^0.4.0;
+
     contract Feline {
         function utterance() returns (bytes32);
     }
 
 Such contracts cannot be compiled (even if they contain implemented functions alongside non-implemented functions), but they can be used as base contracts::
 
+    pragma solidity ^0.4.0;
+
     contract Cat is Feline {
         function utterance() returns (bytes32) { return "miaow"; }
     }
@@ -771,6 +913,8 @@ more advanced example to implement a set).
 
 ::
 
+    pragma solidity ^0.4.0;
+
     library Set {
       // We define a new struct datatype that will be used to
       // hold its data in the calling contract.
@@ -841,6 +985,8 @@ custom types without the overhead of external function calls:
 
 ::
 
+    pragma solidity ^0.4.0;
+
     library BigInt {
         struct bigint {
             uint[] limbs;
@@ -896,7 +1042,7 @@ custom types without the overhead of external function calls:
 As the compiler cannot know where the library will be
 deployed at, these addresses have to be filled into the
 final bytecode by a linker
-(see :ref:`commandline-compiler`) on how to use the
+(see :ref:`commandline-compiler` for how to use the
 commandline compiler for linking). If the addresses are not
 given as arguments to the compiler, the compiled hex code
 will contain placeholders of the form ``__Set______`` (where
@@ -906,10 +1052,11 @@ encoding of the address of the library contract.
 
 Restrictions for libraries in comparison to contracts:
 
-- no state variables
-- cannot inherit nor be inherited
+- No state variables
+- Cannot inherit nor be inherited
+- Cannot recieve Ether
 
-(these might be lifted at a later point)
+(These might be lifted at a later point.)
 
 .. index:: ! using for, library
 
@@ -943,6 +1090,8 @@ available without having to add further code.
 Let us rewrite the set example from the
 :ref:`libraries` in this way::
 
+    pragma solidity ^0.4.0;
+
     // This is the same code as before, just without comments
     library Set {
       struct Data { mapping(uint => bool) flags; }
@@ -989,6 +1138,8 @@ Let us rewrite the set example from the
 
 It is also possible to extend elementary types in that way::
 
+    pragma solidity ^0.4.0;
+
     library Search {
         function indexOf(uint[] storage self, uint value) returns (uint) {
             for (uint i = 0; i < self.length; i++)
diff --git a/docs/contributing.rst b/docs/contributing.rst
new file mode 100644
index 00000000..a316abd6
--- /dev/null
+++ b/docs/contributing.rst
@@ -0,0 +1,59 @@
+############
+Contributing
+############
+
+Help is always appreciated!
+
+To get started, you can try :ref:`building-from-source` in order to familiarize
+yourself with the components of Solidity and the build process. Also, it may be
+useful to become well-versed at writing smart-contracts in Solidity.
+
+In particular, we need help in the following areas:
+
+* Improving the documentation
+* Responding to questions from other users on `StackExchange
+  <http://ethereum.stackexchange.com/>`_ and the `Solidity Gitter
+  <https://gitter.im/ethereum/solidity>`_
+* Fixing and responding to `Solidity's GitHub issues
+  <https://github.com/ethereum/solidity/issues>`_
+
+How to Report Issues
+====================
+
+To report an issue, please use the
+`GitHub issues tracker <https://github.com/ethereum/solidity/issues>`_. When
+reporting issues, please mention the following details:
+
+* Which version of Solidity you are using
+* What was the source code (if applicable)
+* Which platform are you running on
+* How to reproduce the issue
+* What was the result of the issue
+* What the expected behaviour is
+
+Reducing the source code that caused the issue to a bare minimum is always
+very helpful and sometimes even clarifies a misunderstanding.
+
+Workflow for Pull Requests
+==========================
+
+In order to contribute, please fork off of the ``develop`` branch and make your
+changes there. Your commit messages should detail *why* you made your change
+in addition to *what* you did (unless it is a tiny change).
+
+If you need to pull in any changes from ``develop`` after making your fork (for
+example, to resolve potential merge conflicts), please avoid using ``git merge``
+and instead, ``git rebase`` your branch.
+
+Additionally, if you are writing a new feature, please ensure you write appropriate
+Boost test cases and place them under ``test/``.
+
+However, if you are making a larger change, please consult with the Gitter
+channel, first.
+
+Finally, please make sure you respect the `coding standards
+<https://raw.githubusercontent.com/ethereum/cpp-ethereum/develop/CodingStandards.txt>`_
+for this project. Also, even though we do CI testing, please test your code and
+ensure that it builds locally before submitting a pull request.
+
+Thank you for your help!
diff --git a/docs/control-structures.rst b/docs/control-structures.rst
index 9d7ebeac..db24d5c3 100644
--- a/docs/control-structures.rst
+++ b/docs/control-structures.rst
@@ -10,7 +10,7 @@ Control Structures
 Most of the control structures from C/JavaScript are available in Solidity
 except for ``switch`` and ``goto``. So
 there is: ``if``, ``else``, ``while``, ``for``, ``break``, ``continue``, ``return``, ``? :``, with
-the usual semantics known from C / JavaScript.
+the usual semantics known from C or JavaScript.
 
 Parentheses can *not* be omitted for conditionals, but curly brances can be omitted
 around single-statement bodies.
@@ -44,8 +44,12 @@ contract can be called internally.
 External Function Calls
 -----------------------
 
-The expression ``this.g(8);`` is also a valid function call, but this time, the function
+The expressions ``this.g(8);`` and ``c.g(2);`` (where ``g`` is a contract
+instance) are also valid function calls, but this time, the function
 will be called "externally", via a message call and not directly via jumps.
+Please note that function calls on ``this`` cannot be used in the constructor, as the
+actual contract has not been created yet.
+
 Functions of other contracts have to be called externally. For an external call,
 all function arguments have to be copied to memory.
 
@@ -53,7 +57,7 @@ When calling functions
 of other contracts, the amount of Wei sent with the call and the gas can be specified::
 
     contract InfoFeed {
-        function info() returns (uint ret) { return 42; }
+        function info() payable returns (uint ret) { return 42; }
     }
 
 
@@ -63,12 +67,24 @@ of other contracts, the amount of Wei sent with the call and the gas can be spec
         function callFeed() { feed.info.value(10).gas(800)(); }
     }
 
+The modifier ``payable`` has to be used for ``info``, because otherwise,
+we would not be able to send Ether to it in the call ``feed.info.value(10).gas(800)()``.
+
 Note that the expression ``InfoFeed(addr)`` performs an explicit type conversion stating
 that "we know that the type of the contract at the given address is ``InfoFeed``" and
-this does not execute a constructor. We could also have used ``function setFeed(InfoFeed _feed) { feed = _feed; }`` directly.  Be careful about the fact that ``feed.info.value(10).gas(800)``
+this does not execute a constructor. Explicit type conversions have to be
+handled with extreme caution. Never call a function on a contract where you
+are not sure about its type.
+
+We could also have used ``function setFeed(InfoFeed _feed) { feed = _feed; }`` directly.
+Be careful about the fact that ``feed.info.value(10).gas(800)``
 only (locally) sets the value and amount of gas sent with the function call and only the
 parentheses at the end perform the actual call.
 
+Function calls cause exceptions if the called contract does not exist (in the
+sense that the account does not contain code) or if the called contract itself
+throws an exception or goes out of gas.
+
 .. warning::
     Any interaction with another contract imposes a potential danger, especially
     if the source code of the contract is not known in advance. The current
@@ -82,16 +98,20 @@ parentheses at the end perform the actual call.
     that the called contract can change state variables of the calling contract
     via its functions. Write your functions in a way that, for example, calls to
     external functions happen after any changes to state variables in your contract
-    so your contract is not vulnerable to a recursive call exploit.
+    so your contract is not vulnerable to a reentrancy exploit.
 
 Named Calls and Anonymous Function Parameters
 ---------------------------------------------
 
-Function call arguments can also be given by name, in any order, and the names
-of unused parameters (especially return parameters) can be omitted.
+Function call arguments can also be given by name, in any order,
+if they are enclosed in ``{ }`` as can be seen in the following
+example. The argument list has to coincide by name with the list of
+parameters from the function declaration, but can be in arbitrary order.
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract C {
         function f(uint key, uint value) { ... }
 
@@ -99,12 +119,66 @@ of unused parameters (especially return parameters) can be omitted.
             // named arguments
             f({value: 2, key: 3});
         }
+    }
+
+Omitted Function Parameter Names
+--------------------------------
+
+The names of unused parameters (especially return parameters) can be omitted.
+Those names will still be present on the stack, but they are inaccessible.
+
+::
 
-        // omitted parameters
+    pragma solidity ^0.4.0;
+
+    contract C {
+        // omitted name for parameter
         function func(uint k, uint) returns(uint) {
             return k;
         }
     }
+    
+
+.. index:: ! new, contracts;creating
+
+.. _creating-contracts:
+
+Creating Contracts via ``new``
+==============================
+
+A contract can create a new contract using the ``new`` keyword. The full
+code of the contract being created has to be known and, thus, recursive
+creation-dependencies are now possible.
+
+::
+
+    pragma solidity ^0.4.0;
+
+    contract D {
+        uint x;
+        function D(uint a) payable {
+            x = a;
+        }
+    }
+
+
+    contract C {
+        D d = new D(4); // will be executed as part of C's constructor
+
+        function createD(uint arg) {
+            D newD = new D(arg);
+        }
+
+        function createAndEndowD(uint arg, uint amount) {
+            // Send ether along with the creation
+            D newD = (new D).value(amount)(arg);
+        }
+    }
+
+As seen in the example, it is possible to forward Ether to the creation,
+but it is not possible to limit the amount of gas. If the creation fails
+(due to out-of-stack, not enough balance or other problems), an exception
+is thrown.
 
 Order of Evaluation of Expressions
 ==================================
@@ -179,6 +253,8 @@ This happens because Solidity inherits its scoping rules from JavaScript.
 This is in contrast to many languages where variables are only scoped where they are declared until the end of the semantic block.
 As a result, the following code is illegal and cause the compiler to throw an error, ``Identifier already declared``::
 
+    pragma solidity ^0.4.0;
+
     contract ScopingErrors {
         function scoping() {
             uint i = 0;
@@ -219,8 +295,7 @@ As a result, the following code is legal, despite being poorly written::
         uint bar = 5;
         if (true) {
             bar += baz;
-        }
-        else {
+        } else {
             uint baz = 10;// never executes
         }
         return bar;// returns 5
@@ -237,19 +312,24 @@ Catching exceptions is not yet possible.
 
 In the following example, we show how ``throw`` can be used to easily revert an Ether transfer and also how to check the return value of ``send``::
 
+    pragma solidity ^0.4.0;
+
     contract Sharer {
-        function sendHalf(address addr) returns (uint balance) {
+        function sendHalf(address addr) payable returns (uint balance) {
             if (!addr.send(msg.value / 2))
                 throw; // also reverts the transfer to Sharer
             return this.balance;
         }
     }
 
-Currently, there are three situations, where exceptions happen automatically in Solidity:
+Currently, there are six situations, where exceptions happen automatically in Solidity:
 
-1. If you access an array beyond its length (i.e. ``x[i]`` where ``i >= x.length``)
+1. If you access an array beyond its length (i.e. ``x[i]`` where ``i >= x.length``).
 2. If a function called via a message call does not finish properly (i.e. it runs out of gas or throws an exception itself).
 3. If a non-existent function on a library is called or Ether is sent to a library.
+4. If you divide or modulo by zero (e.g. ``5 / 0`` or ``23 % 0``).
+5. If you perform an external function call targeting a contract that contains no code.
+6. If a contract-creation call using the ``new`` keyword fails.
 
 Internally, Solidity performs an "invalid jump" when an exception is thrown and thus causes the EVM to revert all changes made to the state. The reason for this is that there is no safe way to continue execution, because an expected effect did not occur. Because we want to retain the atomicity of transactions, the safest thing to do is to revert all changes and make the whole transaction (or at least call) without effect.
 
@@ -273,8 +353,9 @@ arising when writing manual assembly by the following features:
 We now want to describe the inline assembly language in detail.
 
 .. warning::
-    Inline assembly is still a relatively new feature and might change if it does not prove useful,
-    so please try to keep up to date.
+    Inline assembly is a way to access the Ethereum Virtual Machine
+    at a low level. This discards several important safety
+    features of Solidity.
 
 Example
 -------
@@ -285,6 +366,8 @@ idea is that assembly libraries will be used to enhance the language in such way
 
 .. code::
 
+    pragma solidity ^0.4.0;
+
     library GetCode {
         function at(address _addr) returns (bytes o_code) {
             assembly {
@@ -310,6 +393,8 @@ you really know what you are doing.
 
 .. code::
 
+    pragma solidity ^0.4.0;
+
     library VectorSum {
         // This function is less efficient because the optimizer currently fails to
         // remove the bounds checks in array access.
@@ -337,9 +422,9 @@ Inline assembly parses comments, literals and identifiers exactly as Solidity, s
 usual ``//`` and ``/* */`` comments. Inline assembly is initiated by ``assembly { ... }`` and inside
 these curly braces, the following can be used (see the later sections for more details)
 
- - literals, i.e. ``0x123``, ``42`` or ``"abc"`` (strings up to 32 characters)
+ - literals, e.g. ``0x123``, ``42`` or ``"abc"`` (strings up to 32 characters)
  - opcodes (in "instruction style"), e.g. ``mload sload dup1 sstore``, for a list see below
- - opcode in functional style, e.g. ``add(1, mlod(0))``
+ - opcodes in functional style, e.g. ``add(1, mlod(0))``
  - labels, e.g. ``name:``
  - variable declarations, e.g. ``let x := 7`` or ``let x := add(y, 3)``
  - identifiers (externals, labels or assembly-local variables), e.g. ``jump(name)``, ``3 x add``
@@ -354,7 +439,7 @@ This document does not want to be a full description of the Ethereum virtual mac
 following list can be used as a reference of its opcodes.
 
 If an opcode takes arguments (always from the top of the stack), they are given in parentheses.
-Note that the order of arguments can be seed to be reversed in non-functional style (explained below).
+Note that the order of arguments can be seen as being reversed compared to the instructional style (explained below).
 Opcodes marked with ``-`` do not push an item onto the stack, those marked with ``*`` are
 special and all others push exactly one item onte the stack.
 
@@ -446,9 +531,9 @@ The opcodes ``pushi`` and ``jumpdest`` cannot be used directly.
 +-------------------------+------+-----------------------------------------------------------------+
 | callvalue               |      | wei sent together with the current call                         |
 +-------------------------+------+-----------------------------------------------------------------+
-| calldataload(p)         |      | call data starting from position p (32 bytes)                   |
+| calldataload(p)         |      | calldata starting from position p (32 bytes)                    |
 +-------------------------+------+-----------------------------------------------------------------+
-| calldatasize            |      | size of call data in bytes                                      |
+| calldatasize            |      | size of calldata in bytes                                       |
 +-------------------------+------+-----------------------------------------------------------------+
 | calldatacopy(t, f, s)   | `-`  | copy s bytes from calldata at position f to mem at position t   |
 +-------------------------+------+-----------------------------------------------------------------+
@@ -463,14 +548,15 @@ The opcodes ``pushi`` and ``jumpdest`` cannot be used directly.
 | create(v, p, s)         |      | create new contract with code mem[p..(p+s)) and send v wei      |
 |                         |      | and return the new address                                      |
 +-------------------------+------+-----------------------------------------------------------------+
-| call(g, a, v, in,       |      | call contract at address a with input mem[in..(in+insize)]      |
+| call(g, a, v, in,       |      | call contract at address a with input mem[in..(in+insize))      |
 | insize, out, outsize)   |      | providing g gas and v wei and output area                       |
-|                         |      | mem[out..(out+outsize)] returting 1 on error (out of gas)       |
+|                         |      | mem[out..(out+outsize)) returning 0 on error (eg. out of gas)   |
+|                         |      | and 1 on success                                                |
 +-------------------------+------+-----------------------------------------------------------------+
-| callcode(g, a, v, in,   |      | identical to call but only use the code from a and stay         |
+| callcode(g, a, v, in,   |      | identical to `call` but only use the code from a and stay       |
 | insize, out, outsize)   |      | in the context of the current contract otherwise                |
 +-------------------------+------+-----------------------------------------------------------------+
-| delegatecall(g, a, in,  |      | identical to callcode but also keep ``caller``                  |
+| delegatecall(g, a, in,  |      | identical to `callcode` but also keep ``caller``                |
 | insize, out, outsize)   |      | and ``callvalue``                                               |
 +-------------------------+------+-----------------------------------------------------------------+
 | return(p, s)            | `*`  | end execution, return data mem[p..(p+s))                        |
@@ -564,6 +650,8 @@ It is planned that the stack height changes can be specified in inline assembly.
 
 .. code::
 
+    pragma solidity ^0.4.0;
+
     contract C {
         uint b;
         function f(uint x) returns (uint r) {
@@ -638,6 +726,8 @@ be just ``0``, but it can also be a complex functional-style expression.
 
 .. code::
 
+    pragma solidity ^0.4.0;
+
     contract C {
         function f(uint x) returns (uint b) {
             assembly {
diff --git a/docs/frequently-asked-questions.rst b/docs/frequently-asked-questions.rst
index b3667a11..acc0c106 100644
--- a/docs/frequently-asked-questions.rst
+++ b/docs/frequently-asked-questions.rst
@@ -317,17 +317,12 @@ providing any data or if someone messed up the types so that they tried to
 call a function that does not exist.
 
 The default behaviour (if no fallback function is explicitly given) in
-these situations is to just accept the call and do nothing.
-This is desireable in many cases, but should only be used if there is
-a way to pull out Ether from a contract.
+these situations is to throw an exception.
 
-If the contract is not meant to receive Ether with simple transfers, you
+If the contract is meant to receive Ether with simple transfers, you
 should implement the fallback function as
 
-``function() { throw; }``
-
-this will cause all transactions to this contract that do not call an
-existing function to be reverted, so that all Ether is sent back.
+``function() payable { }``
 
 Another use of the fallback function is to e.g. register that your
 contract received ether by using an event.
@@ -399,7 +394,7 @@ What character set does Solidity use?
 =====================================
 
 Solidity is character set agnostic concerning strings in the source code, although
-utf-8 is recommended. Identifiers (variables, functions, ...) can only use
+UTF-8 is recommended. Identifiers (variables, functions, ...) can only use
 ASCII.
 
 What are some examples of basic string manipulation (``substring``, ``indexOf``, ``charAt``, etc)?
@@ -461,16 +456,17 @@ If you do not want to throw, you can return a pair::
 
         function getCounter(uint index)
             returns (uint counter, bool error) {
-                if (index >= counters.length) return (0, true);
-                else return (counters[index], false);
+                if (index >= counters.length)
+                    return (0, true);
+                else
+                    return (counters[index], false);
         }
 
         function checkCounter(uint index) {
             var (counter, error) = getCounter(index);
             if (error) {
                 ...
-            }
-            else {
+            } else {
                 ...
             }
         }
@@ -487,6 +483,8 @@ What happens if you send ether along with a function call to a contract?
 ========================================================================
 
 It gets added to the total balance of the contract, just like when you send ether when creating a contract.
+You can only send ether along to a function that has the ``payable`` modifier,
+otherwise an exception is thrown.
 
 Is it possible to get a tx receipt for a transaction executed contract-to-contract?
 ===================================================================================
@@ -741,15 +739,15 @@ see a 32-byte hex value, this is just ``"stringliteral"`` in hex.
 The type ``bytes`` is similar, only that it can change its length.
 
 Finally, ``string`` is basically identical to ``bytes`` only that it is assumed
-to hold the utf-8 encoding of a real string. Since ``string`` stores the
-data in utf-8 encoding it is quite expensive to compute the number of
+to hold the UTF-8 encoding of a real string. Since ``string`` stores the
+data in UTF-8 encoding it is quite expensive to compute the number of
 characters in the string (the encoding of some characters takes more
 than a single byte). Because of that, ``string s; s.length`` is not yet
 supported and not even index access ``s[2]``. But if you want to access
 the low-level byte encoding of the string, you can use
 ``bytes(s).length`` and ``bytes(s)[2]`` which will result in the number
-of bytes in the utf-8 encoding of the string (not the number of
-characters) and the second byte (not character) of the utf-8 encoded
+of bytes in the UTF-8 encoding of the string (not the number of
+characters) and the second byte (not character) of the UTF-8 encoded
 string, respectively.
 
 
diff --git a/docs/index.rst b/docs/index.rst
index 5ca5c4a9..4cf75282 100644
--- a/docs/index.rst
+++ b/docs/index.rst
@@ -46,6 +46,9 @@ Available Solidity Integrations
 
 * `Atom Solidity Linter <https://atom.io/packages/linter-solidity>`_
     Plugin for the Atom editor that provides Solidity linting.
+    
+* `Solium <https://github.com/duaraghav8/Solium/>`_
+    A commandline linter for Solidity which strictly follows the rules prescribed by the `Solidity Style Guide <http://solidity.readthedocs.io/en/latest/style-guide.html>`_.
 
 * `Visual Studio Code extension <http://juan.blanco.ws/solidity-contracts-in-visual-studio-code/>`_
     Solidity plugin for Microsoft Visual Studio Code that includes syntax highlighting and the Solidity compiler.
@@ -56,6 +59,9 @@ Available Solidity Integrations
 * `Vim Solidity <https://github.com/tomlion/vim-solidity/>`_
     Plugin for the Vim editor providing syntax highlighting.
 
+* `Vim Syntastic <https://github.com/scrooloose/syntastic>`_
+    Plugin for the Vim editor providing compile checking.
+
 Discontinued:
 
 * `Mix IDE <https://github.com/ethereum/mix/>`_
@@ -63,11 +69,14 @@ Discontinued:
 
 
 Solidity Tools
--------------------------------
+--------------
+
+* `Dapple <https://github.com/nexusdev/dapple>`_
+    Package and deployment manager for Solidity.
 
 * `Solidity REPL <https://github.com/raineorshine/solidity-repl>`_
     Try Solidity instantly with a command-line Solidity console.
-    
+
 * `solgraph <https://github.com/raineorshine/solgraph>`_
     Visualize Solidity control flow and highlight potential security vulnerabilities.
 
@@ -110,4 +119,5 @@ Contents
    security-considerations.rst
    style-guide.rst
    common-patterns.rst
+   contributing.rst
    frequently-asked-questions.rst
diff --git a/docs/installing-solidity.rst b/docs/installing-solidity.rst
index 33bba29b..ad27e528 100644
--- a/docs/installing-solidity.rst
+++ b/docs/installing-solidity.rst
@@ -1,3 +1,7 @@
+.. index:: ! installing
+
+.. _installing-solidity:
+
 ###################
 Installing Solidity
 ###################
@@ -8,8 +12,10 @@ Browser-Solidity
 If you just want to try Solidity for small contracts, you
 can try `browser-solidity <https://ethereum.github.io/browser-solidity>`_
 which does not need any installation. If you want to use it
-without connection to the Internet, you can also just save the page
-locally or clone http://github.com/ethereum/browser-solidity.
+without connection to the Internet, you can go to
+https://github.com/ethereum/browser-solidity/tree/gh-pages and
+download the .ZIP file as explained on that page.
+
 
 npm / Node.js
 =============
@@ -22,7 +28,7 @@ package available.
 
 To install it, simply use
 
-::
+.. code:: bash
 
     npm install solc
 
@@ -32,102 +38,151 @@ Details about the usage of the Node.js package can be found in the
 Binary Packages
 ===============
 
-Binary packages of Solidity together with its IDE Mix are available through
-the `C++ bundle <https://github.com/ethereum/webthree-umbrella/releases>`_ of
-Ethereum.
+Binary packages of Solidity available at
+`solidity/releases <https://github.com/ethereum/solidity/releases>`_.
 
-Building from Source
-====================
+We also have PPAs for Ubuntu.  For the latest stable version.
 
-Building Solidity is quite similar on MacOS X, Ubuntu and probably other Unices.
-This guide starts explaining how to install the dependencies for each platform
-and then shows how to build Solidity itself.
+.. code:: bash
 
-MacOS X
--------
+    sudo add-apt-repository ppa:ethereum/ethereum
+    sudo apt-get update
+    sudo apt-get install solc
 
+If you want to use the cutting edge developer version:
 
-Requirements:
+.. code:: bash
 
-- OS X Yosemite (10.10.5)
-- Homebrew
-- Xcode
+    sudo add-apt-repository ppa:ethereum/ethereum
+    sudo add-apt-repository ppa:ethereum/ethereum-dev
+    sudo apt-get update
+    sudo apt-get install solc
 
-Set up Homebrew:
+Homebrew is missing pre-built bottles at the time of writing,
+following a Jenkins to TravisCI migration, but Homebrew
+should still work just fine as a means to build-from-source.
+We will re-add the pre-built bottles soon.
 
-.. code-block:: bash
+.. code:: bash
 
     brew update
     brew upgrade
+    brew tap ethereum/ethereum
+    brew install solidity
+    brew linkapps solidity
+
 
-    brew install boost --c++11             # this takes a while
-    brew install cmake cryptopp gmp
+.. _building-from-source:
 
-Ubuntu Trusty (14.04)
+Building from Source
+====================
+
+Clone the Repository
+--------------------
+
+To clone the source code, execute the following command:
+
+.. code:: bash
+
+    git clone --recursive https://github.com/ethereum/solidity.git
+    cd solidity
+
+If you want to help developing Solidity,
+you should fork Solidity and add your personal fork as a second remote:
+
+.. code:: bash
+
+    cd solidity
+    git remote add personal git@github.com:[username]/solidity.git
+
+
+Prerequisites - macOS
 ---------------------
 
-Below are the instructions to install the minimal dependencies required
-to compile Solidity on Ubuntu 14.04 (Trusty Tahr).
+For macOS, ensure that you have the latest version of
+`Xcode installed <https://developer.apple.com/xcode/download/>`_.
+This contains the `Clang C++ compiler <https://en.wikipedia.org/wiki/Clang>`_, the
+`Xcode IDE <https://en.wikipedia.org/wiki/Xcode>`_ and other Apple development
+tools which are required for building C++ applications on OS X.
+If you are installing Xcode for the first time, or have just installed a new
+version then you will need to agree to the license before you can do
+command-line builds:
+
+.. code:: bash
+
+    sudo xcodebuild -license accept
+
+Our OS X builds require you to `install the Homebrew <http://brew.sh>`_
+package manager for installing external dependencies.
+Here's how to `uninstall Homebrew
+<https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/FAQ.md#how-do-i-uninstall-homebrew>`_,
+if you ever want to start again from scratch.
 
-.. code-block:: bash
 
-    sudo apt-get -y install build-essential git cmake libgmp-dev libboost-all-dev \
-        libjsoncpp-dev
-    
-    sudo add-apt-repository -y ppa:ethereum/ethereum
-    sudo add-apt-repository -y ppa:ethereum/ethereum-dev
-    sudo apt-get -y update
-    sudo apt-get -y upgrade # this will update cmake to version 3.x
-    sudo apt-get -y install libcryptopp-dev libjsoncpp-dev
+Prerequisites - Windows
+-----------------------
 
-Ubuntu Xenial (16.04)
+You will need to install the following dependencies for Windows builds of Solidity:
+
++------------------------------+-------------------------------------------------------+
+| Software                     | Notes                                                 |
++==============================+=======================================================+
+| `Git for Windows`_           | Command-line tool for retrieving source from Github.  |
++------------------------------+-------------------------------------------------------+
+| `CMake`_                     | Cross-platform build file generator.                  |
++------------------------------+-------------------------------------------------------+
+| `Visual Studio 2015`_        | C++ compiler and dev environment.                     |
++------------------------------+-------------------------------------------------------+
+
+.. _Git for Windows: https://git-scm.com/download/win
+.. _CMake: https://cmake.org/download/
+.. _Visual Studio 2015: https://www.visualstudio.com/products/vs-2015-product-editions
+
+
+External Dependencies
 ---------------------
 
-Below are the instructions to install the minimal dependencies required
-to compile Solidity on Ubuntu 16.04 (Xenial Xerus).
-
-One of the dependencies (Crypto++ Library, with version >= 5.6.2) can be
-installed either by adding the Ethereum PPA (Option 1) or by backporting
-``libcrypto++`` from Ubuntu Development to Ubuntu Xenial (Option 2).
-
-.. code-block:: bash
-
-    sudo apt-get -y install build-essential git cmake libgmp-dev libboost-all-dev \
-        libjsoncpp-dev
-    
-    # (Option 1) For those willing to add the Ethereum PPA:
-    sudo add-apt-repository -y ppa:ethereum/ethereum
-    sudo add-apt-repository -y ppa:ethereum/ethereum-dev
-    sudo apt-get -y update
-    sudo apt-get -y upgrade
-    sudo apt-get -y install libcryptopp-dev
-    
-    ## (Option 2) For those willing to backport libcrypto++:
-    #sudo apt-get -y install ubuntu-dev-tools
-    #sudo pbuilder create
-    #mkdir ubuntu
-    #cd ubuntu
-    #backportpackage --workdir=. --build --dont-sign libcrypto++
-    #sudo dpkg -i buildresult/libcrypto++6_*.deb buildresult/libcrypto++-dev_*.deb
-    #cd ..
-
-Building
---------
-
-Run this if you plan on installing Solidity only:
-
-.. code-block:: bash
+We now have a "one button" script which installs all required external dependencies
+on macOS, Windows and on numerous Linux distros.  This used to be a multi-step
+manual process, but is now a one-liner:
+
+.. code:: bash
+
+    ./scripts/install_deps.sh
+
+Or, on Windows:
+
+.. code:: bat
+
+    scripts\install_deps.bat
+
+
+Command-Line Build
+------------------
+
+Building Solidity is quite similar on Linux, macOS and other Unices:
+
+.. code:: bash
 
-    git clone --recursive https://github.com/ethereum/solidity.git
-    cd solidity
     mkdir build
     cd build
     cmake .. && make
 
-If you want to help developing Solidity,
-you should fork Solidity and add your personal fork as a second remote:
+And even on Windows:
 
-.. code-block:: bash
+.. code:: bash
 
-    cd solidity
-    git remote add personal git@github.com:username/solidity.git
+    mkdir build
+    cd build
+    cmake -G "Visual Studio 14 2015 Win64" ..
+
+This latter set of instructions should result in the creation of
+**solidity.sln** in that build directory.  Double-clicking on that file
+should result in Visual Studio firing up.  We suggest building
+**RelWithDebugInfo** configuration, but all others work.
+
+Alternatively, you can build for Windows on the command-line, like so:
+
+.. code:: bash
+
+    cmake --build . --config RelWithDebInfo
diff --git a/docs/introduction-to-smart-contracts.rst b/docs/introduction-to-smart-contracts.rst
index 0122387b..922056ec 100644
--- a/docs/introduction-to-smart-contracts.rst
+++ b/docs/introduction-to-smart-contracts.rst
@@ -16,6 +16,8 @@ Storage
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract SimpleStorage {
         uint storedData;
 
@@ -28,6 +30,11 @@ Storage
         }
     }
 
+The first line simply tells that the source code is written for
+Solidity version 0.4.0 or anything newer that does not break functionality
+(up to, but not including, version 0.5.0). This is to ensure that the
+contract does not suddenly behave differently with a new compiler version.
+
 A contract in the sense of Solidity is a collection of code (its functions) and
 data (its *state*) that resides at a specific address on the Ethereum
 blockchain. The line ``uint storedData;`` declares a state variable called ``storedData`` of
@@ -63,6 +70,8 @@ registering with username and password - all you need is an Ethereum keypair.
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract Coin {
         // The keyword "public" makes those variables
         // readable from outside.
@@ -95,7 +104,7 @@ registering with username and password - all you need is an Ethereum keypair.
 This contract introduces some new concepts, let us go through them one by one.
 
 The line ``address public minter;`` declares a state variable of type address
-that is publicly accessible. The ``address`` type is a 160 bit value
+that is publicly accessible. The ``address`` type is a 160-bit value
 that does not allow any arithmetic operations. It is suitable for
 storing addresses of contracts or keypairs belonging to external
 persons. The keyword ``public`` automatically generates a function that
@@ -220,7 +229,7 @@ only the person holding the keys to the account can transfer money from it.
 Blocks
 ======
 
-One major obstacle to overcome is what in bitcoin terms is called "double-spend attack":
+One major obstacle to overcome is what, in Bitcoin terms, is called a "double-spend attack":
 What happens if two transactions exist in the network that both want to empty an account,
 a so-called conflict?
 
@@ -236,7 +245,7 @@ Ethereum this is roughly every 17 seconds.
 
 As part of the "order selection mechanism" (which is called "mining") it may happen that
 blocks are reverted from time to time, but only at the "tip" of the chain. The more
-blocks are reverted the less likely it is. So it might be that your transactions
+blocks that are added on top, the less likely it is. So it might be that your transactions
 are reverted and even removed from the blockchain, but the longer you wait, the less
 likely it will be.
 
@@ -277,7 +286,7 @@ of transactions sent from that address, the so-called "nonce").
 Apart from the fact whether an account stores code or not,
 the EVM treats the two types equally, though.
 
-Every account has a persistent key-value store mapping 256 bit words to 256 bit
+Every account has a persistent key-value store mapping 256-bit words to 256-bit
 words called **storage**.
 
 Furthermore, every account has a **balance** in
@@ -300,7 +309,7 @@ If the target account is the zero-account (the account with the
 address ``0``), the transaction creates a **new contract**.
 As already mentioned, the address of that contract is not
 the zero address but an address derived from the sender and
-its number of transaction sent (the "nonce"). The payload
+its number of transactions sent (the "nonce"). The payload
 of such a contract creation transaction is taken to be
 EVM bytecode and executed. The output of this execution is
 permanently stored as the code of the contract.
@@ -332,7 +341,7 @@ Storage, Memory and the Stack
 =============================
 
 Each account has a persistent memory area which is called **storage**.
-Storage is a key-value store that maps 256 bit words to 256 bit words.
+Storage is a key-value store that maps 256-bit words to 256-bit words.
 It is not possible to enumerate storage from within a contract
 and it is comparatively costly to read and even more so, to modify
 storage. A contract can neither read nor write to any storage apart
@@ -340,7 +349,7 @@ from its own.
 
 The second memory area is called **memory**, of which a contract obtains
 a freshly cleared instance for each message call. Memory can be
-addressed at byte level, but read and written to in 32 byte (256 bit)
+addressed at byte level, but read and written to in 32 byte (256-bit)
 chunks. Memory is more costly the larger it grows (it scales
 quadratically).
 
@@ -364,7 +373,7 @@ Instruction Set
 
 The instruction set of the EVM is kept minimal in order to avoid
 incorrect implementations which could cause consensus problems.
-All instructions operate on the basic data type, 256 bit words.
+All instructions operate on the basic data type, 256-bit words.
 The usual arithmetic, bit, logical and comparison operations are present.
 Conditional and unconditional jumps are possible. Furthermore,
 contracts can access relevant properties of the current block
@@ -444,13 +453,13 @@ receives the address of the new contract on the stack.
 
 .. index:: selfdestruct
 
-Selfdestruct
-============
+``selfdestruct``
+================
 
 The only possibility that code is removed from the blockchain is
-when a contract at that address performs the ``SELFDESTRUCT`` operation.
+when a contract at that address performs the ``selfdestruct`` operation.
 The remaining Ether stored at that address is sent to a designated
 target and then the storage and code is removed.
 
-Note that even if a contract's code does not contain the ``SELFDESTRUCT``
-opcode, it can still perform that operation using delegatecall or callcode.
+Note that even if a contract's code does not contain a call to ``selfdestruct``,
+it can still perform that operation using ``delegatecall`` or ``callcode``.
diff --git a/docs/layout-of-source-files.rst b/docs/layout-of-source-files.rst
index ef6fd656..17ac8c6f 100644
--- a/docs/layout-of-source-files.rst
+++ b/docs/layout-of-source-files.rst
@@ -2,7 +2,36 @@
 Layout of a Solidity Source File
 ********************************
 
-Source files can contain an arbitrary number of contract definitions and include directives.
+Source files can contain an arbitrary number of contract definitions, include directives
+and pragma directives.
+
+.. index:: ! pragma, version
+
+Version Pragma
+==============
+
+Source files can (and should) be annotated with a so-called version pragma to reject
+being compiled with future compiler versions that might introduce incompatible
+changes. We try to keep such changes to an absolute minimum and especially
+introduce changes in a way that changes in semantics will also require changes
+in the syntax, but this is of course not always possible. Because of that, it is always
+a good idea to read through the changelog at least for releases that contain
+breaking changes, those releases will always have versions of the form
+``0.x.0`` or ``x.0.0``.
+
+The version pragma is used as follows::
+
+  pragma solidity ^0.4.0;
+
+Such a source file will not compile with a compiler earlier than version 0.4.0
+and it will also not work on a compiler starting form version 0.5.0 (this
+second condition is added by using ``^``). The idea behind this is that
+there will be no breaking changes until version ``0.5.0``, so we can always
+be sure that our code will compile the way we intended it to. We do not fix
+the exact version of the compiler, so that bugfix releases are still possible.
+
+It is possible to specify much more complex rules for the compiler version,
+the expression follows those used by npm.
 
 .. index:: source file, ! import
 
@@ -61,7 +90,7 @@ It depends on the compiler (see below) how to actually resolve the paths.
 In general, the directory hierarchy does not need to strictly map onto your local
 filesystem, it can also map to resources discovered via e.g. ipfs, http or git.
 
-Use in actual Compilers
+Use in Actual Compilers
 -----------------------
 
 When the compiler is invoked, it is not only possible to specify how to
@@ -101,7 +130,7 @@ and then run the compiler as
 
 As a more complex example, suppose you rely on some module that uses a
 very old version of dapp-bin. That old version of dapp-bin is checked
-out at ``/usr/local/dapp-bin_old``, then you can use 
+out at ``/usr/local/dapp-bin_old``, then you can use
 
 .. code-block:: bash
 
@@ -163,6 +192,8 @@ for the two input parameters and two returned values.
 
 ::
 
+    pragma solidity ^0.4.0;
+
  /** @title Shape calculator.*/
  contract shapeCalculator{
      /**@dev Calculates a rectangle's surface and perimeter.
@@ -171,9 +202,9 @@ for the two input parameters and two returned values.
       * @return s The calculated surface.
       * @return p The calculated perimeter.
       */
-     function rectangle(uint w, uint h) returns (uint s, uint p){
-         s = w*h;
-         p = 2*(w+h);
+     function rectangle(uint w, uint h) returns (uint s, uint p) {
+         s = w * h;
+         p = 2 * (w + h);
      }
  }
 
diff --git a/docs/miscellaneous.rst b/docs/miscellaneous.rst
index 304fce14..7d4cedb6 100644
--- a/docs/miscellaneous.rst
+++ b/docs/miscellaneous.rst
@@ -15,6 +15,23 @@ Statically-sized variables (everything except mapping and dynamically-sized arra
 - If an elementary type does not fit the remaining part of a storage slot, it is moved to the next storage slot.
 - Structs and array data always start a new slot and occupy whole slots (but items inside a struct or array are packed tightly according to these rules).
 
+.. warning::
+    When using elements that are smaller than 32 bytes, your contract's gas usage may be higher.
+    This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller
+    than that, the EVM must use more operations in order to reduce the size of the element from 32
+    bytes to the desired size.
+
+    It is only beneficial to use reduced-size arguments if you are dealing with storage values
+    because the compiler will pack multiple elements into one storage slot, and thus, combine
+    multiple reads or writes into a single operation. When dealing with function arguments or memory
+    values, there is no inherent benefit because the compiler does not pack these values.
+
+    Finally, in order to allow the EVM to optimize for this, ensure that you try to order your
+    storage variables and ``struct`` members such that they can be packed tightly. For example,
+    declaring your storage variables in the order of ``uint128, uint128, uint256`` instead of
+    ``uint128, uint256, uint128``, as the former will only take up two slots of storage whereas the
+    latter will take up three.
+
 The elements of structs and arrays are stored after each other, just as if they were given explicitly.
 
 Due to their unpredictable size, mapping and dynamically-sized array types use a ``sha3``
@@ -66,7 +83,7 @@ Calling ``select(false, x)`` will compute ``x * x`` and ``select(true, x)`` will
 .. index:: optimizer, common subexpression elimination, constant propagation
 
 *************************
-Internals - the Optimizer
+Internals - The Optimizer
 *************************
 
 The Solidity optimizer operates on assembly, so it can be and also is used by other languages. It splits the sequence of instructions into basic blocks at JUMPs and JUMPDESTs. Inside these blocks, the instructions are analysed and every modification to the stack, to memory or storage is recorded as an expression which consists of an instruction and a list of arguments which are essentially pointers to other expressions. The main idea is now to find expressions that are always equal (on every input) and combine them into an expression class. The optimizer first tries to find each new expression in a list of already known expressions. If this does not work, the expression is simplified according to rules like ``constant + constant = sum_of_constants`` or ``X * 1 = X``. Since this is done recursively, we can also apply the latter rule if the second factor is a more complex expression where we know that it will always evaluate to one. Modifications to storage and memory locations have to erase knowledge about storage and memory locations which are not known to be different: If we first write to location x and then to location y and both are input variables, the second could overwrite the first, so we actually do not know what is stored at x after we wrote to y. On the other hand, if a simplification of the expression x - y evaluates to a non-zero constant, we know that we can keep our knowledge about what is stored at x.
@@ -195,7 +212,6 @@ Tips and Tricks
 * Make your state variables public - the compiler will create :ref:`getters <visibility-and-accessors>` for you for free.
 * If you end up checking conditions on input or state a lot at the beginning of your functions, try using :ref:`modifiers`.
 * If your contract has a function called ``send`` but you want to use the built-in send-function, use ``address(contractVariable).send(amount)``.
-* If you do **not** want your contracts to receive ether when called via ``send``, you can add a throwing fallback function ``function() { throw; }``.
 * Initialise storage structs with a single assignment: ``x = MyStruct({a: 1, b: 2});``
 
 **********
@@ -228,7 +244,7 @@ The following is the order of precedence for operators, listed in order of evalu
 +            +-------------------------------------+--------------------------------------------+
 |            | Unary plus and minus                | ``+``, ``-``                               |
 +            +-------------------------------------+--------------------------------------------+
-|            | Unary operations                    | ``after``, ``delete``                      |
+|            | Unary operations                    | ``delete``                                 |
 +            +-------------------------------------+--------------------------------------------+
 |            | Logical NOT                         | ``!``                                      |
 +            +-------------------------------------+--------------------------------------------+
@@ -286,7 +302,7 @@ Global Variables
 - ``sha3(...) returns (bytes32)``: compute the Ethereum-SHA-3 (KECCAK-256) hash of the (tightly packed) arguments
 - ``sha256(...) returns (bytes32)``: compute the SHA-256 hash of the (tightly packed) arguments
 - ``ripemd160(...) returns (bytes20)``: compute the RIPEMD-160 hash of the (tightly packed) arguments
-- ``ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)``: recover address associated with the public key from elliptic curve signature
+- ``ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)``: recover address associated with the public key from elliptic curve signature, return zero on error
 - ``addmod(uint x, uint y, uint k) returns (uint)``: compute ``(x + y) % k`` where the addition is performed with arbitrary precision and does not wrap around at ``2**256``
 - ``mulmod(uint x, uint y, uint k) returns (uint)``: compute ``(x * y) % k`` where the multiplication is performed with arbitrary precision and does not wrap around at ``2**256``
 - ``this`` (current contract's type): the current contract, explicitly convertible to ``address``
@@ -321,4 +337,4 @@ Modifiers
 - ``constant`` for functions: Disallows modification of state - this is not enforced yet.
 - ``anonymous`` for events: Does not store event signature as topic.
 - ``indexed`` for event parameters: Stores the parameter as topic.
-
+- ``payable`` for functions: Allows them to receive Ether together with a call.
diff --git a/docs/security-considerations.rst b/docs/security-considerations.rst
index bae6e20b..a2f4ec4c 100644
--- a/docs/security-considerations.rst
+++ b/docs/security-considerations.rst
@@ -1,3 +1,5 @@
+.. _security_considerations:
+
 #######################
 Security Considerations
 #######################
@@ -49,6 +51,8 @@ complete contract):
 
 ::
 
+  pragma solidity ^0.4.0;
+
   // THIS CONTRACT CONTAINS A BUG - DO NOT USE
   contract Fund {
       /// Mapping of ether shares of the contract.
@@ -71,6 +75,8 @@ outlined further below:
 
 ::
 
+  pragma solidity ^0.4.0;
+
   contract Fund {
       /// Mapping of ether shares of the contract.
       mapping(address => uint) shares;
@@ -101,7 +107,14 @@ and stall those. Please be explicit about such cases in the documentation of you
 Sending and Receiving Ether
 ===========================
 
-- If a contract receives Ether (without a function being called), the fallback function is executed. The contract can only rely
+- Neither contracts nor "external accounts" are currently able to prevent that someone sends them Ether.
+  Contracts can react on and reject a regular transfer, but there are ways
+  to move Ether without creating a message call. One way is to simply "mine to"
+  the contract address and the second way is using ``selfdestruct(x)``. 
+
+- If a contract receives Ether (without a function being called), the fallback function is executed.
+  If it does not have a fallback function, the Ether will be rejected (by throwing an exception).
+  During the execution of the fallback function, the contract can only rely
   on the "gas stipend" (2300 gas) being available to it at that time. This stipend is not enough to access storage in any way.
   To be sure that your contract can receive Ether in that way, check the gas requirements of the fallback function
   (for example in the "details" section in browser-solidity).
@@ -124,7 +137,7 @@ Sending and Receiving Ether
      because the operation is just too expensive) - it "runs out of gas" (OOG).
      If the return value of ``send`` is checked, this might provide a
      means for the recipient to block progress in the sending contract. Again, the best practice here is to use
-     a "withdraw" pattern instead of a "send" pattern.
+     a :ref:`"withdraw" pattern instead of a "send" pattern <withdrawal_pattern>`.
 
 Callstack Depth
 ===============
@@ -145,7 +158,10 @@ Never use tx.origin for authorization. Let's say you have a wallet contract like
 
 ::
 
-    contract TxUserWallet {  
+    pragma solidity ^0.4.0;
+
+    // THIS CONTRACT CONTAINS A BUG - DO NOT USE
+    contract TxUserWallet {
         address owner;
 
         function TxUserWallet() {
@@ -162,7 +178,9 @@ Now someone tricks you into sending ether to the address of this attack wallet:
 
 ::
 
-    contract TxAttackWallet {  
+    pragma solidity ^0.4.0;
+
+    contract TxAttackWallet {
         address owner;
 
         function TxAttackWallet() {
@@ -174,7 +192,7 @@ Now someone tricks you into sending ether to the address of this attack wallet:
         }
     }
 
-If your wallet had checked msg.sender for authorization, it would get the address of the attack wallet, instead of the owner address. But by checking tx.origin, it gets the original address that kicked off the transaction, which is still the owner address. The attack wallet instantly drains all your funds.
+If your wallet had checked ``msg.sender`` for authorization, it would get the address of the attack wallet, instead of the owner address. But by checking ``tx.origin``, it gets the original address that kicked off the transaction, which is still the owner address. The attack wallet instantly drains all your funds.
 
 
 Minor Details
diff --git a/docs/solidity-by-example.rst b/docs/solidity-by-example.rst
index 7dd51f00..9d3dd6f6 100644
--- a/docs/solidity-by-example.rst
+++ b/docs/solidity-by-example.rst
@@ -36,6 +36,8 @@ of votes.
 
 ::
 
+    pragma solidity ^0.4.0;
+
     /// @title Voting with delegation.
     contract Ballot {
         // This declares a new complex type which will
@@ -133,8 +135,7 @@ of votes.
                 // If the delegate already voted,
                 // directly add to the number of votes
                 proposals[delegate.vote].voteCount += sender.weight;
-            }
-            else {
+            } else {
                 // If the delegate did not vote yet,
                 // add to her weight.
                 delegate.weight += sender.weight;
@@ -191,6 +192,8 @@ contract into a blind auction where it is not
 possible to see the actual bid until the bidding
 period ends.
 
+.. _simple_auction:
+
 Simple Open Auction
 ===================
 
@@ -207,6 +210,8 @@ activate themselves.
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract SimpleAuction {
         // Parameters of the auction. Times are either
         // absolute unix timestamps (seconds since 1970-01-01)
@@ -250,10 +255,12 @@ activate themselves.
         /// together with this transaction.
         /// The value will only be refunded if the
         /// auction is not won.
-        function bid() {
+        function bid() payable {
             // No arguments are necessary, all
             // information is already part of
-            // the transaction.
+            // the transaction. The keyword payable
+            // is required for the function to
+            // be able to receive Ether.
             if (now > auctionStart + biddingTime) {
                 // Revert the call if the bidding
                 // period is over.
@@ -269,7 +276,7 @@ activate themselves.
                 // highestBidder.send(highestBid) is a security risk
                 // because it can be prevented by the caller by e.g.
                 // raising the call stack to 1023. It is always safer
-                // to let the recipient withdraw their money themselves. 
+                // to let the recipient withdraw their money themselves.
                 pendingReturns[highestBidder] += highestBid;
             }
             highestBidder = msg.sender;
@@ -278,14 +285,21 @@ activate themselves.
         }
 
         /// Withdraw a bid that was overbid.
-        function withdraw() {
+        function withdraw() returns (bool) {
             var amount = pendingReturns[msg.sender];
-            // It is important to set this to zero because the recipient
-            // can call this function again as part of the receiving call
-            // before `send` returns.
-            pendingReturns[msg.sender] = 0;
-            if (!msg.sender.send(amount))
-                throw; // If anything fails, this will revert the changes above
+            if (amount > 0) {
+                // It is important to set this to zero because the recipient
+                // can call this function again as part of the receiving call
+                // before `send` returns.
+                pendingReturns[msg.sender] = 0;
+
+                if (!msg.sender.send(amount)) { 
+                    // No need to call throw here, just reset the amount owing
+                    pendingReturns[msg.sender] = amount;
+                    return false;
+                }
+            }
+            return true;
         }
 
         /// End the auction and send the highest bid
@@ -318,16 +332,6 @@ activate themselves.
             if (!beneficiary.send(highestBid))
                 throw;
         }
-
-        function () {
-            // This function gets executed if a
-            // transaction with invalid data is sent to
-            // the contract or just ether without data.
-            // We revert the send so that no-one
-            // accidentally loses money when using the
-            // contract.
-            throw;
-        }
     }
 
 Blind Auction
@@ -369,6 +373,8 @@ high or low invalid bids.
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract BlindAuction {
         struct Bid {
             bytes32 blindedBid;
@@ -395,8 +401,8 @@ high or low invalid bids.
         /// functions. `onlyBefore` is applied to `bid` below:
         /// The new function body is the modifier's body where
         /// `_` is replaced by the old function body.
-        modifier onlyBefore(uint _time) { if (now >= _time) throw; _ }
-        modifier onlyAfter(uint _time) { if (now <= _time) throw; _ }
+        modifier onlyBefore(uint _time) { if (now >= _time) throw; _; }
+        modifier onlyAfter(uint _time) { if (now <= _time) throw; _; }
 
         function BlindAuction(
             uint _biddingTime,
@@ -419,6 +425,7 @@ high or low invalid bids.
         /// still make the required deposit. The same address can
         /// place multiple bids.
         function bid(bytes32 _blindedBid)
+            payable
             onlyBefore(biddingEnd)
         {
             bids[msg.sender].push(Bid({
@@ -489,15 +496,22 @@ high or low invalid bids.
         }
 
         /// Withdraw a bid that was overbid.
-        function withdraw() {
+        function withdraw() returns (bool) {
             var amount = pendingReturns[msg.sender];
-            // It is important to set this to zero because the recipient
-            // can call this function again as part of the receiving call
-            // before `send` returns (see the remark above about
-            // conditions -> effects -> interaction).
-            pendingReturns[msg.sender] = 0;
-            if (!msg.sender.send(amount))
-                throw; // If anything fails, this will revert the changes above
+            if (amount > 0) {
+                // It is important to set this to zero because the recipient
+                // can call this function again as part of the receiving call
+                // before `send` returns (see the remark above about
+                // conditions -> effects -> interaction).
+                pendingReturns[msg.sender] = 0;
+
+                if (!msg.sender.send(amount)){
+                    // No need to call throw here, just reset the amount owing
+                    pendingReturns[msg.sender] = amount;
+                    return false;
+                }
+            }
+            return true;
         }
 
         /// End the auction and send the highest bid
@@ -514,10 +528,6 @@ high or low invalid bids.
             if (!beneficiary.send(this.balance))
                 throw;
         }
-
-        function () {
-            throw;
-        }
     }
 
 .. index:: purchase, remote purchase, escrow
@@ -528,6 +538,8 @@ Safe Remote Purchase
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract Purchase {
         uint public value;
         address public seller;
@@ -535,7 +547,7 @@ Safe Remote Purchase
         enum State { Created, Locked, Inactive }
         State public state;
 
-        function Purchase() {
+        function Purchase() payable {
             seller = msg.sender;
             value = msg.value / 2;
             if (2 * value != msg.value) throw;
@@ -543,22 +555,22 @@ Safe Remote Purchase
 
         modifier require(bool _condition) {
             if (!_condition) throw;
-            _
+            _;
         }
 
         modifier onlyBuyer() {
             if (msg.sender != buyer) throw;
-            _
+            _;
         }
 
         modifier onlySeller() {
             if (msg.sender != seller) throw;
-            _
+            _;
         }
 
         modifier inState(State _state) {
             if (state != _state) throw;
-            _
+            _;
         }
 
         event aborted();
@@ -585,6 +597,7 @@ Safe Remote Purchase
         function confirmPurchase()
             inState(State.Created)
             require(msg.value == 2 * value)
+            payable
         {
             purchaseConfirmed();
             buyer = msg.sender;
@@ -607,10 +620,6 @@ Safe Remote Purchase
             if (!buyer.send(value) || !seller.send(this.balance))
                 throw;
         }
-
-        function() {
-            throw;
-        }
     }
 
 ********************
diff --git a/docs/structure-of-a-contract.rst b/docs/structure-of-a-contract.rst
index 79f78422..c7af0c8c 100644
--- a/docs/structure-of-a-contract.rst
+++ b/docs/structure-of-a-contract.rst
@@ -20,6 +20,8 @@ State variables are values which are permanently stored in contract storage.
 
 ::
 
+  pragma solidity ^0.4.0;
+
   contract SimpleStorage {
       uint storedData; // State variable
       // ...
@@ -38,8 +40,10 @@ Functions are the executable units of code within a contract.
 
 ::
 
+  pragma solidity ^0.4.0;
+
   contract SimpleAuction {
-      function bid() { // Function
+      function bid() payable { // Function
           // ...
       }
   }
@@ -58,12 +62,14 @@ Function modifiers can be used to amend the semantics of functions in a declarat
 
 ::
 
+  pragma solidity ^0.4.0;
+
   contract Purchase {
       address public seller;
 
       modifier onlySeller() { // Modifier
           if (msg.sender != seller) throw;
-          _
+          _;
       }
 
       function abort() onlySeller { // Modifier usage
@@ -80,10 +86,12 @@ Events are convenience interfaces with the EVM logging facilities.
 
 ::
 
+  pragma solidity ^0.4.0;
+
   contract SimpleAuction {
       event HighestBidIncreased(address bidder, uint amount); // Event
 
-      function bid() {
+      function bid() payable {
           // ...
           HighestBidIncreased(msg.sender, msg.value); // Triggering event
       }
@@ -102,6 +110,8 @@ Structs are custom defined types that can group several variables (see
 
 ::
 
+  pragma solidity ^0.4.0;
+
   contract Ballot {
       struct Voter { // Struct
           uint weight;
@@ -121,6 +131,8 @@ Enums can be used to create custom types with a finite set of values (see
 
 ::
 
+  pragma solidity ^0.4.0;
+
   contract Purchase {
       enum State { Created, Locked, Inactive } // Enum
   }
diff --git a/docs/style-guide.rst b/docs/style-guide.rst
index c509a9d4..272a1b31 100644
--- a/docs/style-guide.rst
+++ b/docs/style-guide.rst
@@ -118,7 +118,7 @@ Source File Encoding
 UTF-8 or ASCII encoding is preferred.
 
 Imports
-==========
+=======
 
 Import statements should always be placed at the top of the file.
 
@@ -273,17 +273,17 @@ No::
         }));
 
 For ``if`` blocks which have an ``else`` or ``else if`` clause, the ``else`` should be
-placed on it's own line following the previous closing parenthesis.  The
-parenthesis for the else block should follow the same rules as the other
-conditional control structures.
+placed on the same line as the ``if``'s closing brace. This is an exception compared
+to the rules of other block-like structures.
 
 Yes::
 
     if (x < 3) {
         x += 1;
-    }
-    else {
+    } else if (x > 7) {
         x -= 1;
+    } else {
+        x = 5;
     }
 
 
@@ -296,7 +296,8 @@ No::
 
     if (x < 3) {
         x += 1;
-    } else {
+    }
+    else {
         x -= 1;
     }
 
@@ -354,7 +355,7 @@ No::
         selfdestruct(owner);
     }
 
-For long function declarations, it is recommended to drop each arguent onto
+For long function declarations, it is recommended to drop each argument onto
 it's own line at the same indentation level as the function body.  The closing
 parenthesis and opening bracket should be placed on their own line as well at
 the same indentation level as the function declaration.
@@ -519,6 +520,18 @@ No::
 Other Recommendations
 =====================
 
+* Strings should be quoted with double-quotes instead of single-quotes.
+
+Yes::
+
+    str = "foo";
+    str = "Hamlet says, 'To be or not to be...'";
+
+No::
+
+    str = 'bar';
+    str = '"Be yourself; everyone else is already taken." -Oscar Wilde';
+
 * Surround operators with a single space on either side.
 
 Yes::
@@ -602,7 +615,7 @@ indistinguishable from the numerals one and zero.
 Contract and Library Names
 ==========================
 
-Contracts should be named using the CapWords style.
+Contracts and libraries should be named using the CapWords style.
 
 
 Events
diff --git a/docs/types.rst b/docs/types.rst
index 0c5aaf1b..9d7ebec9 100644
--- a/docs/types.rst
+++ b/docs/types.rst
@@ -57,6 +57,8 @@ Operators:
 Division always truncates (it just maps to the DIV opcode of the EVM), but it does not truncate if both
 operators are :ref:`literals<rational_literals>` (or literal expressions).
 
+Division by zero and modulus with zero throws an exception.
+
 .. index:: address, balance, send, call, callcode, delegatecall
 
 .. _address:
@@ -147,10 +149,10 @@ Dynamically-sized byte array
 ``bytes``:
     Dynamically-sized byte array, see :ref:`arrays`. Not a value-type!
 ``string``:
-    Dynamically-sized UTF8-encoded string, see :ref:`arrays`. Not a value-type!
+    Dynamically-sized UTF-8-encoded string, see :ref:`arrays`. Not a value-type!
 
 As a rule of thumb, use ``bytes`` for arbitrary-length raw byte data and ``string``
-for arbitrary-length string (utf-8) data. If you can limit the length to a certain
+for arbitrary-length string (UTF-8) data. If you can limit the length to a certain
 number of bytes, always use one of ``bytes1`` to ``bytes32`` because they are much cheaper.
 
 .. index:: ! ufixed, ! fixed, ! fixed point number
@@ -214,9 +216,18 @@ a non-rational number).
 String Literals
 ---------------
 
-String Literals are written with double quotes (``"abc"``). As with integer literals, their type can vary, but they are implicitly convertible to ``bytes1``, ..., ``bytes32`` if they fit, to ``bytes`` and to ``string``.
+String literals are written with either double or single-quotes (``"foo"`` or ``'bar'``). As with integer literals, their type can vary, but they are implicitly convertible to ``bytes1``, ..., ``bytes32``, if they fit, to ``bytes`` and to ``string``.
+
+String literals support escape characters, such as ``\n``, ``\xNN`` and ``\uNNNN``. ``\xNN`` takes a hex value and inserts the appropriate byte, while ``\uNNNN`` takes a Unicode codepoint and inserts an UTF-8 sequence.
+
+.. index:: literal, bytes
+
+Hexadecimal Literals
+--------------------
 
-String Literals support escape characters, such as ``\n``, ``\xNN`` and ``\uNNNN``. ``\xNN`` takes a hex value and inserts the appropriate byte, while ``\uNNNN`` takes a Unicode codepoint and inserts an UTF8 sequence.
+Hexademical Literals are prefixed with the keyword ``hex`` and are enclosed in double or single-quotes (``hex"001122FF"``). Their content must be a hexadecimal string and their value will be the binary representation of those values.
+
+Hexademical Literals behave like String Literals and have the same convertibility restrictions.
 
 .. index:: enum
 
@@ -230,6 +241,8 @@ to and from all integer types but implicit conversion is not allowed.
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract test {
         enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }
         ActionChoices choice;
@@ -289,6 +302,8 @@ memory-stored reference type does not create a copy.
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract C {
         uint[] x; // the data location of x is storage
 
@@ -353,7 +368,7 @@ So ``bytes`` should always be preferred over ``byte[]`` because it is cheaper.
 .. note::
     If you want to access the byte-representation of a string ``s``, use
     ``bytes(s).length`` / ``bytes(s)[7] = 'x';``. Keep in mind
-    that you are accessing the low-level bytes of the utf-8 representation,
+    that you are accessing the low-level bytes of the UTF-8 representation,
     and not the individual characters!
 
 .. index:: ! array;allocating, new
@@ -367,6 +382,8 @@ the ``.length`` member.
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract C {
         function f(uint len) {
             uint[] memory a = new uint[](7);
@@ -386,6 +403,8 @@ assigned to a variable right away.
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract C {
         function f() {
             g([uint(1), 2, 3]);
@@ -405,6 +424,8 @@ possible:
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract C {
         function f() {
             // The next line creates a type error because uint[3] memory
@@ -441,6 +462,8 @@ Members
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract ArrayContract {
         uint[2**20] m_aLotOfIntegers;
         // Note that the following is not a pair of arrays but an array of pairs.
@@ -510,6 +533,8 @@ shown in the following example:
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract CrowdFunding {
         // Defines a new type with two fields.
         struct Funder {
@@ -534,7 +559,7 @@ shown in the following example:
             campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0);
         }
 
-        function contribute(uint campaignID) {
+        function contribute(uint campaignID) payable {
             Campaign c = campaigns[campaignID];
             // Creates a new temporary memory struct, initialised with the given values
             // and copies it over to storage.
@@ -547,9 +572,10 @@ shown in the following example:
             Campaign c = campaigns[campaignID];
             if (c.amount < c.fundingGoal)
                 return false;
-            if (!c.beneficiary.send(c.amount))
-                throw;
+            uint amount = c.amount;
             c.amount = 0;
+            if (!c.beneficiary.send(amount))
+                throw;
             return true;
         }
     }
@@ -611,6 +637,8 @@ It is important to note that ``delete a`` really behaves like an assignment to `
 
 ::
 
+    pragma solidity ^0.4.0;
+
     contract DeleteExample {
         uint data;
         uint[] dataArray;
@@ -650,13 +678,18 @@ Explicit Conversions
 --------------------
 
 If the compiler does not allow implicit conversion but you know what you are
-doing, an explicit type conversion is sometimes possible::
+doing, an explicit type conversion is sometimes possible. Note that this may
+give you some unexpected behaviour so be sure to test to ensure that the
+result is what you want! Take the following example where you are converting
+a negative ``int8`` to a ``uint``:
+
+::
 
     int8 y = -3;
     uint x = uint(y);
 
 At the end of this code snippet, ``x`` will have the value ``0xfffff..fd`` (64 hex
-characters), which is -3 in two's complement representation of 256 bits.
+characters), which is -3 in the two's complement representation of 256 bits.
 
 If a type is explicitly converted to a smaller type, higher-order bits are
 cut off::
diff --git a/docs/units-and-global-variables.rst b/docs/units-and-global-variables.rst
index 8b8f4daa..9ee334cf 100644
--- a/docs/units-and-global-variables.rst
+++ b/docs/units-and-global-variables.rst
@@ -7,18 +7,18 @@ Units and Globally Available Variables
 Ether Units
 ===========
 
-A literal number can take a suffix of ``wei``, ``finney``, ``szabo`` or ``ether`` to convert between the subdenominations of Ether, where Ether currency numbers without a postfix are assumed to be "wei", e.g. ``2 ether == 2000 finney`` evaluates to ``true``.
+A literal number can take a suffix of ``wei``, ``finney``, ``szabo`` or ``ether`` to convert between the subdenominations of Ether, where Ether currency numbers without a postfix are assumed to be Wei, e.g. ``2 ether == 2000 finney`` evaluates to ``true``.
 
 .. index:: time, seconds, minutes, hours, days, weeks, years
 
 Time Units
 ==========
 
-Suffixes of ``seconds``, ``minutes``, ``hours``, ``days``, ``weeks`` and
+Suffixes like ``seconds``, ``minutes``, ``hours``, ``days``, ``weeks`` and
 ``years`` after literal numbers can be used to convert between units of time where seconds are the base
 unit and units are considered naively in the following way:
 
- * ``1 == 1 second``
+ * ``1 == 1 seconds``
  * ``1 minutes == 60 seconds``
  * ``1 hours == 60 minutes``
  * ``1 days == 24 hours``
@@ -95,7 +95,7 @@ Mathematical and Cryptographic Functions
 ``ripemd160(...) returns (bytes20)``:
     compute RIPEMD-160 hash of the (tightly packed) arguments
 ``ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)``:
-    recover the address associated with the public key from elliptic curve signature
+    recover the address associated with the public key from elliptic curve signature or return zero on error
 
 In the above, "tightly packed" means that the arguments are concatenated without padding.
 This means that the following are all identical::
@@ -109,6 +109,10 @@ This means that the following are all identical::
 If padding is needed, explicit type conversions can be used: ``sha3("\x00\x12")`` is the
 same as ``sha3(uint16(0x12))``.
 
+Note that constants will be packed using the minimum number of bytes required to store them.
+This means that, for example, ``sha3(0) == sha3(uint8(0))`` and
+``sha3(0x12345678) == sha3(uint32(0x12345678))``.
+
 It might be that you run into Out-of-Gas for ``sha256``, ``ripemd160`` or ``ecrecover`` on a *private blockchain*. The reason for this is that those are implemented as so-called precompiled contracts and these contracts only really exist after they received the first message (although their contract code is hardcoded). Messages to non-existing contracts are more expensive and thus the execution runs into an Out-of-Gas error. A workaround for this problem is to first send e.g. 1 Wei to each of the contracts before you use them in your actual contracts. This is not an issue on the official or test net.
 
 .. _address_related:
diff --git a/docs/utils/SolidityLexer.py b/docs/utils/SolidityLexer.py
index d05c7b0c..779147f4 100644
--- a/docs/utils/SolidityLexer.py
+++ b/docs/utils/SolidityLexer.py
@@ -58,12 +58,14 @@ class SolidityLexer(RegexLexer):
              r'throw|try|catch|finally|new|delete|typeof|instanceof|void|'
              r'this|import|mapping|returns|private|public|external|internal|'
              r'constant|memory|storage)\b', Keyword, 'slashstartsregex'),
-            (r'(var|let|with|function|event|modifier|struct|enum|contract)\b', Keyword.Declaration, 'slashstartsregex'),
+            (r'(var|let|with|function|event|modifier|struct|enum|contract|library)\b', Keyword.Declaration, 'slashstartsregex'),
             (r'(bytes|string|address|uint|int|bool|byte|' +
              '|'.join(
                  ['uint%d' % (i + 8) for i in range(0, 256, 8)] +
                  ['int%d' % (i + 8) for i in range(0, 256, 8)] +
-                 ['bytes%d' % (i + 1) for i in range(0, 32)]
+                 ['bytes%d' % (i + 1) for i in range(0, 32)] +
+                 ['ufixed%dx%d' % ((i), (j + 8)) for i in range(0, 256, 8) for j in range(0, 256 - i, 8)] +
+                 ['fixed%dx%d' % ((i), (j + 8)) for i in range(0, 256, 8) for j in range(0, 256 - i, 8)]
              ) + r')\b', Keyword.Type, 'slashstartsregex'),
             (r'(abstract|boolean|byte|char|class|const|debugger|double|enum|export|'
              r'extends|final|float|goto|implements|int|interface|long|native|'
diff --git a/libdevcore/Common.h b/libdevcore/Common.h
index 8bc5f58f..6fbc112d 100644
--- a/libdevcore/Common.h
+++ b/libdevcore/Common.h
@@ -23,7 +23,7 @@
 
 #pragma once
 
-// way to many unsigned to size_t warnings in 32 bit build
+// way too many unsigned to size_t warnings in 32 bit build
 #ifdef _M_IX86
 #pragma warning(disable:4244)
 #endif
diff --git a/libdevcore/Hash.cpp b/libdevcore/Hash.cpp
deleted file mode 100644
index c6b917b9..00000000
--- a/libdevcore/Hash.cpp
+++ /dev/null
@@ -1,440 +0,0 @@
-/*
-	This file is part of cpp-ethereum.
-
-	cpp-ethereum is free software: you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation, either version 3 of the License, or
-	(at your option) any later version.
-
-	cpp-ethereum is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.
-*/
-/** @file Hash.cpp
- * @author Gav Wood <i@gavwood.com>
- * @date 2014
- */
-
-#include "Hash.h"
-#include <cstdio>
-#include <cstdlib>
-#include <cstring>
-#include "picosha2.h"
-using namespace std;
-using namespace dev;
-
-namespace dev
-{
-
-h256 sha256(bytesConstRef _input)
-{
-	h256 ret;
-	picosha2::hash256(_input.begin(), _input.end(), ret.data(), ret.data() + 32);
-	return ret;
-}
-
-namespace rmd160
-{
-
-/********************************************************************\
- *
- *      FILE:     rmd160.h
- *      FILE:     rmd160.c
- *
- *      CONTENTS: Header file for a sample C-implementation of the
- *                RIPEMD-160 hash-function.
- *      TARGET:   any computer with an ANSI C compiler
- *
- *      AUTHOR:   Antoon Bosselaers, ESAT-COSIC
- *      DATE:     1 March 1996
- *      VERSION:  1.0
- *
- *      Copyright (c) Katholieke Universiteit Leuven
- *      1996, All Rights Reserved
- *
- \********************************************************************/
-
-// Adapted into "header-only" format by Gav Wood.
-
-/* macro definitions */
-
-#define RMDsize 160
-
-/* collect four bytes into one word: */
-#define BYTES_TO_DWORD(strptr)                    \
-(((uint32_t) *((strptr)+3) << 24) | \
-((uint32_t) *((strptr)+2) << 16) | \
-((uint32_t) *((strptr)+1) <<  8) | \
-((uint32_t) *(strptr)))
-
-/* ROL(x, n) cyclically rotates x over n bits to the left */
-/* x must be of an unsigned 32 bits type and 0 <= n < 32. */
-#define ROL(x, n)        (((x) << (n)) | ((x) >> (32-(n))))
-
-/* the five basic functions F(), G() and H() */
-#define F(x, y, z)        ((x) ^ (y) ^ (z))
-#define G(x, y, z)        (((x) & (y)) | (~(x) & (z)))
-#define H(x, y, z)        (((x) | ~(y)) ^ (z))
-#define I(x, y, z)        (((x) & (z)) | ((y) & ~(z)))
-#define J(x, y, z)        ((x) ^ ((y) | ~(z)))
-
-/* the ten basic operations FF() through III() */
-#define FF(a, b, c, d, e, x, s)        {\
-(a) += F((b), (c), (d)) + (x);\
-(a) = ROL((a), (s)) + (e);\
-(c) = ROL((c), 10);\
-}
-#define GG(a, b, c, d, e, x, s)        {\
-(a) += G((b), (c), (d)) + (x) + 0x5a827999UL;\
-(a) = ROL((a), (s)) + (e);\
-(c) = ROL((c), 10);\
-}
-#define HH(a, b, c, d, e, x, s)        {\
-(a) += H((b), (c), (d)) + (x) + 0x6ed9eba1UL;\
-(a) = ROL((a), (s)) + (e);\
-(c) = ROL((c), 10);\
-}
-#define II(a, b, c, d, e, x, s)        {\
-(a) += I((b), (c), (d)) + (x) + 0x8f1bbcdcUL;\
-(a) = ROL((a), (s)) + (e);\
-(c) = ROL((c), 10);\
-}
-#define JJ(a, b, c, d, e, x, s)        {\
-(a) += J((b), (c), (d)) + (x) + 0xa953fd4eUL;\
-(a) = ROL((a), (s)) + (e);\
-(c) = ROL((c), 10);\
-}
-#define FFF(a, b, c, d, e, x, s)        {\
-(a) += F((b), (c), (d)) + (x);\
-(a) = ROL((a), (s)) + (e);\
-(c) = ROL((c), 10);\
-}
-#define GGG(a, b, c, d, e, x, s)        {\
-(a) += G((b), (c), (d)) + (x) + 0x7a6d76e9UL;\
-(a) = ROL((a), (s)) + (e);\
-(c) = ROL((c), 10);\
-}
-#define HHH(a, b, c, d, e, x, s)        {\
-(a) += H((b), (c), (d)) + (x) + 0x6d703ef3UL;\
-(a) = ROL((a), (s)) + (e);\
-(c) = ROL((c), 10);\
-}
-#define III(a, b, c, d, e, x, s)        {\
-(a) += I((b), (c), (d)) + (x) + 0x5c4dd124UL;\
-(a) = ROL((a), (s)) + (e);\
-(c) = ROL((c), 10);\
-}
-#define JJJ(a, b, c, d, e, x, s)        {\
-(a) += J((b), (c), (d)) + (x) + 0x50a28be6UL;\
-(a) = ROL((a), (s)) + (e);\
-(c) = ROL((c), 10);\
-}
-
-void MDinit(uint32_t *MDbuf)
-{
-	MDbuf[0] = 0x67452301UL;
-	MDbuf[1] = 0xefcdab89UL;
-	MDbuf[2] = 0x98badcfeUL;
-	MDbuf[3] = 0x10325476UL;
-	MDbuf[4] = 0xc3d2e1f0UL;
-
-	return;
-}
-
-/********************************************************************/
-
-void MDcompress(uint32_t *MDbuf, uint32_t *X)
-{
-	uint32_t aa = MDbuf[0],  bb = MDbuf[1],  cc = MDbuf[2],
-	dd = MDbuf[3],  ee = MDbuf[4];
-	uint32_t aaa = MDbuf[0], bbb = MDbuf[1], ccc = MDbuf[2],
-	ddd = MDbuf[3], eee = MDbuf[4];
-
-	/* round 1 */
-	FF(aa, bb, cc, dd, ee, X[ 0], 11);
-	FF(ee, aa, bb, cc, dd, X[ 1], 14);
-	FF(dd, ee, aa, bb, cc, X[ 2], 15);
-	FF(cc, dd, ee, aa, bb, X[ 3], 12);
-	FF(bb, cc, dd, ee, aa, X[ 4],  5);
-	FF(aa, bb, cc, dd, ee, X[ 5],  8);
-	FF(ee, aa, bb, cc, dd, X[ 6],  7);
-	FF(dd, ee, aa, bb, cc, X[ 7],  9);
-	FF(cc, dd, ee, aa, bb, X[ 8], 11);
-	FF(bb, cc, dd, ee, aa, X[ 9], 13);
-	FF(aa, bb, cc, dd, ee, X[10], 14);
-	FF(ee, aa, bb, cc, dd, X[11], 15);
-	FF(dd, ee, aa, bb, cc, X[12],  6);
-	FF(cc, dd, ee, aa, bb, X[13],  7);
-	FF(bb, cc, dd, ee, aa, X[14],  9);
-	FF(aa, bb, cc, dd, ee, X[15],  8);
-
-	/* round 2 */
-	GG(ee, aa, bb, cc, dd, X[ 7],  7);
-	GG(dd, ee, aa, bb, cc, X[ 4],  6);
-	GG(cc, dd, ee, aa, bb, X[13],  8);
-	GG(bb, cc, dd, ee, aa, X[ 1], 13);
-	GG(aa, bb, cc, dd, ee, X[10], 11);
-	GG(ee, aa, bb, cc, dd, X[ 6],  9);
-	GG(dd, ee, aa, bb, cc, X[15],  7);
-	GG(cc, dd, ee, aa, bb, X[ 3], 15);
-	GG(bb, cc, dd, ee, aa, X[12],  7);
-	GG(aa, bb, cc, dd, ee, X[ 0], 12);
-	GG(ee, aa, bb, cc, dd, X[ 9], 15);
-	GG(dd, ee, aa, bb, cc, X[ 5],  9);
-	GG(cc, dd, ee, aa, bb, X[ 2], 11);
-	GG(bb, cc, dd, ee, aa, X[14],  7);
-	GG(aa, bb, cc, dd, ee, X[11], 13);
-	GG(ee, aa, bb, cc, dd, X[ 8], 12);
-
-	/* round 3 */
-	HH(dd, ee, aa, bb, cc, X[ 3], 11);
-	HH(cc, dd, ee, aa, bb, X[10], 13);
-	HH(bb, cc, dd, ee, aa, X[14],  6);
-	HH(aa, bb, cc, dd, ee, X[ 4],  7);
-	HH(ee, aa, bb, cc, dd, X[ 9], 14);
-	HH(dd, ee, aa, bb, cc, X[15],  9);
-	HH(cc, dd, ee, aa, bb, X[ 8], 13);
-	HH(bb, cc, dd, ee, aa, X[ 1], 15);
-	HH(aa, bb, cc, dd, ee, X[ 2], 14);
-	HH(ee, aa, bb, cc, dd, X[ 7],  8);
-	HH(dd, ee, aa, bb, cc, X[ 0], 13);
-	HH(cc, dd, ee, aa, bb, X[ 6],  6);
-	HH(bb, cc, dd, ee, aa, X[13],  5);
-	HH(aa, bb, cc, dd, ee, X[11], 12);
-	HH(ee, aa, bb, cc, dd, X[ 5],  7);
-	HH(dd, ee, aa, bb, cc, X[12],  5);
-
-	/* round 4 */
-	II(cc, dd, ee, aa, bb, X[ 1], 11);
-	II(bb, cc, dd, ee, aa, X[ 9], 12);
-	II(aa, bb, cc, dd, ee, X[11], 14);
-	II(ee, aa, bb, cc, dd, X[10], 15);
-	II(dd, ee, aa, bb, cc, X[ 0], 14);
-	II(cc, dd, ee, aa, bb, X[ 8], 15);
-	II(bb, cc, dd, ee, aa, X[12],  9);
-	II(aa, bb, cc, dd, ee, X[ 4],  8);
-	II(ee, aa, bb, cc, dd, X[13],  9);
-	II(dd, ee, aa, bb, cc, X[ 3], 14);
-	II(cc, dd, ee, aa, bb, X[ 7],  5);
-	II(bb, cc, dd, ee, aa, X[15],  6);
-	II(aa, bb, cc, dd, ee, X[14],  8);
-	II(ee, aa, bb, cc, dd, X[ 5],  6);
-	II(dd, ee, aa, bb, cc, X[ 6],  5);
-	II(cc, dd, ee, aa, bb, X[ 2], 12);
-
-	/* round 5 */
-	JJ(bb, cc, dd, ee, aa, X[ 4],  9);
-	JJ(aa, bb, cc, dd, ee, X[ 0], 15);
-	JJ(ee, aa, bb, cc, dd, X[ 5],  5);
-	JJ(dd, ee, aa, bb, cc, X[ 9], 11);
-	JJ(cc, dd, ee, aa, bb, X[ 7],  6);
-	JJ(bb, cc, dd, ee, aa, X[12],  8);
-	JJ(aa, bb, cc, dd, ee, X[ 2], 13);
-	JJ(ee, aa, bb, cc, dd, X[10], 12);
-	JJ(dd, ee, aa, bb, cc, X[14],  5);
-	JJ(cc, dd, ee, aa, bb, X[ 1], 12);
-	JJ(bb, cc, dd, ee, aa, X[ 3], 13);
-	JJ(aa, bb, cc, dd, ee, X[ 8], 14);
-	JJ(ee, aa, bb, cc, dd, X[11], 11);
-	JJ(dd, ee, aa, bb, cc, X[ 6],  8);
-	JJ(cc, dd, ee, aa, bb, X[15],  5);
-	JJ(bb, cc, dd, ee, aa, X[13],  6);
-
-	/* parallel round 1 */
-	JJJ(aaa, bbb, ccc, ddd, eee, X[ 5],  8);
-	JJJ(eee, aaa, bbb, ccc, ddd, X[14],  9);
-	JJJ(ddd, eee, aaa, bbb, ccc, X[ 7],  9);
-	JJJ(ccc, ddd, eee, aaa, bbb, X[ 0], 11);
-	JJJ(bbb, ccc, ddd, eee, aaa, X[ 9], 13);
-	JJJ(aaa, bbb, ccc, ddd, eee, X[ 2], 15);
-	JJJ(eee, aaa, bbb, ccc, ddd, X[11], 15);
-	JJJ(ddd, eee, aaa, bbb, ccc, X[ 4],  5);
-	JJJ(ccc, ddd, eee, aaa, bbb, X[13],  7);
-	JJJ(bbb, ccc, ddd, eee, aaa, X[ 6],  7);
-	JJJ(aaa, bbb, ccc, ddd, eee, X[15],  8);
-	JJJ(eee, aaa, bbb, ccc, ddd, X[ 8], 11);
-	JJJ(ddd, eee, aaa, bbb, ccc, X[ 1], 14);
-	JJJ(ccc, ddd, eee, aaa, bbb, X[10], 14);
-	JJJ(bbb, ccc, ddd, eee, aaa, X[ 3], 12);
-	JJJ(aaa, bbb, ccc, ddd, eee, X[12],  6);
-
-	/* parallel round 2 */
-	III(eee, aaa, bbb, ccc, ddd, X[ 6],  9);
-	III(ddd, eee, aaa, bbb, ccc, X[11], 13);
-	III(ccc, ddd, eee, aaa, bbb, X[ 3], 15);
-	III(bbb, ccc, ddd, eee, aaa, X[ 7],  7);
-	III(aaa, bbb, ccc, ddd, eee, X[ 0], 12);
-	III(eee, aaa, bbb, ccc, ddd, X[13],  8);
-	III(ddd, eee, aaa, bbb, ccc, X[ 5],  9);
-	III(ccc, ddd, eee, aaa, bbb, X[10], 11);
-	III(bbb, ccc, ddd, eee, aaa, X[14],  7);
-	III(aaa, bbb, ccc, ddd, eee, X[15],  7);
-	III(eee, aaa, bbb, ccc, ddd, X[ 8], 12);
-	III(ddd, eee, aaa, bbb, ccc, X[12],  7);
-	III(ccc, ddd, eee, aaa, bbb, X[ 4],  6);
-	III(bbb, ccc, ddd, eee, aaa, X[ 9], 15);
-	III(aaa, bbb, ccc, ddd, eee, X[ 1], 13);
-	III(eee, aaa, bbb, ccc, ddd, X[ 2], 11);
-
-	/* parallel round 3 */
-	HHH(ddd, eee, aaa, bbb, ccc, X[15],  9);
-	HHH(ccc, ddd, eee, aaa, bbb, X[ 5],  7);
-	HHH(bbb, ccc, ddd, eee, aaa, X[ 1], 15);
-	HHH(aaa, bbb, ccc, ddd, eee, X[ 3], 11);
-	HHH(eee, aaa, bbb, ccc, ddd, X[ 7],  8);
-	HHH(ddd, eee, aaa, bbb, ccc, X[14],  6);
-	HHH(ccc, ddd, eee, aaa, bbb, X[ 6],  6);
-	HHH(bbb, ccc, ddd, eee, aaa, X[ 9], 14);
-	HHH(aaa, bbb, ccc, ddd, eee, X[11], 12);
-	HHH(eee, aaa, bbb, ccc, ddd, X[ 8], 13);
-	HHH(ddd, eee, aaa, bbb, ccc, X[12],  5);
-	HHH(ccc, ddd, eee, aaa, bbb, X[ 2], 14);
-	HHH(bbb, ccc, ddd, eee, aaa, X[10], 13);
-	HHH(aaa, bbb, ccc, ddd, eee, X[ 0], 13);
-	HHH(eee, aaa, bbb, ccc, ddd, X[ 4],  7);
-	HHH(ddd, eee, aaa, bbb, ccc, X[13],  5);
-
-	/* parallel round 4 */
-	GGG(ccc, ddd, eee, aaa, bbb, X[ 8], 15);
-	GGG(bbb, ccc, ddd, eee, aaa, X[ 6],  5);
-	GGG(aaa, bbb, ccc, ddd, eee, X[ 4],  8);
-	GGG(eee, aaa, bbb, ccc, ddd, X[ 1], 11);
-	GGG(ddd, eee, aaa, bbb, ccc, X[ 3], 14);
-	GGG(ccc, ddd, eee, aaa, bbb, X[11], 14);
-	GGG(bbb, ccc, ddd, eee, aaa, X[15],  6);
-	GGG(aaa, bbb, ccc, ddd, eee, X[ 0], 14);
-	GGG(eee, aaa, bbb, ccc, ddd, X[ 5],  6);
-	GGG(ddd, eee, aaa, bbb, ccc, X[12],  9);
-	GGG(ccc, ddd, eee, aaa, bbb, X[ 2], 12);
-	GGG(bbb, ccc, ddd, eee, aaa, X[13],  9);
-	GGG(aaa, bbb, ccc, ddd, eee, X[ 9], 12);
-	GGG(eee, aaa, bbb, ccc, ddd, X[ 7],  5);
-	GGG(ddd, eee, aaa, bbb, ccc, X[10], 15);
-	GGG(ccc, ddd, eee, aaa, bbb, X[14],  8);
-
-	/* parallel round 5 */
-	FFF(bbb, ccc, ddd, eee, aaa, X[12] ,  8);
-	FFF(aaa, bbb, ccc, ddd, eee, X[15] ,  5);
-	FFF(eee, aaa, bbb, ccc, ddd, X[10] , 12);
-	FFF(ddd, eee, aaa, bbb, ccc, X[ 4] ,  9);
-	FFF(ccc, ddd, eee, aaa, bbb, X[ 1] , 12);
-	FFF(bbb, ccc, ddd, eee, aaa, X[ 5] ,  5);
-	FFF(aaa, bbb, ccc, ddd, eee, X[ 8] , 14);
-	FFF(eee, aaa, bbb, ccc, ddd, X[ 7] ,  6);
-	FFF(ddd, eee, aaa, bbb, ccc, X[ 6] ,  8);
-	FFF(ccc, ddd, eee, aaa, bbb, X[ 2] , 13);
-	FFF(bbb, ccc, ddd, eee, aaa, X[13] ,  6);
-	FFF(aaa, bbb, ccc, ddd, eee, X[14] ,  5);
-	FFF(eee, aaa, bbb, ccc, ddd, X[ 0] , 15);
-	FFF(ddd, eee, aaa, bbb, ccc, X[ 3] , 13);
-	FFF(ccc, ddd, eee, aaa, bbb, X[ 9] , 11);
-	FFF(bbb, ccc, ddd, eee, aaa, X[11] , 11);
-
-	/* combine results */
-	ddd += cc + MDbuf[1];               /* final result for MDbuf[0] */
-	MDbuf[1] = MDbuf[2] + dd + eee;
-	MDbuf[2] = MDbuf[3] + ee + aaa;
-	MDbuf[3] = MDbuf[4] + aa + bbb;
-	MDbuf[4] = MDbuf[0] + bb + ccc;
-	MDbuf[0] = ddd;
-
-	return;
-}
-
-void MDfinish(uint32_t *MDbuf, byte const *strptr, uint32_t lswlen, uint32_t mswlen)
-{
-	unsigned int i;                                 /* counter       */
-	uint32_t        X[16];                             /* message words */
-
-	memset(X, 0, 16*sizeof(uint32_t));
-
-	/* put bytes from strptr into X */
-	for (i=0; i<(lswlen&63); i++) {
-		/* byte i goes into word X[i div 4] at pos.  8*(i mod 4)  */
-		X[i>>2] ^= (uint32_t) *strptr++ << (8 * (i&3));
-	}
-
-	/* append the bit m_n == 1 */
-	X[(lswlen>>2)&15] ^= (uint32_t)1 << (8*(lswlen&3) + 7);
-
-	if ((lswlen & 63) > 55) {
-		/* length goes to next block */
-		MDcompress(MDbuf, X);
-		memset(X, 0, 16*sizeof(uint32_t));
-	}
-
-	/* append length in bits*/
-	X[14] = lswlen << 3;
-	X[15] = (lswlen >> 29) | (mswlen << 3);
-	MDcompress(MDbuf, X);
-
-	return;
-}
-
-#undef ROL
-#undef F
-#undef G
-#undef H
-#undef I
-#undef J
-#undef FF
-#undef GG
-#undef HH
-#undef II
-#undef JJ
-#undef FFF
-#undef GGG
-#undef HHH
-#undef III
-#undef JJJ
-
-}
-
-/*
- * @returns RMD(_input)
- */
-h160 ripemd160(bytesConstRef _input)
-{
-	h160 hashcode;
-	uint32_t buffer[RMDsize / 32];		// contains (A, B, C, D(, E))
-	uint32_t current[16];				// current 16-word chunk
-
-	// initialize
-	rmd160::MDinit(buffer);
-	byte const* message = _input.data();
-	uint32_t remaining = _input.size();	// # of bytes not yet processed
-
-	// process message in 16x 4-byte chunks
-	for (; remaining >= 64; remaining -= 64)
-	{
-		for (unsigned i = 0; i < 16; i++)
-		{
-			current[i] = BYTES_TO_DWORD(message);
-			message += 4;
-		}
-		rmd160::MDcompress(buffer, current);
-	}
-	// length mod 64 bytes left
-
-	// finish:
-	rmd160::MDfinish(buffer, message, _input.size(), 0);
-
-	for (unsigned i = 0; i < RMDsize / 8; i += 4)
-	{
-		hashcode[i] = buffer[i >> 2];				//  implicit cast to byte
-		hashcode[i + 1] = (buffer[i >> 2] >> 8);	//extracts the 8 least
-		hashcode[i + 2] = (buffer[i >> 2] >> 16);	// significant bits.
-		hashcode[i + 3] = (buffer[i >> 2] >> 24);
-	}
-
-	return hashcode;
-}
-
-#undef BYTES_TO_DWORD
-#undef RMDsize
-
-}
diff --git a/libdevcore/Hash.h b/libdevcore/Hash.h
deleted file mode 100644
index d4401014..00000000
--- a/libdevcore/Hash.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
-	This file is part of cpp-ethereum.
-
-	cpp-ethereum is free software: you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation, either version 3 of the License, or
-	(at your option) any later version.
-
-	cpp-ethereum is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.
-*/
-/** @file Hash.h
- * @author Gav Wood <i@gavwood.com>
- * @date 2014
- *
- * The FixedHash fixed-size "hash" container type.
- */
-
-#pragma once
-
-#include <string>
-#include "FixedHash.h"
-#include "vector_ref.h"
-#include "SHA3.h"
-
-namespace dev
-{
-
-h256 sha256(bytesConstRef _input);
-
-h160 ripemd160(bytesConstRef _input);
-
-}
diff --git a/libdevcore/vector_ref.h b/libdevcore/vector_ref.h
index 46d06946..698377c9 100644
--- a/libdevcore/vector_ref.h
+++ b/libdevcore/vector_ref.h
@@ -7,7 +7,7 @@
 #include <string>
 
 #ifdef __INTEL_COMPILER
-#pragma warning(disable:597) //will not be called for implicit or explicit conversions
+#pragma warning(disable:597) // will not be called for implicit or explicit conversions
 #endif
 
 namespace dev
diff --git a/libevmasm/Assembly.cpp b/libevmasm/Assembly.cpp
index 2024b1e9..c7822819 100644
--- a/libevmasm/Assembly.cpp
+++ b/libevmasm/Assembly.cpp
@@ -123,7 +123,7 @@ ostream& Assembly::streamAsm(ostream& _out, string const& _prefix, StringMap con
 			_out << "  " << instructionInfo(i.instruction()).name  << "\t" << i.getJumpTypeAsString();
 			break;
 		case Push:
-			_out << "  PUSH " << hex << i.data();
+			_out << "  PUSH" << dec << max<unsigned>(1, dev::bytesRequired(i.data())) << " 0x" << hex << i.data();
 			break;
 		case PushString:
 			_out << "  PUSH \"" << m_strings.at((h256)i.data()) << "\"";
diff --git a/libsolidity/analysis/SemVerHandler.cpp b/libsolidity/analysis/SemVerHandler.cpp
new file mode 100644
index 00000000..c7b212b2
--- /dev/null
+++ b/libsolidity/analysis/SemVerHandler.cpp
@@ -0,0 +1,290 @@
+/*
+	This file is part of cpp-ethereum.
+
+	cpp-ethereum is free software: you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
+
+	cpp-ethereum is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.
+*/
+/**
+ * @author Christian <chris@ethereum.org>
+ * @date 2016
+ * Utilities to handle semantic versioning.
+ */
+
+#include <libsolidity/analysis/SemVerHandler.h>
+#include <functional>
+
+using namespace std;
+using namespace dev;
+using namespace dev::solidity;
+
+SemVerVersion::SemVerVersion(string const& _versionString)
+{
+	auto i = _versionString.begin();
+	auto end = _versionString.end();
+
+	for (unsigned level = 0; level < 3; ++level)
+	{
+		unsigned v = 0;
+		for (; i != end && '0' <= *i && *i <= '9'; ++i)
+			v = v * 10 + (*i - '0');
+		numbers[level] = v;
+		if (level < 2)
+		{
+			if (i == end || *i != '.')
+				throw SemVerError();
+			else
+				++i;
+		}
+	}
+	if (i != end && *i == '-')
+	{
+		auto prereleaseStart = ++i;
+		while (i != end && *i != '+') ++i;
+		prerelease = string(prereleaseStart, i);
+	}
+	if (i != end && *i == '+')
+	{
+		auto buildStart = ++i;
+		while (i != end) ++i;
+		build = string(buildStart, i);
+	}
+	if (i != end)
+		throw SemVerError();
+}
+
+bool SemVerMatchExpression::MatchComponent::matches(SemVerVersion const& _version) const
+{
+	if (prefix == Token::BitNot)
+	{
+		MatchComponent comp = *this;
+
+		comp.prefix = Token::GreaterThanOrEqual;
+		if (!comp.matches(_version))
+			return false;
+
+		if (levelsPresent >= 2)
+			comp.levelsPresent = 2;
+		else
+			comp.levelsPresent = 1;
+		comp.prefix = Token::LessThanOrEqual;
+		return comp.matches(_version);
+	}
+	else if (prefix == Token::BitXor)
+	{
+		MatchComponent comp = *this;
+
+		comp.prefix = Token::GreaterThanOrEqual;
+		if (!comp.matches(_version))
+			return false;
+
+		if (comp.version.numbers[0] == 0)
+			comp.levelsPresent = 2;
+		else
+			comp.levelsPresent = 1;
+		comp.prefix = Token::LessThanOrEqual;
+		return comp.matches(_version);
+	}
+	else
+	{
+		int cmp = 0;
+		bool didCompare = false;
+		for (unsigned i = 0; i < levelsPresent && cmp == 0; i++)
+			if (version.numbers[i] != unsigned(-1))
+			{
+				didCompare = true;
+				cmp = _version.numbers[i] - version.numbers[i];
+			}
+		if (cmp == 0 && !_version.prerelease.empty() && didCompare)
+			cmp = -1;
+		if (prefix == Token::Assign)
+			return cmp == 0;
+		else if (prefix == Token::LessThan)
+			return cmp < 0;
+		else if (prefix == Token::LessThanOrEqual)
+			return cmp <= 0;
+		else if (prefix == Token::GreaterThan)
+			return cmp > 0;
+		else if (prefix == Token::GreaterThanOrEqual)
+			return cmp >= 0;
+		else
+			solAssert(false, "Invalid SemVer expression");
+		return false;
+	}
+}
+
+bool SemVerMatchExpression::Conjunction::matches(SemVerVersion const& _version) const
+{
+	for (auto const& component: components)
+		if (!component.matches(_version))
+			return false;
+	return true;
+}
+
+bool SemVerMatchExpression::matches(SemVerVersion const& _version) const
+{
+	if (!isValid())
+		return false;
+	for (auto const& range: m_disjunction)
+		if (range.matches(_version))
+			return true;
+	return false;
+}
+
+SemVerMatchExpression SemVerMatchExpressionParser::parse()
+{
+	reset();
+
+	try
+	{
+		while (true)
+		{
+			parseMatchExpression();
+			if (m_pos >= m_tokens.size())
+				break;
+			if (currentToken() != Token::Or)
+				throw SemVerError();
+			nextToken();
+		}
+	}
+	catch (SemVerError const&)
+	{
+		reset();
+	}
+
+	return m_expression;
+}
+
+
+void SemVerMatchExpressionParser::reset()
+{
+	m_expression = SemVerMatchExpression();
+	m_pos = 0;
+	m_posInside = 0;
+}
+
+void SemVerMatchExpressionParser::parseMatchExpression()
+{
+	// component - component (range)
+	// or component component* (conjunction)
+
+	SemVerMatchExpression::Conjunction range;
+	range.components.push_back(parseMatchComponent());
+	if (currentToken() == Token::Sub)
+	{
+		range.components[0].prefix = Token::GreaterThanOrEqual;
+		nextToken();
+		range.components.push_back(parseMatchComponent());
+		range.components[1].prefix = Token::LessThanOrEqual;
+	}
+	else
+		while (currentToken() != Token::Or && currentToken() != Token::Illegal)
+			range.components.push_back(parseMatchComponent());
+	m_expression.m_disjunction.push_back(range);
+}
+
+SemVerMatchExpression::MatchComponent SemVerMatchExpressionParser::parseMatchComponent()
+{
+	SemVerMatchExpression::MatchComponent component;
+	Token::Value token = currentToken();
+	if (
+		token == Token::BitXor ||
+		token == Token::BitNot ||
+		token == Token::LessThan ||
+		token == Token::LessThanOrEqual||
+		token == Token::GreaterThan ||
+		token == Token::GreaterThanOrEqual ||
+		token == Token::Assign
+	)
+	{
+		component.prefix = token;
+		nextToken();
+	}
+	else
+		component.prefix = Token::Assign;
+
+	component.levelsPresent = 0;
+	while (component.levelsPresent < 3)
+	{
+		component.version.numbers[component.levelsPresent] = parseVersionPart();
+		component.levelsPresent++;
+		if (currentChar() == '.')
+			nextChar();
+		else
+			break;
+	}
+	// TODO we do not support pre and build version qualifiers for now in match expressions
+	// (but we do support them in the actual versions)
+	return component;
+}
+
+unsigned SemVerMatchExpressionParser::parseVersionPart()
+{
+	auto startPos = m_pos;
+	char c = currentChar();
+	nextChar();
+	if (c == 'x' || c == 'X' || c == '*')
+		return unsigned(-1);
+	else if (c == '0')
+		return 0;
+	else if ('1' <= c && c <= '9')
+	{
+		unsigned v = c - '0';
+		// If we skip to the next token, the current number is terminated.
+		while (m_pos == startPos && '0' <= currentChar() && currentChar() <= '9')
+		{
+			c = currentChar();
+			if (v * 10 < v || v * 10 + (c - '0') < v * 10)
+				throw SemVerError();
+			v = v * 10 + c - '0';
+			nextChar();
+		}
+		return v;
+	}
+	else
+		throw SemVerError();
+}
+
+char SemVerMatchExpressionParser::currentChar() const
+{
+	if (m_pos >= m_literals.size())
+		return char(-1);
+	if (m_posInside >= m_literals[m_pos].size())
+		return char(-1);
+	return m_literals[m_pos][m_posInside];
+}
+
+char SemVerMatchExpressionParser::nextChar()
+{
+	if (m_pos < m_literals.size())
+	{
+		if (m_posInside + 1 >= m_literals[m_pos].size())
+			nextToken();
+		else
+			++m_posInside;
+	}
+	return currentChar();
+}
+
+Token::Value SemVerMatchExpressionParser::currentToken() const
+{
+	if (m_pos < m_tokens.size())
+		return m_tokens[m_pos];
+	else
+		return Token::Illegal;
+}
+
+void SemVerMatchExpressionParser::nextToken()
+{
+	++m_pos;
+	m_posInside = 0;
+}
diff --git a/libsolidity/analysis/SemVerHandler.h b/libsolidity/analysis/SemVerHandler.h
new file mode 100644
index 00000000..3c110b19
--- /dev/null
+++ b/libsolidity/analysis/SemVerHandler.h
@@ -0,0 +1,102 @@
+/*
+	This file is part of cpp-ethereum.
+
+	cpp-ethereum is free software: you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
+
+	cpp-ethereum is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.
+*/
+/**
+ * @author Christian <chris@ethereum.org>
+ * @date 2016
+ * Utilities to handle semantic versioning.
+ */
+
+#pragma once
+
+#include <vector>
+#include <libsolidity/parsing/Token.h>
+
+namespace dev
+{
+namespace solidity
+{
+
+class SemVerError: dev::Exception
+{
+};
+
+struct SemVerVersion
+{
+	unsigned numbers[3];
+	std::string prerelease;
+	std::string build;
+
+	explicit SemVerVersion(std::string const& _versionString = "0.0.0");
+};
+
+struct SemVerMatchExpression
+{
+	bool matches(SemVerVersion const& _version) const;
+
+	bool isValid() const { return !m_disjunction.empty(); }
+
+	struct MatchComponent
+	{
+		/// Prefix from < > <= >= ~ ^
+		Token::Value prefix = Token::Illegal;
+		/// Version, where unsigned(-1) in major, minor or patch denotes '*', 'x' or 'X'
+		SemVerVersion version;
+		/// Whether we have 1, 1.2 or 1.2.4
+		unsigned levelsPresent = 1;
+		bool matches(SemVerVersion const& _version) const;
+	};
+
+	struct Conjunction
+	{
+		std::vector<MatchComponent> components;
+		bool matches(SemVerVersion const& _version) const;
+	};
+
+	std::vector<Conjunction> m_disjunction;
+};
+
+class SemVerMatchExpressionParser
+{
+public:
+	SemVerMatchExpressionParser(std::vector<Token::Value> const& _tokens, std::vector<std::string> const& _literals):
+		m_tokens(_tokens), m_literals(_literals)
+	{}
+	SemVerMatchExpression parse();
+
+private:
+	void reset();
+
+	void parseMatchExpression();
+	SemVerMatchExpression::MatchComponent parseMatchComponent();
+	unsigned parseVersionPart();
+
+	char currentChar() const;
+	char nextChar();
+	Token::Value currentToken() const;
+	void nextToken();
+
+	std::vector<Token::Value> m_tokens;
+	std::vector<std::string> m_literals;
+
+	unsigned m_pos = 0;
+	unsigned m_posInside = 0;
+
+	SemVerMatchExpression m_expression;
+};
+
+}
+}
diff --git a/libsolidity/analysis/SyntaxChecker.cpp b/libsolidity/analysis/SyntaxChecker.cpp
index e94ce9fe..a95b4879 100644
--- a/libsolidity/analysis/SyntaxChecker.cpp
+++ b/libsolidity/analysis/SyntaxChecker.cpp
@@ -15,9 +15,11 @@
 	along with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.
 */
 
+#include <libsolidity/analysis/SyntaxChecker.h>
 #include <memory>
 #include <libsolidity/ast/AST.h>
-#include <libsolidity/analysis/SyntaxChecker.h>
+#include <libsolidity/analysis/SemVerHandler.h>
+#include <libsolidity/interface/Version.h>
 
 using namespace std;
 using namespace dev;
@@ -27,7 +29,7 @@ using namespace dev::solidity;
 bool SyntaxChecker::checkSyntax(SourceUnit const& _sourceUnit)
 {
 	_sourceUnit.accept(*this);
-	return m_errors.empty();
+	return Error::containsOnlyWarnings(m_errors);
 }
 
 void SyntaxChecker::syntaxError(SourceLocation const& _location, std::string const& _description)
@@ -40,13 +42,72 @@ void SyntaxChecker::syntaxError(SourceLocation const& _location, std::string con
 	m_errors.push_back(err);
 }
 
+bool SyntaxChecker::visit(SourceUnit const&)
+{
+	m_versionPragmaFound = false;
+	return true;
+}
+
+void SyntaxChecker::endVisit(SourceUnit const& _sourceUnit)
+{
+	if (!m_versionPragmaFound)
+	{
+		auto err = make_shared<Error>(Error::Type::Warning);
+		*err <<
+			errinfo_sourceLocation(_sourceUnit.location()) <<
+			errinfo_comment(
+				string("Source file does not specify required compiler version! ") +
+				string("Consider adding \"pragma solidity ^") + VersionNumber + string(";\".")
+			);
+		m_errors.push_back(err);
+	}
+}
+
+bool SyntaxChecker::visit(PragmaDirective const& _pragma)
+{
+	solAssert(!_pragma.tokens().empty(), "");
+	solAssert(_pragma.tokens().size() == _pragma.literals().size(), "");
+	if (_pragma.tokens()[0] != Token::Identifier && _pragma.literals()[0] != "solidity")
+		syntaxError(_pragma.location(), "Unknown pragma \"" + _pragma.literals()[0] + "\"");
+	else
+	{
+		vector<Token::Value> tokens(_pragma.tokens().begin() + 1, _pragma.tokens().end());
+		vector<string> literals(_pragma.literals().begin() + 1, _pragma.literals().end());
+		SemVerMatchExpressionParser parser(tokens, literals);
+		auto matchExpression = parser.parse();
+		SemVerVersion currentVersion{string(VersionString)};
+		if (!matchExpression.matches(currentVersion))
+			syntaxError(
+				_pragma.location(),
+				"Source file requires different compiler version (current compiler is " +
+				string(VersionString) + " - note that nightly builds are considered to be "
+				"strictly less than the released version"
+			);
+		m_versionPragmaFound = true;
+	}
+	return true;
+}
+
+bool SyntaxChecker::visit(ModifierDefinition const&)
+{
+	m_placeholderFound = false;
+	return true;
+}
+
+void SyntaxChecker::endVisit(ModifierDefinition const& _modifier)
+{
+	if (!m_placeholderFound)
+		syntaxError(_modifier.body().location(), "Modifier body does not contain '_'.");
+	m_placeholderFound = false;
+}
+
 bool SyntaxChecker::visit(WhileStatement const&)
 {
 	m_inLoopDepth++;
 	return true;
 }
 
-void SyntaxChecker::endVisit(WhileStatement const&)
+void SyntaxChecker::endVisit(WhileStatement const&	)
 {
 	m_inLoopDepth--;
 }
@@ -78,3 +139,9 @@ bool SyntaxChecker::visit(Break const& _breakStatement)
 	return true;
 }
 
+bool SyntaxChecker::visit(PlaceholderStatement const&)
+{
+	m_placeholderFound = true;
+	return true;
+}
+
diff --git a/libsolidity/analysis/SyntaxChecker.h b/libsolidity/analysis/SyntaxChecker.h
index c836d49f..ac8ed872 100644
--- a/libsolidity/analysis/SyntaxChecker.h
+++ b/libsolidity/analysis/SyntaxChecker.h
@@ -31,6 +31,7 @@ namespace solidity
 /**
  * The module that performs syntax analysis on the AST:
  *  - whether continue/break is in a for/while loop.
+ *  - whether a modifier contains at least one '_'
  */
 class SyntaxChecker: private ASTConstVisitor
 {
@@ -44,6 +45,13 @@ private:
 	/// Adds a new error to the list of errors.
 	void syntaxError(SourceLocation const& _location, std::string const& _description);
 
+	virtual bool visit(SourceUnit const& _sourceUnit) override;
+	virtual void endVisit(SourceUnit const& _sourceUnit) override;
+	virtual bool visit(PragmaDirective const& _pragma) override;
+
+	virtual bool visit(ModifierDefinition const& _modifier) override;
+	virtual void endVisit(ModifierDefinition const& _modifier) override;
+
 	virtual bool visit(WhileStatement const& _whileStatement) override;
 	virtual void endVisit(WhileStatement const& _whileStatement) override;
 	virtual bool visit(ForStatement const& _forStatement) override;
@@ -52,8 +60,16 @@ private:
 	virtual bool visit(Continue const& _continueStatement) override;
 	virtual bool visit(Break const& _breakStatement) override;
 
+	virtual bool visit(PlaceholderStatement const& _placeholderStatement) override;
+
 	ErrorList& m_errors;
 
+	/// Flag that indicates whether a function modifier actually contains '_'.
+	bool m_placeholderFound = false;
+
+	/// Flag that indicates whether some version pragma was present.
+	bool m_versionPragmaFound = false;
+
 	int m_inLoopDepth = 0;
 };
 
diff --git a/libsolidity/analysis/TypeChecker.cpp b/libsolidity/analysis/TypeChecker.cpp
index 6b2c1cb8..d9c54f75 100644
--- a/libsolidity/analysis/TypeChecker.cpp
+++ b/libsolidity/analysis/TypeChecker.cpp
@@ -75,8 +75,14 @@ bool TypeChecker::visit(ContractDefinition const& _contract)
 	checkContractAbstractConstructors(_contract);
 
 	FunctionDefinition const* function = _contract.constructor();
-	if (function && !function->returnParameters().empty())
-		typeError(function->returnParameterList()->location(), "Non-empty \"returns\" directive for constructor.");
+	if (function) {
+		if (!function->returnParameters().empty())
+			typeError(function->returnParameterList()->location(), "Non-empty \"returns\" directive for constructor.");
+		if (function->isDeclaredConst())
+			typeError(function->location(), "Constructor cannot be defined as constant.");
+		if (function->visibility() != FunctionDefinition::Visibility::Public && function->visibility() != FunctionDefinition::Visibility::Internal)
+			typeError(function->location(), "Constructor must be public or internal.");
+	}
 
 	FunctionDefinition const* fallbackFunction = nullptr;
 	for (FunctionDefinition const* function: _contract.definedFunctions())
@@ -92,8 +98,14 @@ bool TypeChecker::visit(ContractDefinition const& _contract)
 			else
 			{
 				fallbackFunction = function;
+				if (_contract.isLibrary())
+					typeError(fallbackFunction->location(), "Libraries cannot have fallback functions.");
+				if (fallbackFunction->isDeclaredConst())
+					typeError(fallbackFunction->location(), "Fallback function cannot be declared constant.");
 				if (!fallbackFunction->parameters().empty())
 					typeError(fallbackFunction->parameterList().location(), "Fallback function cannot take parameters.");
+				if (!fallbackFunction->returnParameters().empty())
+					typeError(fallbackFunction->returnParameterList()->location(), "Fallback function cannot return values.");
 			}
 		}
 		if (!function->isImplemented())
@@ -268,6 +280,7 @@ void TypeChecker::checkContractIllegalOverrides(ContractDefinition const& _contr
 				if (
 					overriding->visibility() != function->visibility() ||
 					overriding->isDeclaredConst() != function->isDeclaredConst() ||
+					overriding->isPayable() != function->isPayable() ||
 					overridingType != functionType
 				)
 					typeError(overriding->location(), "Override changes extended function signature.");
@@ -344,7 +357,7 @@ void TypeChecker::endVisit(InheritanceSpecifier const& _inheritance)
 		typeError(_inheritance.location(), "Libraries cannot be inherited from.");
 
 	auto const& arguments = _inheritance.arguments();
-	TypePointers parameterTypes = ContractType(*base).constructorType()->parameterTypes();
+	TypePointers parameterTypes = ContractType(*base).newExpressionType()->parameterTypes();
 	if (!arguments.empty() && parameterTypes.size() != arguments.size())
 	{
 		typeError(
@@ -412,6 +425,15 @@ bool TypeChecker::visit(StructDefinition const& _struct)
 bool TypeChecker::visit(FunctionDefinition const& _function)
 {
 	bool isLibraryFunction = dynamic_cast<ContractDefinition const&>(*_function.scope()).isLibrary();
+	if (_function.isPayable())
+	{
+		if (isLibraryFunction)
+			typeError(_function.location(), "Library functions cannot be payable.");
+		if (!_function.isConstructor() && !_function.name().empty() && !_function.isPartOfExternalInterface())
+			typeError(_function.location(), "Internal functions cannot be payable.");
+		if (_function.isDeclaredConst())
+			typeError(_function.location(), "Functions cannot be constant and payable at the same time.");
+	}
 	for (ASTPointer<VariableDeclaration> const& var: _function.parameters() + _function.returnParameters())
 	{
 		if (!type(*var)->canLiveOutsideStorage())
@@ -1252,15 +1274,7 @@ void TypeChecker::endVisit(NewExpression const& _newExpression)
 				"Circular reference for contract creation (cannot create instance of derived or same contract)."
 			);
 
-		auto contractType = make_shared<ContractType>(*contract);
-		TypePointers parameterTypes = contractType->constructorType()->parameterTypes();
-		_newExpression.annotation().type = make_shared<FunctionType>(
-			parameterTypes,
-			TypePointers{contractType},
-			strings(),
-			strings(),
-			FunctionType::Location::Creation
-		);
+		_newExpression.annotation().type = FunctionType::newExpressionType(*contract);
 	}
 	else if (type->category() == Type::Category::Array)
 	{
@@ -1324,14 +1338,16 @@ bool TypeChecker::visit(MemberAccess const& _memberAccess)
 		fatalTypeError(
 			_memberAccess.location(),
 			"Member \"" + memberName + "\" not found or not visible "
-			"after argument-dependent lookup in " + exprType->toString()
+			"after argument-dependent lookup in " + exprType->toString() +
+			(memberName == "value" ? " - did you forget the \"payable\" modifier?" : "")
 		);
 	}
 	else if (possibleMembers.size() > 1)
 		fatalTypeError(
 			_memberAccess.location(),
 			"Member \"" + memberName + "\" not unique "
-			"after argument-dependent lookup in " + exprType->toString()
+			"after argument-dependent lookup in " + exprType->toString() +
+			(memberName == "value" ? " - did you forget the \"payable\" modifier?" : "")
 		);
 
 	auto& annotation = _memberAccess.annotation();
diff --git a/libsolidity/ast/AST.h b/libsolidity/ast/AST.h
index bf275869..8fd1584d 100644
--- a/libsolidity/ast/AST.h
+++ b/libsolidity/ast/AST.h
@@ -175,6 +175,34 @@ private:
 	ASTNode const* m_scope;
 };
 
+/**
+ * Pragma directive, only version requirements in the form `pragma solidity "^0.4.0";` are
+ * supported for now.
+ */
+class PragmaDirective: public ASTNode
+{
+public:
+	PragmaDirective(
+		SourceLocation const& _location,
+		std::vector<Token::Value> const& _tokens,
+		std::vector<ASTString> const& _literals
+	): ASTNode(_location), m_tokens(_tokens), m_literals(_literals)
+	{}
+
+	virtual void accept(ASTVisitor& _visitor) override;
+	virtual void accept(ASTConstVisitor& _visitor) const override;
+
+	std::vector<Token::Value> const& tokens() const { return m_tokens; }
+	std::vector<ASTString> const& literals() const { return m_literals; }
+
+private:
+
+	/// Sequence of tokens following the "pragma" keyword.
+	std::vector<Token::Value> m_tokens;
+	/// Sequence of literals following the "pragma" keyword.
+	std::vector<ASTString> m_literals;
+};
+
 /**
  * Import directive for referencing other files / source objects.
  * Example: import "abc.sol" // imports all symbols of "abc.sol" into current scope
@@ -512,6 +540,7 @@ public:
 		bool _isDeclaredConst,
 		std::vector<ASTPointer<ModifierInvocation>> const& _modifiers,
 		ASTPointer<ParameterList> const& _returnParameters,
+		bool _isPayable,
 		ASTPointer<Block> const& _body
 	):
 		CallableDeclaration(_location, _name, _visibility, _parameters, _returnParameters),
@@ -519,6 +548,7 @@ public:
 		ImplementationOptional(_body != nullptr),
 		m_isConstructor(_isConstructor),
 		m_isDeclaredConst(_isDeclaredConst),
+		m_isPayable(_isPayable),
 		m_functionModifiers(_modifiers),
 		m_body(_body)
 	{}
@@ -528,6 +558,7 @@ public:
 
 	bool isConstructor() const { return m_isConstructor; }
 	bool isDeclaredConst() const { return m_isDeclaredConst; }
+	bool isPayable() const { return m_isPayable; }
 	std::vector<ASTPointer<ModifierInvocation>> const& modifiers() const { return m_functionModifiers; }
 	std::vector<ASTPointer<VariableDeclaration>> const& returnParameters() const { return m_returnParameters->parameters(); }
 	Block const& body() const { return *m_body; }
@@ -550,6 +581,7 @@ public:
 private:
 	bool m_isConstructor;
 	bool m_isDeclaredConst;
+	bool m_isPayable;
 	std::vector<ASTPointer<ModifierInvocation>> m_functionModifiers;
 	ASTPointer<Block> m_body;
 };
diff --git a/libsolidity/ast/ASTForward.h b/libsolidity/ast/ASTForward.h
index dad2b2e2..59fc1b57 100644
--- a/libsolidity/ast/ASTForward.h
+++ b/libsolidity/ast/ASTForward.h
@@ -35,6 +35,7 @@ namespace solidity
 
 class ASTNode;
 class SourceUnit;
+class PragmaDirective;
 class ImportDirective;
 class Declaration;
 class ContractDefinition;
diff --git a/libsolidity/ast/ASTJsonConverter.cpp b/libsolidity/ast/ASTJsonConverter.cpp
index fc43976d..0ea5e093 100644
--- a/libsolidity/ast/ASTJsonConverter.cpp
+++ b/libsolidity/ast/ASTJsonConverter.cpp
@@ -22,6 +22,7 @@
 
 #include <libsolidity/ast/ASTJsonConverter.h>
 #include <boost/algorithm/string/join.hpp>
+#include <libdevcore/UTF8.h>
 #include <libsolidity/ast/AST.h>
 
 using namespace std;
@@ -31,21 +32,10 @@ namespace dev
 namespace solidity
 {
 
-void ASTJsonConverter::addKeyValue(Json::Value& _obj, string const& _key, string const& _val)
-{
-	// special handling for booleans
-	if (_key == "const" || _key == "public" || _key == "local" ||
-		_key == "lvalue" || _key == "local_lvalue" || _key == "prefix")
-		_obj[_key] = (_val == "1") ? true : false;
-	else
-		// else simply add it as a string
-		_obj[_key] = _val;
-}
-
 void ASTJsonConverter::addJsonNode(
 	ASTNode const& _node,
 	string const& _nodeName,
-	initializer_list<pair<string const, string const>> _list,
+	initializer_list<pair<string const, Json::Value const>> _attributes,
 	bool _hasChildren = false
 )
 {
@@ -54,11 +44,11 @@ void ASTJsonConverter::addJsonNode(
 	node["id"] = reinterpret_cast<Json::UInt64>(&_node);
 	node["src"] = sourceLocationToString(_node.location());
 	node["name"] = _nodeName;
-	if (_list.size() != 0)
+	if (_attributes.size() != 0)
 	{
 		Json::Value attrs;
-		for (auto& e: _list)
-			addKeyValue(attrs, e.first, e.second);
+		for (auto& e: _attributes)
+			attrs[e.first] = e.second;
 		node["attributes"] = attrs;
 	}
 
@@ -89,11 +79,6 @@ ASTJsonConverter::ASTJsonConverter(
 	map<string, unsigned> _sourceIndices
 ): m_ast(&_ast), m_sourceIndices(_sourceIndices)
 {
-	Json::Value children(Json::arrayValue);
-
-	m_astJson["name"] = "root";
-	m_astJson["children"] = children;
-	m_jsonNodePtrs.push(&m_astJson["children"]);
 }
 
 void ASTJsonConverter::print(ostream& _stream)
@@ -108,21 +93,73 @@ Json::Value const& ASTJsonConverter::json()
 	return m_astJson;
 }
 
+bool ASTJsonConverter::visit(SourceUnit const&)
+{
+	Json::Value children(Json::arrayValue);
+
+	m_astJson["name"] = "SourceUnit";
+	m_astJson["children"] = children;
+	m_jsonNodePtrs.push(&m_astJson["children"]);
+
+	return true;
+}
+
+bool ASTJsonConverter::visit(PragmaDirective const& _node)
+{
+	Json::Value literals(Json::arrayValue);
+	for (auto const& literal: _node.literals())
+		literals.append(literal);
+	addJsonNode(_node, "PragmaDirective", { make_pair("literals", literals) });
+	return true;
+}
+
 bool ASTJsonConverter::visit(ImportDirective const& _node)
 {
-	addJsonNode(_node, "Import", { make_pair("file", _node.path())});
+	addJsonNode(_node, "ImportDirective", { make_pair("file", _node.path())});
 	return true;
 }
 
 bool ASTJsonConverter::visit(ContractDefinition const& _node)
 {
-	addJsonNode(_node, "Contract", { make_pair("name", _node.name()) }, true);
+	Json::Value linearizedBaseContracts(Json::arrayValue);
+	for (auto const& baseContract: _node.annotation().linearizedBaseContracts)
+		linearizedBaseContracts.append(reinterpret_cast<Json::UInt64>(baseContract));
+	addJsonNode(_node, "ContractDefinition", {
+		make_pair("name", _node.name()),
+		make_pair("isLibrary", _node.isLibrary()),
+		make_pair("fullyImplemented", _node.annotation().isFullyImplemented),
+		make_pair("linearizedBaseContracts", linearizedBaseContracts),
+	}, true);
+	return true;
+}
+
+bool ASTJsonConverter::visit(InheritanceSpecifier const& _node)
+{
+	addJsonNode(_node, "InheritanceSpecifier", {}, true);
+	return true;
+}
+
+bool ASTJsonConverter::visit(UsingForDirective const& _node)
+{
+	addJsonNode(_node, "UsingForDirective", {}, true);
 	return true;
 }
 
 bool ASTJsonConverter::visit(StructDefinition const& _node)
 {
-	addJsonNode(_node, "Struct", { make_pair("name", _node.name()) }, true);
+	addJsonNode(_node, "StructDefinition", { make_pair("name", _node.name()) }, true);
+	return true;
+}
+
+bool ASTJsonConverter::visit(EnumDefinition const& _node)
+{
+	addJsonNode(_node, "EnumDefinition", { make_pair("name", _node.name()) }, true);
+	return true;
+}
+
+bool ASTJsonConverter::visit(EnumValue const& _node)
+{
+	addJsonNode(_node, "EnumValue", { make_pair("name", _node.name()) });
 	return true;
 }
 
@@ -134,11 +171,11 @@ bool ASTJsonConverter::visit(ParameterList const& _node)
 
 bool ASTJsonConverter::visit(FunctionDefinition const& _node)
 {
-	addJsonNode(_node, "Function",
-				{ make_pair("name", _node.name()),
-					make_pair("public", boost::lexical_cast<std::string>(_node.isPublic())),
-					make_pair("const", boost::lexical_cast<std::string>(_node.isDeclaredConst())) },
-				true);
+	addJsonNode(_node, "FunctionDefinition", {
+		make_pair("name", _node.name()),
+		make_pair("public", _node.isPublic()),
+		make_pair("constant", _node.isDeclaredConst())
+	}, true);
 	return true;
 }
 
@@ -146,16 +183,34 @@ bool ASTJsonConverter::visit(VariableDeclaration const& _node)
 {
 	addJsonNode(_node, "VariableDeclaration", {
 		make_pair("name", _node.name()),
-		make_pair("name", _node.name()),
+		make_pair("type", type(_node))
 	}, true);
 	return true;
 }
 
+bool ASTJsonConverter::visit(ModifierDefinition const& _node)
+{
+	addJsonNode(_node, "ModifierDefinition", { make_pair("name", _node.name()) }, true);
+	return true;
+}
+
+bool ASTJsonConverter::visit(ModifierInvocation const& _node)
+{
+	addJsonNode(_node, "ModifierInvocation", {}, true);
+	return true;
+}
+
 bool ASTJsonConverter::visit(TypeName const&)
 {
 	return true;
 }
 
+bool ASTJsonConverter::visit(EventDefinition const& _node)
+{
+	addJsonNode(_node, "EventDefinition", { make_pair("name", _node.name()) }, true);
+	return true;
+}
+
 bool ASTJsonConverter::visit(ElementaryTypeName const& _node)
 {
 	addJsonNode(_node, "ElementaryTypeName", { make_pair("name", _node.typeName().toString()) });
@@ -176,6 +231,12 @@ bool ASTJsonConverter::visit(Mapping const& _node)
 	return true;
 }
 
+bool ASTJsonConverter::visit(ArrayTypeName const& _node)
+{
+	addJsonNode(_node, "ArrayTypeName", {}, true);
+	return true;
+}
+
 bool ASTJsonConverter::visit(InlineAssembly const& _node)
 {
 	addJsonNode(_node, "InlineAssembly", {}, true);
@@ -188,6 +249,12 @@ bool ASTJsonConverter::visit(Block const& _node)
 	return true;
 }
 
+bool ASTJsonConverter::visit(PlaceholderStatement const& _node)
+{
+	addJsonNode(_node, "PlaceholderStatement", {});
+	return true;
+}
+
 bool ASTJsonConverter::visit(IfStatement const& _node)
 {
 	addJsonNode(_node, "IfStatement", {}, true);
@@ -232,7 +299,7 @@ bool ASTJsonConverter::visit(Throw const& _node)
 
 bool ASTJsonConverter::visit(VariableDeclarationStatement const& _node)
 {
-	addJsonNode(_node, "VariableDefinition", {}, true);
+	addJsonNode(_node, "VariableDefinitionStatement", {}, true);
 	return true;
 }
 
@@ -266,7 +333,7 @@ bool ASTJsonConverter::visit(TupleExpression const& _node)
 bool ASTJsonConverter::visit(UnaryOperation const& _node)
 {
 	addJsonNode(_node, "UnaryOperation",
-				{ make_pair("prefix", boost::lexical_cast<std::string>(_node.isPrefixOperation())),
+				{ make_pair("prefix", _node.isPrefixOperation()),
 					make_pair("operator", Token::toString(_node.getOperator())),
 					make_pair("type", type(_node)) },
 				true);
@@ -285,7 +352,7 @@ bool ASTJsonConverter::visit(BinaryOperation const& _node)
 bool ASTJsonConverter::visit(FunctionCall const& _node)
 {
 	addJsonNode(_node, "FunctionCall", {
-		make_pair("type_conversion", boost::lexical_cast<std::string>(_node.annotation().isTypeConversion)),
+		make_pair("type_conversion", _node.annotation().isTypeConversion),
 		make_pair("type", type(_node))
 	}, true);
 	return true;
@@ -299,10 +366,10 @@ bool ASTJsonConverter::visit(NewExpression const& _node)
 
 bool ASTJsonConverter::visit(MemberAccess const& _node)
 {
-	addJsonNode(_node, "MemberAccess",
-				{ make_pair("member_name", _node.memberName()),
-					make_pair("type", type(_node)) },
-				true);
+	addJsonNode(_node, "MemberAccess", {
+		make_pair("member_name", _node.memberName()),
+		make_pair("type", type(_node))
+	}, true);
 	return true;
 }
 
@@ -321,21 +388,45 @@ bool ASTJsonConverter::visit(Identifier const& _node)
 
 bool ASTJsonConverter::visit(ElementaryTypeNameExpression const& _node)
 {
-	addJsonNode(_node, "ElementaryTypenameExpression",
-				{ make_pair("value", _node.typeName().toString()), make_pair("type", type(_node)) });
+	addJsonNode(_node, "ElementaryTypenameExpression", {
+		make_pair("value", _node.typeName().toString()),
+		make_pair("type", type(_node))
+	});
 	return true;
 }
 
 bool ASTJsonConverter::visit(Literal const& _node)
 {
 	char const* tokenString = Token::toString(_node.token());
-	addJsonNode(_node, "Literal",
-				{ make_pair("string", (tokenString) ? tokenString : "null"),
-					make_pair("value", _node.value()),
-					make_pair("type", type(_node)) });
+	size_t invalidPos = 0;
+	Json::Value value{_node.value()};
+	if (!dev::validate(_node.value(), invalidPos))
+		value = Json::nullValue;
+	Token::Value subdenomination = Token::Value(_node.subDenomination());
+	addJsonNode(_node, "Literal", {
+		make_pair("token", tokenString ? tokenString : Json::Value()),
+		make_pair("value", value),
+		make_pair("hexvalue", toHex(_node.value())),
+		make_pair(
+			"subdenomination",
+			subdenomination == Token::Illegal ?
+			Json::nullValue :
+			Json::Value{Token::toString(subdenomination)}
+		),
+		make_pair("type", type(_node))
+	});
 	return true;
 }
 
+void ASTJsonConverter::endVisit(SourceUnit const&)
+{
+	goUp();
+}
+
+void ASTJsonConverter::endVisit(PragmaDirective const&)
+{
+}
+
 void ASTJsonConverter::endVisit(ImportDirective const&)
 {
 }
@@ -345,11 +436,30 @@ void ASTJsonConverter::endVisit(ContractDefinition const&)
 	goUp();
 }
 
+void ASTJsonConverter::endVisit(InheritanceSpecifier const&)
+{
+	goUp();
+}
+
+void ASTJsonConverter::endVisit(UsingForDirective const&)
+{
+	goUp();
+}
+
 void ASTJsonConverter::endVisit(StructDefinition const&)
 {
 	goUp();
 }
 
+void ASTJsonConverter::endVisit(EnumDefinition const&)
+{
+	goUp();
+}
+
+void ASTJsonConverter::endVisit(EnumValue const&)
+{
+}
+
 void ASTJsonConverter::endVisit(ParameterList const&)
 {
 	goUp();
@@ -362,6 +472,22 @@ void ASTJsonConverter::endVisit(FunctionDefinition const&)
 
 void ASTJsonConverter::endVisit(VariableDeclaration const&)
 {
+	goUp();
+}
+
+void ASTJsonConverter::endVisit(ModifierDefinition const&)
+{
+	goUp();
+}
+
+void ASTJsonConverter::endVisit(ModifierInvocation const&)
+{
+	goUp();
+}
+
+void ASTJsonConverter::endVisit(EventDefinition const&)
+{
+	goUp();
 }
 
 void ASTJsonConverter::endVisit(TypeName const&)
@@ -378,10 +504,17 @@ void ASTJsonConverter::endVisit(UserDefinedTypeName const&)
 
 void ASTJsonConverter::endVisit(Mapping const&)
 {
+	goUp();
+}
+
+void ASTJsonConverter::endVisit(ArrayTypeName const&)
+{
+	goUp();
 }
 
 void ASTJsonConverter::endVisit(InlineAssembly const&)
 {
+	goUp();
 }
 
 void ASTJsonConverter::endVisit(Block const&)
@@ -389,6 +522,10 @@ void ASTJsonConverter::endVisit(Block const&)
 	goUp();
 }
 
+void ASTJsonConverter::endVisit(PlaceholderStatement const&)
+{
+}
+
 void ASTJsonConverter::endVisit(IfStatement const&)
 {
 	goUp();
diff --git a/libsolidity/ast/ASTJsonConverter.h b/libsolidity/ast/ASTJsonConverter.h
index ca4d9c2d..7c7b37f8 100644
--- a/libsolidity/ast/ASTJsonConverter.h
+++ b/libsolidity/ast/ASTJsonConverter.h
@@ -51,18 +51,29 @@ public:
 	void print(std::ostream& _stream);
 	Json::Value const& json();
 
+	bool visit(SourceUnit const& _node) override;
+	bool visit(PragmaDirective const& _node) override;
 	bool visit(ImportDirective const& _node) override;
 	bool visit(ContractDefinition const& _node) override;
+	bool visit(InheritanceSpecifier const& _node) override;
+	bool visit(UsingForDirective const& _node) override;
 	bool visit(StructDefinition const& _node) override;
+	bool visit(EnumDefinition const& _node) override;
+	bool visit(EnumValue const& _node) override;
 	bool visit(ParameterList const& _node) override;
 	bool visit(FunctionDefinition const& _node) override;
 	bool visit(VariableDeclaration const& _node) override;
+	bool visit(ModifierDefinition const& _node) override;
+	bool visit(ModifierInvocation const& _node) override;
+	bool visit(EventDefinition const& _node) override;
 	bool visit(TypeName const& _node) override;
 	bool visit(ElementaryTypeName const& _node) override;
 	bool visit(UserDefinedTypeName const& _node) override;
 	bool visit(Mapping const& _node) override;
+	bool visit(ArrayTypeName const& _node) override;
 	bool visit(InlineAssembly const& _node) override;
 	bool visit(Block const& _node) override;
+	bool visit(PlaceholderStatement const& _node) override;
 	bool visit(IfStatement const& _node) override;
 	bool visit(WhileStatement const& _node) override;
 	bool visit(ForStatement const& _node) override;
@@ -85,18 +96,29 @@ public:
 	bool visit(ElementaryTypeNameExpression const& _node) override;
 	bool visit(Literal const& _node) override;
 
+	void endVisit(SourceUnit const&) override;
+	void endVisit(PragmaDirective const&) override;
 	void endVisit(ImportDirective const&) override;
 	void endVisit(ContractDefinition const&) override;
+	void endVisit(InheritanceSpecifier const&) override;
+	void endVisit(UsingForDirective const&) override;
 	void endVisit(StructDefinition const&) override;
+	void endVisit(EnumDefinition const&) override;
+	void endVisit(EnumValue const&) override;
 	void endVisit(ParameterList const&) override;
 	void endVisit(FunctionDefinition const&) override;
 	void endVisit(VariableDeclaration const&) override;
+	void endVisit(ModifierDefinition const&) override;
+	void endVisit(ModifierInvocation const&) override;
+	void endVisit(EventDefinition const&) override;
 	void endVisit(TypeName const&) override;
 	void endVisit(ElementaryTypeName const&) override;
 	void endVisit(UserDefinedTypeName const&) override;
 	void endVisit(Mapping const&) override;
+	void endVisit(ArrayTypeName const&) override;
 	void endVisit(InlineAssembly const&) override;
 	void endVisit(Block const&) override;
+	void endVisit(PlaceholderStatement const&) override;
 	void endVisit(IfStatement const&) override;
 	void endVisit(WhileStatement const&) override;
 	void endVisit(ForStatement const&) override;
@@ -121,11 +143,10 @@ public:
 
 private:
 	void process();
-	void addKeyValue(Json::Value& _obj, std::string const& _key, std::string const& _val);
 	void addJsonNode(
 		ASTNode const& _node,
 		std::string const& _nodeName,
-		std::initializer_list<std::pair<std::string const, std::string const>> _list,
+		std::initializer_list<std::pair<std::string const, Json::Value const>> _attributes,
 		bool _hasChildren
 	);
 	std::string sourceLocationToString(SourceLocation const& _location) const;
diff --git a/libsolidity/ast/ASTPrinter.cpp b/libsolidity/ast/ASTPrinter.cpp
index 9ed9c6d5..a9de457a 100644
--- a/libsolidity/ast/ASTPrinter.cpp
+++ b/libsolidity/ast/ASTPrinter.cpp
@@ -47,6 +47,13 @@ void ASTPrinter::print(ostream& _stream)
 }
 
 
+bool ASTPrinter::visit(PragmaDirective const& _node)
+{
+	writeLine("PragmaDirective");
+	printSourcePart(_node);
+	return goDeeper();
+}
+
 bool ASTPrinter::visit(ImportDirective const& _node)
 {
 	writeLine("ImportDirective \"" + _node.path() + "\"");
@@ -355,6 +362,11 @@ bool ASTPrinter::visit(Literal const& _node)
 	return goDeeper();
 }
 
+void ASTPrinter::endVisit(PragmaDirective const&)
+{
+	m_indentation--;
+}
+
 void ASTPrinter::endVisit(ImportDirective const&)
 {
 	m_indentation--;
diff --git a/libsolidity/ast/ASTPrinter.h b/libsolidity/ast/ASTPrinter.h
index a2546935..f0ab1098 100644
--- a/libsolidity/ast/ASTPrinter.h
+++ b/libsolidity/ast/ASTPrinter.h
@@ -47,6 +47,7 @@ public:
 	/// Output the string representation of the AST to _stream.
 	void print(std::ostream& _stream);
 
+	bool visit(PragmaDirective const& _node) override;
 	bool visit(ImportDirective const& _node) override;
 	bool visit(ContractDefinition const& _node) override;
 	bool visit(InheritanceSpecifier const& _node) override;
@@ -89,6 +90,7 @@ public:
 	bool visit(ElementaryTypeNameExpression const& _node) override;
 	bool visit(Literal const& _node) override;
 
+	void endVisit(PragmaDirective const&) override;
 	void endVisit(ImportDirective const&) override;
 	void endVisit(ContractDefinition const&) override;
 	void endVisit(InheritanceSpecifier const&) override;
diff --git a/libsolidity/ast/ASTVisitor.h b/libsolidity/ast/ASTVisitor.h
index 5aac2066..3a1b55d3 100644
--- a/libsolidity/ast/ASTVisitor.h
+++ b/libsolidity/ast/ASTVisitor.h
@@ -44,6 +44,7 @@ class ASTVisitor
 {
 public:
 	virtual bool visit(SourceUnit& _node) { return visitNode(_node); }
+	virtual bool visit(PragmaDirective& _node) { return visitNode(_node); }
 	virtual bool visit(ImportDirective& _node) { return visitNode(_node); }
 	virtual bool visit(ContractDefinition& _node) { return visitNode(_node); }
 	virtual bool visit(InheritanceSpecifier& _node) { return visitNode(_node); }
@@ -88,6 +89,7 @@ public:
 	virtual bool visit(Literal& _node) { return visitNode(_node); }
 
 	virtual void endVisit(SourceUnit& _node) { endVisitNode(_node); }
+	virtual void endVisit(PragmaDirective& _node) { endVisitNode(_node); }
 	virtual void endVisit(ImportDirective& _node) { endVisitNode(_node); }
 	virtual void endVisit(ContractDefinition& _node) { endVisitNode(_node); }
 	virtual void endVisit(InheritanceSpecifier& _node) { endVisitNode(_node); }
@@ -144,6 +146,7 @@ class ASTConstVisitor
 {
 public:
 	virtual bool visit(SourceUnit const& _node) { return visitNode(_node); }
+	virtual bool visit(PragmaDirective const& _node) { return visitNode(_node); }
 	virtual bool visit(ImportDirective const& _node) { return visitNode(_node); }
 	virtual bool visit(ContractDefinition const& _node) { return visitNode(_node); }
 	virtual bool visit(InheritanceSpecifier const& _node) { return visitNode(_node); }
@@ -188,6 +191,7 @@ public:
 	virtual bool visit(Literal const& _node) { return visitNode(_node); }
 
 	virtual void endVisit(SourceUnit const& _node) { endVisitNode(_node); }
+	virtual void endVisit(PragmaDirective const& _node) { endVisitNode(_node); }
 	virtual void endVisit(ImportDirective const& _node) { endVisitNode(_node); }
 	virtual void endVisit(ContractDefinition const& _node) { endVisitNode(_node); }
 	virtual void endVisit(InheritanceSpecifier const& _node) { endVisitNode(_node); }
diff --git a/libsolidity/ast/AST_accept.h b/libsolidity/ast/AST_accept.h
index dd2a7d60..b5a3806b 100644
--- a/libsolidity/ast/AST_accept.h
+++ b/libsolidity/ast/AST_accept.h
@@ -45,6 +45,18 @@ void SourceUnit::accept(ASTConstVisitor& _visitor) const
 	_visitor.endVisit(*this);
 }
 
+void PragmaDirective::accept(ASTVisitor& _visitor)
+{
+	_visitor.visit(*this);
+	_visitor.endVisit(*this);
+}
+
+void PragmaDirective::accept(ASTConstVisitor& _visitor) const
+{
+	_visitor.visit(*this);
+	_visitor.endVisit(*this);
+}
+
 void ImportDirective::accept(ASTVisitor& _visitor)
 {
 	_visitor.visit(*this);
diff --git a/libsolidity/ast/Types.cpp b/libsolidity/ast/Types.cpp
index 28f7e1b7..4b5f12ce 100644
--- a/libsolidity/ast/Types.cpp
+++ b/libsolidity/ast/Types.cpp
@@ -306,7 +306,7 @@ TypePointer IntegerType::unaryOperatorResult(Token::Value _operator) const
 	// for non-address integers, we allow +, -, ++ and --
 	else if (_operator == Token::Add || _operator == Token::Sub ||
 			_operator == Token::Inc || _operator == Token::Dec ||
-			_operator == Token::After || _operator == Token::BitNot)
+			_operator == Token::BitNot)
 		return shared_from_this();
 	else
 		return TypePointer();
@@ -362,8 +362,8 @@ MemberList::MemberMap IntegerType::nativeMembers(ContractDefinition const*) cons
 	if (isAddress())
 		return {
 			{"balance", make_shared<IntegerType >(256)},
-			{"call", make_shared<FunctionType>(strings(), strings{"bool"}, FunctionType::Location::Bare, true)},
-			{"callcode", make_shared<FunctionType>(strings(), strings{"bool"}, FunctionType::Location::BareCallCode, true)},
+			{"call", make_shared<FunctionType>(strings(), strings{"bool"}, FunctionType::Location::Bare, true, false, true)},
+			{"callcode", make_shared<FunctionType>(strings(), strings{"bool"}, FunctionType::Location::BareCallCode, true, false, true)},
 			{"delegatecall", make_shared<FunctionType>(strings(), strings{"bool"}, FunctionType::Location::BareDelegateCall, true)},
 			{"send", make_shared<FunctionType>(strings{"uint"}, strings{"bool"}, FunctionType::Location::Send)}
 		};
@@ -416,8 +416,7 @@ TypePointer FixedPointType::unaryOperatorResult(Token::Value _operator) const
 		_operator == Token::Add || 
 		_operator == Token::Sub ||
 		_operator == Token::Inc || 
-		_operator == Token::Dec ||
-		_operator == Token::After
+		_operator == Token::Dec
 	)
 		return shared_from_this();
 	else
@@ -1330,16 +1329,10 @@ MemberList::MemberMap ContractType::nativeMembers(ContractDefinition const*) con
 	return members;
 }
 
-shared_ptr<FunctionType const> const& ContractType::constructorType() const
+shared_ptr<FunctionType const> const& ContractType::newExpressionType() const
 {
 	if (!m_constructorType)
-	{
-		FunctionDefinition const* constructor = m_contract.constructor();
-		if (constructor)
-			m_constructorType = make_shared<FunctionType>(*constructor);
-		else
-			m_constructorType = make_shared<FunctionType>(TypePointers(), TypePointers());
-	}
+		m_constructorType = FunctionType::newExpressionType(m_contract);
 	return m_constructorType;
 }
 
@@ -1654,6 +1647,7 @@ TypePointer TupleType::closestTemporaryType(TypePointer const& _targetType) cons
 FunctionType::FunctionType(FunctionDefinition const& _function, bool _isInternal):
 	m_location(_isInternal ? Location::Internal : Location::External),
 	m_isConstant(_function.isDeclaredConst()),
+	m_isPayable(_function.isPayable()),
 	m_declaration(&_function)
 {
 	TypePointers params;
@@ -1738,7 +1732,7 @@ FunctionType::FunctionType(VariableDeclaration const& _varDecl):
 	swap(retParamNames, m_returnParameterNames);
 }
 
-FunctionType::FunctionType(const EventDefinition& _event):
+FunctionType::FunctionType(EventDefinition const& _event):
 	m_location(Location::Event), m_isConstant(true), m_declaration(&_event)
 {
 	TypePointers params;
@@ -1754,6 +1748,35 @@ FunctionType::FunctionType(const EventDefinition& _event):
 	swap(paramNames, m_parameterNames);
 }
 
+FunctionTypePointer FunctionType::newExpressionType(ContractDefinition const& _contract)
+{
+	FunctionDefinition const* constructor = _contract.constructor();
+	TypePointers parameters;
+	strings parameterNames;
+	bool payable = false;
+
+	if (constructor)
+	{
+		for (ASTPointer<VariableDeclaration> const& var: constructor->parameters())
+		{
+			parameterNames.push_back(var->name());
+			parameters.push_back(var->annotation().type);
+		}
+		payable = constructor->isPayable();
+	}
+	return make_shared<FunctionType>(
+		parameters,
+		TypePointers{make_shared<ContractType>(_contract)},
+		parameterNames,
+		strings{""},
+		Location::Creation,
+		false,
+		nullptr,
+		false,
+		payable
+	);
+}
+
 vector<string> FunctionType::parameterNames() const
 {
 	if (!bound())
@@ -1872,7 +1895,12 @@ FunctionTypePointer FunctionType::interfaceFunctionType() const
 	if (variable && retParamTypes.empty())
 		return FunctionTypePointer();
 
-	return make_shared<FunctionType>(paramTypes, retParamTypes, m_parameterNames, m_returnParameterNames, m_location, m_arbitraryParameters);
+	return make_shared<FunctionType>(
+		paramTypes, retParamTypes,
+		m_parameterNames, m_returnParameterNames,
+		m_location, m_arbitraryParameters,
+		m_declaration, m_isConstant, m_isPayable
+	);
 }
 
 MemberList::MemberMap FunctionType::nativeMembers(ContractDefinition const*) const
@@ -1890,20 +1918,25 @@ MemberList::MemberMap FunctionType::nativeMembers(ContractDefinition const*) con
 	{
 		MemberList::MemberMap members;
 		if (m_location != Location::BareDelegateCall && m_location != Location::DelegateCall)
-			members.push_back(MemberList::Member(
-				"value",
-				make_shared<FunctionType>(
-					parseElementaryTypeVector({"uint"}),
-					TypePointers{copyAndSetGasOrValue(false, true)},
-					strings(),
-					strings(),
-					Location::SetValue,
-					false,
-					nullptr,
-					m_gasSet,
-					m_valueSet
-				)
-			));
+		{
+			if (m_isPayable)
+				members.push_back(MemberList::Member(
+					"value",
+					make_shared<FunctionType>(
+						parseElementaryTypeVector({"uint"}),
+						TypePointers{copyAndSetGasOrValue(false, true)},
+						strings(),
+						strings(),
+						Location::SetValue,
+						false,
+						nullptr,
+						false,
+						false,
+						m_gasSet,
+						m_valueSet
+					)
+				));
+		}
 		if (m_location != Location::Creation)
 			members.push_back(MemberList::Member(
 				"gas",
@@ -1915,6 +1948,8 @@ MemberList::MemberMap FunctionType::nativeMembers(ContractDefinition const*) con
 					Location::SetGas,
 					false,
 					nullptr,
+					false,
+					false,
 					m_gasSet,
 					m_valueSet
 				)
@@ -2020,6 +2055,8 @@ TypePointer FunctionType::copyAndSetGasOrValue(bool _setGas, bool _setValue) con
 		m_location,
 		m_arbitraryParameters,
 		m_declaration,
+		m_isConstant,
+		m_isPayable,
 		m_gasSet || _setGas,
 		m_valueSet || _setValue,
 		m_bound
@@ -2065,6 +2102,8 @@ FunctionTypePointer FunctionType::asMemberFunction(bool _inLibrary, bool _bound)
 		location,
 		m_arbitraryParameters,
 		m_declaration,
+		m_isConstant,
+		m_isPayable,
 		m_gasSet,
 		m_valueSet,
 		_bound
@@ -2091,7 +2130,8 @@ vector<string> const FunctionType::returnParameterTypeNames(bool _addDataLocatio
 
 TypePointer FunctionType::selfType() const
 {
-	solAssert(bound(), "");
+	solAssert(bound(), "Function is not bound.");
+	solAssert(m_parameterTypes.size() > 0, "Function has no self type.");
 	return m_parameterTypes.at(0);
 }
 
diff --git a/libsolidity/ast/Types.h b/libsolidity/ast/Types.h
index 1282e5d8..9173f39a 100644
--- a/libsolidity/ast/Types.h
+++ b/libsolidity/ast/Types.h
@@ -640,9 +640,8 @@ public:
 	bool isSuper() const { return m_super; }
 	ContractDefinition const& contractDefinition() const { return m_contract; }
 
-	/// Returns the function type of the constructor. Note that the location part of the function type
-	/// is not used, as this type cannot be the type of a variable or expression.
-	FunctionTypePointer const& constructorType() const;
+	/// Returns the function type of the constructor modified to return an object of the contract's type.
+	FunctionTypePointer const& newExpressionType() const;
 
 	/// @returns the identifier of the function with the given name or Invalid256 if such a name does
 	/// not exist.
@@ -820,21 +819,32 @@ public:
 	explicit FunctionType(VariableDeclaration const& _varDecl);
 	/// Creates the function type of an event.
 	explicit FunctionType(EventDefinition const& _event);
+	/// Function type constructor to be used for a plain type (not derived from a declaration).
 	FunctionType(
 		strings const& _parameterTypes,
 		strings const& _returnParameterTypes,
 		Location _location = Location::Internal,
-		bool _arbitraryParameters = false
+		bool _arbitraryParameters = false,
+		bool _constant = false,
+		bool _payable = false
 	): FunctionType(
 		parseElementaryTypeVector(_parameterTypes),
 		parseElementaryTypeVector(_returnParameterTypes),
 		strings(),
 		strings(),
 		_location,
-		_arbitraryParameters
+		_arbitraryParameters,
+		nullptr,
+		_constant,
+		_payable
 	)
 	{
 	}
+
+	/// @returns the type of the "new Contract" function, i.e. basically the constructor.
+	static FunctionTypePointer newExpressionType(ContractDefinition const& _contract);
+
+	/// Detailed constructor, use with care.
 	FunctionType(
 		TypePointers const& _parameterTypes,
 		TypePointers const& _returnParameterTypes,
@@ -843,6 +853,8 @@ public:
 		Location _location = Location::Internal,
 		bool _arbitraryParameters = false,
 		Declaration const* _declaration = nullptr,
+		bool _isConstant = false,
+		bool _isPayable = false,
 		bool _gasSet = false,
 		bool _valueSet = false,
 		bool _bound = false
@@ -856,6 +868,8 @@ public:
 		m_gasSet(_gasSet),
 		m_valueSet(_valueSet),
 		m_bound(_bound),
+		m_isConstant(_isConstant),
+		m_isPayable(_isPayable),
 		m_declaration(_declaration)
 	{}
 
@@ -905,6 +919,7 @@ public:
 	}
 	bool hasDeclaration() const { return !!m_declaration; }
 	bool isConstant() const { return m_isConstant; }
+	bool isPayable() const { return m_isPayable; }
 	/// @return A shared pointer of an ASTString.
 	/// Can contain a nullptr in which case indicates absence of documentation
 	ASTPointer<ASTString> documentation() const;
@@ -942,6 +957,7 @@ private:
 	bool const m_valueSet = false; ///< true iff the value to be sent is on the stack
 	bool const m_bound = false; ///< true iff the function is called as arg1.fun(arg2, ..., argn)
 	bool m_isConstant = false;
+	bool m_isPayable = false;
 	Declaration const* m_declaration = nullptr;
 };
 
diff --git a/libsolidity/codegen/CompilerContext.cpp b/libsolidity/codegen/CompilerContext.cpp
index c1dc8dfb..3ac5bd3c 100644
--- a/libsolidity/codegen/CompilerContext.cpp
+++ b/libsolidity/codegen/CompilerContext.cpp
@@ -23,9 +23,12 @@
 #include <libsolidity/codegen/CompilerContext.h>
 #include <utility>
 #include <numeric>
+#include <boost/algorithm/string/replace.hpp>
 #include <libsolidity/ast/AST.h>
 #include <libsolidity/codegen/Compiler.h>
 #include <libsolidity/interface/Version.h>
+#include <libsolidity/inlineasm/AsmData.h>
+#include <libsolidity/inlineasm/AsmStack.h>
 
 using namespace std;
 
@@ -172,6 +175,51 @@ void CompilerContext::resetVisitedNodes(ASTNode const* _node)
 	updateSourceLocation();
 }
 
+void CompilerContext::appendInlineAssembly(
+	string const& _assembly,
+	vector<string> const& _localVariables,
+	map<string, string> const& _replacements
+)
+{
+	string replacedAssembly;
+	string const* assembly = &_assembly;
+	if (!_replacements.empty())
+	{
+		replacedAssembly = _assembly;
+		for (auto const& replacement: _replacements)
+			replacedAssembly = boost::algorithm::replace_all_copy(replacedAssembly, replacement.first, replacement.second);
+		assembly = &replacedAssembly;
+	}
+
+	unsigned startStackHeight = stackHeight();
+	auto identifierAccess = [&](
+		assembly::Identifier const& _identifier,
+		eth::Assembly& _assembly,
+		assembly::CodeGenerator::IdentifierContext _context
+	) {
+		auto it = std::find(_localVariables.begin(), _localVariables.end(), _identifier.name);
+		if (it == _localVariables.end())
+			return false;
+		unsigned stackDepth = _localVariables.end() - it;
+		int stackDiff = _assembly.deposit() - startStackHeight + stackDepth;
+		if (stackDiff < 1 || stackDiff > 16)
+			BOOST_THROW_EXCEPTION(
+				CompilerError() <<
+				errinfo_comment("Stack too deep, try removing local variables.")
+			);
+		if (_context == assembly::CodeGenerator::IdentifierContext::RValue)
+			_assembly.append(dupInstruction(stackDiff));
+		else
+		{
+			_assembly.append(swapInstruction(stackDiff));
+			_assembly.append(Instruction::POP);
+		}
+		return true;
+	};
+
+	solAssert(assembly::InlineAssemblyStack().parseAndAssemble(*assembly, m_asm, identifierAccess), "");
+}
+
 void CompilerContext::injectVersionStampIntoSub(size_t _subIndex)
 {
 	eth::Assembly& sub = m_asm.sub(_subIndex);
diff --git a/libsolidity/codegen/CompilerContext.h b/libsolidity/codegen/CompilerContext.h
index a56335ce..0c1500b0 100644
--- a/libsolidity/codegen/CompilerContext.h
+++ b/libsolidity/codegen/CompilerContext.h
@@ -132,6 +132,15 @@ public:
 	CompilerContext& operator<<(u256 const& _value) { m_asm.append(_value); return *this; }
 	CompilerContext& operator<<(bytes const& _data) { m_asm.append(_data); return *this; }
 
+	/// Appends inline assembly. @a _replacements are string-matching replacements that are performed
+	/// prior to parsing the inline assembly.
+	/// @param _localVariables assigns stack positions to variables with the last one being the stack top
+	void appendInlineAssembly(
+		std::string const& _assembly,
+		std::vector<std::string> const& _localVariables = std::vector<std::string>(),
+		std::map<std::string, std::string> const& _replacements = std::map<std::string, std::string>{}
+	);
+
 	/// Prepends "PUSH <compiler version number> POP"
 	void injectVersionStampIntoSub(size_t _subIndex);
 
diff --git a/libsolidity/codegen/CompilerUtils.cpp b/libsolidity/codegen/CompilerUtils.cpp
index d7d17b8e..ec496df8 100644
--- a/libsolidity/codegen/CompilerUtils.cpp
+++ b/libsolidity/codegen/CompilerUtils.cpp
@@ -160,7 +160,15 @@ void CompilerUtils::encodeToMemory(
 	TypePointers targetTypes = _targetTypes.empty() ? _givenTypes : _targetTypes;
 	solAssert(targetTypes.size() == _givenTypes.size(), "");
 	for (TypePointer& t: targetTypes)
+	{
+		solAssert(
+			t->mobileType() &&
+			t->mobileType()->interfaceType(_encodeAsLibraryTypes) &&
+			t->mobileType()->interfaceType(_encodeAsLibraryTypes)->encodingType(),
+			"Encoding type \"" + t->toString() + "\" not yet implemented."
+		);
 		t = t->mobileType()->interfaceType(_encodeAsLibraryTypes)->encodingType();
+	}
 
 	// Stack during operation:
 	// <v1> <v2> ... <vn> <mem_start> <dyn_head_1> ... <dyn_head_r> <end_of_mem>
diff --git a/libsolidity/codegen/ContractCompiler.cpp b/libsolidity/codegen/ContractCompiler.cpp
index bcfd33f2..33571bc0 100644
--- a/libsolidity/codegen/ContractCompiler.cpp
+++ b/libsolidity/codegen/ContractCompiler.cpp
@@ -242,23 +242,34 @@ void ContractCompiler::appendFunctionSelector(ContractDefinition const& _contrac
 	m_context << notFound;
 	if (fallback)
 	{
+		if (!fallback->isPayable())
+		{
+			// Throw if function is not payable but call contained ether.
+			m_context << Instruction::CALLVALUE;
+			m_context.appendConditionalJumpTo(m_context.errorTag());
+		}
 		eth::AssemblyItem returnTag = m_context.pushNewTag();
 		fallback->accept(*this);
 		m_context << returnTag;
 		appendReturnValuePacker(FunctionType(*fallback).returnParameterTypes(), _contract.isLibrary());
 	}
-	else if (_contract.isLibrary())
-		// Reject invalid library calls and ether sent to a library.
-		m_context.appendJumpTo(m_context.errorTag());
 	else
-		m_context << Instruction::STOP; // function not found
+		m_context.appendJumpTo(m_context.errorTag());
 
 	for (auto const& it: interfaceFunctions)
 	{
 		FunctionTypePointer const& functionType = it.second;
 		solAssert(functionType->hasDeclaration(), "");
 		CompilerContext::LocationSetter locationSetter(m_context, functionType->declaration());
+
 		m_context << callDataUnpackerEntryPoints.at(it.first);
+		if (!functionType->isPayable())
+		{
+			// Throw if function is not payable but call contained ether.
+			m_context << Instruction::CALLVALUE;
+			m_context.appendConditionalJumpTo(m_context.errorTag());
+		}
+
 		eth::AssemblyItem returnTag = m_context.pushNewTag();
 		m_context << CompilerUtils::dataStartOffset;
 		appendCalldataUnpacker(functionType->parameterTypes());
@@ -431,16 +442,16 @@ bool ContractCompiler::visit(FunctionDefinition const& _function)
 		if (auto c = m_context.nextConstructor(dynamic_cast<ContractDefinition const&>(*_function.scope())))
 			appendBaseConstructor(*c);
 
-	m_returnTag = m_context.newTag();
+	solAssert(m_returnTags.empty(), "");
 	m_breakTags.clear();
 	m_continueTags.clear();
 	m_stackCleanupForReturn = 0;
 	m_currentFunction = &_function;
-	m_modifierDepth = 0;
+	m_modifierDepth = -1;
 
 	appendModifierOrFunctionCode();
 
-	m_context << m_returnTag;
+	solAssert(m_returnTags.empty(), "");
 
 	// Now we need to re-shuffle the stack. For this we keep a record of the stack layout
 	// that shows the target positions of the elements, where "-1" denotes that this element needs
@@ -695,7 +706,7 @@ bool ContractCompiler::visit(Return const& _return)
 	}
 	for (unsigned i = 0; i < m_stackCleanupForReturn; ++i)
 		m_context << Instruction::POP;
-	m_context.appendJumpTo(m_returnTag);
+	m_context.appendJumpTo(m_returnTags.back());
 	m_context.adjustStackOffset(m_stackCleanupForReturn);
 	return false;
 }
@@ -755,9 +766,7 @@ bool ContractCompiler::visit(PlaceholderStatement const& _placeholderStatement)
 {
 	StackHeightChecker checker(m_context);
 	CompilerContext::LocationSetter locationSetter(m_context, _placeholderStatement);
-	++m_modifierDepth;
 	appendModifierOrFunctionCode();
-	--m_modifierDepth;
 	checker.check();
 	return true;
 }
@@ -775,10 +784,15 @@ void ContractCompiler::appendMissingFunctions()
 void ContractCompiler::appendModifierOrFunctionCode()
 {
 	solAssert(m_currentFunction, "");
+	unsigned stackSurplus = 0;
+	Block const* codeBlock = nullptr;
+
+	m_modifierDepth++;
+
 	if (m_modifierDepth >= m_currentFunction->modifiers().size())
 	{
 		solAssert(m_currentFunction->isImplemented(), "");
-		m_currentFunction->body().accept(*this);
+		codeBlock = &m_currentFunction->body();
 	}
 	else
 	{
@@ -786,37 +800,45 @@ void ContractCompiler::appendModifierOrFunctionCode()
 
 		// constructor call should be excluded
 		if (dynamic_cast<ContractDefinition const*>(modifierInvocation->name()->annotation().referencedDeclaration))
-		{
-			++m_modifierDepth;
 			appendModifierOrFunctionCode();
-			--m_modifierDepth;
-			return;
-		}
-
-		ModifierDefinition const& modifier = m_context.functionModifier(modifierInvocation->name()->name());
-		CompilerContext::LocationSetter locationSetter(m_context, modifier);
-		solAssert(modifier.parameters().size() == modifierInvocation->arguments().size(), "");
-		for (unsigned i = 0; i < modifier.parameters().size(); ++i)
+		else
 		{
-			m_context.addVariable(*modifier.parameters()[i]);
-			compileExpression(
-				*modifierInvocation->arguments()[i],
-				modifier.parameters()[i]->annotation().type
-			);
+			ModifierDefinition const& modifier = m_context.functionModifier(modifierInvocation->name()->name());
+			CompilerContext::LocationSetter locationSetter(m_context, modifier);
+			solAssert(modifier.parameters().size() == modifierInvocation->arguments().size(), "");
+			for (unsigned i = 0; i < modifier.parameters().size(); ++i)
+			{
+				m_context.addVariable(*modifier.parameters()[i]);
+				compileExpression(
+					*modifierInvocation->arguments()[i],
+					modifier.parameters()[i]->annotation().type
+				);
+			}
+			for (VariableDeclaration const* localVariable: modifier.localVariables())
+				appendStackVariableInitialisation(*localVariable);
+
+			stackSurplus =
+				CompilerUtils::sizeOnStack(modifier.parameters()) +
+				CompilerUtils::sizeOnStack(modifier.localVariables());
+			codeBlock = &modifier.body();
+
+			codeBlock = &modifier.body();
 		}
-		for (VariableDeclaration const* localVariable: modifier.localVariables())
-			appendStackVariableInitialisation(*localVariable);
+	}
 
-		unsigned const c_stackSurplus = CompilerUtils::sizeOnStack(modifier.parameters()) +
-										CompilerUtils::sizeOnStack(modifier.localVariables());
-		m_stackCleanupForReturn += c_stackSurplus;
+	if (codeBlock)
+	{
+		m_returnTags.push_back(m_context.newTag());
 
-		modifier.body().accept(*this);
+		codeBlock->accept(*this);
 
-		for (unsigned i = 0; i < c_stackSurplus; ++i)
-			m_context << Instruction::POP;
-		m_stackCleanupForReturn -= c_stackSurplus;
+		solAssert(!m_returnTags.empty(), "");
+		m_context << m_returnTags.back();
+		m_returnTags.pop_back();
+
+		CompilerUtils(m_context).popStackSlots(stackSurplus);
 	}
+	m_modifierDepth--;
 }
 
 void ContractCompiler::appendStackVariableInitialisation(VariableDeclaration const& _variable)
diff --git a/libsolidity/codegen/ContractCompiler.h b/libsolidity/codegen/ContractCompiler.h
index d1517e88..0799a543 100644
--- a/libsolidity/codegen/ContractCompiler.h
+++ b/libsolidity/codegen/ContractCompiler.h
@@ -40,11 +40,9 @@ class ContractCompiler: private ASTConstVisitor
 public:
 	explicit ContractCompiler(CompilerContext& _context, bool _optimise):
 		m_optimise(_optimise),
-		m_context(_context),
-		m_returnTag(eth::Tag, u256(-1))
+		m_context(_context)
 	{
 		m_context = CompilerContext();
-		m_returnTag = m_context.newTag();
 	}
 
 	void compileContract(
@@ -122,7 +120,8 @@ private:
 	CompilerContext& m_context;
 	std::vector<eth::AssemblyItem> m_breakTags; ///< tag to jump to for a "break" statement
 	std::vector<eth::AssemblyItem> m_continueTags; ///< tag to jump to for a "continue" statement
-	eth::AssemblyItem m_returnTag; ///< tag to jump to for a "return" statement
+	/// Tag to jump to for a "return" statement, needs to be stacked because of modifiers.
+	std::vector<eth::AssemblyItem> m_returnTags;
 	unsigned m_modifierDepth = 0;
 	FunctionDefinition const* m_currentFunction = nullptr;
 	unsigned m_stackCleanupForReturn = 0; ///< this number of stack elements need to be removed before jump to m_returnTag
diff --git a/libsolidity/codegen/ExpressionCompiler.cpp b/libsolidity/codegen/ExpressionCompiler.cpp
index 80009a90..96ca4296 100644
--- a/libsolidity/codegen/ExpressionCompiler.cpp
+++ b/libsolidity/codegen/ExpressionCompiler.cpp
@@ -23,6 +23,7 @@
 #include <utility>
 #include <numeric>
 #include <boost/range/adaptor/reversed.hpp>
+#include <boost/algorithm/string/replace.hpp>
 #include <libdevcore/Common.h>
 #include <libdevcore/SHA3.h>
 #include <libsolidity/ast/AST.h>
@@ -297,9 +298,6 @@ bool ExpressionCompiler::visit(UnaryOperation const& _unaryOperation)
 	case Token::BitNot: // ~
 		m_context << Instruction::NOT;
 		break;
-	case Token::After: // after
-		m_context << Instruction::TIMESTAMP << Instruction::ADD;
-		break;
 	case Token::Delete: // delete
 		solAssert(!!m_currentLValue, "LValue not retrieved.");
 		m_currentLValue->setToZero(_unaryOperation.location());
@@ -536,6 +534,9 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 			else
 				m_context << u256(0);
 			m_context << Instruction::CREATE;
+			// Check if zero (out of stack or not enough balance).
+			m_context << Instruction::DUP1 << Instruction::ISZERO;
+			m_context.appendConditionalJumpTo(m_context.errorTag());
 			if (function.valueSet())
 				m_context << swapInstruction(1) << Instruction::POP;
 			break;
@@ -567,12 +568,17 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 			break;
 		case Location::Send:
 			_functionCall.expression().accept(*this);
-			m_context << u256(0); // do not send gas (there still is the stipend)
+			// Provide the gas stipend manually at first because we may send zero ether.
+			// Will be zeroed if we send more than zero ether.
+			m_context << u256(eth::GasCosts::callStipend);
 			arguments.front()->accept(*this);
 			utils().convertType(
 				*arguments.front()->annotation().type,
 				*function.parameterTypes().front(), true
 			);
+			// gas <- gas * !value
+			m_context << Instruction::SWAP1 << Instruction::DUP2;
+			m_context << Instruction::ISZERO << Instruction::MUL << Instruction::SWAP1;
 			appendExternalFunctionCall(
 				FunctionType(
 					TypePointers{},
@@ -582,6 +588,8 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 					Location::Bare,
 					false,
 					nullptr,
+					false,
+					false,
 					true,
 					true
 				),
@@ -1323,11 +1331,18 @@ void ExpressionCompiler::appendArithmeticOperatorCode(Token::Value _operator, Ty
 		m_context << Instruction::MUL;
 		break;
 	case Token::Div:
-		m_context  << (c_isSigned ? Instruction::SDIV : Instruction::DIV);
-		break;
 	case Token::Mod:
-		m_context << (c_isSigned ? Instruction::SMOD : Instruction::MOD);
+	{
+		// Test for division by zero
+		m_context << Instruction::DUP2 << Instruction::ISZERO;
+		m_context.appendConditionalJumpTo(m_context.errorTag());
+
+		if (_operator == Token::Div)
+			m_context << (c_isSigned ? Instruction::SDIV : Instruction::DIV);
+		else
+			m_context << (c_isSigned ? Instruction::SMOD : Instruction::MOD);
 		break;
+	}
 	case Token::Exp:
 		m_context << Instruction::EXP;
 		break;
@@ -1448,6 +1463,19 @@ void ExpressionCompiler::appendExternalFunctionCall(
 		argumentTypes.push_back(_arguments[i]->annotation().type);
 	}
 
+	if (funKind == FunctionKind::ECRecover)
+	{
+		// Clears 32 bytes of currently free memory and advances free memory pointer.
+		// Output area will be "start of input area" - 32.
+		// The reason is that a failing ECRecover cannot be detected, it will just return
+		// zero bytes (which we cannot detect).
+		solAssert(0 < retSize && retSize <= 32, "");
+		utils().fetchFreeMemoryPointer();
+		m_context << Instruction::DUP1 << u256(0) << Instruction::MSTORE;
+		m_context << u256(32) << Instruction::ADD;
+		utils().storeFreeMemoryPointer();
+	}
+
 	// Copy function identifier to memory.
 	utils().fetchFreeMemoryPointer();
 	if (!_functionType.isBareCall() || manualFunctionId)
@@ -1456,7 +1484,7 @@ void ExpressionCompiler::appendExternalFunctionCall(
 		utils().storeInMemoryDynamic(IntegerType(8 * CompilerUtils::dataStartOffset), false);
 	}
 	// If the function takes arbitrary parameters, copy dynamic length data in place.
-	// Move argumenst to memory, will not update the free memory pointer (but will update the memory
+	// Move arguments to memory, will not update the free memory pointer (but will update the memory
 	// pointer on the stack).
 	utils().encodeToMemory(
 		argumentTypes,
@@ -1474,12 +1502,24 @@ void ExpressionCompiler::appendExternalFunctionCall(
 	// function identifier [unless bare]
 	// contract address
 
-	// Output data will replace input data.
+	// Output data will replace input data, unless we have ECRecover (then, output
+	// area will be 32 bytes just before input area).
 	// put on stack: <size of output> <memory pos of output> <size of input> <memory pos of input>
 	m_context << u256(retSize);
-	utils().fetchFreeMemoryPointer();
-	m_context << Instruction::DUP1 << Instruction::DUP4 << Instruction::SUB;
-	m_context << Instruction::DUP2;
+	utils().fetchFreeMemoryPointer(); // This is the start of input
+	if (funKind == FunctionKind::ECRecover)
+	{
+		// In this case, output is 32 bytes before input and has already been cleared.
+		m_context << u256(32) << Instruction::DUP2 << Instruction::SUB << Instruction::SWAP1;
+		// Here: <input end> <output size> <outpos> <input pos>
+		m_context << Instruction::DUP1 << Instruction::DUP5 << Instruction::SUB;
+		m_context << Instruction::SWAP1;
+	}
+	else
+	{
+		m_context << Instruction::DUP1 << Instruction::DUP4 << Instruction::SUB;
+		m_context << Instruction::DUP2;
+	}
 
 	// CALL arguments: outSize, outOff, inSize, inOff (already present up to here)
 	// [value,] addr, gas (stack top)
@@ -1491,6 +1531,15 @@ void ExpressionCompiler::appendExternalFunctionCall(
 		m_context << u256(0);
 	m_context << dupInstruction(m_context.baseToCurrentStackOffset(contractStackPos));
 
+	bool existenceChecked = false;
+	// Check the the target contract exists (has code) for non-low-level calls.
+	if (funKind == FunctionKind::External || funKind == FunctionKind::CallCode || funKind == FunctionKind::DelegateCall)
+	{
+		m_context << Instruction::DUP1 << Instruction::EXTCODESIZE << Instruction::ISZERO;
+		m_context.appendConditionalJumpTo(m_context.errorTag());
+		existenceChecked = true;
+	}
+
 	if (_functionType.gasSet())
 		m_context << dupInstruction(m_context.baseToCurrentStackOffset(gasStackPos));
 	else
@@ -1500,7 +1549,7 @@ void ExpressionCompiler::appendExternalFunctionCall(
 		u256 gasNeededByCaller = eth::GasCosts::callGas + 10;
 		if (_functionType.valueSet())
 			gasNeededByCaller += eth::GasCosts::callValueTransferGas;
-		if (!isCallCode && !isDelegateCall)
+		if (!isCallCode && !isDelegateCall && !existenceChecked)
 			gasNeededByCaller += eth::GasCosts::callNewAccountGas; // we never know
 		m_context <<
 			gasNeededByCaller <<
@@ -1542,6 +1591,14 @@ void ExpressionCompiler::appendExternalFunctionCall(
 		utils().loadFromMemoryDynamic(IntegerType(160), false, true, false);
 		utils().convertType(IntegerType(160), FixedBytesType(20));
 	}
+	else if (funKind == FunctionKind::ECRecover)
+	{
+		// Output is 32 bytes before input / free mem pointer.
+		// Failing ecrecover cannot be detected, so we clear output before the call.
+		m_context << u256(32);
+		utils().fetchFreeMemoryPointer();
+		m_context << Instruction::SUB << Instruction::MLOAD;
+	}
 	else if (!_functionType.returnParameterTypes().empty())
 	{
 		utils().fetchFreeMemoryPointer();
diff --git a/libsolidity/codegen/LValue.cpp b/libsolidity/codegen/LValue.cpp
index ea8bc1ba..553e5518 100644
--- a/libsolidity/codegen/LValue.cpp
+++ b/libsolidity/codegen/LValue.cpp
@@ -17,7 +17,7 @@
 /**
  * @author Christian <c@ethdev.com>
  * @date 2015
- * LValues for use in the expresison compiler.
+ * LValues for use in the expression compiler.
  */
 
 #include <libsolidity/codegen/LValue.h>
diff --git a/libsolidity/codegen/LValue.h b/libsolidity/codegen/LValue.h
index e8c3aa80..a2f979db 100644
--- a/libsolidity/codegen/LValue.h
+++ b/libsolidity/codegen/LValue.h
@@ -17,7 +17,7 @@
 /**
  * @author Christian <c@ethdev.com>
  * @date 2015
- * LValues for use in the expresison compiler.
+ * LValues for use in the expression compiler.
  */
 
 #pragma once
diff --git a/libsolidity/formal/Why3Translator.cpp b/libsolidity/formal/Why3Translator.cpp
index bd0a020d..834024fa 100644
--- a/libsolidity/formal/Why3Translator.cpp
+++ b/libsolidity/formal/Why3Translator.cpp
@@ -466,7 +466,8 @@ bool Why3Translator::visit(BinaryOperation const& _binaryOperation)
 		auto const& constantNumber = dynamic_cast<RationalNumberType const&>(commonType);
 		if (constantNumber.isFractional())
 			error(_binaryOperation, "Fractional numbers not supported.");
-		add("(of_int " + toString(commonType.literalValue(nullptr)) + ")");
+		else
+			add("(of_int " + toString(commonType.literalValue(nullptr)) + ")");
 		return false;
 	}
 	static const map<Token::Value, char const*> optrans({
@@ -488,7 +489,10 @@ bool Why3Translator::visit(BinaryOperation const& _binaryOperation)
 		{Token::GreaterThanOrEqual, " >= "}
 	});
 	if (!optrans.count(c_op))
+	{
 		error(_binaryOperation, "Operator not supported.");
+		return true;
+	}
 
 	add("(");
 	leftExpression.accept(*this);
@@ -676,9 +680,10 @@ bool Why3Translator::visit(Literal const& _literal)
 		auto const& constantNumber = dynamic_cast<RationalNumberType const&>(*type);
 		if (constantNumber.isFractional())
 			error(_literal, "Fractional numbers not supported.");
-		add("(of_int " + toString(type->literalValue(&_literal)) + ")");
+		else
+			add("(of_int " + toString(type->literalValue(&_literal)) + ")");
 		break;
-	}	
+	}
 	default:
 		error(_literal, "Not supported.");
 	}
diff --git a/libsolidity/formal/Why3Translator.h b/libsolidity/formal/Why3Translator.h
index e5b16844..1b80ed61 100644
--- a/libsolidity/formal/Why3Translator.h
+++ b/libsolidity/formal/Why3Translator.h
@@ -36,7 +36,7 @@ class SourceUnit;
 /**
  * Simple translator from Solidity to Why3.
  *
- * @todo detect side effects in sub-expressions and limit them to one per statement.
+ * @todo detect side effects in sub-expressions and limit them to one per statement. #1043
  * @todo `x = y = z`
  * @todo implicit and explicit type conversion
  */
@@ -108,7 +108,7 @@ private:
 	/// @returns a string representing an expression that is a copy of this.storage
 	std::string copyOfStorage() const;
 
-	/// Visits the givin statement and indents it unless it is a block
+	/// Visits the given statement and indents it unless it is a block
 	/// (which does its own indentation).
 	void visitIndentedUnlessBlock(Statement const& _statement);
 
diff --git a/libsolidity/grammar.txt b/libsolidity/grammar.txt
index 08a74f45..755cf281 100644
--- a/libsolidity/grammar.txt
+++ b/libsolidity/grammar.txt
@@ -1,48 +1,106 @@
+SourceUnit = (PragmaDirective | ImportDirective | ContractDefinition)*
+
+// Pragma actually parses anything up to the trailing ';' to be fully forward-compatible.
+PragmaDirective = 'pragma' Identifier Expression ';'
+
+ImportDirective = 'import' StringLiteral ('as' Identifier)? ';'
+        | 'import' ('*' | Identifier) ('as' Identifier)? 'from' StringLiteral ';'
+        | 'import' '{' Identifier ('as' Identifier)? ( ',' Identifier ('as' Identifier)? )* '}' 'from' StringLiteral ';'
+
 ContractDefinition = ( 'contract' | 'library' ) Identifier
                      ( 'is' InheritanceSpecifier (',' InheritanceSpecifier )* )?
                      '{' ContractPart* '}'
-ContractPart = StateVariableDeclaration | StructDefinition | ModifierDefinition | FunctionDefinition | EnumDefinition
+
+ContractPart = StateVariableDeclaration | UsingForDeclaration
+             | StructDefinition | ModifierDefinition | FunctionDefinition | EventDefinition | EnumDefinition
 
 InheritanceSpecifier = Identifier ( '(' Expression ( ',' Expression )* ')' )?
+
+StateVariableDeclaration = TypeName ( 'public' | 'internal' | 'private' )? Identifier ('=' Expression)? ';'
+UsingForDeclaration = 'using' Identifier 'for' ('*' | TypeName) ';'
 StructDefinition = 'struct' Identifier '{'
-                     ( VariableDeclaration (';' VariableDeclaration)* )? '}
-StateVariableDeclaration = TypeName ( 'public' | 'inheritable' | 'private' )? Identifier ';'
+                     ( VariableDeclaration ';' (VariableDeclaration ';')* )? '}'
 ModifierDefinition = 'modifier' Identifier ParameterList? Block
-FunctionDefinition = 'function' Identifier ParameterList
-					 ( Identifier | 'constant' | 'external' | 'public' | 'inheritable' | 'private' )*
+FunctionDefinition = 'function' Identifier? ParameterList
+                     ( FunctionCall | Identifier | 'constant' | 'external' | 'public' | 'internal' | 'private' )*
                      ( 'returns' ParameterList )? Block
+EventDefinition = 'event' Identifier IndexedParameterList 'anonymous'? ';'
 
 EnumValue = Identifier
-EnumDefinition = 'enum' '{' EnumValue (',' EnumValue)* '}'
-ParameterList = '(' ( VariableDeclaration (',' VariableDeclaration)* )? ')'
+EnumDefinition = 'enum' Identifier '{' EnumValue? (',' EnumValue)* '}'
+
+IndexedParameterList = '(' ( TypeName 'indexed'? Identifier? (',' TypeName 'indexed'? Identifier?)* )? ')'
+ParameterList =        '(' ( TypeName            Identifier? (',' TypeName            Identifier?)* )? ')'
+
 // semantic restriction: mappings and structs (recursively) containing mappings
 // are not allowed in argument lists
 VariableDeclaration = TypeName Identifier
-TypeName = ElementaryTypeName | Identifier | Mapping | ArrayTypeName
+TypeName = ElementaryTypeName | Identifier StorageLocation? | Mapping | ArrayTypeName
 Mapping = 'mapping' '(' ElementaryTypeName '=>' TypeName ')'
-ArrayTypeName = TypeName '[' (Expression)? ']'
+ArrayTypeName = TypeName StorageLocation? '[' Expression? ']'
+StorageLocation = 'memory' | 'storage'
 
 Block = '{' Statement* '}'
-Statement = IfStatement | WhileStatement | Block |
-			( Continue | Break | Return | VariableDefinition | ExpressionStatement ) ';'
+Statement = IfStatement | WhileStatement | ForStatement | Block |
+            ( PlaceholderStatement | Continue | Break | Return |
+              Throw | SimpleStatement ) ';'
 
 ExpressionStatement = Expression
 IfStatement = 'if' '(' Expression ')' Statement ( 'else' Statement )?
 WhileStatement = 'while' '(' Expression ')' Statement
-VardefOrExprStmt = Variabledefinition | ExpressionStatement
-ForStatement = 'for' '(' (VardefOrExprStmt)? ';' (Expression)? ';' (ExpressionStatement)? ')' Statement
-Continue = 'continue' ';'
-Break = 'break' ';'
-Return = 'return' Expression? ';'
-Throw = 'throw' Expression? ';'
-VariableDefinition = VariableDeclaration ( = Expression )? ';'
-
-Expression = Assignment | UnaryOperation | BinaryOperation | FunctionCall | NewExpression | IndexAccess |
-			 MemberAccess | PrimaryExpression
-// The expression syntax is actually much more complicated
-Assignment = Expression (AssignmentOp Expression)
-FunctionCall = Expression '(' Expression ( ',' Expression )* ')'
+PlaceholderStatement = '_'
+SimpleStatement = VariableDefinition | ExpressionStatement
+ForStatement = 'for' '(' (SimpleStatement)? ';' (Expression)? ';' (ExpressionStatement)? ')' Statement
+Continue = 'continue'
+Break = 'break'
+Return = 'return' Expression?
+Throw = 'throw'
+VariableDefinition = VariableDeclaration ( '=' Expression )?
+
+// Precedence by order (see github.com/ethereum/solidity/pull/732)
+Expression =
+  ( Expression ('++' | '--') | FunctionCall | IndexAccess | MemberAccess | '(' Expression ')' )
+  | ('!' | '~' | 'delete' | '++' | '--' | '+' | '-') Expression
+  | Expression '**' Expression
+  | Expression ('*' | '/' | '%') Expression
+  | Expression ('+' | '-') Expression
+  | Expression ('<<' | '>>' | '>>>')
+  | Expression '&' Expression
+  | Expression '^' Expression
+  | Expression '|' Expression
+  | Expression ('<' | '>' | '<=' | '>=') Expression
+  | Expression ('==' | '!=') Expression
+  | Expression '&&' Expression
+  | Expression '||' Expression
+  | Expression '?' Expression ':' Expression
+  | Expression ('=' | '|=' | '^=' | '&=' | '<<=' | '>>=' | '+=' | '-=' | '*=' | '/=' | '%=') Expression
+  | Expression? (',' Expression)
+  | PrimaryExpression
+
+PrimaryExpression = Identifier | BooleanLiteral | NumberLiteral | StringLiteral
+
+FunctionCall = ( PrimaryExpression | NewExpression | TypeName ) ( ( '.' Identifier ) | ( '[' Expression ']' ) )* '(' Expression? ( ',' Expression )* ')'
 NewExpression = 'new' Identifier
 MemberAccess = Expression '.' Identifier
-IndexAccess = Expression '[' (Expresison)? ']'
-PrimaryExpression = Identifier | NumberLiteral | StringLiteral | ElementaryTypeName | '(' Expression ')'
+IndexAccess = Expression '[' Expression? ']'
+
+BooleanLiteral = 'true' | 'false'
+NumberLiteral = '0x'? [0-9]+ (' ' NumberUnit)?
+NumberUnit = 'wei' | 'szabo' | 'finney' | 'ether'
+           | 'seconds' | 'minutes' | 'hours' | 'days' | 'weeks' | 'years'
+StringLiteral = '"' ([^"\r\n\\] | '\\' .)* '"'
+
+Identifier = [a-zA-Z_] [a-zA-Z_0-9]*
+
+ElementaryTypeName = 'address' | 'bool' | 'string' | 'var'
+                   | Int | Uint | Byte | Fixed | Ufixed
+
+Int = 'int' | 'int8' | 'int16' | 'int24' | 'int32' | 'int40' | 'int48' | 'int56' | 'int64' | 'int72' | 'int80' | 'int88' | 'int96' | 'int104' | 'int112' | 'int120' | 'int128' | 'int136' | 'int144' | 'int152' | 'int160' | 'int168' | 'int176' | 'int184' | 'int192' | 'int200' | 'int208' | 'int216' | 'int224' | 'int232' | 'int240' | 'int248' | 'int256'
+
+Uint = 'uint' | 'uint8' | 'uint16' | 'uint24' | 'uint32' | 'uint40' | 'uint48' | 'uint56' | 'uint64' | 'uint72' | 'uint80' | 'uint88' | 'uint96' | 'uint104' | 'uint112' | 'uint120' | 'uint128' | 'uint136' | 'uint144' | 'uint152' | 'uint160' | 'uint168' | 'uint176' | 'uint184' | 'uint192' | 'uint200' | 'uint208' | 'uint216' | 'uint224' | 'uint232' | 'uint240' | 'uint248' | 'uint256'
+
+Byte = 'byte' | 'bytes' | 'bytes1' | 'bytes2' | 'bytes3' | 'bytes4' | 'bytes5' | 'bytes6' | 'bytes7' | 'bytes8' | 'bytes9' | 'bytes10' | 'bytes11' | 'bytes12' | 'bytes13' | 'bytes14' | 'bytes15' | 'bytes16' | 'bytes17' | 'bytes18' | 'bytes19' | 'bytes20' | 'bytes21' | 'bytes22' | 'bytes23' | 'bytes24' | 'bytes25' | 'bytes26' | 'bytes27' | 'bytes28' | 'bytes29' | 'bytes30' | 'bytes31' | 'bytes32'
+
+Fixed = 'fixed' | 'fixed0x8' | 'fixed0x16' | 'fixed0x24' | 'fixed0x32' | 'fixed0x40' | 'fixed0x48' | 'fixed0x56' | 'fixed0x64' | 'fixed0x72' | 'fixed0x80' | 'fixed0x88' | 'fixed0x96' | 'fixed0x104' | 'fixed0x112' | 'fixed0x120' | 'fixed0x128' | 'fixed0x136' | 'fixed0x144' | 'fixed0x152' | 'fixed0x160' | 'fixed0x168' | 'fixed0x176' | 'fixed0x184' | 'fixed0x192' | 'fixed0x200' | 'fixed0x208' | 'fixed0x216' | 'fixed0x224' | 'fixed0x232' | 'fixed0x240' | 'fixed0x248' | 'fixed0x256' | 'fixed8x8' | 'fixed8x16' | 'fixed8x24' | 'fixed8x32' | 'fixed8x40' | 'fixed8x48' | 'fixed8x56' | 'fixed8x64' | 'fixed8x72' | 'fixed8x80' | 'fixed8x88' | 'fixed8x96' | 'fixed8x104' | 'fixed8x112' | 'fixed8x120' | 'fixed8x128' | 'fixed8x136' | 'fixed8x144' | 'fixed8x152' | 'fixed8x160' | 'fixed8x168' | 'fixed8x176' | 'fixed8x184' | 'fixed8x192' | 'fixed8x200' | 'fixed8x208' | 'fixed8x216' | 'fixed8x224' | 'fixed8x232' | 'fixed8x240' | 'fixed8x248' | 'fixed16x8' | 'fixed16x16' | 'fixed16x24' | 'fixed16x32' | 'fixed16x40' | 'fixed16x48' | 'fixed16x56' | 'fixed16x64' | 'fixed16x72' | 'fixed16x80' | 'fixed16x88' | 'fixed16x96' | 'fixed16x104' | 'fixed16x112' | 'fixed16x120' | 'fixed16x128' | 'fixed16x136' | 'fixed16x144' | 'fixed16x152' | 'fixed16x160' | 'fixed16x168' | 'fixed16x176' | 'fixed16x184' | 'fixed16x192' | 'fixed16x200' | 'fixed16x208' | 'fixed16x216' | 'fixed16x224' | 'fixed16x232' | 'fixed16x240' | 'fixed24x8' | 'fixed24x16' | 'fixed24x24' | 'fixed24x32' | 'fixed24x40' | 'fixed24x48' | 'fixed24x56' | 'fixed24x64' | 'fixed24x72' | 'fixed24x80' | 'fixed24x88' | 'fixed24x96' | 'fixed24x104' | 'fixed24x112' | 'fixed24x120' | 'fixed24x128' | 'fixed24x136' | 'fixed24x144' | 'fixed24x152' | 'fixed24x160' | 'fixed24x168' | 'fixed24x176' | 'fixed24x184' | 'fixed24x192' | 'fixed24x200' | 'fixed24x208' | 'fixed24x216' | 'fixed24x224' | 'fixed24x232' | 'fixed32x8' | 'fixed32x16' | 'fixed32x24' | 'fixed32x32' | 'fixed32x40' | 'fixed32x48' | 'fixed32x56' | 'fixed32x64' | 'fixed32x72' | 'fixed32x80' | 'fixed32x88' | 'fixed32x96' | 'fixed32x104' | 'fixed32x112' | 'fixed32x120' | 'fixed32x128' | 'fixed32x136' | 'fixed32x144' | 'fixed32x152' | 'fixed32x160' | 'fixed32x168' | 'fixed32x176' | 'fixed32x184' | 'fixed32x192' | 'fixed32x200' | 'fixed32x208' | 'fixed32x216' | 'fixed32x224' | 'fixed40x8' | 'fixed40x16' | 'fixed40x24' | 'fixed40x32' | 'fixed40x40' | 'fixed40x48' | 'fixed40x56' | 'fixed40x64' | 'fixed40x72' | 'fixed40x80' | 'fixed40x88' | 'fixed40x96' | 'fixed40x104' | 'fixed40x112' | 'fixed40x120' | 'fixed40x128' | 'fixed40x136' | 'fixed40x144' | 'fixed40x152' | 'fixed40x160' | 'fixed40x168' | 'fixed40x176' | 'fixed40x184' | 'fixed40x192' | 'fixed40x200' | 'fixed40x208' | 'fixed40x216' | 'fixed48x8' | 'fixed48x16' | 'fixed48x24' | 'fixed48x32' | 'fixed48x40' | 'fixed48x48' | 'fixed48x56' | 'fixed48x64' | 'fixed48x72' | 'fixed48x80' | 'fixed48x88' | 'fixed48x96' | 'fixed48x104' | 'fixed48x112' | 'fixed48x120' | 'fixed48x128' | 'fixed48x136' | 'fixed48x144' | 'fixed48x152' | 'fixed48x160' | 'fixed48x168' | 'fixed48x176' | 'fixed48x184' | 'fixed48x192' | 'fixed48x200' | 'fixed48x208' | 'fixed56x8' | 'fixed56x16' | 'fixed56x24' | 'fixed56x32' | 'fixed56x40' | 'fixed56x48' | 'fixed56x56' | 'fixed56x64' | 'fixed56x72' | 'fixed56x80' | 'fixed56x88' | 'fixed56x96' | 'fixed56x104' | 'fixed56x112' | 'fixed56x120' | 'fixed56x128' | 'fixed56x136' | 'fixed56x144' | 'fixed56x152' | 'fixed56x160' | 'fixed56x168' | 'fixed56x176' | 'fixed56x184' | 'fixed56x192' | 'fixed56x200' | 'fixed64x8' | 'fixed64x16' | 'fixed64x24' | 'fixed64x32' | 'fixed64x40' | 'fixed64x48' | 'fixed64x56' | 'fixed64x64' | 'fixed64x72' | 'fixed64x80' | 'fixed64x88' | 'fixed64x96' | 'fixed64x104' | 'fixed64x112' | 'fixed64x120' | 'fixed64x128' | 'fixed64x136' | 'fixed64x144' | 'fixed64x152' | 'fixed64x160' | 'fixed64x168' | 'fixed64x176' | 'fixed64x184' | 'fixed64x192' | 'fixed72x8' | 'fixed72x16' | 'fixed72x24' | 'fixed72x32' | 'fixed72x40' | 'fixed72x48' | 'fixed72x56' | 'fixed72x64' | 'fixed72x72' | 'fixed72x80' | 'fixed72x88' | 'fixed72x96' | 'fixed72x104' | 'fixed72x112' | 'fixed72x120' | 'fixed72x128' | 'fixed72x136' | 'fixed72x144' | 'fixed72x152' | 'fixed72x160' | 'fixed72x168' | 'fixed72x176' | 'fixed72x184' | 'fixed80x8' | 'fixed80x16' | 'fixed80x24' | 'fixed80x32' | 'fixed80x40' | 'fixed80x48' | 'fixed80x56' | 'fixed80x64' | 'fixed80x72' | 'fixed80x80' | 'fixed80x88' | 'fixed80x96' | 'fixed80x104' | 'fixed80x112' | 'fixed80x120' | 'fixed80x128' | 'fixed80x136' | 'fixed80x144' | 'fixed80x152' | 'fixed80x160' | 'fixed80x168' | 'fixed80x176' | 'fixed88x8' | 'fixed88x16' | 'fixed88x24' | 'fixed88x32' | 'fixed88x40' | 'fixed88x48' | 'fixed88x56' | 'fixed88x64' | 'fixed88x72' | 'fixed88x80' | 'fixed88x88' | 'fixed88x96' | 'fixed88x104' | 'fixed88x112' | 'fixed88x120' | 'fixed88x128' | 'fixed88x136' | 'fixed88x144' | 'fixed88x152' | 'fixed88x160' | 'fixed88x168' | 'fixed96x8' | 'fixed96x16' | 'fixed96x24' | 'fixed96x32' | 'fixed96x40' | 'fixed96x48' | 'fixed96x56' | 'fixed96x64' | 'fixed96x72' | 'fixed96x80' | 'fixed96x88' | 'fixed96x96' | 'fixed96x104' | 'fixed96x112' | 'fixed96x120' | 'fixed96x128' | 'fixed96x136' | 'fixed96x144' | 'fixed96x152' | 'fixed96x160' | 'fixed104x8' | 'fixed104x16' | 'fixed104x24' | 'fixed104x32' | 'fixed104x40' | 'fixed104x48' | 'fixed104x56' | 'fixed104x64' | 'fixed104x72' | 'fixed104x80' | 'fixed104x88' | 'fixed104x96' | 'fixed104x104' | 'fixed104x112' | 'fixed104x120' | 'fixed104x128' | 'fixed104x136' | 'fixed104x144' | 'fixed104x152' | 'fixed112x8' | 'fixed112x16' | 'fixed112x24' | 'fixed112x32' | 'fixed112x40' | 'fixed112x48' | 'fixed112x56' | 'fixed112x64' | 'fixed112x72' | 'fixed112x80' | 'fixed112x88' | 'fixed112x96' | 'fixed112x104' | 'fixed112x112' | 'fixed112x120' | 'fixed112x128' | 'fixed112x136' | 'fixed112x144' | 'fixed120x8' | 'fixed120x16' | 'fixed120x24' | 'fixed120x32' | 'fixed120x40' | 'fixed120x48' | 'fixed120x56' | 'fixed120x64' | 'fixed120x72' | 'fixed120x80' | 'fixed120x88' | 'fixed120x96' | 'fixed120x104' | 'fixed120x112' | 'fixed120x120' | 'fixed120x128' | 'fixed120x136' | 'fixed128x8' | 'fixed128x16' | 'fixed128x24' | 'fixed128x32' | 'fixed128x40' | 'fixed128x48' | 'fixed128x56' | 'fixed128x64' | 'fixed128x72' | 'fixed128x80' | 'fixed128x88' | 'fixed128x96' | 'fixed128x104' | 'fixed128x112' | 'fixed128x120' | 'fixed128x128' | 'fixed136x8' | 'fixed136x16' | 'fixed136x24' | 'fixed136x32' | 'fixed136x40' | 'fixed136x48' | 'fixed136x56' | 'fixed136x64' | 'fixed136x72' | 'fixed136x80' | 'fixed136x88' | 'fixed136x96' | 'fixed136x104' | 'fixed136x112' | 'fixed136x120' | 'fixed144x8' | 'fixed144x16' | 'fixed144x24' | 'fixed144x32' | 'fixed144x40' | 'fixed144x48' | 'fixed144x56' | 'fixed144x64' | 'fixed144x72' | 'fixed144x80' | 'fixed144x88' | 'fixed144x96' | 'fixed144x104' | 'fixed144x112' | 'fixed152x8' | 'fixed152x16' | 'fixed152x24' | 'fixed152x32' | 'fixed152x40' | 'fixed152x48' | 'fixed152x56' | 'fixed152x64' | 'fixed152x72' | 'fixed152x80' | 'fixed152x88' | 'fixed152x96' | 'fixed152x104' | 'fixed160x8' | 'fixed160x16' | 'fixed160x24' | 'fixed160x32' | 'fixed160x40' | 'fixed160x48' | 'fixed160x56' | 'fixed160x64' | 'fixed160x72' | 'fixed160x80' | 'fixed160x88' | 'fixed160x96' | 'fixed168x8' | 'fixed168x16' | 'fixed168x24' | 'fixed168x32' | 'fixed168x40' | 'fixed168x48' | 'fixed168x56' | 'fixed168x64' | 'fixed168x72' | 'fixed168x80' | 'fixed168x88' | 'fixed176x8' | 'fixed176x16' | 'fixed176x24' | 'fixed176x32' | 'fixed176x40' | 'fixed176x48' | 'fixed176x56' | 'fixed176x64' | 'fixed176x72' | 'fixed176x80' | 'fixed184x8' | 'fixed184x16' | 'fixed184x24' | 'fixed184x32' | 'fixed184x40' | 'fixed184x48' | 'fixed184x56' | 'fixed184x64' | 'fixed184x72' | 'fixed192x8' | 'fixed192x16' | 'fixed192x24' | 'fixed192x32' | 'fixed192x40' | 'fixed192x48' | 'fixed192x56' | 'fixed192x64' | 'fixed200x8' | 'fixed200x16' | 'fixed200x24' | 'fixed200x32' | 'fixed200x40' | 'fixed200x48' | 'fixed200x56' | 'fixed208x8' | 'fixed208x16' | 'fixed208x24' | 'fixed208x32' | 'fixed208x40' | 'fixed208x48' | 'fixed216x8' | 'fixed216x16' | 'fixed216x24' | 'fixed216x32' | 'fixed216x40' | 'fixed224x8' | 'fixed224x16' | 'fixed224x24' | 'fixed224x32' | 'fixed232x8' | 'fixed232x16' | 'fixed232x24' | 'fixed240x8' | 'fixed240x16' | 'fixed248x8'
+
+Ufixed = 'ufixed' | 'ufixed0x8' | 'ufixed0x16' | 'ufixed0x24' | 'ufixed0x32' | 'ufixed0x40' | 'ufixed0x48' | 'ufixed0x56' | 'ufixed0x64' | 'ufixed0x72' | 'ufixed0x80' | 'ufixed0x88' | 'ufixed0x96' | 'ufixed0x104' | 'ufixed0x112' | 'ufixed0x120' | 'ufixed0x128' | 'ufixed0x136' | 'ufixed0x144' | 'ufixed0x152' | 'ufixed0x160' | 'ufixed0x168' | 'ufixed0x176' | 'ufixed0x184' | 'ufixed0x192' | 'ufixed0x200' | 'ufixed0x208' | 'ufixed0x216' | 'ufixed0x224' | 'ufixed0x232' | 'ufixed0x240' | 'ufixed0x248' | 'ufixed0x256' | 'ufixed8x8' | 'ufixed8x16' | 'ufixed8x24' | 'ufixed8x32' | 'ufixed8x40' | 'ufixed8x48' | 'ufixed8x56' | 'ufixed8x64' | 'ufixed8x72' | 'ufixed8x80' | 'ufixed8x88' | 'ufixed8x96' | 'ufixed8x104' | 'ufixed8x112' | 'ufixed8x120' | 'ufixed8x128' | 'ufixed8x136' | 'ufixed8x144' | 'ufixed8x152' | 'ufixed8x160' | 'ufixed8x168' | 'ufixed8x176' | 'ufixed8x184' | 'ufixed8x192' | 'ufixed8x200' | 'ufixed8x208' | 'ufixed8x216' | 'ufixed8x224' | 'ufixed8x232' | 'ufixed8x240' | 'ufixed8x248' | 'ufixed16x8' | 'ufixed16x16' | 'ufixed16x24' | 'ufixed16x32' | 'ufixed16x40' | 'ufixed16x48' | 'ufixed16x56' | 'ufixed16x64' | 'ufixed16x72' | 'ufixed16x80' | 'ufixed16x88' | 'ufixed16x96' | 'ufixed16x104' | 'ufixed16x112' | 'ufixed16x120' | 'ufixed16x128' | 'ufixed16x136' | 'ufixed16x144' | 'ufixed16x152' | 'ufixed16x160' | 'ufixed16x168' | 'ufixed16x176' | 'ufixed16x184' | 'ufixed16x192' | 'ufixed16x200' | 'ufixed16x208' | 'ufixed16x216' | 'ufixed16x224' | 'ufixed16x232' | 'ufixed16x240' | 'ufixed24x8' | 'ufixed24x16' | 'ufixed24x24' | 'ufixed24x32' | 'ufixed24x40' | 'ufixed24x48' | 'ufixed24x56' | 'ufixed24x64' | 'ufixed24x72' | 'ufixed24x80' | 'ufixed24x88' | 'ufixed24x96' | 'ufixed24x104' | 'ufixed24x112' | 'ufixed24x120' | 'ufixed24x128' | 'ufixed24x136' | 'ufixed24x144' | 'ufixed24x152' | 'ufixed24x160' | 'ufixed24x168' | 'ufixed24x176' | 'ufixed24x184' | 'ufixed24x192' | 'ufixed24x200' | 'ufixed24x208' | 'ufixed24x216' | 'ufixed24x224' | 'ufixed24x232' | 'ufixed32x8' | 'ufixed32x16' | 'ufixed32x24' | 'ufixed32x32' | 'ufixed32x40' | 'ufixed32x48' | 'ufixed32x56' | 'ufixed32x64' | 'ufixed32x72' | 'ufixed32x80' | 'ufixed32x88' | 'ufixed32x96' | 'ufixed32x104' | 'ufixed32x112' | 'ufixed32x120' | 'ufixed32x128' | 'ufixed32x136' | 'ufixed32x144' | 'ufixed32x152' | 'ufixed32x160' | 'ufixed32x168' | 'ufixed32x176' | 'ufixed32x184' | 'ufixed32x192' | 'ufixed32x200' | 'ufixed32x208' | 'ufixed32x216' | 'ufixed32x224' | 'ufixed40x8' | 'ufixed40x16' | 'ufixed40x24' | 'ufixed40x32' | 'ufixed40x40' | 'ufixed40x48' | 'ufixed40x56' | 'ufixed40x64' | 'ufixed40x72' | 'ufixed40x80' | 'ufixed40x88' | 'ufixed40x96' | 'ufixed40x104' | 'ufixed40x112' | 'ufixed40x120' | 'ufixed40x128' | 'ufixed40x136' | 'ufixed40x144' | 'ufixed40x152' | 'ufixed40x160' | 'ufixed40x168' | 'ufixed40x176' | 'ufixed40x184' | 'ufixed40x192' | 'ufixed40x200' | 'ufixed40x208' | 'ufixed40x216' | 'ufixed48x8' | 'ufixed48x16' | 'ufixed48x24' | 'ufixed48x32' | 'ufixed48x40' | 'ufixed48x48' | 'ufixed48x56' | 'ufixed48x64' | 'ufixed48x72' | 'ufixed48x80' | 'ufixed48x88' | 'ufixed48x96' | 'ufixed48x104' | 'ufixed48x112' | 'ufixed48x120' | 'ufixed48x128' | 'ufixed48x136' | 'ufixed48x144' | 'ufixed48x152' | 'ufixed48x160' | 'ufixed48x168' | 'ufixed48x176' | 'ufixed48x184' | 'ufixed48x192' | 'ufixed48x200' | 'ufixed48x208' | 'ufixed56x8' | 'ufixed56x16' | 'ufixed56x24' | 'ufixed56x32' | 'ufixed56x40' | 'ufixed56x48' | 'ufixed56x56' | 'ufixed56x64' | 'ufixed56x72' | 'ufixed56x80' | 'ufixed56x88' | 'ufixed56x96' | 'ufixed56x104' | 'ufixed56x112' | 'ufixed56x120' | 'ufixed56x128' | 'ufixed56x136' | 'ufixed56x144' | 'ufixed56x152' | 'ufixed56x160' | 'ufixed56x168' | 'ufixed56x176' | 'ufixed56x184' | 'ufixed56x192' | 'ufixed56x200' | 'ufixed64x8' | 'ufixed64x16' | 'ufixed64x24' | 'ufixed64x32' | 'ufixed64x40' | 'ufixed64x48' | 'ufixed64x56' | 'ufixed64x64' | 'ufixed64x72' | 'ufixed64x80' | 'ufixed64x88' | 'ufixed64x96' | 'ufixed64x104' | 'ufixed64x112' | 'ufixed64x120' | 'ufixed64x128' | 'ufixed64x136' | 'ufixed64x144' | 'ufixed64x152' | 'ufixed64x160' | 'ufixed64x168' | 'ufixed64x176' | 'ufixed64x184' | 'ufixed64x192' | 'ufixed72x8' | 'ufixed72x16' | 'ufixed72x24' | 'ufixed72x32' | 'ufixed72x40' | 'ufixed72x48' | 'ufixed72x56' | 'ufixed72x64' | 'ufixed72x72' | 'ufixed72x80' | 'ufixed72x88' | 'ufixed72x96' | 'ufixed72x104' | 'ufixed72x112' | 'ufixed72x120' | 'ufixed72x128' | 'ufixed72x136' | 'ufixed72x144' | 'ufixed72x152' | 'ufixed72x160' | 'ufixed72x168' | 'ufixed72x176' | 'ufixed72x184' | 'ufixed80x8' | 'ufixed80x16' | 'ufixed80x24' | 'ufixed80x32' | 'ufixed80x40' | 'ufixed80x48' | 'ufixed80x56' | 'ufixed80x64' | 'ufixed80x72' | 'ufixed80x80' | 'ufixed80x88' | 'ufixed80x96' | 'ufixed80x104' | 'ufixed80x112' | 'ufixed80x120' | 'ufixed80x128' | 'ufixed80x136' | 'ufixed80x144' | 'ufixed80x152' | 'ufixed80x160' | 'ufixed80x168' | 'ufixed80x176' | 'ufixed88x8' | 'ufixed88x16' | 'ufixed88x24' | 'ufixed88x32' | 'ufixed88x40' | 'ufixed88x48' | 'ufixed88x56' | 'ufixed88x64' | 'ufixed88x72' | 'ufixed88x80' | 'ufixed88x88' | 'ufixed88x96' | 'ufixed88x104' | 'ufixed88x112' | 'ufixed88x120' | 'ufixed88x128' | 'ufixed88x136' | 'ufixed88x144' | 'ufixed88x152' | 'ufixed88x160' | 'ufixed88x168' | 'ufixed96x8' | 'ufixed96x16' | 'ufixed96x24' | 'ufixed96x32' | 'ufixed96x40' | 'ufixed96x48' | 'ufixed96x56' | 'ufixed96x64' | 'ufixed96x72' | 'ufixed96x80' | 'ufixed96x88' | 'ufixed96x96' | 'ufixed96x104' | 'ufixed96x112' | 'ufixed96x120' | 'ufixed96x128' | 'ufixed96x136' | 'ufixed96x144' | 'ufixed96x152' | 'ufixed96x160' | 'ufixed104x8' | 'ufixed104x16' | 'ufixed104x24' | 'ufixed104x32' | 'ufixed104x40' | 'ufixed104x48' | 'ufixed104x56' | 'ufixed104x64' | 'ufixed104x72' | 'ufixed104x80' | 'ufixed104x88' | 'ufixed104x96' | 'ufixed104x104' | 'ufixed104x112' | 'ufixed104x120' | 'ufixed104x128' | 'ufixed104x136' | 'ufixed104x144' | 'ufixed104x152' | 'ufixed112x8' | 'ufixed112x16' | 'ufixed112x24' | 'ufixed112x32' | 'ufixed112x40' | 'ufixed112x48' | 'ufixed112x56' | 'ufixed112x64' | 'ufixed112x72' | 'ufixed112x80' | 'ufixed112x88' | 'ufixed112x96' | 'ufixed112x104' | 'ufixed112x112' | 'ufixed112x120' | 'ufixed112x128' | 'ufixed112x136' | 'ufixed112x144' | 'ufixed120x8' | 'ufixed120x16' | 'ufixed120x24' | 'ufixed120x32' | 'ufixed120x40' | 'ufixed120x48' | 'ufixed120x56' | 'ufixed120x64' | 'ufixed120x72' | 'ufixed120x80' | 'ufixed120x88' | 'ufixed120x96' | 'ufixed120x104' | 'ufixed120x112' | 'ufixed120x120' | 'ufixed120x128' | 'ufixed120x136' | 'ufixed128x8' | 'ufixed128x16' | 'ufixed128x24' | 'ufixed128x32' | 'ufixed128x40' | 'ufixed128x48' | 'ufixed128x56' | 'ufixed128x64' | 'ufixed128x72' | 'ufixed128x80' | 'ufixed128x88' | 'ufixed128x96' | 'ufixed128x104' | 'ufixed128x112' | 'ufixed128x120' | 'ufixed128x128' | 'ufixed136x8' | 'ufixed136x16' | 'ufixed136x24' | 'ufixed136x32' | 'ufixed136x40' | 'ufixed136x48' | 'ufixed136x56' | 'ufixed136x64' | 'ufixed136x72' | 'ufixed136x80' | 'ufixed136x88' | 'ufixed136x96' | 'ufixed136x104' | 'ufixed136x112' | 'ufixed136x120' | 'ufixed144x8' | 'ufixed144x16' | 'ufixed144x24' | 'ufixed144x32' | 'ufixed144x40' | 'ufixed144x48' | 'ufixed144x56' | 'ufixed144x64' | 'ufixed144x72' | 'ufixed144x80' | 'ufixed144x88' | 'ufixed144x96' | 'ufixed144x104' | 'ufixed144x112' | 'ufixed152x8' | 'ufixed152x16' | 'ufixed152x24' | 'ufixed152x32' | 'ufixed152x40' | 'ufixed152x48' | 'ufixed152x56' | 'ufixed152x64' | 'ufixed152x72' | 'ufixed152x80' | 'ufixed152x88' | 'ufixed152x96' | 'ufixed152x104' | 'ufixed160x8' | 'ufixed160x16' | 'ufixed160x24' | 'ufixed160x32' | 'ufixed160x40' | 'ufixed160x48' | 'ufixed160x56' | 'ufixed160x64' | 'ufixed160x72' | 'ufixed160x80' | 'ufixed160x88' | 'ufixed160x96' | 'ufixed168x8' | 'ufixed168x16' | 'ufixed168x24' | 'ufixed168x32' | 'ufixed168x40' | 'ufixed168x48' | 'ufixed168x56' | 'ufixed168x64' | 'ufixed168x72' | 'ufixed168x80' | 'ufixed168x88' | 'ufixed176x8' | 'ufixed176x16' | 'ufixed176x24' | 'ufixed176x32' | 'ufixed176x40' | 'ufixed176x48' | 'ufixed176x56' | 'ufixed176x64' | 'ufixed176x72' | 'ufixed176x80' | 'ufixed184x8' | 'ufixed184x16' | 'ufixed184x24' | 'ufixed184x32' | 'ufixed184x40' | 'ufixed184x48' | 'ufixed184x56' | 'ufixed184x64' | 'ufixed184x72' | 'ufixed192x8' | 'ufixed192x16' | 'ufixed192x24' | 'ufixed192x32' | 'ufixed192x40' | 'ufixed192x48' | 'ufixed192x56' | 'ufixed192x64' | 'ufixed200x8' | 'ufixed200x16' | 'ufixed200x24' | 'ufixed200x32' | 'ufixed200x40' | 'ufixed200x48' | 'ufixed200x56' | 'ufixed208x8' | 'ufixed208x16' | 'ufixed208x24' | 'ufixed208x32' | 'ufixed208x40' | 'ufixed208x48' | 'ufixed216x8' | 'ufixed216x16' | 'ufixed216x24' | 'ufixed216x32' | 'ufixed216x40' | 'ufixed224x8' | 'ufixed224x16' | 'ufixed224x24' | 'ufixed224x32' | 'ufixed232x8' | 'ufixed232x16' | 'ufixed232x24' | 'ufixed240x8' | 'ufixed240x16' | 'ufixed248x8'
diff --git a/libsolidity/inlineasm/AsmStack.cpp b/libsolidity/inlineasm/AsmStack.cpp
index c891678b..11c6e28f 100644
--- a/libsolidity/inlineasm/AsmStack.cpp
+++ b/libsolidity/inlineasm/AsmStack.cpp
@@ -24,6 +24,7 @@
 #include <memory>
 #include <libevmasm/Assembly.h>
 #include <libevmasm/SourceLocation.h>
+#include <libsolidity/parsing/Scanner.h>
 #include <libsolidity/inlineasm/AsmParser.h>
 #include <libsolidity/inlineasm/AsmCodeGen.h>
 
@@ -32,7 +33,7 @@ using namespace dev;
 using namespace dev::solidity;
 using namespace dev::solidity::assembly;
 
-bool InlineAssemblyStack::parse(const std::shared_ptr<Scanner>& _scanner)
+bool InlineAssemblyStack::parse(shared_ptr<Scanner> const& _scanner)
 {
 	m_parserResult = make_shared<Block>();
 	Parser parser(m_errors);
@@ -49,3 +50,22 @@ eth::Assembly InlineAssemblyStack::assemble()
 	return codeGen.assemble();
 }
 
+bool InlineAssemblyStack::parseAndAssemble(
+	string const& _input,
+	eth::Assembly& _assembly,
+	CodeGenerator::IdentifierAccess const& _identifierAccess
+)
+{
+	ErrorList errors;
+	auto scanner = make_shared<Scanner>(CharStream(_input), "--CODEGEN--");
+	auto parserResult = Parser(errors).parse(scanner);
+	if (!errors.empty())
+		return false;
+
+	CodeGenerator(*parserResult, errors).assemble(_assembly, _identifierAccess);
+
+	// At this point, the assembly might be messed up, but we should throw an
+	// internal compiler error anyway.
+	return errors.empty();
+}
+
diff --git a/libsolidity/inlineasm/AsmStack.h b/libsolidity/inlineasm/AsmStack.h
index 8a860e46..521f5fe7 100644
--- a/libsolidity/inlineasm/AsmStack.h
+++ b/libsolidity/inlineasm/AsmStack.h
@@ -25,6 +25,7 @@
 #include <string>
 #include <functional>
 #include <libsolidity/interface/Exceptions.h>
+#include <libsolidity/inlineasm/AsmCodeGen.h>
 
 namespace dev
 {
@@ -47,6 +48,13 @@ public:
 	bool parse(std::shared_ptr<Scanner> const& _scanner);
 	eth::Assembly assemble();
 
+	/// Parse and assemble a string in one run - for use in Solidity code generation itself.
+	bool parseAndAssemble(
+		std::string const& _input,
+		eth::Assembly& _assembly,
+		CodeGenerator::IdentifierAccess const& _identifierAccess = CodeGenerator::IdentifierAccess()
+	);
+
 	ErrorList const& errors() const { return m_errors; }
 
 private:
diff --git a/libsolidity/interface/CompilerStack.cpp b/libsolidity/interface/CompilerStack.cpp
index f7982872..ec6b5d2e 100644
--- a/libsolidity/interface/CompilerStack.cpp
+++ b/libsolidity/interface/CompilerStack.cpp
@@ -42,26 +42,8 @@ using namespace std;
 using namespace dev;
 using namespace dev::solidity;
 
-const map<string, string> StandardSources = map<string, string>{
-	{"coin", R"(import "CoinReg";import "Config";import "configUser";contract coin is configUser{function coin(bytes3 name, uint denom) {CoinReg(Config(configAddr()).lookup(3)).register(name, denom);}})"},
-	{"Coin", R"(contract Coin{function isApprovedFor(address _target,address _proxy)constant returns(bool _r){}function isApproved(address _proxy)constant returns(bool _r){}function sendCoinFrom(address _from,uint256 _val,address _to){}function coinBalanceOf(address _a)constant returns(uint256 _r){}function sendCoin(uint256 _val,address _to){}function coinBalance()constant returns(uint256 _r){}function approve(address _a){}})"},
-	{"CoinReg", R"(contract CoinReg{function count()constant returns(uint256 r){}function info(uint256 i)constant returns(address addr,bytes3 name,uint256 denom){}function register(bytes3 name,uint256 denom){}function unregister(){}})"},
-	{"configUser", R"(contract configUser{function configAddr()constant returns(address a){ return 0xc6d9d2cd449a754c494264e1809c50e34d64562b;}})"},
-	{"Config", R"(contract Config{function lookup(uint256 service)constant returns(address a){}function kill(){}function unregister(uint256 id){}function register(uint256 id,address service){}})"},
-	{"mortal", R"(import "owned";contract mortal is owned {function kill() { if (msg.sender == owner) suicide(owner); }})"},
-	{"named", R"(import "Config";import "NameReg";import "configUser";contract named is configUser {function named(bytes32 name) {NameReg(Config(configAddr()).lookup(1)).register(name);}})"},
-	{"NameReg", R"(contract NameReg{function register(bytes32 name){}function addressOf(bytes32 name)constant returns(address addr){}function unregister(){}function nameOf(address addr)constant returns(bytes32 name){}})"},
-	{"owned", R"(contract owned{function owned(){owner = msg.sender;}modifier onlyowner(){if(msg.sender==owner)_}address owner;})"},
-	{"service", R"(import "Config";import "configUser";contract service is configUser{function service(uint _n){Config(configAddr()).register(_n, this);}})"},
-	{"std", R"(import "owned";import "mortal";import "Config";import "configUser";import "NameReg";import "named";)"}
-};
-
-CompilerStack::CompilerStack(bool _addStandardSources, ReadFileCallback const& _readFile):
-	m_readFile(_readFile), m_parseSuccessful(false)
-{
-	if (_addStandardSources)
-		addSources(StandardSources, true); // add them as libraries
-}
+CompilerStack::CompilerStack(ReadFileCallback const& _readFile):
+	m_readFile(_readFile), m_parseSuccessful(false) {}
 
 void CompilerStack::setRemappings(vector<string> const& _remappings)
 {
@@ -81,7 +63,7 @@ void CompilerStack::setRemappings(vector<string> const& _remappings)
 	swap(m_remappings, remappings);
 }
 
-void CompilerStack::reset(bool _keepSources, bool _addStandardSources)
+void CompilerStack::reset(bool _keepSources)
 {
 	m_parseSuccessful = false;
 	if (_keepSources)
@@ -90,8 +72,6 @@ void CompilerStack::reset(bool _keepSources, bool _addStandardSources)
 	else
 	{
 		m_sources.clear();
-		if (_addStandardSources)
-			addSources(StandardSources, true);
 	}
 	m_globalContext.reset();
 	m_sourceOrder.clear();
@@ -358,11 +338,6 @@ string const& CompilerStack::interface(string const& _contractName) const
 	return metadata(_contractName, DocumentationType::ABIInterface);
 }
 
-string const& CompilerStack::solidityInterface(string const& _contractName) const
-{
-	return metadata(_contractName, DocumentationType::ABISolidityInterface);
-}
-
 string const& CompilerStack::metadata(string const& _contractName, DocumentationType _type) const
 {
 	if (!m_parseSuccessful)
@@ -383,9 +358,6 @@ string const& CompilerStack::metadata(string const& _contractName, Documentation
 	case DocumentationType::ABIInterface:
 		doc = &currentContract.interface;
 		break;
-	case DocumentationType::ABISolidityInterface:
-		doc = &currentContract.solidityInterface;
-		break;
 	default:
 		BOOST_THROW_EXCEPTION(InternalCompilerError() << errinfo_comment("Illegal documentation type."));
 	}
@@ -583,7 +555,7 @@ string CompilerStack::absolutePath(string const& _path, string const& _reference
 			result = result.parent_path();
 		else if (*it != ".")
 			result /= *it;
-	return result.string();
+	return result.generic_string();
 }
 
 void CompilerStack::compileContract(
@@ -624,10 +596,9 @@ CompilerStack::Contract const& CompilerStack::contract(string const& _contractNa
 	if (_contractName.empty())
 		// try to find some user-supplied contract
 		for (auto const& it: m_sources)
-			if (!StandardSources.count(it.first))
-				for (ASTPointer<ASTNode> const& node: it.second.ast->nodes())
-					if (auto contract = dynamic_cast<ContractDefinition const*>(node.get()))
-						contractName = contract->name();
+			for (ASTPointer<ASTNode> const& node: it.second.ast->nodes())
+				if (auto contract = dynamic_cast<ContractDefinition const*>(node.get()))
+					contractName = contract->name();
 	auto it = m_contracts.find(contractName);
 	if (it == m_contracts.end())
 		BOOST_THROW_EXCEPTION(CompilerError() << errinfo_comment("Contract " + _contractName + " not found."));
diff --git a/libsolidity/interface/CompilerStack.h b/libsolidity/interface/CompilerStack.h
index a4b8447f..da479638 100644
--- a/libsolidity/interface/CompilerStack.h
+++ b/libsolidity/interface/CompilerStack.h
@@ -63,8 +63,7 @@ enum class DocumentationType: uint8_t
 {
 	NatspecUser = 1,
 	NatspecDev,
-	ABIInterface,
-	ABISolidityInterface
+	ABIInterface
 };
 
 /**
@@ -86,14 +85,13 @@ public:
 
 	/// Creates a new compiler stack.
 	/// @param _readFile callback to used to read files for import statements. Should return
-	/// @param _addStandardSources Adds standard sources if @a _addStandardSources.
-	explicit CompilerStack(bool _addStandardSources = true, ReadFileCallback const& _readFile = ReadFileCallback());
+	explicit CompilerStack(ReadFileCallback const& _readFile = ReadFileCallback());
 
 	/// Sets path remappings in the format "context:prefix=target"
 	void setRemappings(std::vector<std::string> const& _remappings);
 
 	/// Resets the compiler to a state where the sources are not parsed or even removed.
-	void reset(bool _keepSources = false, bool _addStandardSources = true);
+	void reset(bool _keepSources = false);
 
 	/// Adds a source object (e.g. file) to the parser. After this, parse has to be called again.
 	/// @returns true if a source object by the name already existed and was replaced.
@@ -167,9 +165,6 @@ public:
 	/// @returns a string representing the contract interface in JSON.
 	/// Prerequisite: Successful call to parse or compile.
 	std::string const& interface(std::string const& _contractName = "") const;
-	/// @returns a string representing the contract interface in Solidity.
-	/// Prerequisite: Successful call to parse or compile.
-	std::string const& solidityInterface(std::string const& _contractName = "") const;
 	/// @returns a string representing the contract's documentation in JSON.
 	/// Prerequisite: Successful call to parse or compile.
 	/// @param type The type of the documentation to get.
@@ -219,7 +214,6 @@ private:
 		eth::LinkerObject runtimeObject;
 		eth::LinkerObject cloneObject;
 		mutable std::unique_ptr<std::string const> interface;
-		mutable std::unique_ptr<std::string const> solidityInterface;
 		mutable std::unique_ptr<std::string const> userDocumentation;
 		mutable std::unique_ptr<std::string const> devDocumentation;
 		mutable std::unique_ptr<std::string const> sourceMapping;
diff --git a/libsolidity/interface/InterfaceHandler.cpp b/libsolidity/interface/InterfaceHandler.cpp
index e254137f..de16a372 100644
--- a/libsolidity/interface/InterfaceHandler.cpp
+++ b/libsolidity/interface/InterfaceHandler.cpp
@@ -21,8 +21,6 @@ string InterfaceHandler::documentation(
 		return devDocumentation(_contractDef);
 	case DocumentationType::ABIInterface:
 		return abiInterface(_contractDef);
-	case DocumentationType::ABISolidityInterface:
-		return ABISolidityInterface(_contractDef);
 	}
 
 	BOOST_THROW_EXCEPTION(InternalCompilerError() << errinfo_comment("Unknown documentation type"));
@@ -54,6 +52,7 @@ string InterfaceHandler::abiInterface(ContractDefinition const& _contractDef)
 		method["type"] = "function";
 		method["name"] = it.second->declaration().name();
 		method["constant"] = it.second->isConstant();
+		method["payable"] = it.second->isPayable();
 		method["inputs"] = populateParameters(
 			externalFunctionType->parameterNames(),
 			externalFunctionType->parameterTypeNames(_contractDef.isLibrary())
@@ -76,7 +75,15 @@ string InterfaceHandler::abiInterface(ContractDefinition const& _contractDef)
 		);
 		abi.append(method);
 	}
-
+	if (_contractDef.fallbackFunction())
+	{
+		auto externalFunctionType = FunctionType(*_contractDef.fallbackFunction()).interfaceFunctionType();
+		solAssert(!!externalFunctionType, "");
+		Json::Value method;
+		method["type"] = "fallback";
+		method["payable"] = externalFunctionType->isPayable();
+		abi.append(method);
+	}
 	for (auto const& it: _contractDef.interfaceEvents())
 	{
 		Json::Value event;
@@ -86,9 +93,10 @@ string InterfaceHandler::abiInterface(ContractDefinition const& _contractDef)
 		Json::Value params(Json::arrayValue);
 		for (auto const& p: it->parameters())
 		{
+			solAssert(!!p->annotation().type->interfaceType(false), "");
 			Json::Value input;
 			input["name"] = p->name();
-			input["type"] = p->annotation().type->canonicalName(false);
+			input["type"] = p->annotation().type->interfaceType(false)->canonicalName(false);
 			input["indexed"] = p->isIndexed();
 			params.append(input);
 		}
@@ -98,74 +106,6 @@ string InterfaceHandler::abiInterface(ContractDefinition const& _contractDef)
 	return Json::FastWriter().write(abi);
 }
 
-string InterfaceHandler::ABISolidityInterface(ContractDefinition const& _contractDef)
-{
-	string ret = (_contractDef.isLibrary() ? "library " : "contract ") + _contractDef.name() + "{";
-
-	auto populateParameters = [](vector<string> const& _paramNames, vector<string> const& _paramTypes)
-	{
-		string ret = "(";
-		for (size_t i = 0; i < _paramNames.size(); ++i)
-			ret += _paramTypes[i] + " " + _paramNames[i] + ",";
-		if (ret.size() != 1)
-			ret.pop_back();
-		return ret + ")";
-	};
-	// If this is a library, include all its enum and struct types. Should be more intelligent
-	// in the future and check what is actually used (it might even use types from other libraries
-	// or contracts or in the global scope).
-	if (_contractDef.isLibrary())
-	{
-		for (auto const& stru: _contractDef.definedStructs())
-		{
-			ret += "struct " + stru->name() + "{";
-			for (ASTPointer<VariableDeclaration> const& _member: stru->members())
-				ret += _member->type()->canonicalName(false) + " " + _member->name() + ";";
-			ret += "}";
-		}
-		for (auto const& enu: _contractDef.definedEnums())
-		{
-			ret += "enum " + enu->name() + "{";
-			for (ASTPointer<EnumValue> const& val: enu->members())
-				ret += val->name() + ",";
-			if (ret.back() == ',')
-				ret.pop_back();
-			ret += "}";
-		}
-	}
-	if (_contractDef.constructor())
-	{
-		auto externalFunction = FunctionType(*_contractDef.constructor()).interfaceFunctionType();
-		solAssert(!!externalFunction, "");
-		ret +=
-			"function " +
-			_contractDef.name() +
-			populateParameters(
-				externalFunction->parameterNames(),
-				externalFunction->parameterTypeNames(_contractDef.isLibrary())
-			) +
-			";";
-	}
-	for (auto const& it: _contractDef.interfaceFunctions())
-	{
-		ret += "function " + it.second->declaration().name() +
-			populateParameters(
-				it.second->parameterNames(),
-				it.second->parameterTypeNames(_contractDef.isLibrary())
-			) + (it.second->isConstant() ? "constant " : "");
-		if (it.second->returnParameterTypes().size())
-			ret += "returns" + populateParameters(
-				it.second->returnParameterNames(),
-				it.second->returnParameterTypeNames(_contractDef.isLibrary())
-			);
-		else if (ret.back() == ' ')
-			ret.pop_back();
-		ret += ";";
-	}
-
-	return ret + "}";
-}
-
 string InterfaceHandler::userDocumentation(ContractDefinition const& _contractDef)
 {
 	Json::Value doc;
diff --git a/libsolidity/interface/InterfaceHandler.h b/libsolidity/interface/InterfaceHandler.h
index 3e0a1660..54199e4e 100644
--- a/libsolidity/interface/InterfaceHandler.h
+++ b/libsolidity/interface/InterfaceHandler.h
@@ -73,7 +73,6 @@ public:
 	/// @param _contractDef The contract definition
 	/// @return             A string with the json representation of the contract's ABI Interface
 	static std::string abiInterface(ContractDefinition const& _contractDef);
-	static std::string ABISolidityInterface(ContractDefinition const& _contractDef);
 	/// Get the User documentation of the contract
 	/// @param _contractDef The contract definition
 	/// @return             A string with the json representation of the contract's user documentation
diff --git a/libsolidity/interface/Version.cpp b/libsolidity/interface/Version.cpp
index a846efea..31ba4afc 100644
--- a/libsolidity/interface/Version.cpp
+++ b/libsolidity/interface/Version.cpp
@@ -35,10 +35,8 @@ char const* dev::solidity::VersionNumber = ETH_PROJECT_VERSION;
 
 string const dev::solidity::VersionString =
 	string(dev::solidity::VersionNumber) +
-	"-" +
-	string(DEV_QUOTED(ETH_COMMIT_HASH)).substr(0, 8) +
-	(ETH_CLEAN_REPO ? "" : "*") +
-	"/" DEV_QUOTED(ETH_BUILD_TYPE) "-" DEV_QUOTED(ETH_BUILD_PLATFORM);
+	(string(SOL_VERSION_PRERELEASE).empty() ? "" : "-" + string(SOL_VERSION_PRERELEASE)) +
+	(string(SOL_VERSION_BUILDINFO).empty() ? "" : "+" + string(SOL_VERSION_BUILDINFO));
 
 
 bytes dev::solidity::binaryVersion()
diff --git a/libsolidity/parsing/Parser.cpp b/libsolidity/parsing/Parser.cpp
index b8f72238..0e99d1e7 100644
--- a/libsolidity/parsing/Parser.cpp
+++ b/libsolidity/parsing/Parser.cpp
@@ -76,6 +76,9 @@ ASTPointer<SourceUnit> Parser::parse(shared_ptr<Scanner> const& _scanner)
 		{
 			switch (auto token = m_scanner->currentToken())
 			{
+			case Token::Pragma:
+				nodes.push_back(parsePragmaDirective());
+				break;
 			case Token::Import:
 				nodes.push_back(parseImportDirective());
 				break;
@@ -97,6 +100,36 @@ ASTPointer<SourceUnit> Parser::parse(shared_ptr<Scanner> const& _scanner)
 	}
 }
 
+ASTPointer<PragmaDirective> Parser::parsePragmaDirective()
+{
+	// pragma anything* ;
+	// Currently supported:
+	// pragma solidity ^0.4.0 || ^0.3.0;
+	ASTNodeFactory nodeFactory(*this);
+	expectToken(Token::Pragma);
+	vector<string> literals;
+	vector<Token::Value> tokens;
+	do
+	{
+		Token::Value token = m_scanner->currentToken();
+		if (token == Token::Illegal)
+			parserError("Token incompatible with Solidity parser as part of pragma directive.");
+		else
+		{
+			string literal = m_scanner->currentLiteral();
+			if (literal.empty() && Token::toString(token))
+				literal = Token::toString(token);
+			literals.push_back(literal);
+			tokens.push_back(token);
+		}
+		m_scanner->next();
+	}
+	while (m_scanner->currentToken() != Token::Semicolon && m_scanner->currentToken() != Token::EOS);
+	nodeFactory.markEndPosition();
+	expectToken(Token::Semicolon);
+	return nodeFactory.createNode<PragmaDirective>(tokens, literals);
+}
+
 ASTPointer<ImportDirective> Parser::parseImportDirective()
 {
 	// import "abc" [as x];
@@ -272,6 +305,7 @@ ASTPointer<FunctionDefinition> Parser::parseFunctionDefinition(ASTString const*
 	options.allowLocationSpecifier = true;
 	ASTPointer<ParameterList> parameters(parseParameterList(options));
 	bool isDeclaredConst = false;
+	bool isPayable = false;
 	Declaration::Visibility visibility(Declaration::Visibility::Default);
 	vector<ASTPointer<ModifierInvocation>> modifiers;
 	while (true)
@@ -282,6 +316,11 @@ ASTPointer<FunctionDefinition> Parser::parseFunctionDefinition(ASTString const*
 			isDeclaredConst = true;
 			m_scanner->next();
 		}
+		else if (m_scanner->currentToken() == Token::Payable)
+		{
+			isPayable = true;
+			m_scanner->next();
+		}
 		else if (token == Token::Identifier)
 			modifiers.push_back(parseModifierInvocation());
 		else if (Token::isVisibilitySpecifier(token))
@@ -321,6 +360,7 @@ ASTPointer<FunctionDefinition> Parser::parseFunctionDefinition(ASTString const*
 		isDeclaredConst,
 		modifiers,
 		returnParameters,
+		isPayable,
 		block
 	);
 }
@@ -720,7 +760,7 @@ ASTPointer<Statement> Parser::parseStatement()
 		{
 			statement = ASTNodeFactory(*this).createNode<PlaceholderStatement>(docString);
 			m_scanner->next();
-			return statement;
+			break;
 		}
 	// fall-through
 	default:
diff --git a/libsolidity/parsing/Parser.h b/libsolidity/parsing/Parser.h
index d776c3fd..9c30cf60 100644
--- a/libsolidity/parsing/Parser.h
+++ b/libsolidity/parsing/Parser.h
@@ -55,6 +55,7 @@ private:
 
 	///@{
 	///@name Parsing functions for the AST nodes
+	ASTPointer<PragmaDirective> parsePragmaDirective();
 	ASTPointer<ImportDirective> parseImportDirective();
 	ASTPointer<ContractDefinition> parseContractDefinition(bool _isLibrary);
 	ASTPointer<InheritanceSpecifier> parseInheritanceSpecifier();
diff --git a/libsolidity/parsing/ParserBase.cpp b/libsolidity/parsing/ParserBase.cpp
index 71085a4d..2abf58cc 100644
--- a/libsolidity/parsing/ParserBase.cpp
+++ b/libsolidity/parsing/ParserBase.cpp
@@ -47,7 +47,17 @@ void ParserBase::expectToken(Token::Value _value)
 	Token::Value tok = m_scanner->currentToken();
 	if (tok != _value)
 	{
-		if (Token::isElementaryTypeName(tok)) //for the sake of accuracy in reporting
+		if (Token::isReservedKeyword(tok))
+		{
+			fatalParserError(
+				string("Expected token ") +
+				string(Token::name(_value)) +
+				string(" got reserved keyword '") +
+				string(Token::name(tok)) +
+				string("'")
+			);
+		}
+		else if (Token::isElementaryTypeName(tok)) //for the sake of accuracy in reporting
 		{
 			ElementaryTypeNameToken elemTypeName = m_scanner->currentElementaryTypeNameToken();
 			fatalParserError(
diff --git a/libsolidity/parsing/Scanner.cpp b/libsolidity/parsing/Scanner.cpp
index d730210a..603f3e42 100644
--- a/libsolidity/parsing/Scanner.cpp
+++ b/libsolidity/parsing/Scanner.cpp
@@ -591,7 +591,23 @@ void Scanner::scanToken()
 			break;
 		default:
 			if (isIdentifierStart(m_char))
+			{
 				tie(token, m, n) = scanIdentifierOrKeyword();
+
+				// Special case for hexademical literals
+				if (token == Token::Hex)
+				{
+					// reset
+					m = 0;
+					n = 0;
+
+					// Special quoted hex string must follow
+					if (m_char == '"' || m_char == '\'')
+						token = scanHexString();
+					else
+						token = Token::Illegal;
+				}
+			}
 			else if (isDecimalDigit(m_char))
 				token = scanNumber();
 			else if (skipWhitespace())
@@ -684,6 +700,25 @@ Token::Value Scanner::scanString()
 	return Token::StringLiteral;
 }
 
+Token::Value Scanner::scanHexString()
+{
+	char const quote = m_char;
+	advance();  // consume quote
+	LiteralScope literal(this, LITERAL_TYPE_STRING);
+	while (m_char != quote && !isSourcePastEndOfInput() && !isLineTerminator(m_char))
+	{
+		char c = m_char;
+		if (!scanHexByte(c))
+			return Token::Illegal;
+		addLiteralChar(c);
+	}
+	if (m_char != quote)
+		return Token::Illegal;
+	literal.complete();
+	advance();  // consume quote
+	return Token::StringLiteral;
+}
+
 void Scanner::scanDecimalDigits()
 {
 	while (isDecimalDigit(m_char))
diff --git a/libsolidity/parsing/Scanner.h b/libsolidity/parsing/Scanner.h
index 708adf8f..36cba112 100644
--- a/libsolidity/parsing/Scanner.h
+++ b/libsolidity/parsing/Scanner.h
@@ -203,6 +203,7 @@ private:
 	std::tuple<Token::Value, unsigned, unsigned> scanIdentifierOrKeyword();
 
 	Token::Value scanString();
+	Token::Value scanHexString();
 	Token::Value scanSingleLineDocComment();
 	Token::Value scanMultiLineDocComment();
 	/// Scans a slash '/' and depending on the characters returns the appropriate token
diff --git a/libsolidity/parsing/Token.h b/libsolidity/parsing/Token.h
index 581df3a5..5dd42992 100644
--- a/libsolidity/parsing/Token.h
+++ b/libsolidity/parsing/Token.h
@@ -141,6 +141,7 @@ namespace solidity
 	\
 	/* Keywords */                                                     \
 	K(Anonymous, "anonymous", 0)                                       \
+	K(As, "as", 0)                                                     \
 	K(Assembly, "assembly", 0)                                         \
 	K(Break, "break", 0)                                               \
 	K(Const, "constant", 0)                                            \
@@ -154,6 +155,7 @@ namespace solidity
 	K(External, "external", 0)                                         \
 	K(For, "for", 0)                                                   \
 	K(Function, "function", 0)                                         \
+	K(Hex, "hex", 0)                                                   \
 	K(If, "if", 0)                                                     \
 	K(Indexed, "indexed", 0)                                           \
 	K(Internal, "internal", 0)                                         \
@@ -164,13 +166,16 @@ namespace solidity
 	K(Memory, "memory", 0)                                             \
 	K(Modifier, "modifier", 0)                                         \
 	K(New, "new", 0)                                                   \
+	K(Payable, "payable", 0)                                           \
 	K(Public, "public", 0)                                             \
+	K(Pragma, "pragma", 0)                                             \
 	K(Private, "private", 0)                                           \
 	K(Return, "return", 0)                                             \
 	K(Returns, "returns", 0)                                           \
 	K(Storage, "storage", 0)                                           \
 	K(Struct, "struct", 0)                                             \
 	K(Throw, "throw", 0)                                               \
+	K(Using, "using", 0)                                               \
 	K(Var, "var", 0)                                                   \
 	K(While, "while", 0)                                               \
 	\
@@ -185,7 +190,6 @@ namespace solidity
 	K(SubDay, "days", 0)                                               \
 	K(SubWeek, "weeks", 0)                                             \
 	K(SubYear, "years", 0)                                             \
-	K(After, "after", 0)                                               \
 	/* type keywords*/                                                 \
 	K(Int, "int", 0)                                                   \
 	K(UInt, "uint", 0)                                                 \
@@ -215,21 +219,25 @@ namespace solidity
 	T(Identifier, NULL, 0)                                             \
 	\
 	/* Keywords reserved for future use. */                            \
-	K(As, "as", 0)                                                     \
+	K(Abstract, "abstract", 0)                                         \
+	K(After, "after", 0)                                               \
 	K(Case, "case", 0)                                                 \
 	K(Catch, "catch", 0)                                               \
 	K(Final, "final", 0)                                               \
 	K(In, "in", 0)                                                     \
 	K(Inline, "inline", 0)                                             \
+	K(Interface, "interface", 0)                                       \
 	K(Let, "let", 0)                                                   \
 	K(Match, "match", 0)                                               \
 	K(Of, "of", 0)                                                     \
+	K(Pure, "pure", 0)                                                 \
 	K(Relocatable, "relocatable", 0)                                   \
+	K(Static, "static", 0)                                             \
 	K(Switch, "switch", 0)                                             \
 	K(Try, "try", 0)                                                   \
 	K(Type, "type", 0)                                                 \
 	K(TypeOf, "typeof", 0)                                             \
-	K(Using, "using", 0)                                               \
+	K(View, "view", 0)                                                 \
 	/* Illegal token - not able to scan. */                            \
 	T(Illegal, "ILLEGAL", 0)                                           \
 	\
@@ -277,7 +285,7 @@ public:
 
 	static bool isBitOp(Value op) { return (BitOr <= op && op <= BitAnd) || op == BitNot; }
 	static bool isBooleanOp(Value op) { return (Or <= op && op <= And) || op == Not; }
-	static bool isUnaryOp(Value op) { return (Not <= op && op <= Delete) || op == Add || op == Sub || op == After; }
+	static bool isUnaryOp(Value op) { return (Not <= op && op <= Delete) || op == Add || op == Sub; }
 	static bool isCountOp(Value op) { return op == Inc || op == Dec; }
 	static bool isShiftOp(Value op) { return (SHL <= op) && (op <= SHR); }
 	static bool isVisibilitySpecifier(Value op) { return isVariableVisibilitySpecifier(op) || op == External; }
@@ -285,6 +293,7 @@ public:
 	static bool isLocationSpecifier(Value op) { return op == Memory || op == Storage; }
 	static bool isEtherSubdenomination(Value op) { return op == SubWei || op == SubSzabo || op == SubFinney || op == SubEther; }
 	static bool isTimeSubdenomination(Value op) { return op == SubSecond || op == SubMinute || op == SubHour || op == SubDay || op == SubWeek || op == SubYear; }
+	static bool isReservedKeyword(Value op) { return (Abstract <= op && op <= TypeOf); }
 
 	// @returns a string corresponding to the JS token string
 	// (.e., "<" for the token LT) or NULL if the token doesn't
diff --git a/lllc/main.cpp b/lllc/main.cpp
index a4c92d67..06611af0 100644
--- a/lllc/main.cpp
+++ b/lllc/main.cpp
@@ -22,6 +22,7 @@
 
 #include <fstream>
 #include <iostream>
+#include <clocale>
 #include <liblll/Compiler.h>
 #include <libdevcore/CommonIO.h>
 #include <libdevcore/CommonData.h>
@@ -52,10 +53,34 @@ void version()
 	exit(0);
 }
 
+/*
+The equivalent of setlocale(LC_ALL, "C") is called before any user code is run.
+If the user has an invalid environment setting then it is possible for the call
+to set locale to fail, so there are only two possible actions, the first is to
+throw a runtime exception and cause the program to quit (default behaviour),
+or the second is to modify the environment to something sensible (least
+surprising behaviour).
+
+The follow code produces the least surprising behaviour. It will use the user
+specified default locale if it is valid, and if not then it will modify the
+environment the process is running in to use a sensible default. This also means
+that users do not need to install language packs for their OS.
+*/
+void setDefaultOrCLocale()
+{
+#if __unix__
+	if (!std::setlocale(LC_ALL, ""))
+	{
+		setenv("LC_ALL", "C", 1);
+	}
+#endif
+}
+
 enum Mode { Binary, Hex, Assembly, ParseTree, Disassemble };
 
 int main(int argc, char** argv)
 {
+	setDefaultOrCLocale();
 	unsigned optimise = 1;
 	string infile;
 	Mode mode = Hex;
diff --git a/scripts/build_emscripten.sh b/scripts/build_emscripten.sh
index 6046978e..da2c7df3 100755
--- a/scripts/build_emscripten.sh
+++ b/scripts/build_emscripten.sh
@@ -29,6 +29,7 @@
 set -e
 
 if [[ "$OSTYPE" != "darwin"* ]]; then
+    date -u +"nightly.%Y.%m.%d" > prerelease.txt
     ./scripts/travis-emscripten/install_deps.sh
     docker run -v $(pwd):/src trzeci/emscripten:sdk-tag-1.35.4-64bit ./scripts/travis-emscripten/build_emscripten.sh
 fi
diff --git a/scripts/install_deps.bat b/scripts/install_deps.bat
index 512a28df..bd68b07a 100644
--- a/scripts/install_deps.bat
+++ b/scripts/install_deps.bat
@@ -59,3 +59,4 @@ REM Copyright (c) 2016 solidity contributors.
 REM ---------------------------------------------------------------------------
 
 cmake -P deps\install_deps.cmake
+cmake -P scripts\install_eth.cmake
diff --git a/scripts/install_deps.sh b/scripts/install_deps.sh
index bbf28d95..7c8523a8 100755
--- a/scripts/install_deps.sh
+++ b/scripts/install_deps.sh
@@ -1,7 +1,7 @@
-#!/usr/bin/env bash
+#!/usr/bin/env sh
 
 #------------------------------------------------------------------------------
-# Bash script for installing pre-requisite packages for solidity on a
+# Shell script for installing pre-requisite packages for solidity on a
 # variety of Linux and other UNIX-derived platforms.
 #
 # This is an "infrastucture-as-code" alternative to the manual build
@@ -12,17 +12,9 @@
 # flow for all supported operating systems:
 #
 # - git clone --recursive
-# - ./install_deps.sh
+# - ./scripts/install_deps.sh
 # - cmake && make
 #
-# At the time of writing we are assuming that 'lsb_release' is present for all
-# Linux distros, which is not a valid assumption.  We will need a variety of
-# approaches to actually get this working across all the distros which people
-# are using.
-#
-# See http://unix.stackexchange.com/questions/92199/how-can-i-reliably-get-the-operating-systems-name
-# for some more background on this common problem.
-#
 # TODO - There is no support here yet for cross-builds in any form, only
 # native builds.  Expanding the functionality here to cover the mobile,
 # wearable and SBC platforms covered by doublethink and EthEmbedded would
@@ -52,9 +44,24 @@
 # (c) 2016 solidity contributors.
 #------------------------------------------------------------------------------
 
+set -e
+
 # Check for 'uname' and abort if it is not available.
 uname -v > /dev/null 2>&1 || { echo >&2 "ERROR - solidity requires 'uname' to identify the platform."; exit 1; }
 
+# See http://unix.stackexchange.com/questions/92199/how-can-i-reliably-get-the-operating-systems-name
+detect_linux_distro() {
+    if [ $(command -v lsb_release) ]; then
+        DISTRO=$(lsb_release -is)
+    elif [ -f /etc/os-release ]; then
+        # extract 'foo' from NAME=foo, only on the line with NAME=foo
+        DISTRO=$(sed -n -e 's/^NAME="\(.*\)\"/\1/p' /etc/os-release)
+    else
+        DISTRO=''
+    fi
+    echo $DISTRO
+}
+
 case $(uname -s) in
 
 #------------------------------------------------------------------------------
@@ -93,7 +100,7 @@ case $(uname -s) in
 
         brew update
         brew upgrade
-        
+
         brew install boost
         brew install cmake
         brew install jsoncpp
@@ -122,14 +129,14 @@ case $(uname -s) in
 #------------------------------------------------------------------------------
 # Linux
 #------------------------------------------------------------------------------
-        
+
     Linux)
-        case $(lsb_release -is) in
+        case $(detect_linux_distro) in
 
 #------------------------------------------------------------------------------
 # Arch Linux
 #------------------------------------------------------------------------------
-        
+
             Arch)
                 #Arch
                 echo "Installing solidity dependencies on Arch Linux."
@@ -138,7 +145,7 @@ case $(uname -s) in
                 # See https://wiki.archlinux.org/index.php/Official_repositories
                 sudo pacman -Sy \
                     base-devel \
-                    boost \ 
+                    boost \
                     cmake \
                     git \
                 ;;
@@ -147,15 +154,14 @@ case $(uname -s) in
 # Alpine Linux
 #------------------------------------------------------------------------------
 
-            Alpine)
+            "Alpine Linux")
                 #Alpine
                 echo "Installing solidity dependencies on Alpine Linux."
 
                 # All our dependencies can be found in the Alpine Linux official repositories.
                 # See https://pkgs.alpinelinux.org/
-                
+
                 apk update
-                apk upgrade
                 apk add boost-dev build-base cmake jsoncpp-dev
 
                 ;;
@@ -227,7 +233,7 @@ case $(uname -s) in
                 # Install "normal packages"
                 # See https://fedoraproject.org/wiki/Package_management_system.
                 dnf install \
-                    autoconf \ 
+                    autoconf \
                     automake \
                     boost-devel \
                     cmake \
@@ -322,16 +328,6 @@ case $(uname -s) in
                 sudo apt-get -y update
                 sudo apt-get -y install eth
 
-                # And install the English language package and reconfigure the locales.
-                # We really shouldn't need to do this, and should instead force our locales to "C"
-                # within our application runtimes, because this issue shows up on multiple Linux distros,
-                # and each will need fixing in the install steps, where we should really just fix it once
-                # in the code.
-                #
-                # See https://github.com/ethereum/webthree-umbrella/issues/169
-                sudo apt-get -y install language-pack-en-base
-                sudo dpkg-reconfigure locales
-
                 ;;
             *)
 
diff --git a/scripts/install_eth.cmake b/scripts/install_eth.cmake
new file mode 100644
index 00000000..25f449e0
--- /dev/null
+++ b/scripts/install_eth.cmake
@@ -0,0 +1,76 @@
+#------------------------------------------------------------------------------
+# Cmake script for installing pre-requisite package eth for solidity.
+#
+# The aim of this script is to simply download and unpack eth binaries to the deps folder.
+#
+# The documentation for solidity is hosted at:
+#
+# http://solidity.readthedocs.io/
+#
+# ------------------------------------------------------------------------------
+# This file is part of solidity.
+#
+# solidity is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# solidity is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with solidity.  If not, see <http://www.gnu.org/licenses/>
+#
+# (c) 2016 solidity contributors.
+#------------------------------------------------------------------------------
+
+function(download URL DST_FILE STATUS)
+    set(TMP_FILE "${DST_FILE}.part")
+
+    get_filename_component(FILE_NAME ${DST_FILE} NAME)
+    if (NOT EXISTS ${DST_FILE})
+        message("Downloading ${FILE_NAME}")
+        file(DOWNLOAD ${URL} ${TMP_FILE} SHOW_PROGRESS STATUS DOWNLOAD_STATUS)
+        list(GET DOWNLOAD_STATUS 0 STATUS_CODE)
+        if (STATUS_CODE EQUAL 0)
+            file(RENAME ${TMP_FILE} ${DST_FILE})
+        else()
+            file(REMOVE ${TMP_FILE})
+            list(GET DOWNLOAD_STATUS 1 ERROR_MSG)
+
+            message("ERROR! Downloading '${FILE_NAME}' failed.")
+            message(STATUS "URL:   ${URL}")
+            message(STATUS "Error: ${STATUS_CODE} ${ERROR_MSG}")
+            set(STATUS FALSE PARENT_SCOPE)
+            return()
+        endif()
+    else()
+        message("Using cached ${FILE_NAME}")
+    endif()
+    set(STATUS TRUE PARENT_SCOPE)
+endfunction(download)
+
+function(download_and_unpack PACKAGE_URL DST_DIR)
+    get_filename_component(FILE_NAME ${PACKAGE_URL} NAME)
+
+    set(DST_FILE "${CACHE_DIR}/${FILE_NAME}")
+    set(TMP_FILE "${DST_FILE}.part")
+
+    file(MAKE_DIRECTORY ${CACHE_DIR})
+    file(MAKE_DIRECTORY ${DST_DIR})
+
+    download(${PACKAGE_URL} ${DST_FILE} STATUS)
+
+    if (STATUS)
+        message("Unpacking ${FILE_NAME} to ${DST_DIR}")
+        execute_process(COMMAND ${CMAKE_COMMAND} -E tar -xf ${DST_FILE}
+                        WORKING_DIRECTORY ${DST_DIR})
+    endif()
+endfunction(download_and_unpack)
+
+get_filename_component(ROOT_DIR "${CMAKE_CURRENT_LIST_DIR}/.." ABSOLUTE)
+set(CACHE_DIR "${ROOT_DIR}/deps/cache")
+set(INSTALL_DIR "${ROOT_DIR}/deps/install/x64/eth")
+download_and_unpack("https://github.com/bobsummerwill/cpp-ethereum/releases/download/develop-v1.3.0.401/cpp-ethereum-develop-windows.zip" ${INSTALL_DIR})
diff --git a/scripts/release.bat b/scripts/release.bat
index 6f0ef6b0..54d85862 100644
--- a/scripts/release.bat
+++ b/scripts/release.bat
@@ -28,7 +28,6 @@ REM ---------------------------------------------------------------------------
 
 set CONFIGURATION=%1
 
-REM TODO - Add soltest\%CONFIGURATION%\soltest.exe, when that is buildable.
-7z a solidity-develop-windows.zip ^
-    .\build\solc\%CONFIGURATION%\solc.exe ^
+7z a solidity-windows.zip ^
+    .\build\solc\%CONFIGURATION%\solc.exe .\build\test\%CONFIGURATION%\soltest.exe ^
     "C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\redist\x86\Microsoft.VC140.CRT\msvc*.dll"
diff --git a/scripts/release.sh b/scripts/release.sh
index 275e53bb..e9f43f6c 100755
--- a/scripts/release.sh
+++ b/scripts/release.sh
@@ -89,4 +89,4 @@ fi
 
 # And ZIP it all up, with a filename suffix passed in on the command-line.
 
-zip -j $REPO_ROOT/solidity-develop-$ZIP_SUFFIX.zip $ZIP_TEMP_DIR/*
+zip -j $REPO_ROOT/solidity-$ZIP_SUFFIX.zip $ZIP_TEMP_DIR/*
diff --git a/scripts/release_ppa.sh b/scripts/release_ppa.sh
index 2fd286fd..8e9dc282 100755
--- a/scripts/release_ppa.sh
+++ b/scripts/release_ppa.sh
@@ -56,13 +56,13 @@ commithash=`git rev-parse --short HEAD`
 committimestamp=`git show --format=%ci HEAD | head -n 1`
 commitdate=`git show --format=%ci HEAD | head -n 1 | cut - -b1-10`
 
-# TODO store the commit hash in a file so that the build info mechanism can pick it up even without git
-
+echo "$commithash" > commit_hash.txt
 if [ $branch = develop ]
 then
     debversion="$version-nightly-$commitdate-$commithash"
 else
     debversion="$version"
+    echo -n > prerelease.txt # proper release
 fi
 
 # gzip will create different tars all the time and we are not allowed
diff --git a/scripts/tests.sh b/scripts/tests.sh
index 5c482d3d..93afd2d2 100755
--- a/scripts/tests.sh
+++ b/scripts/tests.sh
@@ -53,7 +53,7 @@ $ETH_PATH --test -d /tmp/test &
 while [ ! -S /tmp/test/geth.ipc ]; do sleep 2; done
 
 # And then run the Solidity unit-tests, pointing to that IPC endpoint.
-"$REPO_ROOT"/build/test/soltest --ipc /tmp/test/geth.ipc
+"$REPO_ROOT"/build/test/soltest -- --ipcpath /tmp/test/geth.ipc
 ERROR_CODE=$?
 pkill eth || true
 sleep 4
diff --git a/scripts/travis-emscripten/publish_binary.sh b/scripts/travis-emscripten/publish_binary.sh
index a62d4b47..d202764a 100755
--- a/scripts/travis-emscripten/publish_binary.sh
+++ b/scripts/travis-emscripten/publish_binary.sh
@@ -52,19 +52,20 @@ git config user.email "chris@ethereum.org"
 git checkout -B gh-pages origin/gh-pages
 git clean -f -d -x
 # We only want one release per day and we do not want to push the same commit twice.
-if ls ./bin/soljson-"$VER-$DATE"-*.js ./bin/soljson-*-"$COMMIT.js" > /dev/null
+if ls ./bin/soljson-"$VER-$DATE"-*.js || ls ./bin/soljson-*-"$COMMIT.js"
 then
-  true
-else
-  # This file is assumed to be the product of the build_emscripten.sh script.
-  cp ../soljson.js ./bin/"soljson-$VER-$DATE-$COMMIT.js"
-  ./update-index.sh
-  cd bin
-  LATEST=$(ls -r soljson-v* | head -n 1)
-  cp "$LATEST" soljson-latest.js
-  cp soljson-latest.js ../soljson.js
-  git add .
-  git add ../soljson.js
-  git commit -m "Added compiler version $LATEST"
-  git push origin gh-pages
+  echo "Not publishing, we already published this version today."
+  exit 0
 fi
+
+# This file is assumed to be the product of the build_emscripten.sh script.
+cp ../soljson.js ./bin/"soljson-$VER-$DATE-$COMMIT.js"
+node ./update
+cd bin
+LATEST=$(ls -r soljson-v* | head -n 1)
+cp "$LATEST" soljson-latest.js
+cp soljson-latest.js ../soljson.js
+git add .
+git add ../soljson.js
+git commit -m "Added compiler version $LATEST"
+git push origin gh-pages
diff --git a/solc/CommandLineInterface.cpp b/solc/CommandLineInterface.cpp
index ec87b891..f0a34632 100644
--- a/solc/CommandLineInterface.cpp
+++ b/solc/CommandLineInterface.cpp
@@ -65,7 +65,6 @@ namespace solidity
 {
 
 static string const g_argAbiStr = "abi";
-static string const g_argSolInterfaceStr = "interface";
 static string const g_argSignatureHashes = "hashes";
 static string const g_argGas = "gas";
 static string const g_argAsmStr = "asm";
@@ -116,7 +115,6 @@ static bool needsHumanTargetedStdout(po::variables_map const& _args)
 		return false;
 	for (string const& arg: {
 		g_argAbiStr,
-		g_argSolInterfaceStr,
 		g_argSignatureHashes,
 		g_argNatspecUserStr,
 		g_argAstJson,
@@ -215,11 +213,6 @@ void CommandLineInterface::handleMeta(DocumentationType _type, string const& _co
 		suffix = ".abi";
 		title = "Contract JSON ABI";
 		break;
-	case DocumentationType::ABISolidityInterface:
-		argName = g_argSolInterfaceStr;
-		suffix = "_interface.sol";
-		title = "Contract Solidity ABI";
-		break;
 	case DocumentationType::NatspecUser:
 		argName = g_argNatspecUserStr;
 		suffix = ".docuser";
@@ -310,21 +303,18 @@ void CommandLineInterface::handleFormal()
 
 void CommandLineInterface::readInputFilesAndConfigureRemappings()
 {
+	vector<string> inputFiles;
+	bool addStdin = false;
 	if (!m_args.count("input-file"))
-	{
-		string s;
-		while (!cin.eof())
-		{
-			getline(cin, s);
-			m_sourceCodes[g_stdinFileName].append(s + '\n');
-		}
-	}
+		addStdin = true;
 	else
 		for (string path: m_args["input-file"].as<vector<string>>())
 		{
 			auto eq = find(path.begin(), path.end(), '=');
 			if (eq != path.end())
 				path = string(eq + 1, path.end());
+			else if (path == "-")
+				addStdin = true;
 			else
 			{
 				auto infile = boost::filesystem::path(path);
@@ -345,6 +335,15 @@ void CommandLineInterface::readInputFilesAndConfigureRemappings()
 			}
 			m_allowedDirectories.push_back(boost::filesystem::path(path).remove_filename());
 		}
+	if (addStdin)
+	{
+		string s;
+		while (!cin.eof())
+		{
+			getline(cin, s);
+			m_sourceCodes[g_stdinFileName].append(s + '\n');
+		}
+	}
 }
 
 bool CommandLineInterface::parseLibraryOption(string const& _input)
@@ -399,9 +398,9 @@ bool CommandLineInterface::parseArguments(int _argc, char** _argv)
 	po::options_description desc(
 		R"(solc, the Solidity commandline compiler.
 Usage: solc [options] [input_file...]
-Compiles the given Solidity input files (or the standard input if none given) and
-outputs the components specified in the options at standard output or in files in
-the output directory, if specified.
+Compiles the given Solidity input files (or the standard input if none given or
+"-" is used as a file name) and outputs the components specified in the options
+at standard output or in files in the output directory, if specified.
 Example: solc --bin -o /tmp/solcoutput contract.sol
 
 Allowed options)",
@@ -455,7 +454,6 @@ Allowed options)",
 		(g_argRuntimeBinaryStr.c_str(), "Binary of the runtime part of the contracts in hex.")
 		(g_argCloneBinaryStr.c_str(), "Binary of the clone contracts in hex.")
 		(g_argAbiStr.c_str(), "ABI specification of the contracts.")
-		(g_argSolInterfaceStr.c_str(), "Solidity interface of the contracts.")
 		(g_argSignatureHashes.c_str(), "Function signature hashes of the contracts.")
 		(g_argNatspecUserStr.c_str(), "Natspec user documentation of all contracts.")
 		(g_argNatspecDevStr.c_str(), "Natspec developer documentation of all contracts.")
@@ -562,7 +560,7 @@ bool CommandLineInterface::processInput()
 		}
 	};
 
-	m_compiler.reset(new CompilerStack(m_args.count(g_argAddStandard) > 0, fileReader));
+	m_compiler.reset(new CompilerStack(fileReader));
 	auto scannerFromSourceName = [&](string const& _sourceName) -> solidity::Scanner const& { return m_compiler->scanner(_sourceName); };
 	try
 	{
@@ -643,8 +641,6 @@ void CommandLineInterface::handleCombinedJSON()
 	for (string const& contractName: contracts)
 	{
 		Json::Value contractData(Json::objectValue);
-		if (requests.count("interface"))
-			contractData["interface"] = m_compiler->solidityInterface(contractName);
 		if (requests.count("abi"))
 			contractData["abi"] = m_compiler->interface(contractName);
 		if (requests.count("bin"))
@@ -782,37 +778,43 @@ void CommandLineInterface::actOnInput()
 
 bool CommandLineInterface::link()
 {
+	// Map from how the libraries will be named inside the bytecode to their addresses.
+	map<string, h160> librariesReplacements;
+	int const placeholderSize = 40; // 20 bytes or 40 hex characters
+	for (auto const& library: m_libraries)
+	{
+		string const& name = library.first;
+		// Library placeholders are 40 hex digits (20 bytes) that start and end with '__'.
+		// This leaves 36 characters for the library name, while too short library names are
+		// padded on the right with '_' and too long names are truncated.
+		string replacement = "__";
+		for (size_t i = 0; i < placeholderSize - 4; ++i)
+			replacement.push_back(i < name.size() ? name[i] : '_');
+		replacement += "__";
+		librariesReplacements[replacement] = library.second;
+	}
 	for (auto& src: m_sourceCodes)
 	{
 		auto end = src.second.end();
 		for (auto it = src.second.begin(); it != end;)
 		{
 			while (it != end && *it != '_') ++it;
-			auto insertStart = it;
-			while (it != end && *it == '_') ++it;
-			auto nameStart = it;
-			while (it != end && *it != '_') ++it;
-			auto nameEnd = it;
-			while (it != end && *it == '_') ++it;
-			auto insertEnd = it;
-
-			if (insertStart == end)
-				break;
-
-			if (insertEnd - insertStart != 40)
+			if (it == end) break;
+			if (end - it < placeholderSize)
 			{
-				cerr << "Error in binary object file " << src.first << " at position " << (insertStart - src.second.begin()) << endl;
+				cerr << "Error in binary object file " << src.first << " at position " << (end - src.second.begin()) << endl;
 				return false;
 			}
 
-			string name(nameStart, nameEnd);
-			if (m_libraries.count(name))
+			string name(it, it + placeholderSize);
+			if (librariesReplacements.count(name))
 			{
-				string hexStr(toHex(m_libraries.at(name).asBytes()));
-				copy(hexStr.begin(), hexStr.end(), insertStart);
+				string hexStr(toHex(librariesReplacements.at(name).asBytes()));
+				copy(hexStr.begin(), hexStr.end(), it);
 			}
 			else
 				cerr << "Reference \"" << name << "\" in file \"" << src.first << "\" still unresolved." << endl;
+			it += placeholderSize;
 		}
 	}
 	return true;
@@ -901,7 +903,6 @@ void CommandLineInterface::outputCompilationResults()
 		handleBytecode(contract);
 		handleSignatureHashes(contract);
 		handleMeta(DocumentationType::ABIInterface, contract);
-		handleMeta(DocumentationType::ABISolidityInterface, contract);
 		handleMeta(DocumentationType::NatspecDev, contract);
 		handleMeta(DocumentationType::NatspecUser, contract);
 	} // end of contracts iteration
diff --git a/solc/jsonCompiler.cpp b/solc/jsonCompiler.cpp
index 20112103..ef69105e 100644
--- a/solc/jsonCompiler.cpp
+++ b/solc/jsonCompiler.cpp
@@ -159,7 +159,7 @@ string compile(StringMap const& _sources, bool _optimize, CStyleReadFileCallback
 			return result;
 		};
 	}
-	CompilerStack compiler(true, readCallback);
+	CompilerStack compiler(readCallback);
 	auto scannerFromSourceName = [&](string const& _sourceName) -> solidity::Scanner const& { return compiler.scanner(_sourceName); };
 	bool success = false;
 	try
@@ -203,52 +203,79 @@ string compile(StringMap const& _sources, bool _optimize, CStyleReadFileCallback
 
 	if (success)
 	{
-		output["contracts"] = Json::Value(Json::objectValue);
-		for (string const& contractName: compiler.contractNames())
+		try
 		{
-			Json::Value contractData(Json::objectValue);
-			contractData["solidity_interface"] = compiler.solidityInterface(contractName);
-			contractData["interface"] = compiler.interface(contractName);
-			contractData["bytecode"] = compiler.object(contractName).toHex();
-			contractData["runtimeBytecode"] = compiler.runtimeObject(contractName).toHex();
-			contractData["opcodes"] = solidity::disassemble(compiler.object(contractName).bytecode);
-			contractData["functionHashes"] = functionHashes(compiler.contractDefinition(contractName));
-			contractData["gasEstimates"] = estimateGas(compiler, contractName);
-			auto sourceMap = compiler.sourceMapping(contractName);
-			contractData["srcmap"] = sourceMap ? *sourceMap : "";
-			auto runtimeSourceMap = compiler.runtimeSourceMapping(contractName);
-			contractData["srcmap-runtime"] = runtimeSourceMap ? *runtimeSourceMap : "";
-			ostringstream unused;
-			contractData["assembly"] = compiler.streamAssembly(unused, contractName, _sources, true);
-			output["contracts"][contractName] = contractData;
+			output["contracts"] = Json::Value(Json::objectValue);
+			for (string const& contractName: compiler.contractNames())
+			{
+				Json::Value contractData(Json::objectValue);
+				contractData["interface"] = compiler.interface(contractName);
+				contractData["bytecode"] = compiler.object(contractName).toHex();
+				contractData["runtimeBytecode"] = compiler.runtimeObject(contractName).toHex();
+				contractData["opcodes"] = solidity::disassemble(compiler.object(contractName).bytecode);
+				contractData["functionHashes"] = functionHashes(compiler.contractDefinition(contractName));
+				contractData["gasEstimates"] = estimateGas(compiler, contractName);
+				auto sourceMap = compiler.sourceMapping(contractName);
+				contractData["srcmap"] = sourceMap ? *sourceMap : "";
+				auto runtimeSourceMap = compiler.runtimeSourceMapping(contractName);
+				contractData["srcmapRuntime"] = runtimeSourceMap ? *runtimeSourceMap : "";
+				ostringstream unused;
+				contractData["assembly"] = compiler.streamAssembly(unused, contractName, _sources, true);
+				output["contracts"][contractName] = contractData;
+			}
+		}
+		catch (...)
+		{
+			output["errors"].append("Unknown exception while generating contract data output.");
 		}
 
-		// Do not taint the internal error list
-		ErrorList formalErrors;
-		if (compiler.prepareFormalAnalysis(&formalErrors))
-			output["formal"]["why3"] = compiler.formalTranslation();
-		if (!formalErrors.empty())
+		try
+		{
+			// Do not taint the internal error list
+			ErrorList formalErrors;
+			if (compiler.prepareFormalAnalysis(&formalErrors))
+				output["formal"]["why3"] = compiler.formalTranslation();
+			if (!formalErrors.empty())
+			{
+				Json::Value errors(Json::arrayValue);
+				for (auto const& error: formalErrors)
+					errors.append(formatError(
+						*error,
+						(error->type() == Error::Type::Warning) ? "Warning" : "Error",
+						scannerFromSourceName
+					));
+				output["formal"]["errors"] = errors;
+			}
+		}
+		catch (...)
 		{
-			Json::Value errors(Json::arrayValue);
-			for (auto const& error: formalErrors)
-				errors.append(formatError(
-					*error,
-					(error->type() == Error::Type::Warning) ? "Warning" : "Error",
-					scannerFromSourceName
-				));
-			output["formal"]["errors"] = errors;
+			output["errors"].append("Unknown exception while generating formal method output.");
 		}
 
-		// Indices into this array are used to abbreviate source names in source locations.
-		output["sourceList"] = Json::Value(Json::arrayValue);
-		for (auto const& source: compiler.sourceNames())
-			output["sourceList"].append(source);
-		output["sources"] = Json::Value(Json::objectValue);
-		for (auto const& source: compiler.sourceNames())
-			output["sources"][source]["AST"] = ASTJsonConverter(compiler.ast(source), compiler.sourceIndices()).json();
+		try
+		{
+			// Indices into this array are used to abbreviate source names in source locations.
+			output["sourceList"] = Json::Value(Json::arrayValue);
+			for (auto const& source: compiler.sourceNames())
+				output["sourceList"].append(source);
+			output["sources"] = Json::Value(Json::objectValue);
+			for (auto const& source: compiler.sourceNames())
+				output["sources"][source]["AST"] = ASTJsonConverter(compiler.ast(source), compiler.sourceIndices()).json();
+		}
+		catch (...)
+		{
+			output["errors"].append("Unknown exception while generating source name output.");
+		}
 	}
 
-	return Json::FastWriter().write(output);
+	try
+	{
+		return Json::FastWriter().write(output);
+	}
+	catch (...)
+	{
+		return "{\"errors\":[\"Unknown error while generating JSON.\"]}";
+	}
 }
 
 string compileMulti(string const& _input, bool _optimize, CStyleReadFileCallback _readCallback = nullptr)
diff --git a/solc/main.cpp b/solc/main.cpp
index eaada1c4..26010716 100644
--- a/solc/main.cpp
+++ b/solc/main.cpp
@@ -21,13 +21,38 @@
  */
 
 #include "CommandLineInterface.h"
+#include <clocale>
 #include <iostream>
 #include <boost/exception/all.hpp>
 
 using namespace std;
 
+/*
+The equivalent of setlocale(LC_ALL, "C") is called before any user code is run.
+If the user has an invalid environment setting then it is possible for the call
+to set locale to fail, so there are only two possible actions, the first is to
+throw a runtime exception and cause the program to quit (default behaviour),
+or the second is to modify the environment to something sensible (least
+surprising behaviour).
+
+The follow code produces the least surprising behaviour. It will use the user
+specified default locale if it is valid, and if not then it will modify the
+environment the process is running in to use a sensible default. This also means
+that users do not need to install language packs for their OS.
+*/
+void setDefaultOrCLocale()
+{
+#if __unix__
+	if (!std::setlocale(LC_ALL, ""))
+	{
+		setenv("LC_ALL", "C", 1);
+	}
+#endif
+}
+
 int main(int argc, char** argv)
 {
+	setDefaultOrCLocale();
 	dev::solidity::CommandLineInterface cli;
 	if (!cli.parseArguments(argc, argv))
 		return 1;
diff --git a/std/StandardToken.sol b/std/StandardToken.sol
new file mode 100644
index 00000000..41f2d709
--- /dev/null
+++ b/std/StandardToken.sol
@@ -0,0 +1,41 @@
+import "./Token.sol";
+
+contract StandardToken is Token {
+	uint256 public totalSupply;
+	mapping (address => uint256) public balanceOf;
+	mapping (address =>
+		mapping (address => uint256)) public allowance;
+
+	function StandardToken(address _initialOwner, uint256 _supply) {
+		totalSupply = _supply;
+		balanceOf[_initialOwner] = _supply;
+	}
+
+	function transfer(address _to, uint256 _value) returns (bool success) {
+		if (balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]) {
+			balanceOf[msg.sender] -= _value;
+			balanceOf[_to] += _value;
+			Transfer(msg.sender, _to, _value);
+			return true;
+		} else {
+			return false;
+		}
+	}
+
+	function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
+		if (allowance[_from][msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]) {
+			allowance[_from][msg.sender] -= _value;
+			balanceOf[_to] += _value;
+			Transfer(_from, _to, _value);
+			return true;
+		} else {
+			return false;
+		}
+	}
+
+	function approve(address _spender, uint256 _value) returns (bool success) {
+		allowance[msg.sender][_spender] = _value;
+		Approval(msg.sender, _spender, _value);
+		return true;
+	}
+}
diff --git a/std/Token.sol b/std/Token.sol
new file mode 100644
index 00000000..50d9ab7a
--- /dev/null
+++ b/std/Token.sol
@@ -0,0 +1,11 @@
+contract Token {
+	event Transfer(address indexed _from, address indexed _to, uint256 _value);
+	event Approval(address indexed _owner, address indexed _spender, uint256 _value);
+
+	function totalSupply() constant returns (uint256 supply) {}
+	function balanceOf(address _owner) constant returns (uint256 balance) {}
+	function transfer(address _to, uint256 _value) returns (bool success) {}
+	function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}
+	function approve(address _spender, uint256 _value) returns (bool success) {}
+	function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}
+}
diff --git a/std/mortal.sol b/std/mortal.sol
new file mode 100644
index 00000000..8de019ab
--- /dev/null
+++ b/std/mortal.sol
@@ -0,0 +1,8 @@
+import "./owned.sol";
+
+contract mortal is owned {
+    function kill() {
+        if (msg.sender == owner)
+            selfdestruct(owner);
+    }
+}
diff --git a/std/owned.sol b/std/owned.sol
new file mode 100644
index 00000000..3d7674f5
--- /dev/null
+++ b/std/owned.sol
@@ -0,0 +1,13 @@
+contract owned {
+    address owner;
+
+    modifier onlyowner() {
+        if (msg.sender == owner) {
+            _;
+        }
+    }
+
+    function owned() {
+        owner = msg.sender;
+    }
+}
diff --git a/std/std.sol b/std/std.sol
new file mode 100644
index 00000000..c3f66b1b
--- /dev/null
+++ b/std/std.sol
@@ -0,0 +1,4 @@
+import "./owned.sol";
+import "./mortal.sol";
+import "./Token.sol";
+import "./StandardToken.sol";
diff --git a/test/RPCSession.cpp b/test/RPCSession.cpp
index 8ed9e9ac..0a01ddb2 100644
--- a/test/RPCSession.cpp
+++ b/test/RPCSession.cpp
@@ -46,7 +46,7 @@ IPCSocket::IPCSocket(string const& _path): m_path(_path)
 		NULL);          // no template file
 
 	if (m_socket == INVALID_HANDLE_VALUE)
-		BOOST_FAIL("Error creating IPC socket object");
+		BOOST_FAIL("Error creating IPC socket object!");
 
 #else
 	if (_path.length() >= sizeof(sockaddr_un::sun_path))
@@ -244,15 +244,39 @@ void RPCSession::test_mineBlocks(int _number)
 	u256 startBlock = fromBigEndian<u256>(fromHex(rpcCall("eth_blockNumber").asString()));
 	rpcCall("test_mineBlocks", { to_string(_number) }, true);
 
-	//@TODO do not use polling - but that would probably need a change to the test client
-	for (size_t polls = 0; polls < 100; ++polls)
+	bool mined = false;
+
+	// We auto-calibrate the time it takes to mine the transaction.
+	// It would be better to go without polling, but that would probably need a change to the test client
+
+	unsigned sleepTime = m_sleepTime;
+	size_t polls = 0;
+	for (; polls < 14 && !mined; ++polls)
 	{
+		std::this_thread::sleep_for(chrono::milliseconds(sleepTime));
 		if (fromBigEndian<u256>(fromHex(rpcCall("eth_blockNumber").asString())) >= startBlock + _number)
-			return;
-		std::this_thread::sleep_for(chrono::milliseconds(10)); //it does not work faster then 10 ms
+			mined = true;
+		else
+			sleepTime *= 2;
+	}
+	if (polls > 1)
+	{
+		m_successfulMineRuns = 0;
+		m_sleepTime += 2;
+	}
+	else if (polls == 1)
+	{
+		m_successfulMineRuns++;
+		if (m_successfulMineRuns > 5)
+		{
+			m_successfulMineRuns = 0;
+			if (m_sleepTime > 2)
+				m_sleepTime--;
+		}
 	}
 
-	BOOST_FAIL("Error in test_mineBlocks: block mining timeout!");
+	if (!mined)
+		BOOST_FAIL("Error in test_mineBlocks: block mining timeout!");
 }
 
 void RPCSession::test_modifyTimestamp(size_t _timestamp)
diff --git a/test/RPCSession.h b/test/RPCSession.h
index 9b7009bf..2a9825b0 100644
--- a/test/RPCSession.h
+++ b/test/RPCSession.h
@@ -124,6 +124,8 @@ private:
 
 	IPCSocket m_ipcSocket;
 	size_t m_rpcSequence = 1;
+	unsigned m_sleepTime = 10;
+	unsigned m_successfulMineRuns = 0;
 
 	std::vector<std::string> m_accounts;
 };
diff --git a/test/TestHelper.cpp b/test/TestHelper.cpp
index a704ab17..df35ff53 100644
--- a/test/TestHelper.cpp
+++ b/test/TestHelper.cpp
@@ -24,28 +24,22 @@
 using namespace std;
 using namespace dev::test;
 
-Options::Options(int argc, char** argv)
+Options const& Options::get()
 {
-	tArgc = 0;
-	tArgv = new char*[argc];
-	for (auto i = 0; i < argc; i++)
-	{
-		string arg = argv[i];
-		if (arg == "--ipc" && i + 1 < argc)
+	static Options instance;
+	return instance;
+}
+
+Options::Options()
+{
+	auto const& suite = boost::unit_test::framework::master_test_suite();
+	for (auto i = 0; i < suite.argc; i++)
+		if (string(suite.argv[i]) == "--ipcpath" && i + 1 < suite.argc)
 		{
-			ipcPath = argv[i + 1];
+			ipcPath = suite.argv[i + 1];
 			i++;
 		}
-		else
-		{
-			tArgv[i] = argv[i];
-			tArgc++;
-		}
-	}
+	if (ipcPath.empty())
+		if (auto path = getenv("ETH_TEST_IPC"))
+			ipcPath = path;
 }
-
-Options const& Options::get(int argc, char** argv)
-{
-	static Options instance(argc, argv);
-	return instance;
-}
\ No newline at end of file
diff --git a/test/TestHelper.h b/test/TestHelper.h
index 49931614..2cb24fd7 100644
--- a/test/TestHelper.h
+++ b/test/TestHelper.h
@@ -103,19 +103,15 @@ namespace test
 	while (0)
 
 
-	class Options
-	{
-	public:
-		std::string ipcPath;
-		int tArgc;
-		char **tArgv;
-		/// Get reference to options
-		/// The first time used, options are parsed with argc, argv
-		static Options const& get(int argc = 0, char** argv = 0);
+struct Options: boost::noncopyable
+{
+	std::string ipcPath;
+
+	static Options const& get();
+
+private:
+	Options();
+};
 
-	private:
-		Options(int argc, char** argv = 0);
-		Options(Options const&) = delete;
-	};
 }
 }
diff --git a/test/boostTest.cpp b/test/boostTest.cpp
index 7ed2a6cd..4ddae0b7 100644
--- a/test/boostTest.cpp
+++ b/test/boostTest.cpp
@@ -26,59 +26,13 @@
 #pragma GCC diagnostic ignored "-Wunused-parameter"
 
 
-	#define BOOST_TEST_NO_MAIN
-	#if defined(_MSC_VER)
-	#pragma warning(push)
-	#pragma warning(disable:4535) // calling _set_se_translator requires /EHa
-	#endif
-	#include <boost/test/included/unit_test.hpp>
-	#if defined(_MSC_VER)
-	#pragma warning(pop)
-	#endif
-
-	#pragma GCC diagnostic pop
-
-	#include <stdlib.h>
-	#include <boost/version.hpp>
-	#include "TestHelper.h"
-
-	using namespace boost::unit_test;
-
-	std::vector<char*> parameters;
-	static std::ostringstream strCout;
-	std::streambuf* oldCoutStreamBuf;
-	std::streambuf* oldCerrStreamBuf;
-
-	//Custom Boost Initialization
-	test_suite* fake_init_func(int argc, char* argv[])
-	{
-		//Required for boost. -nowarning
-		(void)argc;
-		(void)argv;
-		return 0;
-	}
-
-	//Custom Boost Unit Test Main
-	int main(int argc, char* argv[])
-	{
-		//Initialize options before boost reads it
-		dev::test::Options const& opt = dev::test::Options::get(argc, argv);
-		return unit_test_main(fake_init_func, opt.tArgc, opt.tArgv);
-	}
-
-	/*
-#else
-	#if defined(_MSC_VER)
-	#pragma warning(push)
-	#pragma warning(disable:4535) // calling _set_se_translator requires /EHa
-	#endif
-	#include <boost/test/included/unit_test.hpp>
-	#if defined(_MSC_VER)
-	#pragma warning(pop)
-	#endif
-
-	#pragma GCC diagnostic pop
-
-	#include <test/TestHelper.h>
-	using namespace boost::unit_test;
-#endif*/
\ No newline at end of file
+#if defined(_MSC_VER)
+#pragma warning(push)
+#pragma warning(disable:4535) // calling _set_se_translator requires /EHa
+#endif
+#include <boost/test/included/unit_test.hpp>
+#if defined(_MSC_VER)
+#pragma warning(pop)
+#endif
+
+#pragma GCC diagnostic pop
diff --git a/test/contracts/AuctionRegistrar.cpp b/test/contracts/AuctionRegistrar.cpp
index 8860727d..05da3490 100644
--- a/test/contracts/AuctionRegistrar.cpp
+++ b/test/contracts/AuctionRegistrar.cpp
@@ -24,7 +24,6 @@
 #include <tuple>
 #include <boost/test/unit_test.hpp>
 #include <libdevcore/ABI.h>
-#include <libdevcore/Hash.h>
 #include <test/libsolidity/SolidityExecutionFramework.h>
 
 using namespace std;
@@ -40,7 +39,7 @@ namespace
 {
 
 static char const* registrarCode = R"DELIMITER(
-//sol
+pragma solidity ^0.3.5;
 
 contract NameRegister {
 	function addr(string _name) constant returns (address o_owner);
@@ -116,11 +115,6 @@ contract GlobalRegistrar is Registrar, AuctionSystem {
 		// TODO: Populate with hall-of-fame.
 	}
 
-	function() {
-		// prevent people from just sending funds to the registrar
-		throw;
-	}
-
 	function onAuctionEnd(string _name) internal {
 		var auction = m_auctions[_name];
 		var record = m_toRecord[_name];
@@ -131,15 +125,13 @@ contract GlobalRegistrar is Registrar, AuctionSystem {
 		if (previousOwner != 0) {
 			if (!record.owner.send(auction.sumOfBids - auction.highestBid / 100))
 				throw;
-		}
-		else
-		{
+		} else {
 			if (!auction.highestBidder.send(auction.highestBid - auction.secondHighestBid))
 				throw;
 		}
 	}
 
-	function reserve(string _name) external {
+	function reserve(string _name) external payable {
 		if (bytes(_name).length == 0)
 			throw;
 		bool needAuction = requiresAuction(_name);
@@ -148,9 +140,7 @@ contract GlobalRegistrar is Registrar, AuctionSystem {
 			if (now < m_toRecord[_name].renewalDate)
 				throw;
 			bid(_name, msg.sender, msg.value);
-		}
-		else
-		{
+		} else {
 			Record record = m_toRecord[_name];
 			if (record.owner != 0)
 				throw;
@@ -163,7 +153,7 @@ contract GlobalRegistrar is Registrar, AuctionSystem {
 		return bytes(_name).length < c_freeBytes;
 	}
 
-	modifier onlyrecordowner(string _name) { if (m_toRecord[_name].owner == msg.sender) _ }
+	modifier onlyrecordowner(string _name) { if (m_toRecord[_name].owner == msg.sender) _; }
 
 	function transfer(string _name, address _newOwner) onlyrecordowner(_name) {
 		m_toRecord[_name].owner = _newOwner;
@@ -231,7 +221,7 @@ protected:
 		if (!s_compiledRegistrar)
 		{
 			m_optimize = true;
-			m_compiler.reset(false, m_addStandardSources);
+			m_compiler.reset(false);
 			m_compiler.addSource("", registrarCode);
 			ETH_TEST_REQUIRE_NO_THROW(m_compiler.compile(m_optimize, m_optimizeRuns), "Compiling contract failed");
 			s_compiledRegistrar.reset(new bytes(m_compiler.object("GlobalRegistrar").bytecode));
diff --git a/test/contracts/FixedFeeRegistrar.cpp b/test/contracts/FixedFeeRegistrar.cpp
index 63db0531..af8ee595 100644
--- a/test/contracts/FixedFeeRegistrar.cpp
+++ b/test/contracts/FixedFeeRegistrar.cpp
@@ -32,7 +32,6 @@
 #pragma warning(pop)
 #endif
 
-#include <libdevcore/Hash.h>
 #include <test/libsolidity/SolidityExecutionFramework.h>
 
 using namespace std;
@@ -53,6 +52,8 @@ static char const* registrarCode = R"DELIMITER(
 // @authors:
 //   Gav Wood <g@ethdev.com>
 
+pragma solidity ^0.3.5;
+
 contract Registrar {
 	event Changed(string indexed name);
 
@@ -70,9 +71,9 @@ contract FixedFeeRegistrar is Registrar {
 		address owner;
 	}
 
-	modifier onlyrecordowner(string _name) { if (m_record(_name).owner == msg.sender) _ }
+	modifier onlyrecordowner(string _name) { if (m_record(_name).owner == msg.sender) _; }
 
-	function reserve(string _name) {
+	function reserve(string _name) payable {
 		Record rec = m_record(_name);
 		if (rec.owner == 0 && msg.value >= c_fee) {
 			rec.owner = msg.sender;
@@ -132,7 +133,7 @@ protected:
 		if (!s_compiledRegistrar)
 		{
 			m_optimize = true;
-			m_compiler.reset(false, m_addStandardSources);
+			m_compiler.reset(false);
 			m_compiler.addSource("", registrarCode);
 			ETH_TEST_REQUIRE_NO_THROW(m_compiler.compile(m_optimize, m_optimizeRuns), "Compiling contract failed");
 			s_compiledRegistrar.reset(new bytes(m_compiler.object("FixedFeeRegistrar").bytecode));
diff --git a/test/contracts/Wallet.cpp b/test/contracts/Wallet.cpp
index 27bdb396..b4f29a87 100644
--- a/test/contracts/Wallet.cpp
+++ b/test/contracts/Wallet.cpp
@@ -32,7 +32,6 @@
 #pragma warning(pop)
 #endif
 
-#include <libdevcore/Hash.h>
 #include <test/libsolidity/SolidityExecutionFramework.h>
 
 using namespace std;
@@ -55,6 +54,9 @@ static char const* walletCode = R"DELIMITER(
 // use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by
 // some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the
 // interior is executed.
+
+pragma solidity ^0.3.5;
+
 contract multiowned {
 
 	// TYPES
@@ -84,14 +86,14 @@ contract multiowned {
 	// simple single-sig function modifier.
 	modifier onlyowner {
 		if (isOwner(msg.sender))
-			_
+			_;
 	}
 	// multi-sig function modifier: the operation must have an intrinsic hash in order
 	// that later attempts can be realised as the same underlying operation and
 	// thus count as confirmations.
 	modifier onlymanyowners(bytes32 _operation) {
 		if (confirmAndCheck(_operation))
-			_
+			_;
 	}
 
 	// METHODS
@@ -279,7 +281,7 @@ contract daylimit is multiowned {
 	// simple modifier for daily limit.
 	modifier limitedDaily(uint _value) {
 		if (underLimit(_value))
-			_
+			_;
 	}
 
 	// METHODS
@@ -376,7 +378,7 @@ contract Wallet is multisig, multiowned, daylimit {
 	}
 
 	// gets called when no other function matches
-	function() {
+	function() payable {
 		// just being sent some cash?
 		if (msg.value > 0)
 			Deposit(msg.sender, msg.value);
@@ -446,7 +448,7 @@ protected:
 		if (!s_compiledWallet)
 		{
 			m_optimize = true;
-			m_compiler.reset(false, m_addStandardSources);
+			m_compiler.reset(false);
 			m_compiler.addSource("", walletCode);
 			ETH_TEST_REQUIRE_NO_THROW(m_compiler.compile(m_optimize, m_optimizeRuns), "Compiling contract failed");
 			s_compiledWallet.reset(new bytes(m_compiler.object("Wallet").bytecode));
diff --git a/test/libsolidity/ASTJSON.cpp b/test/libsolidity/ASTJSON.cpp
index 6d914391..a0fc5dd7 100644
--- a/test/libsolidity/ASTJSON.cpp
+++ b/test/libsolidity/ASTJSON.cpp
@@ -45,7 +45,7 @@ BOOST_AUTO_TEST_CASE(smoke_test)
 	map<string, unsigned> sourceIndices;
 	sourceIndices["a"] = 1;
 	Json::Value astJson = ASTJsonConverter(c.ast("a"), sourceIndices).json();
-	BOOST_CHECK_EQUAL(astJson["name"], "root");
+	BOOST_CHECK_EQUAL(astJson["name"], "SourceUnit");
 }
 
 BOOST_AUTO_TEST_CASE(source_location)
@@ -56,12 +56,161 @@ BOOST_AUTO_TEST_CASE(source_location)
 	map<string, unsigned> sourceIndices;
 	sourceIndices["a"] = 1;
 	Json::Value astJson = ASTJsonConverter(c.ast("a"), sourceIndices).json();
-	BOOST_CHECK_EQUAL(astJson["name"], "root");
-	BOOST_CHECK_EQUAL(astJson["children"][0]["name"], "Contract");
-	BOOST_CHECK_EQUAL(astJson["children"][0]["children"][0]["name"], "Function");
+	BOOST_CHECK_EQUAL(astJson["name"], "SourceUnit");
+	BOOST_CHECK_EQUAL(astJson["children"][0]["name"], "ContractDefinition");
+	BOOST_CHECK_EQUAL(astJson["children"][0]["children"][0]["name"], "FunctionDefinition");
 	BOOST_CHECK_EQUAL(astJson["children"][0]["children"][0]["src"], "13:32:1");
 }
 
+BOOST_AUTO_TEST_CASE(inheritance_specifier)
+{
+	CompilerStack c;
+	c.addSource("a", "contract C1 {} contract C2 is C1 {}");
+	c.parse();
+	map<string, unsigned> sourceIndices;
+	sourceIndices["a"] = 1;
+	Json::Value astJson = ASTJsonConverter(c.ast("a"), sourceIndices).json();
+	BOOST_CHECK_EQUAL(astJson["children"][1]["attributes"]["name"], "C2");
+	BOOST_CHECK_EQUAL(astJson["children"][1]["children"][0]["name"], "InheritanceSpecifier");
+	BOOST_CHECK_EQUAL(astJson["children"][1]["children"][0]["src"], "30:2:1");
+	BOOST_CHECK_EQUAL(astJson["children"][1]["children"][0]["children"][0]["name"], "UserDefinedTypeName");
+	BOOST_CHECK_EQUAL(astJson["children"][1]["children"][0]["children"][0]["attributes"]["name"], "C1");
+}
+
+BOOST_AUTO_TEST_CASE(using_for_directive)
+{
+	CompilerStack c;
+	c.addSource("a", "library L {} contract C { using L for uint; }");
+	c.parse();
+	map<string, unsigned> sourceIndices;
+	sourceIndices["a"] = 1;
+	Json::Value astJson = ASTJsonConverter(c.ast("a"), sourceIndices).json();
+	Json::Value usingFor = astJson["children"][1]["children"][0];
+	BOOST_CHECK_EQUAL(usingFor["name"], "UsingForDirective");
+	BOOST_CHECK_EQUAL(usingFor["src"], "26:17:1");
+	BOOST_CHECK_EQUAL(usingFor["children"][0]["name"], "UserDefinedTypeName");
+	BOOST_CHECK_EQUAL(usingFor["children"][0]["attributes"]["name"], "L");
+	BOOST_CHECK_EQUAL(usingFor["children"][1]["name"], "ElementaryTypeName");
+	BOOST_CHECK_EQUAL(usingFor["children"][1]["attributes"]["name"], "uint");    
+}
+
+BOOST_AUTO_TEST_CASE(enum_definition)
+{
+	CompilerStack c;
+	c.addSource("a", "contract C { enum E {} }");
+	c.parse();
+	map<string, unsigned> sourceIndices;
+	sourceIndices["a"] = 1;
+	Json::Value astJson = ASTJsonConverter(c.ast("a"), sourceIndices).json();
+	Json::Value enumDefinition = astJson["children"][0]["children"][0];
+	BOOST_CHECK_EQUAL(enumDefinition["name"], "EnumDefinition");
+	BOOST_CHECK_EQUAL(enumDefinition["attributes"]["name"], "E");
+	BOOST_CHECK_EQUAL(enumDefinition["src"], "13:9:1");
+}
+
+BOOST_AUTO_TEST_CASE(enum_value)
+{
+	CompilerStack c;
+	c.addSource("a", "contract C { enum E { A, B } }");
+	c.parse();
+	map<string, unsigned> sourceIndices;
+	sourceIndices["a"] = 1;
+	Json::Value astJson = ASTJsonConverter(c.ast("a"), sourceIndices).json();
+	Json::Value enumDefinition = astJson["children"][0]["children"][0];
+	BOOST_CHECK_EQUAL(enumDefinition["children"][0]["name"], "EnumValue");
+	BOOST_CHECK_EQUAL(enumDefinition["children"][0]["attributes"]["name"], "A");
+	BOOST_CHECK_EQUAL(enumDefinition["children"][0]["src"], "22:1:1");
+	BOOST_CHECK_EQUAL(enumDefinition["children"][1]["name"], "EnumValue");
+	BOOST_CHECK_EQUAL(enumDefinition["children"][1]["attributes"]["name"], "B");
+	BOOST_CHECK_EQUAL(enumDefinition["children"][1]["src"], "25:1:1");
+}
+
+BOOST_AUTO_TEST_CASE(modifier_definition)
+{
+	CompilerStack c;
+	c.addSource("a", "contract C { modifier M(uint i) { _; } function F() M(1) {} }");
+	c.parse();
+	map<string, unsigned> sourceIndices;
+	sourceIndices["a"] = 1;
+	Json::Value astJson = ASTJsonConverter(c.ast("a"), sourceIndices).json();
+	Json::Value modifier = astJson["children"][0]["children"][0];
+	BOOST_CHECK_EQUAL(modifier["name"], "ModifierDefinition");
+	BOOST_CHECK_EQUAL(modifier["attributes"]["name"], "M");
+	BOOST_CHECK_EQUAL(modifier["src"], "13:25:1");
+}
+
+BOOST_AUTO_TEST_CASE(modifier_invocation)
+{
+	CompilerStack c;
+	c.addSource("a", "contract C { modifier M(uint i) { _; } function F() M(1) {} }");
+	c.parse();
+	map<string, unsigned> sourceIndices;
+	sourceIndices["a"] = 1;
+	Json::Value astJson = ASTJsonConverter(c.ast("a"), sourceIndices).json();
+	Json::Value modifier = astJson["children"][0]["children"][1]["children"][2];
+	BOOST_CHECK_EQUAL(modifier["name"], "ModifierInvocation");
+	BOOST_CHECK_EQUAL(modifier["src"], "52:4:1");
+	BOOST_CHECK_EQUAL(modifier["children"][0]["attributes"]["type"], "modifier (uint256)");
+	BOOST_CHECK_EQUAL(modifier["children"][0]["attributes"]["value"], "M");
+	BOOST_CHECK_EQUAL(modifier["children"][1]["attributes"]["value"], "1");
+}
+
+BOOST_AUTO_TEST_CASE(event_definition)
+{
+	CompilerStack c;
+	c.addSource("a", "contract C { event E(); }");
+	c.parse();
+	map<string, unsigned> sourceIndices;
+	sourceIndices["a"] = 1;
+	Json::Value astJson = ASTJsonConverter(c.ast("a"), sourceIndices).json();
+	Json::Value event = astJson["children"][0]["children"][0];
+	BOOST_CHECK_EQUAL(event["name"], "EventDefinition");
+	BOOST_CHECK_EQUAL(event["attributes"]["name"], "E");
+	BOOST_CHECK_EQUAL(event["src"], "13:10:1");
+}
+
+BOOST_AUTO_TEST_CASE(array_type_name)
+{
+	CompilerStack c;
+	c.addSource("a", "contract C { uint[] i; }");
+	c.parse();
+	map<string, unsigned> sourceIndices;
+	sourceIndices["a"] = 1;
+	Json::Value astJson = ASTJsonConverter(c.ast("a"), sourceIndices).json();
+	Json::Value array = astJson["children"][0]["children"][0]["children"][0];
+	BOOST_CHECK_EQUAL(array["name"], "ArrayTypeName");
+	BOOST_CHECK_EQUAL(array["src"], "13:6:1");
+}
+
+BOOST_AUTO_TEST_CASE(placeholder_statement)
+{
+	CompilerStack c;
+	c.addSource("a", "contract C { modifier M { _; } }");
+	c.parse();
+	map<string, unsigned> sourceIndices;
+	sourceIndices["a"] = 1;
+	Json::Value astJson = ASTJsonConverter(c.ast("a"), sourceIndices).json();
+	Json::Value placeholder = astJson["children"][0]["children"][0]["children"][1]["children"][0];
+	BOOST_CHECK_EQUAL(placeholder["name"], "PlaceholderStatement");
+	BOOST_CHECK_EQUAL(placeholder["src"], "26:1:1");
+}
+
+BOOST_AUTO_TEST_CASE(non_utf8)
+{
+	CompilerStack c;
+	c.addSource("a", "contract C { function f() { var x = hex\"ff\"; } }");
+	c.parse();
+	map<string, unsigned> sourceIndices;
+	sourceIndices["a"] = 1;
+	Json::Value astJson = ASTJsonConverter(c.ast("a"), sourceIndices).json();
+	Json::Value literal = astJson["children"][0]["children"][0]["children"][2]["children"][0]["children"][1];
+	BOOST_CHECK_EQUAL(literal["name"], "Literal");
+	BOOST_CHECK_EQUAL(literal["attributes"]["hexvalue"], "ff");
+	BOOST_CHECK_EQUAL(literal["attributes"]["token"], Json::nullValue);
+	BOOST_CHECK_EQUAL(literal["attributes"]["value"], Json::nullValue);
+	BOOST_CHECK(literal["attributes"]["type"].asString().find("invalid") != string::npos);
+}
+
 BOOST_AUTO_TEST_SUITE_END()
 
 }
diff --git a/test/libsolidity/Assembly.cpp b/test/libsolidity/Assembly.cpp
index 557d496a..8d7a3540 100644
--- a/test/libsolidity/Assembly.cpp
+++ b/test/libsolidity/Assembly.cpp
@@ -114,8 +114,8 @@ BOOST_AUTO_TEST_CASE(location_test)
 	shared_ptr<string const> n = make_shared<string>("source");
 	AssemblyItems items = compileContract(sourceCode);
 	vector<SourceLocation> locations =
-		vector<SourceLocation>(17, SourceLocation(2, 75, n)) +
-		vector<SourceLocation>(28, SourceLocation(20, 72, n)) +
+		vector<SourceLocation>(18, SourceLocation(2, 75, n)) +
+		vector<SourceLocation>(31, SourceLocation(20, 72, n)) +
 		vector<SourceLocation>{SourceLocation(42, 51, n), SourceLocation(65, 67, n)} +
 		vector<SourceLocation>(4, SourceLocation(58, 67, n)) +
 		vector<SourceLocation>(3, SourceLocation(20, 72, n));
diff --git a/test/libsolidity/GasMeter.cpp b/test/libsolidity/GasMeter.cpp
index 41204a0a..1f216680 100644
--- a/test/libsolidity/GasMeter.cpp
+++ b/test/libsolidity/GasMeter.cpp
@@ -46,7 +46,7 @@ public:
 	GasMeterTestFramework() { }
 	void compile(string const& _sourceCode)
 	{
-		m_compiler.setSource(_sourceCode);
+		m_compiler.setSource("pragma solidity >= 0.0;" + _sourceCode);
 		ETH_TEST_REQUIRE_NO_THROW(m_compiler.compile(), "Compiling contract failed");
 
 		AssemblyItems const* items = m_compiler.runtimeAssemblyItems("");
diff --git a/test/libsolidity/Imports.cpp b/test/libsolidity/Imports.cpp
index 0736a853..1a9e16cc 100644
--- a/test/libsolidity/Imports.cpp
+++ b/test/libsolidity/Imports.cpp
@@ -39,106 +39,106 @@ BOOST_AUTO_TEST_SUITE(SolidityImports)
 BOOST_AUTO_TEST_CASE(smoke_test)
 {
 	CompilerStack c;
-	c.addSource("a", "contract C {}");
+	c.addSource("a", "contract C {} pragma solidity >=0.0;");
 	BOOST_CHECK(c.compile());
 }
 
 BOOST_AUTO_TEST_CASE(regular_import)
 {
 	CompilerStack c;
-	c.addSource("a", "contract C {}");
-	c.addSource("b", "import \"a\"; contract D is C {}");
+	c.addSource("a", "contract C {} pragma solidity >=0.0;");
+	c.addSource("b", "import \"a\"; contract D is C {} pragma solidity >=0.0;");
 	BOOST_CHECK(c.compile());
 }
 
 BOOST_AUTO_TEST_CASE(import_does_not_clutter_importee)
 {
 	CompilerStack c;
-	c.addSource("a", "contract C { D d; }");
-	c.addSource("b", "import \"a\"; contract D is C {}");
+	c.addSource("a", "contract C { D d; } pragma solidity >=0.0;");
+	c.addSource("b", "import \"a\"; contract D is C {} pragma solidity >=0.0;");
 	BOOST_CHECK(!c.compile());
 }
 
 BOOST_AUTO_TEST_CASE(import_is_transitive)
 {
 	CompilerStack c;
-	c.addSource("a", "contract C { }");
-	c.addSource("b", "import \"a\";");
-	c.addSource("c", "import \"b\"; contract D is C {}");
+	c.addSource("a", "contract C { } pragma solidity >=0.0;");
+	c.addSource("b", "import \"a\"; pragma solidity >=0.0;");
+	c.addSource("c", "import \"b\"; contract D is C {} pragma solidity >=0.0;");
 	BOOST_CHECK(c.compile());
 }
 
 BOOST_AUTO_TEST_CASE(circular_import)
 {
 	CompilerStack c;
-	c.addSource("a", "import \"b\"; contract C { D d; }");
-	c.addSource("b", "import \"a\"; contract D { C c; }");
+	c.addSource("a", "import \"b\"; contract C { D d; } pragma solidity >=0.0;");
+	c.addSource("b", "import \"a\"; contract D { C c; } pragma solidity >=0.0;");
 	BOOST_CHECK(c.compile());
 }
 
 BOOST_AUTO_TEST_CASE(relative_import)
 {
 	CompilerStack c;
-	c.addSource("a", "import \"./dir/b\"; contract A is B {}");
-	c.addSource("dir/b", "contract B {}");
-	c.addSource("dir/c", "import \"../a\"; contract C is A {}");
+	c.addSource("a", "import \"./dir/b\"; contract A is B {} pragma solidity >=0.0;");
+	c.addSource("dir/b", "contract B {} pragma solidity >=0.0;");
+	c.addSource("dir/c", "import \"../a\"; contract C is A {} pragma solidity >=0.0;");
 	BOOST_CHECK(c.compile());
 }
 
 BOOST_AUTO_TEST_CASE(relative_import_multiplex)
 {
 	CompilerStack c;
-	c.addSource("a", "contract A {}");
-	c.addSource("dir/a/b/c", "import \"../../.././a\"; contract B is A {}");
+	c.addSource("a", "contract A {} pragma solidity >=0.0;");
+	c.addSource("dir/a/b/c", "import \"../../.././a\"; contract B is A {} pragma solidity >=0.0;");
 	BOOST_CHECK(c.compile());
 }
 
 BOOST_AUTO_TEST_CASE(simple_alias)
 {
 	CompilerStack c;
-	c.addSource("a", "contract A {}");
-	c.addSource("dir/a/b/c", "import \"../../.././a\" as x; contract B is x.A { function() { x.A r = x.A(20); } }");
+	c.addSource("a", "contract A {} pragma solidity >=0.0;");
+	c.addSource("dir/a/b/c", "import \"../../.././a\" as x; contract B is x.A { function() { x.A r = x.A(20); } } pragma solidity >=0.0;");
 	BOOST_CHECK(c.compile());
 }
 
 BOOST_AUTO_TEST_CASE(library_name_clash)
 {
 	CompilerStack c;
-	c.addSource("a", "library A {}");
-	c.addSource("b", "library A {}");
+	c.addSource("a", "library A {} pragma solidity >=0.0;");
+	c.addSource("b", "library A {} pragma solidity >=0.0;");
 	BOOST_CHECK(!c.compile());
 }
 
 BOOST_AUTO_TEST_CASE(library_name_clash_with_contract)
 {
 	CompilerStack c;
-	c.addSource("a", "contract A {}");
-	c.addSource("b", "library A {}");
+	c.addSource("a", "contract A {} pragma solidity >=0.0;");
+	c.addSource("b", "library A {} pragma solidity >=0.0;");
 	BOOST_CHECK(c.compile());
 }
 
 BOOST_AUTO_TEST_CASE(complex_import)
 {
 	CompilerStack c;
-	c.addSource("a", "contract A {} contract B {} contract C { struct S { uint a; } }");
+	c.addSource("a", "contract A {} contract B {} contract C { struct S { uint a; } } pragma solidity >=0.0;");
 	c.addSource("b", "import \"a\" as x; import {B as b, C as c, C} from \"a\"; "
-				"contract D is b { function f(c.S var1, x.C.S var2, C.S var3) internal {} }");
+				"contract D is b { function f(c.S var1, x.C.S var2, C.S var3) internal {} } pragma solidity >=0.0;");
 	BOOST_CHECK(c.compile());
 }
 
 BOOST_AUTO_TEST_CASE(name_clash_in_import)
 {
 	CompilerStack c;
-	c.addSource("a", "contract A {}");
-	c.addSource("b", "import \"a\"; contract A {} ");
+	c.addSource("a", "contract A {} pragma solidity >=0.0;");
+	c.addSource("b", "import \"a\"; contract A {} pragma solidity >=0.0;");
 	BOOST_CHECK(!c.compile());
-	c.addSource("b", "import \"a\" as A; contract A {} ");
+	c.addSource("b", "import \"a\" as A; contract A {} pragma solidity >=0.0;");
 	BOOST_CHECK(!c.compile());
-	c.addSource("b", "import {A as b} from \"a\"; contract b {} ");
+	c.addSource("b", "import {A as b} from \"a\"; contract b {} pragma solidity >=0.0;");
 	BOOST_CHECK(!c.compile());
-	c.addSource("b", "import {A} from \"a\"; contract A {} ");
+	c.addSource("b", "import {A} from \"a\"; contract A {} pragma solidity >=0.0;");
 	BOOST_CHECK(!c.compile());
-	c.addSource("b", "import {A} from \"a\"; contract B {} ");
+	c.addSource("b", "import {A} from \"a\"; contract B {} pragma solidity >=0.0;");
 	BOOST_CHECK(c.compile());
 }
 
@@ -146,10 +146,10 @@ BOOST_AUTO_TEST_CASE(remappings)
 {
 	CompilerStack c;
 	c.setRemappings(vector<string>{"s=s_1.4.6", "t=Tee"});
-	c.addSource("a", "import \"s/s.sol\"; contract A is S {}");
-	c.addSource("b", "import \"t/tee.sol\"; contract A is Tee {} ");
-	c.addSource("s_1.4.6/s.sol", "contract S {}");
-	c.addSource("Tee/tee.sol", "contract Tee {}");
+	c.addSource("a", "import \"s/s.sol\"; contract A is S {} pragma solidity >=0.0;");
+	c.addSource("b", "import \"t/tee.sol\"; contract A is Tee {} pragma solidity >=0.0;");
+	c.addSource("s_1.4.6/s.sol", "contract S {} pragma solidity >=0.0;");
+	c.addSource("Tee/tee.sol", "contract Tee {} pragma solidity >=0.0;");
 	BOOST_CHECK(c.compile());
 }
 
@@ -157,10 +157,10 @@ BOOST_AUTO_TEST_CASE(context_dependent_remappings)
 {
 	CompilerStack c;
 	c.setRemappings(vector<string>{"a:s=s_1.4.6", "b:s=s_1.4.7"});
-	c.addSource("a/a.sol", "import \"s/s.sol\"; contract A is SSix {}");
-	c.addSource("b/b.sol", "import \"s/s.sol\"; contract B is SSeven {}");
-	c.addSource("s_1.4.6/s.sol", "contract SSix {} ");
-	c.addSource("s_1.4.7/s.sol", "contract SSeven {} ");
+	c.addSource("a/a.sol", "import \"s/s.sol\"; contract A is SSix {} pragma solidity >=0.0;");
+	c.addSource("b/b.sol", "import \"s/s.sol\"; contract B is SSeven {} pragma solidity >=0.0;");
+	c.addSource("s_1.4.6/s.sol", "contract SSix {} pragma solidity >=0.0;");
+	c.addSource("s_1.4.7/s.sol", "contract SSeven {} pragma solidity >=0.0;");
 	BOOST_CHECK(c.compile());
 }
 
diff --git a/test/libsolidity/SemVerMatcher.cpp b/test/libsolidity/SemVerMatcher.cpp
new file mode 100644
index 00000000..80bdf16f
--- /dev/null
+++ b/test/libsolidity/SemVerMatcher.cpp
@@ -0,0 +1,223 @@
+/*
+	This file is part of cpp-ethereum.
+
+	cpp-ethereum is free software: you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
+
+	cpp-ethereum is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.
+*/
+/**
+ * @author Christian <chris@ethereum.org>
+ * @date 2016
+ * Unit tests for the semantic versioning matcher.
+ */
+
+#include <string>
+#include <vector>
+#include <tuple>
+#include <libsolidity/parsing/Scanner.h>
+#include <libsolidity/analysis/SemVerHandler.h>
+#include "../TestHelper.h"
+
+using namespace std;
+
+namespace dev
+{
+namespace solidity
+{
+namespace test
+{
+
+BOOST_AUTO_TEST_SUITE(SemVerMatcher)
+
+SemVerMatchExpression parseExpression(string const& _input)
+{
+	Scanner scanner{CharStream(_input)};
+	vector<string> literals;
+	vector<Token::Value> tokens;
+	while (scanner.currentToken() != Token::EOS)
+	{
+		auto token = scanner.currentToken();
+		string literal = scanner.currentLiteral();
+		if (literal.empty() && Token::toString(token))
+			literal = Token::toString(token);
+		literals.push_back(literal);
+		tokens.push_back(token);
+		scanner.next();
+	}
+
+	auto expression = SemVerMatchExpressionParser(tokens, literals).parse();
+	BOOST_CHECK_MESSAGE(
+		expression.isValid(),
+		"Expression \"" + _input + "\" did not parse properly."
+	);
+	return expression;
+}
+
+BOOST_AUTO_TEST_CASE(positive_range)
+{
+	// Positive range tests
+	vector<pair<string, string>> tests = {
+		{"*", "1.2.3-foo"},
+		{"1.0.0 - 2.0.0", "1.2.3"},
+		{"1.0.0", "1.0.0"},
+		{">=*", "0.2.4"},
+		{"*", "1.2.3"},
+		{">=1.0.0", "1.0.0"},
+		{">=1.0.0", "1.0.1"},
+		{">=1.0.0", "1.1.0"},
+		{">1.0.0", "1.0.1"},
+		{">1.0.0", "1.1.0"},
+		{"<=2.0.0", "2.0.0"},
+		{"<=2.0.0", "1.9999.9999"},
+		{"<=2.0.0", "0.2.9"},
+		{"<2.0.0", "1.9999.9999"},
+		{"<2.0.0", "0.2.9"},
+		{">= 1.0.0", "1.0.0"},
+		{">=  1.0.0", "1.0.1"},
+		{">=   1.0.0", "1.1.0"},
+		{"> 1.0.0", "1.0.1"},
+		{">  1.0.0", "1.1.0"},
+		{"<=   2.0.0", "2.0.0"},
+		{"<= 2.0.0", "1.9999.9999"},
+		{"<=  2.0.0", "0.2.9"},
+		{"<    2.0.0", "1.9999.9999"},
+		{"<\t2.0.0", "0.2.9"},
+		{">=0.1.97", "0.1.97"},
+		{"0.1.20 || 1.2.4", "1.2.4"},
+		{">=0.2.3 || <0.0.1", "0.0.0"},
+		{">=0.2.3 || <0.0.1", "0.2.3"},
+		{">=0.2.3 || <0.0.1", "0.2.4"},
+		{"\"2.x.x\"", "2.1.3"},
+		{"1.2.x", "1.2.3"},
+		{"\"1.2.x\" || \"2.x\"", "2.1.3"},
+		{"\"1.2.x\" || \"2.x\"", "1.2.3"},
+		{"x", "1.2.3"},
+		{"2.*.*", "2.1.3"},
+		{"1.2.*", "1.2.3"},
+		{"1.2.* || 2.*", "2.1.3"},
+		{"1.2.* || 2.*", "1.2.3"},
+		{"*", "1.2.3"},
+		{"2", "2.1.2"},
+		{"2.3", "2.3.1"},
+		{"~2.4", "2.4.0"}, // >=2.4.0 <2.5.0
+		{"~2.4", "2.4.5"},
+		{"~1", "1.2.3"}, // >=1.0.0 <2.0.0
+		{"~1.0", "1.0.2"}, // >=1.0.0 <1.1.0,
+		{"~ 1.0", "1.0.2"},
+		{"~ 1.0.3", "1.0.12"},
+		{">=1", "1.0.0"},
+		{">= 1", "1.0.0"},
+		{"<1.2", "1.1.1"},
+		{"< 1.2", "1.1.1"},
+		{"=0.7.x", "0.7.2"},
+		{"<=0.7.x", "0.7.2"},
+		{">=0.7.x", "0.7.2"},
+		{"<=0.7.x", "0.6.2"},
+		{"~1.2.1 >=1.2.3", "1.2.3"},
+		{"~1.2.1 =1.2.3", "1.2.3"},
+		{"~1.2.1 1.2.3", "1.2.3"},
+		{"~1.2.1 >=1.2.3 1.2.3", "1.2.3"},
+		{"~1.2.1 1.2.3 >=1.2.3", "1.2.3"},
+		{">=\"1.2.1\" 1.2.3", "1.2.3"},
+		{"1.2.3 >=1.2.1", "1.2.3"},
+		{">=1.2.3 >=1.2.1", "1.2.3"},
+		{">=1.2.1 >=1.2.3", "1.2.3"},
+		{">=1.2", "1.2.8"},
+		{"^1.2.3", "1.8.1"},
+		{"^0.1.2", "0.1.2"},
+		{"^0.1", "0.1.2"},
+		{"^1.2", "1.4.2"},
+		{"<=1.2.3", "1.2.3-beta"},
+		{">1.2", "1.3.0-beta"},
+		{"<1.2.3", "1.2.3-beta"},
+		{"^1.2 ^1", "1.4.2"}
+	};
+	for (auto const& t: tests)
+	{
+		SemVerVersion version(t.second);
+		SemVerMatchExpression expression = parseExpression(t.first);
+		BOOST_CHECK_MESSAGE(
+			expression.matches(version),
+			"Version \"" + t.second + "\" did not satisfy expression \"" + t.first + "\""
+		);
+	}
+}
+
+BOOST_AUTO_TEST_CASE(negative_range)
+{
+	// Positive range tests
+	vector<pair<string, string>> tests = {
+		{"1.0.0 - 2.0.0", "2.2.3"},
+		{"^1.2.3", "1.2.3-pre"},
+		{"^1.2", "1.2.0-pre"},
+		{"^1.2.3", "1.2.3-beta"},
+		{"=0.7.x", "0.7.0-asdf"},
+		{">=0.7.x", "0.7.0-asdf"},
+		{"1.0.0", "1.0.1"},
+		{">=1.0.0", "0.0.0"},
+		{">=1.0.0", "0.0.1"},
+		{">=1.0.0", "0.1.0"},
+		{">1.0.0", "0.0.1"},
+		{">1.0.0", "0.1.0"},
+		{"<=2.0.0", "3.0.0"},
+		{"<=2.0.0", "2.9999.9999"},
+		{"<=2.0.0", "2.2.9"},
+		{"<2.0.0", "2.9999.9999"},
+		{"<2.0.0", "2.2.9"},
+		{">=0.1.97", "0.1.93"},
+		{"0.1.20 || 1.2.4", "1.2.3"},
+		{">=0.2.3 || <0.0.1", "0.0.3"},
+		{">=0.2.3 || <0.0.1", "0.2.2"},
+		{"\"2.x.x\"", "1.1.3"},
+		{"\"2.x.x\"", "3.1.3"},
+		{"1.2.x", "1.3.3"},
+		{"\"1.2.x\" || \"2.x\"", "3.1.3"},
+		{"\"1.2.x\" || \"2.x\"", "1.1.3"},
+		{"2.*.*", "1.1.3"},
+		{"2.*.*", "3.1.3"},
+		{"1.2.*", "1.3.3"},
+		{"1.2.* || 2.*", "3.1.3"},
+		{"1.2.* || 2.*", "1.1.3"},
+		{"2", "1.1.2"},
+		{"2.3", "2.4.1"},
+		{"~2.4", "2.5.0"}, // >=2.4.0 <2.5.0
+		{"~2.4", "2.3.9"},
+		{"~1", "0.2.3"}, // >=1.0.0 <2.0.0
+		{"~1.0", "1.1.0"}, // >=1.0.0 <1.1.0
+		{"<1", "1.0.0"},
+		{">=1.2", "1.1.1"},
+		{"=0.7.x", "0.8.2"},
+		{">=0.7.x", "0.6.2"},
+		{"<0.7.x", "0.7.2"},
+		{"=1.2.3", "1.2.3-beta"},
+		{">1.2", "1.2.8"},
+		{"^1.2.3", "2.0.0-alpha"},
+		{"^1.2.3", "1.2.2"},
+		{"^1.2", "1.1.9"}
+	};
+	for (auto const& t: tests)
+	{
+		SemVerVersion version(t.second);
+		SemVerMatchExpression expression = parseExpression(t.first);
+		BOOST_CHECK_MESSAGE(
+			!expression.matches(version),
+			"Version \"" + t.second + "\" did satisfy expression \"" + t.first + "\" " +
+			"(although it should not)"
+		);
+	}
+}
+
+BOOST_AUTO_TEST_SUITE_END()
+
+}
+}
+} // end namespaces
diff --git a/test/libsolidity/SolidityABIJSON.cpp b/test/libsolidity/SolidityABIJSON.cpp
index 77b39978..073d7d97 100644
--- a/test/libsolidity/SolidityABIJSON.cpp
+++ b/test/libsolidity/SolidityABIJSON.cpp
@@ -35,11 +35,11 @@ namespace test
 class JSONInterfaceChecker
 {
 public:
-	JSONInterfaceChecker(): m_compilerStack(false) {}
+	JSONInterfaceChecker(): m_compilerStack() {}
 
 	void checkInterface(std::string const& _code, std::string const& _expectedInterfaceString)
 	{
-		ETH_TEST_REQUIRE_NO_THROW(m_compilerStack.parse(_code), "Parsing contract failed");
+		ETH_TEST_REQUIRE_NO_THROW(m_compilerStack.parse("pragma solidity >=0.0;\n" + _code), "Parsing contract failed");
 		std::string generatedInterfaceString = m_compilerStack.metadata("", DocumentationType::ABIInterface);
 		Json::Value generatedInterface;
 		m_reader.parse(generatedInterfaceString, generatedInterface);
@@ -68,6 +68,7 @@ BOOST_AUTO_TEST_CASE(basic_test)
 	{
 		"name": "f",
 		"constant": false,
+		"payable" : false,
 		"type": "function",
 		"inputs": [
 		{
@@ -107,6 +108,7 @@ BOOST_AUTO_TEST_CASE(multiple_methods)
 	{
 		"name": "f",
 		"constant": false,
+		"payable" : false,
 		"type": "function",
 		"inputs": [
 		{
@@ -124,6 +126,7 @@ BOOST_AUTO_TEST_CASE(multiple_methods)
 	{
 		"name": "g",
 		"constant": false,
+		"payable" : false,
 		"type": "function",
 		"inputs": [
 		{
@@ -153,6 +156,7 @@ BOOST_AUTO_TEST_CASE(multiple_params)
 	{
 		"name": "f",
 		"constant": false,
+		"payable" : false,
 		"type": "function",
 		"inputs": [
 		{
@@ -188,6 +192,7 @@ BOOST_AUTO_TEST_CASE(multiple_methods_order)
 	{
 		"name": "c",
 		"constant": false,
+		"payable" : false,
 		"type": "function",
 		"inputs": [
 		{
@@ -205,6 +210,7 @@ BOOST_AUTO_TEST_CASE(multiple_methods_order)
 	{
 		"name": "f",
 		"constant": false,
+		"payable" : false,
 		"type": "function",
 		"inputs": [
 		{
@@ -235,6 +241,7 @@ BOOST_AUTO_TEST_CASE(const_function)
 	{
 		"name": "foo",
 		"constant": false,
+		"payable" : false,
 		"type": "function",
 		"inputs": [
 		{
@@ -256,6 +263,7 @@ BOOST_AUTO_TEST_CASE(const_function)
 	{
 		"name": "boo",
 		"constant": true,
+		"payable" : false,
 		"type": "function",
 		"inputs": [{
 			"name": "a",
@@ -273,15 +281,6 @@ BOOST_AUTO_TEST_CASE(const_function)
 	checkInterface(sourceCode, interface);
 }
 
-BOOST_AUTO_TEST_CASE(exclude_fallback_function)
-{
-	char const* sourceCode = "contract test { function() {} }";
-
-	char const* interface = "[]";
-
-	checkInterface(sourceCode, interface);
-}
-
 BOOST_AUTO_TEST_CASE(events)
 {
 	char const* sourceCode = "contract test {\n"
@@ -293,6 +292,7 @@ BOOST_AUTO_TEST_CASE(events)
 	{
 		"name": "f",
 		"constant": false,
+		"payable" : false,
 		"type": "function",
 		"inputs": [
 		{
@@ -370,6 +370,7 @@ BOOST_AUTO_TEST_CASE(inherited)
 	{
 		"name": "baseFunction",
 		"constant": false,
+		"payable" : false,
 		"type": "function",
 		"inputs":
 		[{
@@ -385,6 +386,7 @@ BOOST_AUTO_TEST_CASE(inherited)
 	{
 		"name": "derivedFunction",
 		"constant": false,
+		"payable" : false,
 		"type": "function",
 		"inputs":
 		[{
@@ -438,6 +440,7 @@ BOOST_AUTO_TEST_CASE(empty_name_input_parameter_with_named_one)
 	{
 		"name": "f",
 		"constant": false,
+		"payable" : false,
 		"type": "function",
 		"inputs": [
 		{
@@ -478,6 +481,7 @@ BOOST_AUTO_TEST_CASE(empty_name_return_parameter)
 	{
 		"name": "f",
 		"constant": false,
+		"payable" : false,
 		"type": "function",
 		"inputs": [
 		{
@@ -545,6 +549,7 @@ BOOST_AUTO_TEST_CASE(return_param_in_abi)
 	[
 		{
 			"constant" : false,
+			"payable" : false,
 			"inputs" : [],
 			"name" : "ret",
 			"outputs" : [
@@ -582,6 +587,7 @@ BOOST_AUTO_TEST_CASE(strings_and_arrays)
 	[
 		{
 			"constant" : false,
+			"payable" : false,
 			"name": "f",
 			"inputs": [
 				{ "name": "a", "type": "string" },
@@ -609,6 +615,7 @@ BOOST_AUTO_TEST_CASE(library_function)
 	[
 		{
 			"constant" : false,
+			"payable" : false,
 			"name": "f",
 			"inputs": [
 				{ "name": "b", "type": "test.StructType storage" },
@@ -626,6 +633,76 @@ BOOST_AUTO_TEST_CASE(library_function)
 	checkInterface(sourceCode, interface);
 }
 
+BOOST_AUTO_TEST_CASE(include_fallback_function)
+{
+	char const* sourceCode = R"(
+		contract test {
+			function() {}
+		}
+	)";
+
+	char const* interface = R"(
+	[
+		{
+			"payable": false,
+			"type" : "fallback"
+		}
+	]
+	)";
+	checkInterface(sourceCode, interface);
+}
+
+BOOST_AUTO_TEST_CASE(payable_function)
+{
+	char const* sourceCode = R"(
+		contract test {
+			function f() {}
+			function g() payable {}
+		}
+	)";
+
+	char const* interface = R"(
+	[
+		{
+			"constant" : false,
+			"payable": false,
+			"inputs": [],
+			"name": "f",
+			"outputs": [],
+			"type" : "function"
+		},
+		{
+			"constant" : false,
+			"payable": true,
+			"inputs": [],
+			"name": "g",
+			"outputs": [],
+			"type" : "function"
+		}
+	]
+	)";
+	checkInterface(sourceCode, interface);
+}
+
+BOOST_AUTO_TEST_CASE(payable_fallback_unction)
+{
+	char const* sourceCode = R"(
+		contract test {
+			function () payable {}
+		}
+	)";
+
+	char const* interface = R"(
+	[
+		{
+			"payable": true,
+			"type" : "fallback"
+		}
+	]
+	)";
+	checkInterface(sourceCode, interface);
+}
+
 BOOST_AUTO_TEST_SUITE_END()
 
 }
diff --git a/test/libsolidity/SolidityEndToEndTest.cpp b/test/libsolidity/SolidityEndToEndTest.cpp
index 1b7c5ea4..3c85d8a8 100644
--- a/test/libsolidity/SolidityEndToEndTest.cpp
+++ b/test/libsolidity/SolidityEndToEndTest.cpp
@@ -25,7 +25,6 @@
 #include <string>
 #include <tuple>
 #include <boost/test/unit_test.hpp>
-#include <libdevcore/Hash.h>
 #include <libsolidity/interface/Exceptions.h>
 #include <test/libsolidity/SolidityExecutionFramework.h>
 
@@ -1321,7 +1320,7 @@ BOOST_AUTO_TEST_CASE(balance)
 BOOST_AUTO_TEST_CASE(blockchain)
 {
 	char const* sourceCode = "contract test {\n"
-							 "  function someInfo() returns (uint256 value, address coinbase, uint256 blockNumber) {\n"
+							 "  function someInfo() payable returns (uint256 value, address coinbase, uint256 blockNumber) {\n"
 							 "    value = msg.value;\n"
 							 "    coinbase = block.coinbase;\n"
 							 "    blockNumber = block.number;\n"
@@ -1343,7 +1342,7 @@ BOOST_AUTO_TEST_CASE(msg_sig)
 		}
 	)";
 	compileAndRun(sourceCode);
-	BOOST_CHECK(callContractFunctionWithValue("foo(uint256)", 13) == encodeArgs(asString(FixedHash<4>(dev::sha3("foo(uint256)")).asBytes())));
+	BOOST_CHECK(callContractFunction("foo(uint256)") == encodeArgs(asString(FixedHash<4>(dev::sha3("foo(uint256)")).asBytes())));
 }
 
 BOOST_AUTO_TEST_CASE(msg_sig_after_internal_call_is_same)
@@ -1359,7 +1358,7 @@ BOOST_AUTO_TEST_CASE(msg_sig_after_internal_call_is_same)
 		}
 	)";
 	compileAndRun(sourceCode);
-	BOOST_CHECK(callContractFunctionWithValue("foo(uint256)", 13) == encodeArgs(asString(FixedHash<4>(dev::sha3("foo(uint256)")).asBytes())));
+	BOOST_CHECK(callContractFunction("foo(uint256)") == encodeArgs(asString(FixedHash<4>(dev::sha3("foo(uint256)")).asBytes())));
 }
 
 BOOST_AUTO_TEST_CASE(now)
@@ -1527,8 +1526,10 @@ BOOST_AUTO_TEST_CASE(convert_uint_to_fixed_bytes_greater_size)
 			}
 		})";
 	compileAndRun(sourceCode);
-	BOOST_CHECK(callContractFunction("UintToBytes(uint16)", u256("0x6162")) ==
-                encodeArgs(string("\0\0\0\0\0\0ab", 8)));
+	BOOST_CHECK(
+		callContractFunction("UintToBytes(uint16)", u256("0x6162")) ==
+		encodeArgs(string("\0\0\0\0\0\0ab", 8))
+	);
 }
 
 BOOST_AUTO_TEST_CASE(send_ether)
@@ -1700,9 +1701,15 @@ BOOST_AUTO_TEST_CASE(sha256)
 							 "  }\n"
 							 "}\n";
 	compileAndRun(sourceCode);
-	auto f = [&](u256 const& _input) -> u256
+	auto f = [&](u256 const& _x) -> bytes
 	{
-		return dev::sha256(dev::ref(toBigEndian(_input)));
+		if (_x == u256(4))
+			return fromHex("e38990d0c7fc009880a9c07c23842e886c6bbdc964ce6bdd5817ad357335ee6f");
+		if (_x == u256(5))
+			return fromHex("96de8fc8c256fa1e1556d41af431cace7dca68707c78dd88c3acab8b17164c47");
+		if (_x == u256(-1))
+			return fromHex("af9613760f72635fbdb44a5a0a63c39f12af30f950a6ee5c971be188e89c4051");
+		return fromHex("");
 	};
 	testSolidityAgainstCpp("a(bytes32)", f, u256(4));
 	testSolidityAgainstCpp("a(bytes32)", f, u256(5));
@@ -1717,9 +1724,15 @@ BOOST_AUTO_TEST_CASE(ripemd)
 							 "  }\n"
 							 "}\n";
 	compileAndRun(sourceCode);
-	auto f = [&](u256 const& _input) -> u256
+	auto f = [&](u256 const& _x) -> bytes
 	{
-		return h256(dev::ripemd160(h256(_input).ref()), h256::AlignLeft);	// This should be aligned right. i guess it's fixed elsewhere?
+		if (_x == u256(4))
+			return fromHex("1b0f3c404d12075c68c938f9f60ebea4f74941a0000000000000000000000000");
+		if (_x == u256(5))
+			return fromHex("ee54aa84fc32d8fed5a5fe160442ae84626829d9000000000000000000000000");
+		if (_x == u256(-1))
+			return fromHex("1cf4e77f5966e13e109703cd8a0df7ceda7f3dc3000000000000000000000000");
+		return fromHex("");
 	};
 	testSolidityAgainstCpp("a(bytes32)", f, u256(4));
 	testSolidityAgainstCpp("a(bytes32)", f, u256(5));
@@ -2042,10 +2055,11 @@ BOOST_AUTO_TEST_CASE(contracts_as_addresses)
 {
 	char const* sourceCode = R"(
 		contract helper {
+			function() payable { } // can receive ether
 		}
 		contract test {
 			helper h;
-			function test() { h = new helper(); h.send(5); }
+			function test() payable { h = new helper(); h.send(5); }
 			function getBalance() returns (uint256 myBalance, uint256 helperBalance) {
 				myBalance = this.balance;
 				helperBalance = h.balance;
@@ -2053,6 +2067,7 @@ BOOST_AUTO_TEST_CASE(contracts_as_addresses)
 		}
 	)";
 	compileAndRun(sourceCode, 20);
+	BOOST_CHECK_EQUAL(balanceAt(m_contractAddress), 20 - 5);
 	BOOST_REQUIRE(callContractFunction("getBalance()") == encodeArgs(u256(20 - 5), u256(5)));
 }
 
@@ -2061,7 +2076,7 @@ BOOST_AUTO_TEST_CASE(gas_and_value_basic)
 	char const* sourceCode = R"(
 		contract helper {
 			bool flag;
-			function getBalance() returns (uint256 myBalance) {
+			function getBalance() payable returns (uint256 myBalance) {
 				return this.balance;
 			}
 			function setFlag() { flag = true; }
@@ -2069,8 +2084,8 @@ BOOST_AUTO_TEST_CASE(gas_and_value_basic)
 		}
 		contract test {
 			helper h;
-			function test() { h = new helper(); }
-			function sendAmount(uint amount) returns (uint256 bal) {
+			function test() payable { h = new helper(); }
+			function sendAmount(uint amount) payable returns (uint256 bal) {
 				return h.getBalance.value(amount)();
 			}
 			function outOfGas() returns (bool ret) {
@@ -2086,8 +2101,8 @@ BOOST_AUTO_TEST_CASE(gas_and_value_basic)
 	compileAndRun(sourceCode, 20);
 	BOOST_REQUIRE(callContractFunction("sendAmount(uint256)", 5) == encodeArgs(5));
 	// call to helper should not succeed but amount should be transferred anyway
-	BOOST_REQUIRE(callContractFunction("outOfGas()", 5) == bytes());
-	BOOST_REQUIRE(callContractFunction("checkState()", 5) == encodeArgs(false, 20 - 5));
+	BOOST_REQUIRE(callContractFunction("outOfGas()") == bytes());
+	BOOST_REQUIRE(callContractFunction("checkState()") == encodeArgs(false, 20 - 5));
 }
 
 BOOST_AUTO_TEST_CASE(gas_for_builtin)
@@ -2109,14 +2124,14 @@ BOOST_AUTO_TEST_CASE(value_complex)
 {
 	char const* sourceCode = R"(
 		contract helper {
-			function getBalance() returns (uint256 myBalance) {
+			function getBalance() payable returns (uint256 myBalance) {
 				return this.balance;
 			}
 		}
 		contract test {
 			helper h;
-			function test() { h = new helper(); }
-			function sendAmount(uint amount) returns (uint256 bal) {
+			function test() payable { h = new helper(); }
+			function sendAmount(uint amount) payable returns (uint256 bal) {
 				var x1 = h.getBalance.value(amount);
 				uint someStackElement = 20;
 				var x2 = x1.gas(1000);
@@ -2132,13 +2147,13 @@ BOOST_AUTO_TEST_CASE(value_insane)
 {
 	char const* sourceCode = R"(
 		contract helper {
-			function getBalance() returns (uint256 myBalance) {
+			function getBalance() payable returns (uint256 myBalance) {
 				return this.balance;
 			}
 		}
 		contract test {
 			helper h;
-			function test() { h = new helper(); }
+			function test() payable { h = new helper(); }
 			function sendAmount(uint amount) returns (uint256 bal) {
 				var x1 = h.getBalance.value;
 				var x2 = x1(amount).gas;
@@ -2157,7 +2172,7 @@ BOOST_AUTO_TEST_CASE(value_for_constructor)
 		contract Helper {
 			bytes3 name;
 			bool flag;
-			function Helper(bytes3 x, bool f) {
+			function Helper(bytes3 x, bool f) payable {
 				name = x;
 				flag = f;
 			}
@@ -2166,7 +2181,7 @@ BOOST_AUTO_TEST_CASE(value_for_constructor)
 		}
 		contract Main {
 			Helper h;
-			function Main() {
+			function Main() payable {
 				h = (new Helper).value(10)("abc", true);
 			}
 			function getFlag() returns (bool ret) { return h.getFlag(); }
@@ -2340,8 +2355,8 @@ BOOST_AUTO_TEST_CASE(function_modifier)
 {
 	char const* sourceCode = R"(
 		contract C {
-			function getOne() nonFree returns (uint r) { return 1; }
-			modifier nonFree { if (msg.value > 0) _ }
+			function getOne() payable nonFree returns (uint r) { return 1; }
+			modifier nonFree { if (msg.value > 0) _; }
 		}
 	)";
 	compileAndRun(sourceCode);
@@ -2353,8 +2368,8 @@ BOOST_AUTO_TEST_CASE(function_modifier_local_variables)
 {
 	char const* sourceCode = R"(
 		contract C {
-			modifier mod1 { var a = 1; var b = 2; _ }
-			modifier mod2(bool a) { if (a) return; else _ }
+			modifier mod1 { var a = 1; var b = 2; _; }
+			modifier mod2(bool a) { if (a) return; else _; }
 			function f(bool a) mod1 mod2(a) returns (uint r) { return 3; }
 		}
 	)";
@@ -2367,7 +2382,7 @@ BOOST_AUTO_TEST_CASE(function_modifier_loop)
 {
 	char const* sourceCode = R"(
 		contract C {
-			modifier repeat(uint count) { for (var i = 0; i < count; ++i) _ }
+			modifier repeat(uint count) { for (var i = 0; i < count; ++i) _; }
 			function f() repeat(10) returns (uint r) { r += 1; }
 		}
 	)";
@@ -2379,7 +2394,7 @@ BOOST_AUTO_TEST_CASE(function_modifier_multi_invocation)
 {
 	char const* sourceCode = R"(
 		contract C {
-			modifier repeat(bool twice) { if (twice) _ _ }
+			modifier repeat(bool twice) { if (twice) _; _; }
 			function f(bool twice) repeat(twice) returns (uint r) { r += 1; }
 		}
 	)";
@@ -2390,16 +2405,17 @@ BOOST_AUTO_TEST_CASE(function_modifier_multi_invocation)
 
 BOOST_AUTO_TEST_CASE(function_modifier_multi_with_return)
 {
-	// Here, the explicit return prevents the second execution
+	// Note that return sets the return variable and jumps to the end of the current function or
+	// modifier code block.
 	char const* sourceCode = R"(
 		contract C {
-			modifier repeat(bool twice) { if (twice) _ _ }
+			modifier repeat(bool twice) { if (twice) _; _; }
 			function f(bool twice) repeat(twice) returns (uint r) { r += 1; return r; }
 		}
 	)";
 	compileAndRun(sourceCode);
 	BOOST_CHECK(callContractFunction("f(bool)", false) == encodeArgs(1));
-	BOOST_CHECK(callContractFunction("f(bool)", true) == encodeArgs(1));
+	BOOST_CHECK(callContractFunction("f(bool)", true) == encodeArgs(2));
 }
 
 BOOST_AUTO_TEST_CASE(function_modifier_overriding)
@@ -2407,10 +2423,10 @@ BOOST_AUTO_TEST_CASE(function_modifier_overriding)
 	char const* sourceCode = R"(
 		contract A {
 			function f() mod returns (bool r) { return true; }
-			modifier mod { _ }
+			modifier mod { _; }
 		}
 		contract C is A {
-			modifier mod { }
+			modifier mod { if (false) _; }
 		}
 	)";
 	compileAndRun(sourceCode);
@@ -2426,12 +2442,12 @@ BOOST_AUTO_TEST_CASE(function_modifier_calling_functions_in_creation_context)
 			function f1() mod2 { data |= 0x1; }
 			function f2() { data |= 0x20; }
 			function f3() { }
-			modifier mod1 { f2(); _ }
-			modifier mod2 { f3(); }
+			modifier mod1 { f2(); _; }
+			modifier mod2 { f3(); if (false) _; }
 			function getData() returns (uint r) { return data; }
 		}
 		contract C is A {
-			modifier mod1 { f4(); _ }
+			modifier mod1 { f4(); _; }
 			function f3() { data |= 0x300; }
 			function f4() { data |= 0x4000; }
 		}
@@ -2446,32 +2462,17 @@ BOOST_AUTO_TEST_CASE(function_modifier_for_constructor)
 		contract A {
 			uint data;
 			function A() mod1 { data |= 2; }
-			modifier mod1 { data |= 1; _ }
+			modifier mod1 { data |= 1; _; }
 			function getData() returns (uint r) { return data; }
 		}
 		contract C is A {
-			modifier mod1 { data |= 4; _ }
+			modifier mod1 { data |= 4; _; }
 		}
 	)";
 	compileAndRun(sourceCode);
 	BOOST_CHECK(callContractFunction("getData()") == encodeArgs(4 | 2));
 }
 
-BOOST_AUTO_TEST_CASE(use_std_lib)
-{
-	char const* sourceCode = R"(
-		import "mortal";
-		contract Icarus is mortal { }
-	)";
-	m_addStandardSources = true;
-	u256 amount(130 * ether);
-	compileAndRun(sourceCode, amount, "Icarus");
-	u256 balanceBefore = balanceAt(m_sender);
-	BOOST_CHECK(callContractFunction("kill()") == bytes());
-	BOOST_CHECK(!addressHasCode(m_contractAddress));
-	BOOST_CHECK(balanceAt(m_sender) > balanceBefore);
-}
-
 BOOST_AUTO_TEST_CASE(crazy_elementary_typenames_on_stack)
 {
 	char const* sourceCode = R"(
@@ -2517,13 +2518,13 @@ BOOST_AUTO_TEST_CASE(fallback_function)
 	char const* sourceCode = R"(
 		contract A {
 			uint data;
-			function() returns (uint r) { data = 1; return 2; }
+			function() { data = 1; }
 			function getData() returns (uint r) { return data; }
 		}
 	)";
 	compileAndRun(sourceCode);
 	BOOST_CHECK(callContractFunction("getData()") == encodeArgs(0));
-	BOOST_CHECK(callContractFunction("") == encodeArgs(2));
+	BOOST_CHECK(callContractFunction("") == encodeArgs());
 	BOOST_CHECK(callContractFunction("getData()") == encodeArgs(1));
 }
 
@@ -2532,28 +2533,42 @@ BOOST_AUTO_TEST_CASE(inherited_fallback_function)
 	char const* sourceCode = R"(
 		contract A {
 			uint data;
-			function() returns (uint r) { data = 1; return 2; }
+			function() { data = 1; }
 			function getData() returns (uint r) { return data; }
 		}
 		contract B is A {}
 	)";
 	compileAndRun(sourceCode, 0, "B");
 	BOOST_CHECK(callContractFunction("getData()") == encodeArgs(0));
-	BOOST_CHECK(callContractFunction("") == encodeArgs(2));
+	BOOST_CHECK(callContractFunction("") == encodeArgs());
 	BOOST_CHECK(callContractFunction("getData()") == encodeArgs(1));
 }
 
+BOOST_AUTO_TEST_CASE(default_fallback_throws)
+{
+	char const* sourceCode = R"(
+		contract A {
+			function f() returns (bool) {
+				return this.call();
+			}
+		}
+	)";
+	compileAndRun(sourceCode);
+	BOOST_CHECK(callContractFunction("f()") == encodeArgs(0));
+}
+
 BOOST_AUTO_TEST_CASE(event)
 {
 	char const* sourceCode = R"(
 		contract ClientReceipt {
 			event Deposit(address indexed _from, bytes32 indexed _id, uint _value);
-			function deposit(bytes32 _id, bool _manually) {
+			function deposit(bytes32 _id, bool _manually) payable {
 				if (_manually) {
 					bytes32 s = 0x19dacbf83c5de6658e14cbf7bcae5c15eca2eedecf1c66fbca928e4d351bea0f;
 					log3(bytes32(msg.value), s, bytes32(msg.sender), _id);
-				} else
+				} else {
 					Deposit(msg.sender, _id, msg.value);
+				}
 			}
 		}
 	)";
@@ -2612,7 +2627,7 @@ BOOST_AUTO_TEST_CASE(event_anonymous_with_topics)
 	char const* sourceCode = R"(
 		contract ClientReceipt {
 			event Deposit(address indexed _from, bytes32 indexed _id, uint indexed _value, uint indexed _value2, bytes32 data) anonymous;
-			function deposit(bytes32 _id, bool _manually) {
+			function deposit(bytes32 _id, bool _manually) payable {
 				Deposit(msg.sender, _id, msg.value, 2, "abc");
 			}
 		}
@@ -2636,7 +2651,7 @@ BOOST_AUTO_TEST_CASE(event_lots_of_data)
 	char const* sourceCode = R"(
 		contract ClientReceipt {
 			event Deposit(address _from, bytes32 _id, uint _value, bool _flag);
-			function deposit(bytes32 _id) {
+			function deposit(bytes32 _id) payable {
 				Deposit(msg.sender, _id, msg.value, true);
 			}
 		}
@@ -2862,9 +2877,10 @@ BOOST_AUTO_TEST_CASE(generic_call)
 	char const* sourceCode = R"**(
 			contract receiver {
 				uint public received;
-				function receive(uint256 x) { received = x; }
+				function receive(uint256 x) payable { received = x; }
 			}
 			contract sender {
+				function sender() payable {}
 				function doSend(address rec) returns (uint d)
 				{
 					bytes4 signature = bytes4(bytes32(sha3("receive(uint256)")));
@@ -2885,10 +2901,11 @@ BOOST_AUTO_TEST_CASE(generic_callcode)
 	char const* sourceCode = R"**(
 			contract receiver {
 				uint public received;
-				function receive(uint256 x) { received = x; }
+				function receive(uint256 x) payable { received = x; }
 			}
 			contract sender {
 				uint public received;
+				function sender() payable { }
 				function doSend(address rec) returns (uint d)
 				{
 					bytes4 signature = bytes4(bytes32(sha3("receive(uint256)")));
@@ -2918,16 +2935,16 @@ BOOST_AUTO_TEST_CASE(generic_delegatecall)
 				uint public received;
 				address public sender;
 				uint public value;
-				function receive(uint256 x) { received = x; sender = msg.sender; value = msg.value; }
+				function receive(uint256 x) payable { received = x; sender = msg.sender; value = msg.value; }
 			}
 			contract sender {
 				uint public received;
 				address public sender;
 				uint public value;
-				function doSend(address rec)
+				function doSend(address rec) payable
 				{
 					bytes4 signature = bytes4(bytes32(sha3("receive(uint256)")));
-					rec.delegatecall(signature, 23);
+					if (rec.delegatecall(signature, 23)) {}
 				}
 			}
 	)**";
@@ -2990,13 +3007,13 @@ BOOST_AUTO_TEST_CASE(bytes_from_calldata_to_memory)
 {
 	char const* sourceCode = R"(
 		contract C {
-			function() returns (bytes32) {
+			function f() returns (bytes32) {
 				return sha3("abc", msg.data);
 			}
 		}
 	)";
 	compileAndRun(sourceCode);
-	bytes calldata1 = bytes(61, 0x22) + bytes(12, 0x12);
+	bytes calldata1 = FixedHash<4>(dev::sha3("f()")).asBytes() + bytes(61, 0x22) + bytes(12, 0x12);
 	sendMessage(calldata1, false);
 	BOOST_CHECK(m_output == encodeArgs(dev::sha3(bytes{'a', 'b', 'c'} + calldata1)));
 }
@@ -3012,7 +3029,7 @@ BOOST_AUTO_TEST_CASE(call_forward_bytes)
 		contract sender {
 			function sender() { rec = new receiver(); }
 			function() { savedData = msg.data; }
-			function forward() returns (bool) { rec.call(savedData); return true; }
+			function forward() returns (bool) { !rec.call(savedData); return true; }
 			function clear() returns (bool) { delete savedData; return true; }
 			function val() returns (uint) { return rec.received(); }
 			receiver rec;
@@ -4330,12 +4347,12 @@ BOOST_AUTO_TEST_CASE(external_types_in_calls)
 				y = this.t1(C1(7));
 			}
 			function t1(C1 a) returns (C1) { return a; }
-			function() returns (C1) { return C1(9); }
+			function t2() returns (C1) { return C1(9); }
 		}
 	)";
 	compileAndRun(sourceCode, 0, "C");
 	BOOST_CHECK(callContractFunction("test()") == encodeArgs(u256(9), u256(7)));
-	BOOST_CHECK(callContractFunction("nonexisting") == encodeArgs(u256(9)));
+	BOOST_CHECK(callContractFunction("t2()") == encodeArgs(u256(9)));
 }
 
 BOOST_AUTO_TEST_CASE(proper_order_of_overwriting_of_attributes)
@@ -4608,6 +4625,26 @@ BOOST_AUTO_TEST_CASE(failing_send)
 	BOOST_REQUIRE(callContractFunction("callHelper(address)", c_helperAddress) == encodeArgs(true, 20));
 }
 
+BOOST_AUTO_TEST_CASE(send_zero_ether)
+{
+	// Sending zero ether to a contract should still invoke the fallback function
+	// (it previously did not because the gas stipend was not provided by the EVM)
+	char const* sourceCode = R"(
+		contract Receiver {
+			function () payable {
+			}
+		}
+		contract Main {
+			function s() returns (bool) {
+				var r = new Receiver();
+				return r.send(0);
+			}
+		}
+	)";
+	compileAndRun(sourceCode, 20, "Main");
+	BOOST_REQUIRE(callContractFunction("s()") == encodeArgs(true));
+}
+
 BOOST_AUTO_TEST_CASE(reusing_memory)
 {
 	// Invoke some features that use memory and test that they do not interfere with each other.
@@ -5946,6 +5983,7 @@ BOOST_AUTO_TEST_CASE(reject_ether_sent_to_library)
 			function f(address x) returns (bool) {
 				return x.send(1);
 			}
+			function () payable {}
 		}
 	)";
 	compileAndRun(sourceCode, 0, "lib");
@@ -6208,6 +6246,27 @@ BOOST_AUTO_TEST_CASE(addmod_mulmod)
 	BOOST_CHECK(callContractFunction("test()") == encodeArgs(u256(0)));
 }
 
+BOOST_AUTO_TEST_CASE(divisiod_by_zero)
+{
+	char const* sourceCode = R"(
+		contract C {
+			function div(uint a, uint b) returns (uint) {
+				return a / b;
+			}
+			function mod(uint a, uint b) returns (uint) {
+				return a % b;
+			}
+		}
+	)";
+	compileAndRun(sourceCode);
+	BOOST_CHECK(callContractFunction("div(uint256,uint256)", 7, 2) == encodeArgs(u256(3)));
+	// throws
+	BOOST_CHECK(callContractFunction("div(uint256,uint256)", 7, 0) == encodeArgs());
+	BOOST_CHECK(callContractFunction("mod(uint256,uint256)", 7, 2) == encodeArgs(u256(1)));
+	// throws
+	BOOST_CHECK(callContractFunction("mod(uint256,uint256)", 7, 0) == encodeArgs());
+}
+
 BOOST_AUTO_TEST_CASE(string_allocation_bug)
 {
 	char const* sourceCode = R"(
@@ -6839,6 +6898,33 @@ BOOST_AUTO_TEST_CASE(skip_dynamic_types_for_structs)
 	BOOST_CHECK(callContractFunction("g()") == encodeArgs(u256(2), u256(6)));
 }
 
+BOOST_AUTO_TEST_CASE(failed_create)
+{
+	char const* sourceCode = R"(
+		contract D { function D() payable {} }
+		contract C {
+			uint public x;
+			function f(uint amount) returns (address) {
+				x++;
+				return (new D).value(amount)();
+			}
+			function stack(uint depth) returns (address) {
+				if (depth < 1024)
+					return this.stack(depth - 1);
+				else
+					return f(0);
+			}
+		}
+	)";
+	compileAndRun(sourceCode, 20, "C");
+	BOOST_CHECK(callContractFunction("f(uint256)", 20) != encodeArgs(u256(0)));
+	BOOST_CHECK(callContractFunction("x()") == encodeArgs(u256(1)));
+	BOOST_CHECK(callContractFunction("f(uint256)", 20) == encodeArgs());
+	BOOST_CHECK(callContractFunction("x()") == encodeArgs(u256(1)));
+	BOOST_CHECK(callContractFunction("stack(uint256)", 1023) == encodeArgs());
+	BOOST_CHECK(callContractFunction("x()") == encodeArgs(u256(1)));
+}
+
 BOOST_AUTO_TEST_CASE(create_dynamic_array_with_zero_length)
 {
 	char const* sourceCode = R"(
@@ -6853,6 +6939,254 @@ BOOST_AUTO_TEST_CASE(create_dynamic_array_with_zero_length)
 	BOOST_CHECK(callContractFunction("f()") == encodeArgs(u256(7)));
 }
 
+BOOST_AUTO_TEST_CASE(return_does_not_skip_modifier)
+{
+	char const* sourceCode = R"(
+		contract C {
+			uint public x;
+			modifier setsx {
+				_;
+				x = 9;
+			}
+			function f() setsx returns (uint) {
+				return 2;
+			}
+		}
+	)";
+	compileAndRun(sourceCode, 0, "C");
+	BOOST_CHECK(callContractFunction("x()") == encodeArgs(u256(0)));
+	BOOST_CHECK(callContractFunction("f()") == encodeArgs(u256(2)));
+	BOOST_CHECK(callContractFunction("x()") == encodeArgs(u256(9)));
+}
+
+BOOST_AUTO_TEST_CASE(break_in_modifier)
+{
+	char const* sourceCode = R"(
+		contract C {
+			uint public x;
+			modifier run() {
+				for (uint i = 0; i < 10; i++) {
+					_;
+					break;
+				}
+			}
+			function f() run {
+				x++;
+			}
+		}
+	)";
+	compileAndRun(sourceCode, 0, "C");
+	BOOST_CHECK(callContractFunction("x()") == encodeArgs(u256(0)));
+	BOOST_CHECK(callContractFunction("f()") == encodeArgs());
+	BOOST_CHECK(callContractFunction("x()") == encodeArgs(u256(1)));
+}
+
+BOOST_AUTO_TEST_CASE(stacked_return_with_modifiers)
+{
+	char const* sourceCode = R"(
+		contract C {
+			uint public x;
+			modifier run() {
+				for (uint i = 0; i < 10; i++) {
+					_;
+					break;
+				}
+			}
+			function f() run {
+				x++;
+			}
+		}
+	)";
+	compileAndRun(sourceCode, 0, "C");
+	BOOST_CHECK(callContractFunction("x()") == encodeArgs(u256(0)));
+	BOOST_CHECK(callContractFunction("f()") == encodeArgs());
+	BOOST_CHECK(callContractFunction("x()") == encodeArgs(u256(1)));
+}
+
+BOOST_AUTO_TEST_CASE(mutex)
+{
+	char const* sourceCode = R"(
+		contract mutexed {
+			bool locked;
+			modifier protected {
+				if (locked) throw;
+				locked = true;
+				_;
+				locked = false;
+			}
+		}
+		contract Fund is mutexed {
+			uint shares;
+			function Fund() { shares = msg.value; }
+			function withdraw(uint amount) protected returns (uint) {
+				// NOTE: It is very bad practice to write this function this way.
+				// Please refer to the documentation of how to do this properly.
+				if (amount > shares) throw;
+				if (!msg.sender.call.value(amount)()) throw;
+				shares -= amount;
+				return shares;
+			}
+			function withdrawUnprotected(uint amount) returns (uint) {
+				// NOTE: It is very bad practice to write this function this way.
+				// Please refer to the documentation of how to do this properly.
+				if (amount > shares) throw;
+				if (!msg.sender.call.value(amount)()) throw;
+				shares -= amount;
+				return shares;
+			}
+		}
+		contract Attacker {
+			Fund public fund;
+			uint callDepth;
+			bool protected;
+			function setProtected(bool _protected) { protected = _protected; }
+			function Attacker(Fund _fund) { fund = _fund; }
+			function attack() returns (uint) {
+				callDepth = 0;
+				return attackInternal();
+			}
+			function attackInternal() internal returns (uint) {
+				if (protected)
+					return fund.withdraw(10);
+				else
+					return fund.withdrawUnprotected(10);
+			}
+			function() payable {
+				callDepth++;
+				if (callDepth < 4)
+					attackInternal();
+			}
+		}
+	)";
+	compileAndRun(sourceCode, 500, "Fund");
+	auto fund = m_contractAddress;
+	BOOST_CHECK_EQUAL(balanceAt(fund), 500);
+	compileAndRun(sourceCode, 0, "Attacker", encodeArgs(u160(fund)));
+	BOOST_CHECK(callContractFunction("setProtected(bool)", true) == encodeArgs());
+	BOOST_CHECK(callContractFunction("attack()") == encodeArgs());
+	BOOST_CHECK_EQUAL(balanceAt(fund), 500);
+	BOOST_CHECK(callContractFunction("setProtected(bool)", false) == encodeArgs());
+	BOOST_CHECK(callContractFunction("attack()") == encodeArgs(u256(460)));
+	BOOST_CHECK_EQUAL(balanceAt(fund), 460);
+}
+
+BOOST_AUTO_TEST_CASE(failing_ecrecover_invalid_input)
+{
+	// ecrecover should return zero for malformed input
+	// (v should be 27 or 28, not 1)
+	// Note that the precompile does not return zero but returns nothing.
+	char const* sourceCode = R"(
+		contract C {
+			function f() returns (address) {
+				return ecrecover(bytes32(uint(-1)), 1, 2, 3);
+			}
+		}
+	)";
+	compileAndRun(sourceCode, 0, "C");
+	BOOST_CHECK(callContractFunction("f()") == encodeArgs(u256(0)));
+}
+
+BOOST_AUTO_TEST_CASE(calling_nonexisting_contract_throws)
+{
+	char const* sourceCode = R"(
+		contract D { function g(); }
+		contract C {
+			D d = D(0x1212);
+			function f() returns (uint) {
+				d.g();
+				return 7;
+			}
+			function g() returns (uint) {
+				d.g.gas(200)();
+				return 7;
+			}
+			function h() returns (uint) {
+				d.call(); // this does not throw (low-level)
+				return 7;
+			}
+		}
+	)";
+	compileAndRun(sourceCode, 0, "C");
+	BOOST_CHECK(callContractFunction("f()") == encodeArgs());
+	BOOST_CHECK(callContractFunction("g()") == encodeArgs());
+	BOOST_CHECK(callContractFunction("h()") == encodeArgs(u256(7)));
+}
+
+BOOST_AUTO_TEST_CASE(payable_constructor)
+{
+	char const* sourceCode = R"(
+		contract C {
+			function C() payable { }
+		}
+	)";
+	compileAndRun(sourceCode, 27, "C");
+}
+
+BOOST_AUTO_TEST_CASE(payable_function)
+{
+	char const* sourceCode = R"(
+		contract C {
+			uint public a;
+			function f() payable returns (uint) {
+				return msg.value;
+			}
+			function() payable {
+				a = msg.value + 1;
+			}
+		}
+	)";
+	compileAndRun(sourceCode, 0, "C");
+	BOOST_CHECK(callContractFunctionWithValue("f()", 27) == encodeArgs(u256(27)));
+	BOOST_CHECK_EQUAL(balanceAt(m_contractAddress), 27);
+	BOOST_CHECK(callContractFunctionWithValue("", 27) == encodeArgs());
+	BOOST_CHECK_EQUAL(balanceAt(m_contractAddress), 27 + 27);
+	BOOST_CHECK(callContractFunction("a()") == encodeArgs(u256(28)));
+	BOOST_CHECK_EQUAL(balanceAt(m_contractAddress), 27 + 27);
+}
+
+BOOST_AUTO_TEST_CASE(non_payable_throw)
+{
+	char const* sourceCode = R"(
+		contract C {
+			uint public a;
+			function f() returns (uint) {
+				return msg.value;
+			}
+			function() {
+				a = msg.value + 1;
+			}
+		}
+	)";
+	compileAndRun(sourceCode, 0, "C");
+	BOOST_CHECK(callContractFunctionWithValue("f()", 27) == encodeArgs());
+	BOOST_CHECK_EQUAL(balanceAt(m_contractAddress), 0);
+	BOOST_CHECK(callContractFunction("") == encodeArgs());
+	BOOST_CHECK(callContractFunction("a()") == encodeArgs(u256(1)));
+	BOOST_CHECK(callContractFunctionWithValue("", 27) == encodeArgs());
+	BOOST_CHECK_EQUAL(balanceAt(m_contractAddress), 0);
+	BOOST_CHECK(callContractFunction("a()") == encodeArgs(u256(1)));
+	BOOST_CHECK(callContractFunctionWithValue("a()", 27) == encodeArgs());
+	BOOST_CHECK_EQUAL(balanceAt(m_contractAddress), 0);
+}
+
+BOOST_AUTO_TEST_CASE(no_nonpayable_circumvention_by_modifier)
+{
+	char const* sourceCode = R"(
+		contract C {
+			modifier tryCircumvent {
+				if (false) _; // avoid the function, we should still not accept ether
+			}
+			function f() tryCircumvent returns (uint) {
+				return msg.value;
+			}
+		}
+	)";
+	compileAndRun(sourceCode);
+	BOOST_CHECK(callContractFunctionWithValue("f()", 27) == encodeArgs());
+	BOOST_CHECK_EQUAL(balanceAt(m_contractAddress), 0);
+}
+
+
 BOOST_AUTO_TEST_SUITE_END()
 
 }
diff --git a/test/libsolidity/SolidityExecutionFramework.cpp b/test/libsolidity/SolidityExecutionFramework.cpp
index 921fd056..02548121 100644
--- a/test/libsolidity/SolidityExecutionFramework.cpp
+++ b/test/libsolidity/SolidityExecutionFramework.cpp
@@ -39,10 +39,7 @@ string getIPCSocketPath()
 {
 	string ipcPath = dev::test::Options::get().ipcPath;
 	if (ipcPath.empty())
-		if (auto path = getenv("ETH_TEST_IPC"))
-			ipcPath = path;
-	if (ipcPath.empty())
-		BOOST_FAIL("ERROR: ipcPath not set! (use --ipc <path> or the environment variable ETH_TEST_IPC)");
+		BOOST_FAIL("ERROR: ipcPath not set! (use --ipcpath <path> or the environment variable ETH_TEST_IPC)");
 
 	return ipcPath;
 }
diff --git a/test/libsolidity/SolidityExecutionFramework.h b/test/libsolidity/SolidityExecutionFramework.h
index 5764784a..6cf7e0ee 100644
--- a/test/libsolidity/SolidityExecutionFramework.h
+++ b/test/libsolidity/SolidityExecutionFramework.h
@@ -33,6 +33,7 @@
 
 #include <libsolidity/interface/CompilerStack.h>
 #include <libsolidity/interface/Exceptions.h>
+#include <libsolidity/interface/SourceReferenceFormatter.h>
 
 namespace dev
 {
@@ -66,9 +67,21 @@ public:
 		std::map<std::string, Address> const& _libraryAddresses = std::map<std::string, Address>()
 	)
 	{
-		m_compiler.reset(false, m_addStandardSources);
-		m_compiler.addSource("", _sourceCode);
-		ETH_TEST_REQUIRE_NO_THROW(m_compiler.compile(m_optimize, m_optimizeRuns), "Compiling contract failed");
+		// Silence compiler version warning
+		std::string sourceCode = "pragma solidity >=0.0;\n" + _sourceCode;
+		m_compiler.reset(false);
+		m_compiler.addSource("", sourceCode);
+		if (!m_compiler.compile(m_optimize, m_optimizeRuns))
+		{
+			for (auto const& error: m_compiler.errors())
+				SourceReferenceFormatter::printExceptionInformation(
+					std::cerr,
+					*error,
+					(error->type() == Error::Type::Warning) ? "Warning" : "Error",
+					[&](std::string const& _sourceName) -> solidity::Scanner const& { return m_compiler.scanner(_sourceName); }
+				);
+			BOOST_ERROR("Compiling contract failed");
+		}
 		eth::LinkerObject obj = m_compiler.object(_contractName);
 		obj.link(_libraryAddresses);
 		BOOST_REQUIRE(obj.linkReferences.empty());
@@ -279,7 +292,6 @@ protected:
 
 	size_t m_optimizeRuns = 200;
 	bool m_optimize = false;
-	bool m_addStandardSources = false;
 	dev::solidity::CompilerStack m_compiler;
 	Address m_sender;
 	Address m_contractAddress;
diff --git a/test/libsolidity/SolidityExpressionCompiler.cpp b/test/libsolidity/SolidityExpressionCompiler.cpp
index 967b2907..e9a05745 100644
--- a/test/libsolidity/SolidityExpressionCompiler.cpp
+++ b/test/libsolidity/SolidityExpressionCompiler.cpp
@@ -323,7 +323,15 @@ BOOST_AUTO_TEST_CASE(arithmetics)
 					   byte(Instruction::OR),
 					   byte(Instruction::SUB),
 					   byte(Instruction::ADD),
+					   byte(Instruction::DUP2),
+					   byte(Instruction::ISZERO),
+					   byte(Instruction::PUSH1), 0x2,
+					   byte(Instruction::JUMPI),
 					   byte(Instruction::MOD),
+					   byte(Instruction::DUP2),
+					   byte(Instruction::ISZERO),
+					   byte(Instruction::PUSH1), 0x2,
+					   byte(Instruction::JUMPI),
 					   byte(Instruction::DIV),
 					   byte(Instruction::MUL)});
 	BOOST_CHECK_EQUAL_COLLECTIONS(code.begin(), code.end(), expectation.begin(), expectation.end());
diff --git a/test/libsolidity/SolidityInterface.cpp b/test/libsolidity/SolidityInterface.cpp
deleted file mode 100644
index 9a1c104d..00000000
--- a/test/libsolidity/SolidityInterface.cpp
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
-	This file is part of cpp-ethereum.
-
-	cpp-ethereum is free software: you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation, either version 3 of the License, or
-	(at your option) any later version.
-
-	cpp-ethereum is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.
- */
-/**
- * @author Christian <c@ethdev.com>
- * @date 2015
- * Unit tests for generating source interfaces for Solidity contracts.
- */
-
-#include "../TestHelper.h"
-#include <libsolidity/interface/CompilerStack.h>
-#include <libsolidity/ast/AST.h>
-
-using namespace std;
-
-namespace dev
-{
-namespace solidity
-{
-namespace test
-{
-
-class SolidityInterfaceChecker
-{
-public:
-	SolidityInterfaceChecker(): m_compilerStack(false) {}
-
-	/// Compiles the given code, generates the interface and parses that again.
-	ContractDefinition const& checkInterface(string const& _code, string const& _contractName = "")
-	{
-		m_code = _code;
-		ETH_TEST_REQUIRE_NO_THROW(m_compilerStack.parse(_code), "Parsing failed");
-		m_interface = m_compilerStack.metadata("", DocumentationType::ABISolidityInterface);
-		ETH_TEST_REQUIRE_NO_THROW(m_reCompiler.parse(m_interface), "Interface parsing failed");
-		return m_reCompiler.contractDefinition(_contractName);
-	}
-
-	string sourcePart(ASTNode const& _node) const
-	{
-		SourceLocation location = _node.location();
-		BOOST_REQUIRE(!location.isEmpty());
-		return m_interface.substr(location.start, location.end - location.start);
-	}
-
-protected:
-	string m_code;
-	string m_interface;
-	CompilerStack m_compilerStack;
-	CompilerStack m_reCompiler;
-};
-
-BOOST_FIXTURE_TEST_SUITE(SolidityInterface, SolidityInterfaceChecker)
-
-BOOST_AUTO_TEST_CASE(empty_contract)
-{
-	ContractDefinition const& contract = checkInterface("contract test {}");
-	BOOST_CHECK_EQUAL(sourcePart(contract), "contract test{}");
-}
-
-BOOST_AUTO_TEST_CASE(single_function)
-{
-	ContractDefinition const& contract = checkInterface(
-		"contract test {\n"
-		"  function f(uint a) returns(uint d) { return a * 7; }\n"
-		"}\n");
-	BOOST_REQUIRE_EQUAL(1, contract.definedFunctions().size());
-	BOOST_CHECK_EQUAL(sourcePart(*contract.definedFunctions().front()),
-					  "function f(uint256 a)returns(uint256 d);");
-}
-
-BOOST_AUTO_TEST_CASE(single_constant_function)
-{
-	ContractDefinition const& contract = checkInterface(
-			"contract test { function f(uint a) constant returns(bytes1 x) { 1==2; } }");
-	BOOST_REQUIRE_EQUAL(1, contract.definedFunctions().size());
-	BOOST_CHECK_EQUAL(sourcePart(*contract.definedFunctions().front()),
-					  "function f(uint256 a)constant returns(bytes1 x);");
-}
-
-BOOST_AUTO_TEST_CASE(multiple_functions)
-{
-	char const* sourceCode = "contract test {\n"
-	"  function f(uint a) returns(uint d) { return a * 7; }\n"
-	"  function g(uint b) returns(uint e) { return b * 8; }\n"
-	"}\n";
-	ContractDefinition const& contract = checkInterface(sourceCode);
-	set<string> expectation({"function f(uint256 a)returns(uint256 d);",
-							 "function g(uint256 b)returns(uint256 e);"});
-	BOOST_REQUIRE_EQUAL(2, contract.definedFunctions().size());
-	BOOST_CHECK(expectation == set<string>({sourcePart(*contract.definedFunctions().at(0)),
-											sourcePart(*contract.definedFunctions().at(1))}));
-}
-
-BOOST_AUTO_TEST_CASE(exclude_fallback_function)
-{
-	char const* sourceCode = "contract test { function() {} }";
-	ContractDefinition const& contract = checkInterface(sourceCode);
-	BOOST_CHECK_EQUAL(sourcePart(contract), "contract test{}");
-}
-
-BOOST_AUTO_TEST_CASE(events)
-{
-	char const* sourceCode = "contract test {\n"
-	"  function f(uint a) returns(uint d) { return a * 7; }\n"
-	"  event e1(uint b, address indexed c); \n"
-	"  event e2(); \n"
-	"}\n";
-	ContractDefinition const& contract = checkInterface(sourceCode);
-	// events should not appear in the Solidity Interface
-	BOOST_REQUIRE_EQUAL(0, contract.events().size());
-}
-
-BOOST_AUTO_TEST_CASE(inheritance)
-{
-	char const* sourceCode =
-	"	contract Base { \n"
-	"		function baseFunction(uint p) returns (uint i) { return p; } \n"
-	"		event baseEvent(bytes32 indexed evtArgBase); \n"
-	"	} \n"
-	"	contract Derived is Base { \n"
-	"		function derivedFunction(bytes32 p) returns (bytes32 i) { return p; } \n"
-	"		event derivedEvent(uint indexed evtArgDerived); \n"
-	"	}";
-	ContractDefinition const& contract = checkInterface(sourceCode);
-	set<string> expectedFunctions({"function baseFunction(uint256 p)returns(uint256 i);",
-								   "function derivedFunction(bytes32 p)returns(bytes32 i);"});
-	BOOST_REQUIRE_EQUAL(2, contract.definedFunctions().size());
-	BOOST_CHECK(expectedFunctions == set<string>({sourcePart(*contract.definedFunctions().at(0)),
-												  sourcePart(*contract.definedFunctions().at(1))}));
-}
-
-BOOST_AUTO_TEST_CASE(libraries)
-{
-	char const* sourceCode = R"(
-		library Lib {
-			struct Str { uint a; }
-			enum E { E1, E2 }
-			function f(uint[] x,Str storage y,E z) external;
-		}
-	)";
-	ContractDefinition const& contract = checkInterface(sourceCode);
-	BOOST_CHECK(contract.isLibrary());
-	set<string> expectedFunctions({"function f(uint256[] x,Lib.Str storage y,Lib.E z);"});
-	BOOST_REQUIRE_EQUAL(1, contract.definedFunctions().size());
-	BOOST_CHECK(expectedFunctions == set<string>({sourcePart(*contract.definedFunctions().at(0))}));
-}
-
-BOOST_AUTO_TEST_SUITE_END()
-
-}
-}
-}
diff --git a/test/libsolidity/SolidityNameAndTypeResolution.cpp b/test/libsolidity/SolidityNameAndTypeResolution.cpp
index 7e81bd7e..58736025 100644
--- a/test/libsolidity/SolidityNameAndTypeResolution.cpp
+++ b/test/libsolidity/SolidityNameAndTypeResolution.cpp
@@ -45,15 +45,17 @@ namespace
 {
 
 pair<ASTPointer<SourceUnit>, std::shared_ptr<Error::Type const>>
-parseAnalyseAndReturnError(string const& _source, bool _reportWarnings = false)
+parseAnalyseAndReturnError(string const& _source, bool _reportWarnings = false, bool _insertVersionPragma = true)
 {
+	// Silence compiler version warning
+	string source = _insertVersionPragma ? "pragma solidity >=0.0;\n" + _source : _source;
 	ErrorList errors;
 	Parser parser(errors);
 	ASTPointer<SourceUnit> sourceUnit;
 	// catch exceptions for a transition period
 	try
 	{
-		sourceUnit = parser.parse(std::make_shared<Scanner>(CharStream(_source)));
+		sourceUnit = parser.parse(std::make_shared<Scanner>(CharStream(source)));
 		if(!sourceUnit)
 			return make_pair(sourceUnit, nullptr);
 
@@ -445,8 +447,8 @@ BOOST_AUTO_TEST_CASE(function_no_implementation)
 		"}\n";
 	ETH_TEST_REQUIRE_NO_THROW(sourceUnit = parseAndAnalyse(text), "Parsing and name Resolving failed");
 	std::vector<ASTPointer<ASTNode>> nodes = sourceUnit->nodes();
-	ContractDefinition* contract = dynamic_cast<ContractDefinition*>(nodes[0].get());
-	BOOST_CHECK(contract);
+	ContractDefinition* contract = dynamic_cast<ContractDefinition*>(nodes[1].get());
+	BOOST_REQUIRE(contract);
 	BOOST_CHECK(!contract->annotation().isFullyImplemented);
 	BOOST_CHECK(!contract->definedFunctions()[0]->isImplemented());
 }
@@ -460,12 +462,12 @@ BOOST_AUTO_TEST_CASE(abstract_contract)
 		)";
 	ETH_TEST_REQUIRE_NO_THROW(sourceUnit = parseAndAnalyse(text), "Parsing and name Resolving failed");
 	std::vector<ASTPointer<ASTNode>> nodes = sourceUnit->nodes();
-	ContractDefinition* base = dynamic_cast<ContractDefinition*>(nodes[0].get());
-	ContractDefinition* derived = dynamic_cast<ContractDefinition*>(nodes[1].get());
-	BOOST_CHECK(base);
+	ContractDefinition* base = dynamic_cast<ContractDefinition*>(nodes[1].get());
+	ContractDefinition* derived = dynamic_cast<ContractDefinition*>(nodes[2].get());
+	BOOST_REQUIRE(base);
 	BOOST_CHECK(!base->annotation().isFullyImplemented);
 	BOOST_CHECK(!base->definedFunctions()[0]->isImplemented());
-	BOOST_CHECK(derived);
+	BOOST_REQUIRE(derived);
 	BOOST_CHECK(derived->annotation().isFullyImplemented);
 	BOOST_CHECK(derived->definedFunctions()[0]->isImplemented());
 }
@@ -479,8 +481,8 @@ BOOST_AUTO_TEST_CASE(abstract_contract_with_overload)
 		)";
 	ETH_TEST_REQUIRE_NO_THROW(sourceUnit = parseAndAnalyse(text), "Parsing and name Resolving failed");
 	std::vector<ASTPointer<ASTNode>> nodes = sourceUnit->nodes();
-	ContractDefinition* base = dynamic_cast<ContractDefinition*>(nodes[0].get());
-	ContractDefinition* derived = dynamic_cast<ContractDefinition*>(nodes[1].get());
+	ContractDefinition* base = dynamic_cast<ContractDefinition*>(nodes[1].get());
+	ContractDefinition* derived = dynamic_cast<ContractDefinition*>(nodes[2].get());
 	BOOST_REQUIRE(base);
 	BOOST_CHECK(!base->annotation().isFullyImplemented);
 	BOOST_REQUIRE(derived);
@@ -527,9 +529,9 @@ BOOST_AUTO_TEST_CASE(abstract_contract_constructor_args_not_provided)
 		)";
 	ETH_TEST_REQUIRE_NO_THROW(sourceUnit = parseAndAnalyse(text), "Parsing and name resolving failed");
 	std::vector<ASTPointer<ASTNode>> nodes = sourceUnit->nodes();
-	BOOST_CHECK_EQUAL(nodes.size(), 3);
-	ContractDefinition* derived = dynamic_cast<ContractDefinition*>(nodes[2].get());
-	BOOST_CHECK(derived);
+	BOOST_CHECK_EQUAL(nodes.size(), 4);
+	ContractDefinition* derived = dynamic_cast<ContractDefinition*>(nodes[3].get());
+	BOOST_REQUIRE(derived);
 	BOOST_CHECK(!derived->annotation().isFullyImplemented);
 }
 
@@ -553,9 +555,9 @@ BOOST_AUTO_TEST_CASE(implement_abstract_via_constructor)
 	)";
 	ETH_TEST_REQUIRE_NO_THROW(sourceUnit = parseAndAnalyse(text), "Parsing and name resolving failed");
 	std::vector<ASTPointer<ASTNode>> nodes = sourceUnit->nodes();
-	BOOST_CHECK_EQUAL(nodes.size(), 2);
-	ContractDefinition* derived = dynamic_cast<ContractDefinition*>(nodes[1].get());
-	BOOST_CHECK(derived);
+	BOOST_CHECK_EQUAL(nodes.size(), 3);
+	ContractDefinition* derived = dynamic_cast<ContractDefinition*>(nodes[2].get());
+	BOOST_REQUIRE(derived);
 	BOOST_CHECK(!derived->annotation().isFullyImplemented);
 }
 
@@ -857,8 +859,8 @@ BOOST_AUTO_TEST_CASE(function_modifier_invocation)
 	char const* text = R"(
 		contract B {
 			function f() mod1(2, true) mod2("0123456") { }
-			modifier mod1(uint a, bool b) { if (b) _ }
-			modifier mod2(bytes7 a) { while (a == "1234567") _ }
+			modifier mod1(uint a, bool b) { if (b) _; }
+			modifier mod2(bytes7 a) { while (a == "1234567") _; }
 		}
 	)";
 	BOOST_CHECK(success(text));
@@ -869,7 +871,7 @@ BOOST_AUTO_TEST_CASE(invalid_function_modifier_type)
 	char const* text = R"(
 		contract B {
 			function f() mod1(true) { }
-			modifier mod1(uint a) { if (a > 0) _ }
+			modifier mod1(uint a) { if (a > 0) _; }
 		}
 	)";
 	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
@@ -880,8 +882,8 @@ BOOST_AUTO_TEST_CASE(function_modifier_invocation_parameters)
 	char const* text = R"(
 		contract B {
 			function f(uint8 a) mod1(a, true) mod2(r) returns (bytes7 r) { }
-			modifier mod1(uint a, bool b) { if (b) _ }
-			modifier mod2(bytes7 a) { while (a == "1234567") _ }
+			modifier mod1(uint a, bool b) { if (b) _; }
+			modifier mod2(bytes7 a) { while (a == "1234567") _; }
 		}
 	)";
 	BOOST_CHECK(success(text));
@@ -892,7 +894,7 @@ BOOST_AUTO_TEST_CASE(function_modifier_invocation_local_variables)
 	char const* text = R"(
 		contract B {
 			function f() mod(x) { uint x = 7; }
-			modifier mod(uint a) { if (a > 0) _ }
+			modifier mod(uint a) { if (a > 0) _; }
 		}
 	)";
 	BOOST_CHECK(success(text));
@@ -901,8 +903,8 @@ BOOST_AUTO_TEST_CASE(function_modifier_invocation_local_variables)
 BOOST_AUTO_TEST_CASE(legal_modifier_override)
 {
 	char const* text = R"(
-		contract A { modifier mod(uint a) {} }
-		contract B is A { modifier mod(uint a) {} }
+		contract A { modifier mod(uint a) { _; } }
+		contract B is A { modifier mod(uint a) { _; } }
 	)";
 	BOOST_CHECK(success(text));
 }
@@ -910,8 +912,8 @@ BOOST_AUTO_TEST_CASE(legal_modifier_override)
 BOOST_AUTO_TEST_CASE(illegal_modifier_override)
 {
 	char const* text = R"(
-		contract A { modifier mod(uint a) {} }
-		contract B is A { modifier mod(uint8 a) {} }
+		contract A { modifier mod(uint a) { _; } }
+		contract B is A { modifier mod(uint8 a) { _; } }
 	)";
 	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
@@ -919,8 +921,8 @@ BOOST_AUTO_TEST_CASE(illegal_modifier_override)
 BOOST_AUTO_TEST_CASE(modifier_overrides_function)
 {
 	char const* text = R"(
-		contract A { modifier mod(uint a) {} }
-		contract B is A { function mod(uint a) {} }
+		contract A { modifier mod(uint a) { _; } }
+		contract B is A { function mod(uint a) { } }
 	)";
 	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
@@ -928,8 +930,8 @@ BOOST_AUTO_TEST_CASE(modifier_overrides_function)
 BOOST_AUTO_TEST_CASE(function_overrides_modifier)
 {
 	char const* text = R"(
-		contract A { function mod(uint a) {} }
-		contract B is A { modifier mod(uint a) {} }
+		contract A { function mod(uint a) { } }
+		contract B is A { modifier mod(uint a) { _; } }
 	)";
 	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
@@ -938,8 +940,8 @@ BOOST_AUTO_TEST_CASE(modifier_returns_value)
 {
 	char const* text = R"(
 		contract A {
-			function f(uint a) mod(2) returns (uint r) {}
-			modifier mod(uint a) { return 7; }
+			function f(uint a) mod(2) returns (uint r) { }
+			modifier mod(uint a) { _; return 7; }
 		}
 	)";
 	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
@@ -1102,6 +1104,37 @@ BOOST_AUTO_TEST_CASE(fallback_function_with_arguments)
 	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
 }
 
+BOOST_AUTO_TEST_CASE(fallback_function_in_library)
+{
+	char const* text = R"(
+		library C {
+			function() {}
+		}
+	)";
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(fallback_function_with_return_parameters)
+{
+	char const* text = R"(
+		contract C {
+			function() returns (uint) { }
+		}
+	)";
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(fallback_function_with_constant_modifier)
+{
+	char const* text = R"(
+		contract C {
+			uint x;
+			function() constant { x = 2; }
+		}
+	)";
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
+}
+
 BOOST_AUTO_TEST_CASE(fallback_function_twice)
 {
 	char const* text = R"(
@@ -3823,6 +3856,160 @@ BOOST_AUTO_TEST_CASE(unused_return_value_delegatecall)
 	BOOST_CHECK(expectError(text, true) == Error::Type::Warning);
 }
 
+BOOST_AUTO_TEST_CASE(modifier_without_underscore)
+{
+	char const* text = R"(
+		contract test {
+			modifier m() {}
+		}
+	)";
+	BOOST_CHECK(expectError(text) == Error::Type::SyntaxError);
+}
+
+BOOST_AUTO_TEST_CASE(payable_in_library)
+{
+	char const* text = R"(
+		library test {
+			function f() payable {}
+		}
+	)";
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(payable_external)
+{
+	char const* text = R"(
+		contract test {
+			function f() payable external {}
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(payable_internal)
+{
+	char const* text = R"(
+		contract test {
+			function f() payable internal {}
+		}
+	)";
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(payable_private)
+{
+	char const* text = R"(
+		contract test {
+			function f() payable private {}
+		}
+	)";
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(illegal_override_payable)
+{
+	char const* text = R"(
+		contract B { function f() payable {} }
+		contract C is B { function f() {} }
+	)";
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(illegal_override_payable_nonpayable)
+{
+	char const* text = R"(
+		contract B { function f() {} }
+		contract C is B { function f() payable {} }
+	)";
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(payable_constant_conflict)
+{
+	char const* text = R"(
+		contract C { function f() payable constant {} }
+	)";
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(calling_payable)
+{
+	char const* text = R"(
+		contract receiver { function pay() payable {} }
+		contract test {
+			funciton f() { (new receiver()).pay.value(10)(); }
+			recevier r = new receiver();
+			function g() { r.pay.value(10)(); }
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(calling_nonpayable)
+{
+	char const* text = R"(
+		contract receiver { function nopay() {} }
+		contract test {
+			function f() { (new receiver()).nopay.value(10)(); }
+		}
+	)";
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(non_payable_constructor)
+{
+	char const* text = R"(
+		contract C {
+			function C() { }
+		}
+		contract D {
+			function f() returns (uint) {
+				(new C).value(2)();
+				return 2;
+			}
+		}
+	)";
+	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(warn_nonpresent_pragma)
+{
+	char const* text = "contract C {}";
+	auto sourceAndError = parseAnalyseAndReturnError(text, true, false);
+	BOOST_REQUIRE(!!sourceAndError.second);
+	BOOST_REQUIRE(!!sourceAndError.first);
+	BOOST_CHECK(*sourceAndError.second == Error::Type::Warning);
+}
+
+BOOST_AUTO_TEST_CASE(unsatisfied_version)
+{
+	char const* text = R"(
+		pragma solidity ^99.99.0;
+	)";
+	BOOST_CHECK(expectError(text, true) == Error::Type::SyntaxError);
+}
+
+BOOST_AUTO_TEST_CASE(constant_constructor)
+{
+	char const* text = R"(
+		contract test {
+			function test() constant {}
+		}
+	)";
+	BOOST_CHECK(expectError(text, false) == Error::Type::TypeError);
+}
+
+BOOST_AUTO_TEST_CASE(external_constructor)
+{
+	char const* text = R"(
+		contract test {
+			function test() external {}
+		}
+	)";
+	BOOST_CHECK(expectError(text, false) == Error::Type::TypeError);
+}
+
+
 BOOST_AUTO_TEST_SUITE_END()
 
 }
diff --git a/test/libsolidity/SolidityNatspecJSON.cpp b/test/libsolidity/SolidityNatspecJSON.cpp
index 8c0c2098..1f74e928 100644
--- a/test/libsolidity/SolidityNatspecJSON.cpp
+++ b/test/libsolidity/SolidityNatspecJSON.cpp
@@ -37,7 +37,7 @@ namespace test
 class DocumentationChecker
 {
 public:
-	DocumentationChecker(): m_compilerStack(false) {}
+	DocumentationChecker(): m_compilerStack() {}
 
 	void checkNatspec(
 		std::string const& _code,
@@ -46,7 +46,7 @@ public:
 	)
 	{
 		std::string generatedDocumentationString;
-		ETH_TEST_REQUIRE_NO_THROW(m_compilerStack.parse(_code), "Parsing failed");
+		ETH_TEST_REQUIRE_NO_THROW(m_compilerStack.parse("pragma solidity >=0.0;\n" + _code), "Parsing failed");
 
 		if (_userDocumentation)
 			generatedDocumentationString = m_compilerStack.metadata("", DocumentationType::NatspecUser);
diff --git a/test/libsolidity/SolidityParser.cpp b/test/libsolidity/SolidityParser.cpp
index 909d18c9..a81a9828 100644
--- a/test/libsolidity/SolidityParser.cpp
+++ b/test/libsolidity/SolidityParser.cpp
@@ -540,7 +540,7 @@ BOOST_AUTO_TEST_CASE(if_statement)
 {
 	char const* text = "contract test {\n"
 					   "  function fun(uint256 a) {\n"
-					   "    if (a >= 8) return 2; else { var b = 7; }\n"
+					   "    if (a >= 8) { return 2; } else { var b = 7; }\n"
 					   "  }\n"
 					   "}\n";
 	BOOST_CHECK(successParse(text));
@@ -681,15 +681,23 @@ BOOST_AUTO_TEST_CASE(placeholder_in_function_context)
 BOOST_AUTO_TEST_CASE(modifier)
 {
 	char const* text = "contract c {\n"
-					   "  modifier mod { if (msg.sender == 0) _ }\n"
+					   "  modifier mod { if (msg.sender == 0) _; }\n"
 					   "}\n";
 	BOOST_CHECK(successParse(text));
 }
 
+BOOST_AUTO_TEST_CASE(modifier_without_semicolon)
+{
+	char const* text = "contract c {\n"
+					   "  modifier mod { if (msg.sender == 0) _ }\n"
+					   "}\n";
+	BOOST_CHECK(!successParse(text));
+}
+
 BOOST_AUTO_TEST_CASE(modifier_arguments)
 {
 	char const* text = "contract c {\n"
-					   "  modifier mod(uint a) { if (msg.sender == a) _ }\n"
+					   "  modifier mod(uint a) { if (msg.sender == a) _; }\n"
 					   "}\n";
 	BOOST_CHECK(successParse(text));
 }
@@ -697,8 +705,8 @@ BOOST_AUTO_TEST_CASE(modifier_arguments)
 BOOST_AUTO_TEST_CASE(modifier_invocation)
 {
 	char const* text = "contract c {\n"
-					   "  modifier mod1(uint a) { if (msg.sender == a) _ }\n"
-					   "  modifier mod2 { if (msg.sender == 2) _ }\n"
+					   "  modifier mod1(uint a) { if (msg.sender == a) _; }\n"
+					   "  modifier mod2 { if (msg.sender == 2) _; }\n"
 					   "  function f() mod1(7) mod2 { }\n"
 					   "}\n";
 	BOOST_CHECK(successParse(text));
@@ -1223,6 +1231,16 @@ BOOST_AUTO_TEST_CASE(invalid_fixed_conversion_leading_zeroes_check)
 	BOOST_CHECK(!successParse(text));
 }
 
+BOOST_AUTO_TEST_CASE(payable_accessor)
+{
+	char const* text = R"(
+		contract test {
+			uint payable x;
+		}
+	)";
+	BOOST_CHECK(!successParse(text));
+}
+
 BOOST_AUTO_TEST_SUITE_END()
 
 }
diff --git a/test/libsolidity/SolidityScanner.cpp b/test/libsolidity/SolidityScanner.cpp
index 4443b9f6..31b75f25 100644
--- a/test/libsolidity/SolidityScanner.cpp
+++ b/test/libsolidity/SolidityScanner.cpp
@@ -275,12 +275,6 @@ BOOST_AUTO_TEST_CASE(time_subdenominations)
 	BOOST_CHECK_EQUAL(scanner.next(), Token::SubYear);
 }
 
-BOOST_AUTO_TEST_CASE(time_after)
-{
-	Scanner scanner(CharStream("after 1"));
-	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::After);
-}
-
 BOOST_AUTO_TEST_CASE(empty_comment)
 {
 	Scanner scanner(CharStream("//\ncontract{}"));
@@ -330,6 +324,42 @@ BOOST_AUTO_TEST_CASE(invalid_short_unicode_string_escape)
 	BOOST_CHECK_EQUAL(scanner.next(), Token::Illegal);
 }
 
+BOOST_AUTO_TEST_CASE(valid_hex_literal)
+{
+	Scanner scanner(CharStream("{ hex\"00112233FF\""));
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::LBrace);
+	BOOST_CHECK_EQUAL(scanner.next(), Token::StringLiteral);
+	BOOST_CHECK_EQUAL(scanner.currentLiteral(), std::string("\x00\x11\x22\x33\xFF", 5));
+}
+
+BOOST_AUTO_TEST_CASE(invalid_short_hex_literal)
+{
+	Scanner scanner(CharStream("{ hex\"00112233F\""));
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::LBrace);
+	BOOST_CHECK_EQUAL(scanner.next(), Token::Illegal);
+}
+
+BOOST_AUTO_TEST_CASE(invalid_hex_literal_with_space)
+{
+	Scanner scanner(CharStream("{ hex\"00112233FF \""));
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::LBrace);
+	BOOST_CHECK_EQUAL(scanner.next(), Token::Illegal);
+}
+
+BOOST_AUTO_TEST_CASE(invalid_hex_literal_with_wrong_quotes)
+{
+	Scanner scanner(CharStream("{ hex\"00112233FF'"));
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::LBrace);
+	BOOST_CHECK_EQUAL(scanner.next(), Token::Illegal);
+}
+
+BOOST_AUTO_TEST_CASE(invalid_hex_literal_nonhex_string)
+{
+	Scanner scanner(CharStream("{ hex\"hello\""));
+	BOOST_CHECK_EQUAL(scanner.currentToken(), Token::LBrace);
+	BOOST_CHECK_EQUAL(scanner.next(), Token::Illegal);
+}
+
 
 BOOST_AUTO_TEST_SUITE_END()
 
