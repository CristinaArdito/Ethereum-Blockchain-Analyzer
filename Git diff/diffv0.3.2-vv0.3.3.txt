diff --git a/.travis.yml b/.travis.yml
new file mode 100644
index 00000000..07458841
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,11 @@
+# This is used to verify that the documentation compiles.
+language: python
+python:
+  - "2.7"
+# command to install dependencies
+install: "pip install -q Sphinx==1.1.3 --use-mirrors"
+# command to run tests
+script: cd docs && sphinx-build -nW -b html -d _build/doctrees . _build/html
+# Flags used here, not in `make html`:
+#  -n   Run in nit-picky mode. Currently, this generates warnings for all missing references.
+#  -W   Turn warnings into errors. This means that the build stops at the first warning and sphinx-build exits with exit status 1.
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 8120847b..7d0e3f66 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -8,7 +8,7 @@ include(EthPolicy)
 eth_policy()
 
 # project name and version should be set after cmake_policy CMP0048
-set(PROJECT_VERSION "0.3.2")
+set(PROJECT_VERSION "0.3.3")
 project(solidity VERSION ${PROJECT_VERSION})
 
 # Let's find our dependencies
diff --git a/README.md b/README.md
index 217b7f23..a1a524d8 100644
--- a/README.md
+++ b/README.md
@@ -4,9 +4,7 @@
 
 To get started you can find a basic introduction to the language in the [Solidity Documentation](https://solidity.readthedocs.org).
 
-You can start using [Solidity in your browser](https://chriseth.github.io/browser-solidity/) with no need to download or compile anything. This application only supports compilation - if you want to inject it into the blockchain, you have to use a client like [Geth](https://github.com/ethereum/go-ethereum/wiki) or [AlethZero](https://github.com/ethereum/alethzero).
-
-Also check out more documentations for [Solidity ABI](https://github.com/ethereum/wiki/wiki/Solidity,-Docs-and-ABI) and a crowdfunding [example contract](https://github.com/chriseth/cpp-ethereum/wiki/Crowdfunding-example-contract-in-Solidity) written in Solidity.
+You can start using [Solidity in your browser](https://ethereum.github.io/browser-solidity/) with no need to download or compile anything.
 
 [Changelog](https://github.com/ethereum/wiki/wiki/Solidity-Changelog)
 
diff --git a/docs/common-patterns.rst b/docs/common-patterns.rst
index f4794221..679552ff 100644
--- a/docs/common-patterns.rst
+++ b/docs/common-patterns.rst
@@ -179,6 +179,7 @@ function finishes.
             AreWeDoneYet,
             Finished
         }
+
         // This is the current stage.
         Stages public stage = Stages.AcceptingBlindedBids;
 
@@ -188,9 +189,11 @@ function finishes.
             if (stage != _stage) throw;
             _
         }
+
         function nextStage() internal {
             stage = Stages(uint(stage) + 1);
         }
+
         // Perform timed transitions. Be sure to mention
         // this modifier first, otherwise the guards
         // will not take the new stage into account.
@@ -203,7 +206,7 @@ function finishes.
                 nextStage();
             // The other stages transition by transaction
         }
-        
+
         // Order of the modifiers matters here!
         function bid()
             timedTransitions
@@ -211,6 +214,7 @@ function finishes.
         {
             // We will not implement that here
         }
+
         function reveal()
             timedTransitions
             atStage(Stages.RevealBids)
@@ -227,6 +231,7 @@ function finishes.
             _
             nextStage();
         }
+
         function g()
             timedTransitions
             atStage(Stages.AnotherStage)
@@ -235,12 +240,14 @@ function finishes.
             // If you want to use `return` here,
             // you have to call `nextStage()` manually.
         }
+
         function h()
             timedTransitions
             atStage(Stages.AreWeDoneYet)
             transitionNext
         {
         }
+
         function i()
             timedTransitions
             atStage(Stages.Finished)
diff --git a/docs/conf.py b/docs/conf.py
index 48664344..8776ec43 100644
--- a/docs/conf.py
+++ b/docs/conf.py
@@ -134,7 +134,7 @@ html_theme = 'default'
 # Add any paths that contain custom static files (such as style sheets) here,
 # relative to this directory. They are copied after the builtin static files,
 # so a file named "default.css" will overwrite the builtin "default.css".
-html_static_path = ['_static']
+html_static_path = []
 
 # Add any extra paths that contain custom files (such as robots.txt or
 # .htaccess) here, relative to this directory. These files are copied
diff --git a/docs/contracts.rst b/docs/contracts.rst
index 2ab03849..1fd23732 100644
--- a/docs/contracts.rst
+++ b/docs/contracts.rst
@@ -25,27 +25,28 @@ API, this is done as follows::
 
     // The json abi array generated by the compiler
     var abiArray = [
-      {
-        "inputs":[
-          {"name":"x","type":"uint256"},
-          {"name":"y","type":"uint256"}
-        ],
-        "type":"constructor"
-      },
-      {
-        "constant":true,
-        "inputs":[],
-        "name":"x",
-        "outputs":[{"name":"","type":"bytes32"}],
-        "type":"function"
-      }
+        {
+            "inputs":[
+                {"name":"x","type":"uint256"},
+                {"name":"y","type":"uint256"}
+            ],
+            "type":"constructor"
+        },
+        {
+            "constant":true,
+            "inputs":[],
+            "name":"x",
+            "outputs":[{"name":"","type":"bytes32"}],
+            "type":"function"
+        }
     ];
 
     var MyContract = web3.eth.contract(abiArray);
     // deploy new contract
     var contractInstance = MyContract.new(
-      10,
-      {from: myAccount, gas: 1000000}
+        10,
+        11,
+        {from: myAccount, gas: 1000000}
     );
 
 .. index:: constructor;arguments
@@ -67,6 +68,7 @@ This means that cyclic creation dependencies are impossible.
         TokenCreator creator;
         address owner;
         bytes32 name;
+
         // This is the constructor which registers the
         // creator and the assigned name.
         function OwnedToken(bytes32 _name) {
@@ -78,12 +80,15 @@ This means that cyclic creation dependencies are impossible.
             creator = TokenCreator(msg.sender);
             name = _name;
         }
+
         function changeName(bytes32 newName) {
             // Only the creator can alter the name --
             // the comparison is possible since contracts
             // are implicitly convertible to addresses.
-            if (msg.sender == creator) name = newName;
+            if (msg.sender == creator)
+                name = newName;
         }
+
         function transfer(address newOwner) {
             // Only the current owner can transfer the token.
             if (msg.sender != owner) return;
@@ -107,11 +112,13 @@ This means that cyclic creation dependencies are impossible.
             // the ABI.
             return new OwnedToken(name);
         }
+
         function changeName(OwnedToken tokenAddress, bytes32 name) {
             // Again, the external type of "tokenAddress" is
             // simply "address".
             tokenAddress.changeName(name);
         }
+
         function isTokenTransferOK(
             address currentOwner,
             address newOwner
@@ -178,7 +185,7 @@ return parameter list for functions.
 
 ::
 
-    contract c {
+    contract C {
         function f(uint a) private returns (uint b) { return a + 1; }
         function setData(uint a) internal { data = a; }
         uint public data;
@@ -207,7 +214,7 @@ it is a state variable and if it is accessed externally
 
 ::
 
-    contract test {
+    contract Test {
         uint public data = 42;
     }
 
@@ -215,15 +222,18 @@ The next example is a bit more complex:
 
 ::
 
-    contract complex {
-        struct Data { uint a; bytes3 b; mapping(uint => uint) map; }
-        mapping(uint => mapping(bool => Data[])) public data;
+    contract Complex {
+        struct Data {
+            uint a;
+            bytes3 b;
+            mapping (uint => uint) map;
+        }
+        mapping (uint => mapping(bool => Data[])) public data;
     }
 
 It will generate a function of the following form::
 
-    function data(uint arg1, bool arg2, uint arg3) returns (uint a, bytes3 b)
-    {
+    function data(uint arg1, bool arg2, uint arg3) returns (uint a, bytes3 b) {
         a = data[arg1][arg2][arg3].a;
         b = data[arg1][arg2][arg3].b;
     }
@@ -256,29 +266,46 @@ inheritable properties of contracts and may be overridden by derived contracts.
         // This means that if the owner calls this function, the
         // function is executed and otherwise, an exception is
         // thrown.
-        modifier onlyowner { if (msg.sender != owner) throw; _ }
+        modifier onlyOwner {
+            if (msg.sender != owner)
+                throw;
+            _
+        }
     }
+
+
     contract mortal is owned {
-        // This contract inherits the "onlyowner"-modifier from
+        // This contract inherits the "onlyOwner"-modifier from
         // "owned" and applies it to the "close"-function, which
         // causes that calls to "close" only have an effect if
         // they are made by the stored owner.
-        function close() onlyowner {
+        function close() onlyOwner {
             selfdestruct(owner);
         }
     }
+
+
     contract priced {
         // Modifiers can receive arguments:
-        modifier costs(uint price) { if (msg.value >= price) _ }
+        modifier costs(uint price) {
+            if (msg.value >= price) {
+                _
+            }
+        }
     }
+
+
     contract Register is priced, owned {
         mapping (address => bool) registeredAddresses;
         uint price;
+
         function Register(uint initialPrice) { price = initialPrice; }
+
         function register() costs(price) {
             registeredAddresses[msg.sender] = true;
         }
-        function changePrice(uint _price) onlyowner {
+
+        function changePrice(uint _price) onlyOwner {
             price = _price;
         }
     }
@@ -339,21 +366,23 @@ possible.
         uint x;
     }
 
+
     // This contract rejects any Ether sent to it. It is good
     // practise to include such a function for every contract
-    // in order not to loose Ether.
+    // in order not to lose Ether.
     contract Rejector {
         function() { throw; }
     }
 
+
     contract Caller {
-      function callTest(address testAddress) {
-          Test(testAddress).call(0xabcdef01); // hash does not exist
-          // results in Test(testAddress).x becoming == 1.
-          Rejector r = Rejector(0x123);
-          r.send(2 ether);
-          // results in r.balance == 0
-      }
+        function callTest(address testAddress) {
+            Test(testAddress).call(0xabcdef01); // hash does not exist
+            // results in Test(testAddress).x becoming == 1.
+            Rejector r = Rejector(0x123);
+            r.send(2 ether);
+            // results in r.balance == 0
+        }
     }
 
 .. index:: ! event
@@ -406,6 +435,7 @@ All non-indexed arguments will be stored in the data part of the log.
             bytes32 indexed _id,
             uint _value
         );
+
         function deposit(bytes32 _id) {
             // Any call to this function (even deeply nested) can
             // be detected from the JavaScript API by filtering
@@ -497,6 +527,7 @@ Details are given in the following example.
         address owner;
     }
 
+
     // Use "is" to derive from another contract. Derived
     // contracts can access all non-private members including
     // internal functions and state variables. These cannot be
@@ -507,6 +538,7 @@ Details are given in the following example.
         }
     }
 
+
     // These abstract contracts are only provided to make the
     // interface known to the compiler. Note the function
     // without body. If a contract does not implement all
@@ -514,11 +546,14 @@ Details are given in the following example.
     contract Config {
         function lookup(uint id) returns (address adr);
     }
+
+
     contract NameReg {
         function register(bytes32 name);
         function unregister();
      }
 
+
     // Multiple inheritance is possible. Note that "owned" is
     // also a base class of "mortal", yet there is only a single
     // instance of "owned" (as for virtual inheritance in C++).
@@ -542,6 +577,7 @@ Details are given in the following example.
         }
     }
 
+
     // If a constructor takes an argument, it needs to be
     // provided in the header (or modifier-invocation-style at
     // the constructor of the derived contract (see below)).
@@ -564,12 +600,18 @@ seen in the following example::
             if (msg.sender == owner) selfdestruct(owner);
         }
     }
+
+
     contract Base1 is mortal {
         function kill() { /* do cleanup 1 */ mortal.kill(); }
     }
+
+
     contract Base2 is mortal {
         function kill() { /* do cleanup 2 */ mortal.kill(); }
     }
+
+
     contract Final is Base1, Base2 {
     }
 
@@ -583,12 +625,18 @@ derived override, but this function will bypass
             if (msg.sender == owner) selfdestruct(owner);
         }
     }
+
+
     contract Base1 is mortal {
         function kill() { /* do cleanup 1 */ super.kill(); }
     }
+
+
     contract Base2 is mortal {
         function kill() { /* do cleanup 2 */ super.kill(); }
     }
+
+
     contract Final is Base2, Base1 {
     }
 
@@ -615,6 +663,8 @@ the base constructors. This can be done at two places::
         uint x;
         function Base(uint _x) { x = _x; }
     }
+
+
     contract Derived is Base(7) {
         function Derived(uint _y) Base(_y * _y) {
         }
@@ -667,13 +717,13 @@ Abstract Contracts
 
 Contract functions can lack an implementation as in the following example (note that the function declaration header is terminated by `;`)::
 
-    contract feline {
+    contract Feline {
         function utterance() returns (bytes32);
     }
 
 Such contracts cannot be compiled (even if they contain implemented functions alongside non-implemented functions), but they can be used as base contracts::
 
-    contract Cat is feline {
+    contract Cat is Feline {
         function utterance() returns (bytes32) { return "miaow"; }
     }
 
@@ -697,6 +747,18 @@ accessed. As a library is an isolated piece of source code, it can only access
 state variables of the calling contract if they are explicitly supplied (it
 would have to way to name them, otherwise).
 
+Libraries can be seen as implicit base contracts of the contracts that use them.
+They will not be explicitly visible in the inheritance hierarchy, but calls
+to library functions look just like calls to functions of explicit base
+contracts (`L.f()` if `L` is the name of the library). Furthermore,
+`internal` functions of libraries are visible in all contracts, just as
+if the library were a base contract. Of course, calls to internal functions
+use the internal calling convention, which means that all internal types
+can be passed and memory types will be passed by reference and not copied.
+In order to realise this in the EVM, code of internal library functions
+(and all functions called from therein) will be pulled into the calling
+contract and a regular `JUMP` call will be used instead of a `DELEGATECALL`.
+
 .. index:: using for, set
 
 The following example illustrates how to use libraries (but
@@ -709,6 +771,7 @@ more advanced example to implement a set).
       // We define a new struct datatype that will be used to
       // hold its data in the calling contract.
       struct Data { mapping(uint => bool) flags; }
+
       // Note that the first parameter is of type "storage
       // reference" and thus only its storage address and not
       // its contents is passed as part of the call.  This is a
@@ -723,6 +786,7 @@ more advanced example to implement a set).
           self.flags[value] = true;
           return true;
       }
+
       function remove(Data storage self, uint value)
           returns (bool)
       {
@@ -731,14 +795,18 @@ more advanced example to implement a set).
           self.flags[value] = false;
           return true;
       }
+
       function contains(Data storage self, uint value)
           returns (bool)
       {
           return self.flags[value];
       }
     }
+
+
     contract C {
         Set.Data knownValues;
+
         function register(uint value) {
             // The library functions can be called without a
             // specific instance of the library, since the
@@ -763,10 +831,68 @@ actual external function call is performed.
 in this call, though (prior to Homestead, `msg.sender` and
 `msg.value` changed, though).
 
+The following example shows how to use memory types and
+internal functions in libraries in order to implement
+custom types without the overhead of external function calls:
+
+::
+
+    library BigInt {
+        struct bigint {
+            uint[] limbs;
+        }
+
+        function fromUint(uint x) internal returns (bigint r) {
+            r.limbs = new uint[](1);
+            r.limbs[0] = x;
+        }
+
+        function add(bigint _a, bigint _b) internal returns (bigint r) {
+            r.limbs = new uint[](max(_a.limbs.length, _b.limbs.length));
+            uint carry = 0;
+            for (uint i = 0; i < r.limbs.length; ++i) {
+                uint a = limb(_a, i);
+                uint b = limb(_b, i);
+                r.limbs[i] = a + b + carry;
+                if (a + b < a || (a + b == uint(-1) && carry > 0))
+                    carry = 1;
+                else
+                    carry = 0;
+            }
+            if (carry > 0) {
+                // too bad, we have to add a limb
+                uint[] memory newLimbs = new uint[](r.limbs.length + 1);
+                for (i = 0; i < r.limbs.length; ++i)
+                    newLimbs[i] = r.limbs[i];
+                newLimbs[i] = carry;
+                r.limbs = newLimbs;
+            }
+        }
+
+        function limb(bigint _a, uint _limb) internal returns (uint) {
+            return _limb < _a.limbs.length ? _a.limbs[_limb] : 0;
+        }
+
+        function max(uint a, uint b) private returns (uint) {
+            return a > b ? a : b;
+        }
+    }
+
+
+    contract C {
+        using BigInt for BigInt.bigint;
+
+        function f() {
+            var x = bigint.fromUint(7);
+            var y = bigint.fromUint(uint(-1));
+            var z = x.add(y);
+        }
+    }
+
 As the compiler cannot know where the library will be
 deployed at, these addresses have to be filled into the
-final bytecode by a linker (see [Using the Commandline
-Compiler](#using-the-commandline-compiler) on how to use the
+final bytecode by a linker
+(see :ref:`commandline-compiler`) on how to use the
 commandline compiler for linking). If the addresses are not
 given as arguments to the compiler, the compiled hex code
 will contain placeholders of the form `__Set______` (where
@@ -816,6 +942,7 @@ Let us rewrite the set example from the
     // This is the same code as before, just without comments
     library Set {
       struct Data { mapping(uint => bool) flags; }
+
       function insert(Data storage self, uint value)
           returns (bool)
       {
@@ -824,6 +951,7 @@ Let us rewrite the set example from the
           self.flags[value] = true;
           return true;
       }
+
       function remove(Data storage self, uint value)
           returns (bool)
       {
@@ -832,6 +960,7 @@ Let us rewrite the set example from the
           self.flags[value] = false;
           return true;
       }
+
       function contains(Data storage self, uint value)
           returns (bool)
       {
@@ -839,9 +968,11 @@ Let us rewrite the set example from the
       }
     }
 
+
     contract C {
         using Set for Set.Data; // this is the crucial change
         Set.Data knownValues;
+
         function register(uint value) {
             // Here, all variables of type Set.Data have
             // corresponding member functions.
@@ -862,12 +993,15 @@ It is also possible to extend elementary types in that way::
         }
     }
 
+
     contract C {
         using Search for uint[];
         uint[] data;
+
         function append(uint value) {
             data.push(value);
         }
+
         function replace(uint _old, uint _new) {
             // This performs the library function call
             uint index = data.find(_old);
diff --git a/docs/control-structures.rst b/docs/control-structures.rst
index 2d959d1d..4b2363f5 100644
--- a/docs/control-structures.rst
+++ b/docs/control-structures.rst
@@ -31,9 +31,9 @@ Internal Function Calls
 Functions of the current contract can be called directly ("internally"), also recursively, as seen in
 this nonsensical example::
 
-    contract c {
-      function g(uint a) returns (uint ret) { return f(); }
-      function f() returns (uint ret) { return g(7) + f(); }
+    contract C {
+        function g(uint a) returns (uint ret) { return f(); }
+        function f() returns (uint ret) { return g(7) + f(); }
     }
 
 These function calls are translated into simple jumps inside the EVM. This has
@@ -51,14 +51,16 @@ all function arguments have to be copied to memory.
 
 When calling functions
 of other contracts, the amount of Wei sent with the call and the gas can be specified::
-    
+
     contract InfoFeed {
-      function info() returns (uint ret) { return 42; }
+        function info() returns (uint ret) { return 42; }
     }
+
+
     contract Consumer {
-      InfoFeed feed;
-      function setFeed(address addr) { feed = InfoFeed(addr); }
-      function callFeed() { feed.info.value(10).gas(800)(); }
+        InfoFeed feed;
+        function setFeed(address addr) { feed = InfoFeed(addr); }
+        function callFeed() { feed.info.value(10).gas(800)(); }
     }
 
 Note that the expression `InfoFeed(addr)` performs an explicit type conversion stating
@@ -75,16 +77,18 @@ of unused parameters (especially return parameters) can be omitted.
 
 ::
 
-    contract c {
-      function f(uint key, uint value) { ... }
-      function g() {
-        // named arguments
-        f({value: 2, key: 3});
-      }
-      // omitted parameters
-      function func(uint k, uint) returns(uint) {
-        return k;
-      }
+    contract C {
+        function f(uint key, uint value) { ... }
+
+        function g() {
+            // named arguments
+            f({value: 2, key: 3});
+        }
+
+        // omitted parameters
+        function func(uint k, uint) returns(uint) {
+            return k;
+        }
     }
 
 Order of Evaluation of Expressions
@@ -109,29 +113,31 @@ Destructuring Assignments and Returning Multiple Values
 Solidity internally allows tuple types, i.e. a list of objects of potentially different types whose size is a constant at compile-time. Those tuples can be used to return multiple values at the same time and also assign them to multiple variables (or LValues in general) at the same time::
 
     contract C {
-      uint[] data;
-      function f() returns (uint, bool, uint) {
-        return (7, true, 2);
-      }
-      function g() {
-        // Declares and assigns the variables. Specifying the type explicitly is not possible.
-        var (x, b, y) = f();
-        // Assigns to a pre-existing variable.
-        (x, y) = (2, 7);
-        // Common trick to swap values -- does not work for non-value storage types.
-        (x, y) = (y, x);
-        // Components can be left out (also for variable declarations).
-        // If the tuple ends in an empty component,
-        // the rest of the values are discarded.
-        (data.length,) = f(); // Sets the length to 7
-        // The same can be done on the left side.
-        (,data[3]) = f(); // Sets data[3] to 2
-        // Components can only be left out at the left-hand-side of assignments, with
-        // one exception:
-        (x,) = (1,);
-        // (1,) is the only way to specify a 1-component tuple, because (1) is
-        // equivalent to 1.
-      }
+        uint[] data;
+
+        function f() returns (uint, bool, uint) {
+            return (7, true, 2);
+        }
+
+        function g() {
+            // Declares and assigns the variables. Specifying the type explicitly is not possible.
+            var (x, b, y) = f();
+            // Assigns to a pre-existing variable.
+            (x, y) = (2, 7);
+            // Common trick to swap values -- does not work for non-value storage types.
+            (x, y) = (y, x);
+            // Components can be left out (also for variable declarations).
+            // If the tuple ends in an empty component,
+            // the rest of the values are discarded.
+            (data.length,) = f(); // Sets the length to 7
+            // The same can be done on the left side.
+            (,data[3]) = f(); // Sets data[3] to 2
+            // Components can only be left out at the left-hand-side of assignments, with
+            // one exception:
+            (x,) = (1,);
+            // (1,) is the only way to specify a 1-component tuple, because (1) is
+            // equivalent to 1.
+        }
     }
 
 Complications for Arrays and Structs
@@ -142,6 +148,63 @@ Assigning *to* a state variable always creates an independent copy. On the other
 
 .. index:: ! exception, ! throw
 
+Scoping and Declarations
+========================
+
+.. index:: ! scoping, ! declarations
+
+In Solidity, a variable declared anywhere within a function will be in scope for the *entire function*, regardless of where it is declared.
+This happens because Solidity inherits its scoping rules from JavaScript.
+This is in contrast to many languages where variables are only scoped where they are declared until the end of the semantic block.
+As a result, the following code is illegal and cause the compiler to throw an error, `Identifier already declared`::
+
+    contract ScopingErrors {
+        function scoping() {
+            uint i = 0;
+
+            while (i++ < 1) {
+                uint same1 = 0;
+            }
+
+            while (i++ < 2) {
+                uint same1 = 0;// Illegal, second declaration of same1
+            }
+        }
+
+        function minimalScoping() {
+            {
+                uint same2 = 0;
+            }
+
+            {
+                uint same2 = 0;// Illegal, second declaration of same2
+            }
+        }
+
+        function forLoopScoping() {
+            for (uint same3 = 0; same3 < 1; same3++) {
+            }
+
+            for (uint same3 = 0; same3 < 1; same3++) {// Illegal, second declaration of same3
+            }
+        }
+    }
+
+In addition to this, if a variable is declared, it will be initialized at the beginning of the function to its default value.
+As a result, the following code is legal, despite being poorly written::
+
+    function foo() returns (uint) {
+        // baz is implicitly initialized as 0
+        uint bar = 5;
+        if (true) {
+            bar += baz;
+        }
+        else {
+            uint baz = 10;// never executes
+        }
+        return bar;// returns 5
+    }
+
 Exceptions
 ==========
 
@@ -153,7 +216,7 @@ In the following example, we show how `throw` can be used to easily revert an Et
 
     contract Sharer {
         function sendHalf(address addr) returns (uint balance) {
-            if (!addr.send(msg.value/2))
+            if (!addr.send(msg.value / 2))
                 throw; // also reverts the transfer to Sharer
             return this.balance;
         }
@@ -187,8 +250,8 @@ arising when writing manual assembly by the following features:
 We now want to describe the inline assembly language in detail.
 
 .. warning::
-	Inline assembly is still a relatively new feature and might change if it does not prove useful,
-	so please try to keep up to date.
+    Inline assembly is still a relatively new feature and might change if it does not prove useful,
+    so please try to keep up to date.
 
 Example
 -------
@@ -199,46 +262,50 @@ idea is that assembly libraries will be used to enhance the language in such way
 
 .. code::
 
-	library GetCode {
-		function at(address _addr) returns (bytes o_code) {
-			assembly {
-				// retrieve the size of the code, this needs assembly
-				let size := extcodesize(_addr)
-				// allocate output byte array - this could also be done without assembly
-				// by using o_code = new bytes(size)
-				o_code := mload(0x40)
-				// new "memory end" including padding
-				mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), bnot(0x1f))))
-				// store length in memory
-				mstore(o_code, size)
-				// actually retrieve the code, this needs assembly
-				extcodecopy(_addr, add(o_code, 0x20), 0, size)
-			}
-		}
-	}
-
-Inline assemmbly could also be beneficial in cases where the optimizer fails to produce
+    library GetCode {
+        function at(address _addr) returns (bytes o_code) {
+            assembly {
+                // retrieve the size of the code, this needs assembly
+                let size := extcodesize(_addr)
+                // allocate output byte array - this could also be done without assembly
+                // by using o_code = new bytes(size)
+                o_code := mload(0x40)
+                // new "memory end" including padding
+                mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))
+                // store length in memory
+                mstore(o_code, size)
+                // actually retrieve the code, this needs assembly
+                extcodecopy(_addr, add(o_code, 0x20), 0, size)
+            }
+        }
+    }
+
+Inline assembly could also be beneficial in cases where the optimizer fails to produce
 efficient code. Please be aware that assembly is much more difficult to write because
 the compiler does not perform checks, so you should use it for complex things only if
 you really know what you are doing.
 
 .. code::
 
-	library VectorSum {
-		// This function is less efficient because the optimizer currently fails to
-		// remove the bounds checks in array access.
-		function sumSolidity(uint[] _data) returns (uint o_sum) {
-			for (uint i = 0; i < _data.length; ++i)
-				o_sum += _data[i];
-		}
-		// We know that we only access the array in bounds, so we can avoid the check.
-		// 0x20 needs to be added to an array because the first slot contains the
-		// array length.
-		function sumAsm(uint[] _data) returns (uint o_sum) {
-			for (uint i = 0; i < _data.length; ++i)
-				assembly { o_sum := mload(add(add(_data, 0x20), i)) }
-		}
-	}
+    library VectorSum {
+        // This function is less efficient because the optimizer currently fails to
+        // remove the bounds checks in array access.
+        function sumSolidity(uint[] _data) returns (uint o_sum) {
+            for (uint i = 0; i < _data.length; ++i)
+                o_sum += _data[i];
+        }
+
+        // We know that we only access the array in bounds, so we can avoid the check.
+        // 0x20 needs to be added to an array because the first slot contains the
+        // array length.
+        function sumAsm(uint[] _data) returns (uint o_sum) {
+            for (uint i = 0; i < _data.length; ++i) {
+                assembly {
+                    o_sum := mload(add(add(_data, 0x20), i))
+                }
+            }
+        }
+    }
 
 Syntax
 ------
@@ -273,147 +340,147 @@ In the following, `mem[a...b)` signifies the bytes of memory starting at positio
 
 The opcodes `pushi` and `jumpdest` cannot be used directly.
 
-+-----------------------+------+---------------------------------------------------------------+
-| stop                  + `-`  | stop execution, identical to return(0,0)                      |
-+-----------------------+------+---------------------------------------------------------------+
-| add(x, y)             |      | x + y                                                         |
-+-----------------------+------+---------------------------------------------------------------+
-| sub(x, y)             |      | x - y                                                         |
-+-----------------------+------+---------------------------------------------------------------+
-| mul(x, y)             |      | x * y                                                         |
-+-----------------------+------+---------------------------------------------------------------+
-| div(x, y)             |      | x / y                                                         |
-+-----------------------+------+---------------------------------------------------------------+
-| sdiv(x, y)            |      | x / y, for signed numbers in two's complement                 |
-+-----------------------+------+---------------------------------------------------------------+
-| mod(x, y)             |      | x % y                                                         |
-+-----------------------+------+---------------------------------------------------------------+
-| smod(x, y)            |      | x % y, for signed numbers in two's complement                 |
-+-----------------------+------+---------------------------------------------------------------+
-| exp(x, y)             |      | x to the power of y                                           |
-+-----------------------+------+---------------------------------------------------------------+
-| bnot(x)               |      | ~x, every bit of x is negated                                 |
-+-----------------------+------+---------------------------------------------------------------+
-| lt(x, y)              |      | 1 if x < y, 0 otherwise                                       |
-+-----------------------+------+---------------------------------------------------------------+
-| gt(x, y)              |      | 1 if x > y, 0 otherwise                                       |
-+-----------------------+------+---------------------------------------------------------------+
-| slt(x, y)             |      |1 if x < y, 0 otherwise, for signed numbers in two's complement|
-+-----------------------+------+---------------------------------------------------------------+
-| sgt(x, y)             |      |1 if x > y, 0 otherwise, for signed numbers in two's complement|
-+-----------------------+------+---------------------------------------------------------------+
-| eq(x, y)              |      | 1 if x == y, 0 otherwise                                      |
-+-----------------------+------+---------------------------------------------------------------+
-| not(x)                |      | 1 if x == 0, 0 otherwise                                      |
-+-----------------------+------+---------------------------------------------------------------+
-| and(x, y)             |      | bitwise and of x and y                                        |
-+-----------------------+------+---------------------------------------------------------------+
-| or(x, y)              |      | bitwise or of x and y                                         |
-+-----------------------+------+---------------------------------------------------------------+
-| xor(x, y)             |      | bitwise xor of x and y                                        |
-+-----------------------+------+---------------------------------------------------------------+
-| byte(n, x)            |      | nth byte of x, where the most significant byte is the 0th byte|
-+-----------------------+------+---------------------------------------------------------------+
-| addmod(x, y, m)       |      | (x + y) % m with arbitrary precision arithmetics              |
-+-----------------------+------+---------------------------------------------------------------+
-| mulmod(x, y, m)       |      | (x * y) % m with arbitrary precision arithmetics              |
-+-----------------------+------+---------------------------------------------------------------+
-| signextend(i, x)      |      | sign extend from (i*8+7)th bit counting from least significant|
-+-----------------------+------+---------------------------------------------------------------+
-| sha3(p, n)            |      | keccak(mem[p...(p+n)))                                        |
-+-----------------------+------+---------------------------------------------------------------+
-| jump(label)           | `-`  | jump to label / code position                                 |
-+-----------------------+------+---------------------------------------------------------------+
-| jumpi(label, cond)    | `-`  | jump to label if cond is nonzero                              |
-+-----------------------+------+---------------------------------------------------------------+
-| pc                    |      | current position in code                                      |
-+-----------------------+------+---------------------------------------------------------------+
-| pop                   | `*`  | remove topmost stack slot                                     |
-+-----------------------+------+---------------------------------------------------------------+
-| dup1 ... dup16        |      | copy ith stack slot to the top (counting from top)            |
-+-----------------------+------+---------------------------------------------------------------+
-| swap1 ... swap1       | `*`  | swap topmost and ith stack slot below it                      |
-+-----------------------+------+---------------------------------------------------------------+
-| mload(p)              |      | mem[p..(p+32))                                                |
-+-----------------------+------+---------------------------------------------------------------+
-| mstore(p, v)          | `-`  | mem[p..(p+32)) := v                                           |
-+-----------------------+------+---------------------------------------------------------------+
-| mstore8(p, v)         | `-`  | mem[p] := v & 0xff    - only modifies a single byte           |
-+-----------------------+------+---------------------------------------------------------------+
-| sload(p)              |      | storage[p]                                                    |
-+-----------------------+------+---------------------------------------------------------------+
-| sstore(p, v)          | `-`  | storage[p] := v                                               |
-+-----------------------+------+---------------------------------------------------------------+
-| msize                 |      | size of memory, i.e. largest accessed memory index            |
-+-----------------------+------+---------------------------------------------------------------+
-| gas                   |      | gas still available to execution                              |
-+-----------------------+------+---------------------------------------------------------------+
-| address               |      | address of the current contract / execution context           |
-+-----------------------+------+---------------------------------------------------------------+
-| balance(a)            |      | wei balance at address a                                      |
-+-----------------------+------+---------------------------------------------------------------+
-| caller                |      | call sender (excluding delegatecall)                          |
-+-----------------------+------+---------------------------------------------------------------+
-| callvalue             |      | wei sent together with the current call                       |
-+-----------------------+------+---------------------------------------------------------------+
-| calldataload(p)       |      | call data starting from position p (32 bytes)                 |
-+-----------------------+------+---------------------------------------------------------------+
-| calldatasize          |      | size of call data in bytes                                    |
-+-----------------------+------+---------------------------------------------------------------+
-| calldatacopy(t, f, s) | `-`  | copy s bytes from calldata at position f to mem at position t |
-+-----------------------+------+---------------------------------------------------------------+
-| codesize              |      | size of the code of the current contract / execution context  |
-+-----------------------+------+---------------------------------------------------------------+
-| codecopy(t, f, s)     | `-`  | copy s bytes from code at position f to mem at position t     |
-+-----------------------+------+---------------------------------------------------------------+
-| extcodesize(a)        |      | size of the code at address a                                 |
-+-----------------------+------+---------------------------------------------------------------+
-|extcodecopy(a, t, f, s)| `-`  | like codecopy(t, f, s) but take code at address a             |
-+-----------------------+------+---------------------------------------------------------------+
-| create(v, p, s)       |      | create new contract with code mem[p..(p+s)) and send v wei    |
-|                       |      | and return the new address                                    |
-+-----------------------+------+---------------------------------------------------------------+
-| call(g, a, v, in,     |      | call contract at address a with input mem[in..(in+insize)]    |
-| insize, out, outsize) |      | providing g gas and v wei and output area                     |
-|                       |      | mem[out..(out+outsize)] returting 1 on error (out of gas)     |
-+-----------------------+------+---------------------------------------------------------------+
-| callcode(g, a, v, in, |      | identical to call but only use the code from a and stay       |
-| insize, out, outsize) |      | in the context of the current contract otherwise              |
-+-----------------------+------+---------------------------------------------------------------+
-| delegatecall(g, a, in,|      | identical to callcode but also keep `caller` and `callvalue`  |
-| insize, out, outsize) |      |                                                               |
-+-----------------------+------+---------------------------------------------------------------+
-| return(p, s)          | `*`  | end execution, return data mem[p..(p+s))                      |
-+-----------------------+------+---------------------------------------------------------------+
-| selfdestruct(a)       | `*`  | end execution, destroy current contract and send funds to a   |
-+-----------------------+------+---------------------------------------------------------------+
-| log0(p, s)            | `-`  | log without topics and data mem[p..(p+s))                     |
-+-----------------------+------+---------------------------------------------------------------+
-| log1(p, s, t1)        | `-`  | log with topic t1 and data mem[p..(p+s))                      |
-+-----------------------+------+---------------------------------------------------------------+
-| log2(p, s, t1, t2)    | `-`  | log with topics t1, t2 and data mem[p..(p+s))                 |
-+-----------------------+------+---------------------------------------------------------------+
-| log3(p, s, t1, t2, t3)| `-`  | log with topics t1, t2, t3 and data mem[p..(p+s))             |
-+-----------------------+------+---------------------------------------------------------------+
-| log4(p, s, t1, t2, t3,| `-`  | log with topics t1, t2, t3, t4 and data mem[p..(p+s))         |
-| t4)                   |      |                                                               |
-+-----------------------+------+---------------------------------------------------------------+
-| origin                |      | transaction sender                                            |
-+-----------------------+------+---------------------------------------------------------------+
-| gasprice              |      | gas price of the transaction                                  |
-+-----------------------+------+---------------------------------------------------------------+
-| blockhash(b)          |      |hash of block nr b - only for last 256 blocks excluding current|
-+-----------------------+------+---------------------------------------------------------------+
-| coinbase              |      | current mining beneficiary                                    |
-+-----------------------+------+---------------------------------------------------------------+
-| timestamp             |      | timestamp of the current block in seconds since the epoch     |
-+-----------------------+------+---------------------------------------------------------------+
-| number                |      | current block number                                          |
-+-----------------------+------+---------------------------------------------------------------+
-| difficulty            |      | difficulty of the current block                               |
-+-----------------------+------+---------------------------------------------------------------+
-| gaslimit              |      | block gas limit of the current block                          |
-+-----------------------+------+---------------------------------------------------------------+
++-------------------------+------+-----------------------------------------------------------------+
+| stop                    + `-`  | stop execution, identical to return(0,0)                        |
++-------------------------+------+-----------------------------------------------------------------+
+| add(x, y)               |      | x + y                                                           |
++-------------------------+------+-----------------------------------------------------------------+
+| sub(x, y)               |      | x - y                                                           |
++-------------------------+------+-----------------------------------------------------------------+
+| mul(x, y)               |      | x * y                                                           |
++-------------------------+------+-----------------------------------------------------------------+
+| div(x, y)               |      | x / y                                                           |
++-------------------------+------+-----------------------------------------------------------------+
+| sdiv(x, y)              |      | x / y, for signed numbers in two's complement                   |
++-------------------------+------+-----------------------------------------------------------------+
+| mod(x, y)               |      | x % y                                                           |
++-------------------------+------+-----------------------------------------------------------------+
+| smod(x, y)              |      | x % y, for signed numbers in two's complement                   |
++-------------------------+------+-----------------------------------------------------------------+
+| exp(x, y)               |      | x to the power of y                                             |
++-------------------------+------+-----------------------------------------------------------------+
+| not(x)                  |      | ~x, every bit of x is negated                                   |
++-------------------------+------+-----------------------------------------------------------------+
+| lt(x, y)                |      | 1 if x < y, 0 otherwise                                         |
++-------------------------+------+-----------------------------------------------------------------+
+| gt(x, y)                |      | 1 if x > y, 0 otherwise                                         |
++-------------------------+------+-----------------------------------------------------------------+
+| slt(x, y)               |      | 1 if x < y, 0 otherwise, for signed numbers in two's complement |
++-------------------------+------+-----------------------------------------------------------------+
+| sgt(x, y)               |      | 1 if x > y, 0 otherwise, for signed numbers in two's complement |
++-------------------------+------+-----------------------------------------------------------------+
+| eq(x, y)                |      | 1 if x == y, 0 otherwise                                        |
++-------------------------+------+-----------------------------------------------------------------+
+| iszero(x)               |      | 1 if x == 0, 0 otherwise                                        |
++-------------------------+------+-----------------------------------------------------------------+
+| and(x, y)               |      | bitwise and of x and y                                          |
++-------------------------+------+-----------------------------------------------------------------+
+| or(x, y)                |      | bitwise or of x and y                                           |
++-------------------------+------+-----------------------------------------------------------------+
+| xor(x, y)               |      | bitwise xor of x and y                                          |
++-------------------------+------+-----------------------------------------------------------------+
+| byte(n, x)              |      | nth byte of x, where the most significant byte is the 0th byte  |
++-------------------------+------+-----------------------------------------------------------------+
+| addmod(x, y, m)         |      | (x + y) % m with arbitrary precision arithmetics                |
++-------------------------+------+-----------------------------------------------------------------+
+| mulmod(x, y, m)         |      | (x * y) % m with arbitrary precision arithmetics                |
++-------------------------+------+-----------------------------------------------------------------+
+| signextend(i, x)        |      | sign extend from (i*8+7)th bit counting from least significant  |
++-------------------------+------+-----------------------------------------------------------------+
+| sha3(p, n)              |      | keccak(mem[p...(p+n)))                                          |
++-------------------------+------+-----------------------------------------------------------------+
+| jump(label)             | `-`  | jump to label / code position                                   |
++-------------------------+------+-----------------------------------------------------------------+
+| jumpi(label, cond)      | `-`  | jump to label if cond is nonzero                                |
++-------------------------+------+-----------------------------------------------------------------+
+| pc                      |      | current position in code                                        |
++-------------------------+------+-----------------------------------------------------------------+
+| pop                     | `*`  | remove topmost stack slot                                       |
++-------------------------+------+-----------------------------------------------------------------+
+| dup1 ... dup16          |      | copy ith stack slot to the top (counting from top)              |
++-------------------------+------+-----------------------------------------------------------------+
+| swap1 ... swap1         | `*`  | swap topmost and ith stack slot below it                        |
++-------------------------+------+-----------------------------------------------------------------+
+| mload(p)                |      | mem[p..(p+32))                                                  |
++-------------------------+------+-----------------------------------------------------------------+
+| mstore(p, v)            | `-`  | mem[p..(p+32)) := v                                             |
++-------------------------+------+-----------------------------------------------------------------+
+| mstore8(p, v)           | `-`  | mem[p] := v & 0xff    - only modifies a single byte             |
++-------------------------+------+-----------------------------------------------------------------+
+| sload(p)                |      | storage[p]                                                      |
++-------------------------+------+-----------------------------------------------------------------+
+| sstore(p, v)            | `-`  | storage[p] := v                                                 |
++-------------------------+------+-----------------------------------------------------------------+
+| msize                   |      | size of memory, i.e. largest accessed memory index              |
++-------------------------+------+-----------------------------------------------------------------+
+| gas                     |      | gas still available to execution                                |
++-------------------------+------+-----------------------------------------------------------------+
+| address                 |      | address of the current contract / execution context             |
++-------------------------+------+-----------------------------------------------------------------+
+| balance(a)              |      | wei balance at address a                                        |
++-------------------------+------+-----------------------------------------------------------------+
+| caller                  |      | call sender (excluding delegatecall)                            |
++-------------------------+------+-----------------------------------------------------------------+
+| callvalue               |      | wei sent together with the current call                         |
++-------------------------+------+-----------------------------------------------------------------+
+| calldataload(p)         |      | call data starting from position p (32 bytes)                   |
++-------------------------+------+-----------------------------------------------------------------+
+| calldatasize            |      | size of call data in bytes                                      |
++-------------------------+------+-----------------------------------------------------------------+
+| calldatacopy(t, f, s)   | `-`  | copy s bytes from calldata at position f to mem at position t   |
++-------------------------+------+-----------------------------------------------------------------+
+| codesize                |      | size of the code of the current contract / execution context    |
++-------------------------+------+-----------------------------------------------------------------+
+| codecopy(t, f, s)       | `-`  | copy s bytes from code at position f to mem at position t       |
++-------------------------+------+-----------------------------------------------------------------+
+| extcodesize(a)          |      | size of the code at address a                                   |
++-------------------------+------+-----------------------------------------------------------------+
+| extcodecopy(a, t, f, s) | `-`  | like codecopy(t, f, s) but take code at address a               |
++-------------------------+------+-----------------------------------------------------------------+
+| create(v, p, s)         |      | create new contract with code mem[p..(p+s)) and send v wei      |
+|                         |      | and return the new address                                      |
++-------------------------+------+-----------------------------------------------------------------+
+| call(g, a, v, in,       |      | call contract at address a with input mem[in..(in+insize)]      |
+| insize, out, outsize)   |      | providing g gas and v wei and output area                       |
+|                         |      | mem[out..(out+outsize)] returting 1 on error (out of gas)       |
++-------------------------+------+-----------------------------------------------------------------+
+| callcode(g, a, v, in,   |      | identical to call but only use the code from a and stay         |
+| insize, out, outsize)   |      | in the context of the current contract otherwise                |
++-------------------------+------+-----------------------------------------------------------------+
+| delegatecall(g, a, in,  |      | identical to callcode but also keep `caller` and `callvalue`    |
+| insize, out, outsize)   |      |                                                                 |
++-------------------------+------+-----------------------------------------------------------------+
+| return(p, s)            | `*`  | end execution, return data mem[p..(p+s))                        |
++-------------------------+------+-----------------------------------------------------------------+
+| selfdestruct(a)         | `*`  | end execution, destroy current contract and send funds to a     |
++-------------------------+------+-----------------------------------------------------------------+
+| log0(p, s)              | `-`  | log without topics and data mem[p..(p+s))                       |
++-------------------------+------+-----------------------------------------------------------------+
+| log1(p, s, t1)          | `-`  | log with topic t1 and data mem[p..(p+s))                        |
++-------------------------+------+-----------------------------------------------------------------+
+| log2(p, s, t1, t2)      | `-`  | log with topics t1, t2 and data mem[p..(p+s))                   |
++-------------------------+------+-----------------------------------------------------------------+
+| log3(p, s, t1, t2, t3)  | `-`  | log with topics t1, t2, t3 and data mem[p..(p+s))               |
++-------------------------+------+-----------------------------------------------------------------+
+| log4(p, s, t1, t2, t3,  | `-`  | log with topics t1, t2, t3, t4 and data mem[p..(p+s))           |
+| t4)                     |      |                                                                 |
++-------------------------+------+-----------------------------------------------------------------+
+| origin                  |      | transaction sender                                              |
++-------------------------+------+-----------------------------------------------------------------+
+| gasprice                |      | gas price of the transaction                                    |
++-------------------------+------+-----------------------------------------------------------------+
+| blockhash(b)            |      | hash of block nr b - only for last 256 blocks excluding current |
++-------------------------+------+-----------------------------------------------------------------+
+| coinbase                |      | current mining beneficiary                                      |
++-------------------------+------+-----------------------------------------------------------------+
+| timestamp               |      | timestamp of the current block in seconds since the epoch       |
++-------------------------+------+-----------------------------------------------------------------+
+| number                  |      | current block number                                            |
++-------------------------+------+-----------------------------------------------------------------+
+| difficulty              |      | difficulty of the current block                                 |
++-------------------------+------+-----------------------------------------------------------------+
+| gaslimit                |      | block gas limit of the current block                            |
++-------------------------+------+-----------------------------------------------------------------+
 
 Literals
 --------
@@ -425,7 +492,7 @@ Strings are stored left-aligned and cannot be longer than 32 bytes.
 
 .. code::
 
-	assembly { 2 3 add "abc" and }
+    assembly { 2 3 add "abc" and }
 
 Functional Style
 -----------------
@@ -435,7 +502,7 @@ adding `3` to the contents in memory at position `0x80` would be
 
 .. code::
 
-	3 0x80 mload add 0x80 mstore
+    3 0x80 mload add 0x80 mstore
 
 As it is often hard to see what the actual arguments for certain opcodes are,
 Solidity inline assembly also provides a "functional style" notation where the same code
@@ -443,7 +510,7 @@ would be written as follows
 
 .. code::
 
-	mstore(0x80, add(mload(0x80), 3))
+    mstore(0x80, add(mload(0x80), 3))
 
 Functional style and instructional style can be mixed, but any opcode inside a
 functional style expression has to return exactly one stack slot (most of the opcodes do).
@@ -452,8 +519,8 @@ Note that the order of arguments is reversed in functional-style as opposed to t
 way. If you use functional-style, the first argument will end up on the stack top.
 
 
-Access to External Variables
-----------------------------
+Access to External Variables and Functions
+------------------------------------------
 
 Solidity variables and other identifiers can be accessed by simply using their name.
 For storage and memory variables, this will push the address and not the value onto the
@@ -461,20 +528,31 @@ stack. Also note that non-struct and non-array storage variable addresses occupy
 on the stack: One for the address and one for the byte offset inside the storage slot.
 In assignments (see below), we can even use local Solidity variables to assign to.
 
+Functions external to inline assembly can also be accessed: The assembly will
+push their entry label (with virtual function resolution applied). The calling semantics
+in solidity are:
+
+ - the caller pushes return label, arg1, arg2, ..., argn
+ - the call returns with ret1, ret2, ..., retn
+
+This feature is still a bit cumbersome to use, because the stack offset essentially
+changes during the call, and thus references to local variables will be wrong.
+It is planned that the stack height changes can be specified in inline assembly.
+
 .. code::
 
-	contract c {
-		uint b;
-		function f(uint x) returns (uint r) {
-			assembly {
-				b pop // remove the offset, we know it is zero
-				sload
-				x
-				mul
-				=: r  // assign to return variable r
-			}
-		}
-	}
+    contract C {
+        uint b;
+        function f(uint x) returns (uint r) {
+            assembly {
+                b pop // remove the offset, we know it is zero
+                sload
+                x
+                mul
+                =: r  // assign to return variable r
+            }
+        }
+    }
 
 Labels
 ------
@@ -485,19 +563,19 @@ jumps easier. The following code computes an element in the Fibonacci series.
 
 .. code::
 
-	{
-		let n := calldataload(4)
-		let a := 1
-		let b := a
-	loop:
-		jumpi(loopend, eq(n, 0))
-		a add swap1
-		n := sub(n, 1)
-		jump(loop)
-	loopend:
-		mstore(0, a)
-		return(0, 0x20)
-	}
+    {
+        let n := calldataload(4)
+        let a := 1
+        let b := a
+    loop:
+        jumpi(loopend, eq(n, 0))
+        a add swap1
+        n := sub(n, 1)
+        jump(loop)
+    loopend:
+        mstore(0, a)
+        return(0, 0x20)
+    }
 
 Please note that automatically accessing stack variables can only work if the
 assembler knows the current stack height. This fails to work if the jump source
@@ -510,19 +588,19 @@ will have a wrong impression about the stack height at label `two`:
 
 .. code::
 
-	{
-		jump(two)
-		one:
-			// Here the stack height is 1 (because we pushed 7),
-			// but the assembler thinks it is 0 because it reads
-			// from top to bottom.
-			// Accessing stack variables here will lead to errors.
-			jump(three)
-		two:
-			7 // push something onto the stack
-			jump(one)
-		three:
-	}
+    {
+        jump(two)
+        one:
+            // Here the stack height is 1 (because we pushed 7),
+            // but the assembler thinks it is 0 because it reads
+            // from top to bottom.
+            // Accessing stack variables here will lead to errors.
+            jump(three)
+        two:
+            7 // push something onto the stack
+            jump(one)
+        three:
+    }
 
 
 Declaring Assembly-Local Variables
@@ -537,19 +615,19 @@ be just `0`, but it can also be a complex functional-style expression.
 
 .. code::
 
-	contract c {
-		function f(uint x) returns (uint b) {
-			assembly {
-				let v := add(x, 1)
-				mstore(0x80, v)
-				{
-					let y := add(sload(v), 1)
-					b := y
-				} // y is "deallocated" here
-				b := add(b, v)
-			} // v is "deallocated" here
-		}
-	}
+    contract C {
+        function f(uint x) returns (uint b) {
+            assembly {
+                let v := add(x, 1)
+                mstore(0x80, v)
+                {
+                    let y := add(sload(v), 1)
+                    b := y
+                } // y is "deallocated" here
+                b := add(b, v)
+            } // v is "deallocated" here
+        }
+    }
 
 
 Assignments
@@ -567,12 +645,12 @@ For both ways, the colon points to the name of the variable.
 
 .. code::
 
-	assembly {
-		let v := 0 // functional-style assignment as part of variable declaration
-		let g := add(v, 2)
-		sload(10)
-		=: v // instruction style assignment, puts the result of sload(10) into v
-	}
+    assembly {
+        let v := 0 // functional-style assignment as part of variable declaration
+        let g := add(v, 2)
+        sload(10)
+        =: v // instruction style assignment, puts the result of sload(10) into v
+    }
 
 
 Things to Avoid
@@ -608,6 +686,6 @@ arrays are pointers to memory arrays. The length of a dynamic array is stored at
 first slot of the array and then only the array elements follow.
 
 .. warning::
-	Statically-sized memory arrays do not have a length field, but it will be added soon
-	to allow better convertibility between statically- and dynamically-sized arrays, so
-	please do not rely on that.
+    Statically-sized memory arrays do not have a length field, but it will be added soon
+    to allow better convertibility between statically- and dynamically-sized arrays, so
+    please do not rely on that.
diff --git a/docs/frequently-asked-questions.rst b/docs/frequently-asked-questions.rst
index fc7d7b7f..e42ca1c5 100644
--- a/docs/frequently-asked-questions.rst
+++ b/docs/frequently-asked-questions.rst
@@ -2,7 +2,7 @@
 Frequently Asked Questions
 ###########################
 
-This list was originally compiled by [fivedogit](mailto:fivedogit@gmail.com).
+This list was originally compiled by `fivedogit <mailto:fivedogit@gmail.com>`_.
 
 
 ***************
@@ -24,13 +24,13 @@ Solidity contracts can be compiled a few different ways (see below) and the
 resulting output can be cut/pasted into a geth console to deploy them to the
 Ethereum blockchain.
 
-There are some `contract examples <https://github.com/fivedogit/solidity-baby-steps/tree/master/contracts/>`_ by fivedogit and 
+There are some `contract examples <https://github.com/fivedogit/solidity-baby-steps/tree/master/contracts/>`_ by fivedogit and
 there should be a `test contract <https://github.com/ethereum/solidity/blob/develop/test/libsolidity/SolidityEndToEndTest.cpp>`_ for every single feature of Solidity.
 
 How do I compile contracts?
 =============================
 
-Probably the fastest way is the `online compiler <https://chriseth.github.io/browser-solidity/>`_.
+Probably the fastest way is the `online compiler <https://ethereum.github.io/browser-solidity/>`_.
 
 You can also use the `solc` binary which comes with cpp-ethereum to compile
 contracts or an emerging option is to use Mix, the IDE.
@@ -76,7 +76,7 @@ Does selfdestruct() free up space in the blockchain?
 
 It removes the contract bytecode and storage from the current block
 into the future, but since the blockchain stores every single block (i.e.
-all history), this will not actually free up space on full/achive nodes.
+all history), this will not actually free up space on full/archive nodes.
 
 Create a contract that can be killed and return funds
 =====================================================
@@ -85,7 +85,7 @@ First, a word of warning: Killing contracts sounds like a good idea, because "cl
 is always good, but as seen above, it does not really clean up. Furthermore,
 if Ether is sent to removed contracts, the Ether will be forever lost.
 
-If you want to deactivate your contracts, rather **disable** them by changing some
+If you want to deactivate your contracts, it is preferable to **disable** them by changing some
 internal state which causes all functions to throw. This will make it impossible
 to use the contract and ether sent to the contract will be returned automatically.
 
@@ -96,7 +96,7 @@ creator. Save it. Then `selfdestruct(creator);` to kill and return funds.
 
 Note that if you `import "mortal"` at the top of your contracts and declare
 `contract SomeContract is mortal { ...` and compile with a compiler that already
-has it (which includes `browser-solidity <https://chriseth.github.io/browser-solidity/>`_), then
+has it (which includes `browser-solidity <https://ethereum.github.io/browser-solidity/>`_), then
 `kill()` is taken care of for you. Once a contract is "mortal", then you can
 `contractname.kill.sendTransaction({from:eth.coinbase})`, just the same as my
 examples.
@@ -139,10 +139,10 @@ with `c.someMethod.sendTransaction({from:eth.accounts[x], gas: 1000000});`
 That is, because they can change state, they have to have a gas
 payment sent along to get the work done.
 
-Get a contract to return its funds to you (not using selfdestruct(...)). 
+Get a contract to return its funds to you (not using selfdestruct(...)).
 ========================================================================
 
-This example demonstrates how to send funds from a contract to an address. 
+This example demonstrates how to send funds from a contract to an address.
 
 See `endowment_retriever <https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/30_endowment_retriever.sol>`_.
 
@@ -175,16 +175,18 @@ datastructure on top of it, for example the `iterable mapping <https://github.co
 Can I put arrays inside of a mapping? How do I make a mapping of a mapping?
 ===========================================================================
 
-Mappings are already syntactically similar to arrays as they are, therefore it doesn't make much sense to store an array in them. Rather what you should do is create a mapping of a mapping. 
+Mappings are already syntactically similar to arrays as they are, therefore it doesn't make much sense to store an array in them. Rather what you should do is create a mapping of a mapping.
 
 An example of this would be::
 
-    contract c {
+    contract C {
         struct myStruct {
             uint someNumber;
             string someString;
         }
+
         mapping(uint => mapping(string => myStruct)) myDynamicMapping;
+
         function storeInMapping() {
             myDynamicMapping[1]["Foo"] = myStruct(2, "Bar");
         }
@@ -216,7 +218,7 @@ Example::
 
     contract C {
         function f() returns (uint8[5]) {
-            string[4] memory AdaArr = ["This", "is", "an", "array"];
+            string[4] memory adaArr = ["This", "is", "an", "array"];
             return ([1, 2, 3, 4, 5]);
         }
     }
@@ -276,7 +278,7 @@ Is a constructor required?
 
 No. If there is no constructor, a generic one without arguments and no actions will be used.
 
-Are timestamps (now, block.timestamp) reliable? 
+Are timestamps (now, block.timestamp) reliable?
 ===============================================
 
 This depends on what you mean by "reliable".
@@ -325,7 +327,7 @@ should implement the fallback function as
 `function() { throw; }`
 
 this will cause all transactions to this contract that do not call an
-existing function to be reverted, so that all Ether is sent back. 
+existing function to be reverted, so that all Ether is sent back.
 
 Another use of the fallback function is to e.g. register that your
 contract received ether by using an event.
@@ -345,17 +347,23 @@ by `msg.data`.
 Can state variables be initialized in-line?
 ===========================================
 
-Yes, this is possible for all types (even for structs). However, for arrays it 
+Yes, this is possible for all types (even for structs). However, for arrays it
 should be noted that you must declare them as static memory arrays.
 
 Examples::
 
     contract C {
-        struct S { uint a; uint b; }
+        struct S {
+            uint a;
+            uint b;
+        }
+
         S public x = S(1, 2);
         string name = "Ada";
-        string[4] memory AdaArr = ["This", "is", "an", "array"];  
+        string[4] memory adaArr = ["This", "is", "an", "array"];
     }
+
+
     contract D {
         C c = new C();
     }
@@ -405,9 +413,11 @@ you should always convert it to a `bytes` first::
 
     contract C {
         string s;
+
         function append(byte c) {
             bytes(s).push(c);
         }
+
         function set(uint i, byte c) {
             bytes(s)[i] = c;
         }
@@ -448,15 +458,21 @@ If you do not want to throw, you can return a pair::
 
     contract C {
         uint[] counters;
+
         function getCounter(uint index)
             returns (uint counter, bool error) {
                 if (index >= counters.length) return (0, true);
                 else return (counters[index], false);
-            }
+        }
+
         function checkCounter(uint index) {
             var (counter, error) = getCounter(index);
-            if (error) { ... }
-            else { ... }
+            if (error) {
+                ...
+            }
+            else {
+                ...
+            }
         }
     }
 
@@ -515,12 +531,15 @@ Example::
     contract C {
         uint[] data1;
         uint[] data2;
+
         function appendOne() {
             append(data1);
         }
+
         function appendTwo() {
             append(data2);
         }
+
         function append(uint[] storage d) {
             d.push(1);
         }
@@ -542,6 +561,7 @@ be created in memory, although it will be created in storage::
     contract C {
         uint someVariable;
         uint[] data;
+
         function f() {
             uint[] x;
             x.push(2);
@@ -565,6 +585,7 @@ The correct way to do this is the following::
     contract C {
         uint someVariable;
         uint[] data;
+
         function f() {
             uint[] x = data;
             x.push(2);
@@ -671,10 +692,11 @@ What happens to a struct's mapping when copying over a struct?
 
 This is a very interesting question. Suppose that we have a contract field set up like such::
 
-    struct user{
+    struct user {
         mapping(string => address) usedContracts;
     }
-    function somefunction{
+
+    function somefunction {
        user user1;
        user1.usedContracts["Hello"] = "World";
        user user2 = user1;
@@ -691,9 +713,13 @@ In the case of a `contract A` calling a new instance of `contract B`, parenthese
 `new B` because `B.value` would refer to a member of `B` called `value`.
 You will need to make sure that you have both contracts aware of each other's presence.
 In this example::
+
     contract B {}
+
+
     contract A {
         address child;
+
         function test() {
             child = (new B).value(10)(); //construct a new B with 10 wei
         }
@@ -702,7 +728,7 @@ In this example::
 Can a contract function accept a two-dimensional array?
 =======================================================
 
-This is not yet implemented for external calls and dynamic arrays - 
+This is not yet implemented for external calls and dynamic arrays -
 you can only use one level of dynamic arrays.
 
 What is the relationship between bytes32 and string? Why is it that bytes32 somevar = "stringliteral"; works and what does the saved 32-byte hex value mean?
@@ -734,17 +760,21 @@ Sure. Take care that if you cross the memory / storage boundary,
 independent copies will be created::
 
     contract C {
-      uint[20] x;
-      function f() {
-        g(x);
-        h(x);
-      }
-      function g(uint[20] y) {
-        y[2] = 3;
-      }
-      function h(uint[20] storage y) {
-        y[3] = 4;
-      }
+        uint[20] x;
+
+        function f() {
+            g(x);
+            h(x);
+        }
+
+        function g(uint[20] y) {
+            y[2] = 3;
+        }
+
+        function h(uint[20] storage y) {
+            y[3] = 4;
+        }
+    }
 
 The call to `g(x)` will not have an effect on `x` because it needs
 to create an independent copy of the storage value in memory
@@ -765,10 +795,10 @@ contract level) with `arrayname.length = <some new length>;`. If you get the
 
 ::
 
-    int8[] memory memArr;       // Case 1
-    memArr.length++;            // illegal
-    int8[5] storageArr;         // Case 2
-    somearray.length++;         // legal
+    int8[] memory memArr;        // Case 1
+    memArr.length++;             // illegal
+    int8[5] storageArr;          // Case 2
+    somearray.length++;          // legal
     int8[5] storage storageArr2; // Explicit case 2
     somearray2.length++;         // legal
 
@@ -821,7 +851,8 @@ What does the following strange check do in the Custom Token contract?
 
 ::
 
-    if (balanceOf[_to] + _value < balanceOf[_to]) throw;
+    if (balanceOf[_to] + _value < balanceOf[_to])
+        throw;
 
 Integers in Solidity (and most other machine-related programming languages) are restricted to a certain range.
 For `uint256`, this is `0` up to `2**256 - 1`. If the result of some operation on those numbers
diff --git a/docs/index.rst b/docs/index.rst
index fab886c7..4fd80271 100644
--- a/docs/index.rst
+++ b/docs/index.rst
@@ -8,7 +8,7 @@ crowdfunding, blind auctions, multi-signature wallets and more.
 
 .. note::
     The best way to try out Solidity right now is using the
-    `Browser-Based Compiler <https://chriseth.github.io/browser-solidity/>`_
+    `Browser-Based Compiler <https://ethereum.github.io/browser-solidity/>`_
     (it can take a while to load, please be patient).
 
 Useful links
@@ -16,8 +16,6 @@ Useful links
 
 * `Ethereum <https://ethereum.org>`_
 
-* `Browser-Based Compiler <https://chriseth.github.io/browser-solidity/>`_
-
 * `Changelog <https://github.com/ethereum/wiki/wiki/Solidity-Changelog>`_
 
 * `Story Backlog <https://www.pivotaltracker.com/n/projects/1189488>`_
@@ -28,6 +26,36 @@ Useful links
 
 * `Gitter Chat <https://gitter.im/ethereum/solidity/>`_
 
+Available Solidity Integrations
+-------------------------------
+
+* `Browser-Based Compiler <https://ethereum.github.io/browser-solidity/>`_
+	Browser-based IDE with integrated compiler and Solidity runtime environment without server-side components.	
+
+* `Ethereum Studio <https://live.ether.camp/>`_
+	Specialized web IDE that also provides shell access to a complete Ethereum environment.
+
+* `Visual Studio Extension <https://visualstudiogallery.msdn.microsoft.com/96221853-33c4-4531-bdd5-d2ea5acc4799/>`_
+	Solidity plugin for Microsoft Visual Studio that includes the Solidity compiler.
+
+* `Mix IDE <https://github.com/ethereum/mix/>`_
+	Qt based IDE for designing, debugging and testing solidity smart contracts.
+
+* `Package for SublimeText  Solidity language syntax <https://packagecontrol.io/packages/Ethereum/>`_
+	Solidity syntax highlighting for SublimeText editor.
+
+* `Atom Solidity package <https://github.com/gmtcreators/atom-solidity/>`_
+	Plugin for the atom editor that features syntax highlighting, compilation and a runtime environment (requires backend node).
+
+* `Visual Studio Code extension <http://juan.blanco.ws/solidity-contracts-in-visual-studio-code/>`_
+	Solidity plugin for Microsoft Visual Studio Code that includes syntax highlighting and the Solidity compiler.
+
+* `Emacs Solidity <https://github.com/ethereum/emacs-solidity/>`_
+	Plugin for the emacs editor providing syntax highlighting and compilation error reporting.
+
+* `VIM Solidity <https://github.com/tomlion/vim-solidity/>`_
+	Plugin for the VIM editor providing syntax highlighting.
+
 Language Documentation
 ----------------------
 
@@ -38,7 +66,7 @@ and the :ref:`Ethereum Virtual Machine <the-ethereum-virtual-machine>`.
 The next section will explain several *features* of Solidity by giving
 useful :ref:`example contracts <voting>`
 Remember that you can always try out the contracts
-`in your browser <https://chriseth.github.io/browser-solidity>`_!
+`in your browser <https://ethereum.github.io/browser-solidity>`_!
 
 The last and most extensive section will cover all aspects of Solidity in depth.
 
diff --git a/docs/installing-solidity.rst b/docs/installing-solidity.rst
index b4448c95..06407cc2 100644
--- a/docs/installing-solidity.rst
+++ b/docs/installing-solidity.rst
@@ -6,18 +6,18 @@ Browser-Solidity
 ================
 
 If you just want to try Solidity for small contracts, you
-can try `browser-solidity <https://chriseth.github.io/browser-solidity>`_
+can try `browser-solidity <https://ethereum.github.io/browser-solidity>`_
 which does not need any installation. If you want to use it
 without connection to the Internet, you can also just save the page
-locally or clone http://github.com/chriseth/browser-solidity.
+locally or clone http://github.com/ethereum/browser-solidity.
 
-NPM / node.js
+npm / Node.js
 =============
 
 This is probably the most portable and most convenient way to install Solidity locally.
 
 A platform-independent JavaScript library is provided by compiling the C++ source
-into JavaScript using Emscripten for browser-solidity and there is also an NPM
+into JavaScript using Emscripten for browser-solidity and there is also an npm
 package available.
 
 To install it, simply use
@@ -26,8 +26,8 @@ To install it, simply use
 
     npm install solc
 
-Details about the usage of the nodejs package can be found in the
-`repository <https://github.com/chriseth/browser-solidity#nodejs-usage>`_.
+Details about the usage of the Node.js package can be found in the
+`solc-js repository <https://github.com/ethereum/solc-js>`_.
 
 Binary Packages
 ===============
@@ -59,13 +59,13 @@ Set up Homebrew:
 
     brew update
     brew upgrade
-    
+
     brew install boost --c++11             # this takes a while
-    brew install cmake cryptopp miniupnpc leveldb gmp libmicrohttpd libjson-rpc-cpp 
+    brew install cmake cryptopp miniupnpc leveldb gmp libmicrohttpd libjson-rpc-cpp
     # For Mix IDE and Alethzero only
     brew install xz d-bus
     brew install homebrew/versions/v8-315
-    brew install llvm --HEAD --with-clang 
+    brew install llvm --HEAD --with-clang
     brew install qt5 --with-d-bus          # add --verbose if long waits with a stale screen drive you crazy as well
 
 Ubuntu
@@ -112,7 +112,7 @@ For Ubuntu 15.10 (Wily Werewolf) or newer, use the following command instead:
 .. code-block:: bash
 
     sudo apt-get -y install build-essential git cmake libboost-all-dev libgmp-dev libleveldb-dev libminiupnpc-dev libreadline-dev libncurses5-dev libcurl4-openssl-dev libcryptopp-dev libjsonrpccpp-dev libmicrohttpd-dev libjsoncpp-dev libedit-dev libz-dev
-    
+
 The reason for the change is that `libjsonrpccpp-dev` is available in the universe repository for newer versions of Ubuntu.
 
 Building
@@ -128,7 +128,7 @@ they relate only to Alethzero and Mix
     ./webthree-helpers/scripts/ethupdate.sh --no-push --simple-pull --project solidity # update Solidity repo
     ./webthree-helpers/scripts/ethbuild.sh --no-git --project solidity --all --cores 4 -DEVMJIT=0 # build Solidity and others
                                                                                 #enabling DEVMJIT on OS X will not build
-                                                                                #feel free to enable it on Linux 
+                                                                                #feel free to enable it on Linux
 
 If you opted to install Alethzero and Mix:
 
diff --git a/docs/introduction-to-smart-contracts.rst b/docs/introduction-to-smart-contracts.rst
index cecd6b91..7743c53d 100644
--- a/docs/introduction-to-smart-contracts.rst
+++ b/docs/introduction-to-smart-contracts.rst
@@ -20,9 +20,11 @@ Storage
 
     contract SimpleStorage {
         uint storedData;
+
         function set(uint x) {
             storedData = x;
         }
+
         function get() constant returns (uint retVal) {
             return storedData;
         }
@@ -61,14 +63,6 @@ Furthermore, anyone can send coins to each other without any need for
 registering with username and password - all you need is an Ethereum keypair.
 
 
-.. note::
-    This is not a nice example for browser-solidity.
-    If you use `browser-solidity <https://chriseth.github.io/browser-solidity>`_
-    to try this example, you cannot change the address where you call
-    functions from. So you will always be the "minter", you can mint coins and send
-    them somewhere, but you cannot impersonate someone else. This might change in
-    the future.
-
 .. Gist: ad490694f3e5b3de47ab
 
 ::
@@ -88,10 +82,12 @@ registering with username and password - all you need is an Ethereum keypair.
         function Coin() {
             minter = msg.sender;
         }
+
         function mint(address receiver, uint amount) {
             if (msg.sender != minter) return;
             balances[receiver] += amount;
         }
+
         function send(address receiver, uint amount) {
             if (balances[msg.sender] < amount) return;
             balances[msg.sender] -= amount;
diff --git a/docs/layout-of-source-files.rst b/docs/layout-of-source-files.rst
index 48ecfb09..07f796da 100644
--- a/docs/layout-of-source-files.rst
+++ b/docs/layout-of-source-files.rst
@@ -21,7 +21,7 @@ At a global level, you can use import statements of the following form:
 
   import "filename";
 
-...will import all global symbols from "filename" (and symbols imported there) into the 
+...will import all global symbols from "filename" (and symbols imported there) into the
 current global scope (different than in ES6 but backwards-compatible for Solidity).
 
 ::
@@ -88,7 +88,7 @@ the following in your source file:
 
 and then run the compiler as
 
-.. code-block:: shell
+.. code-block:: bash
 
   solc github.com/ethereum/dapp-bin/=/usr/local/dapp-bin/ source.sol
 
@@ -103,7 +103,7 @@ with the longest common prefix is chosen.
 
 **browser-solidity**:
 
-The `browser-based compiler <https://chriseth.github.io/browser-solidity>`_
+The `browser-based compiler <https://ethereum.github.io/browser-solidity>`_
 provides an automatic remapping for github and will also automatically retrieve
 the file over the network:
 You can import the iterable mapping by e.g.
@@ -122,17 +122,18 @@ Single-line comments (`//`) and multi-line comments (`/*...*/`) are possible.
 ::
 
   // This is a single-line comment.
-  
+
   /*
-  This is a 
+  This is a
   multi-line comment.
   */
-  
-
-There are special types of comments called natspec comments
-(documentation yet to be written). These are introduced by 
-triple-slash comments (`///`) or using double asterisks (`/** ... */`).
-Right in front of function declarations or statements,
-you can use doxygen-style tags inside them to document functions, annotate conditions for formal
-verification and provide a **confirmation text** that is shown to users if they want to
-invoke a function.
+
+
+Additionally, there is another type of comment called a natspec comment,
+for which the documentation is not yet written. They are written with a
+triple slash (`///`) or a double asterisk block(`/** ... */`) and
+they should be used directly above function declarations or statements.
+You can use Doxygen-style tags inside these comments to document
+functions, annotate conditions for formal verification, and provide a
+**confirmation text** which is shown to users when they attempt to invoke a
+function.
diff --git a/docs/miscellaneous.rst b/docs/miscellaneous.rst
index f2ad0f88..4a7b8438 100644
--- a/docs/miscellaneous.rst
+++ b/docs/miscellaneous.rst
@@ -31,10 +31,10 @@ non-elementary type, the positions are found by adding an offset of `sha3(k . p)
 
 So for the following contract snippet::
 
-    contract c {
-      struct S { uint a; uint b; }
+    contract C {
+      struct s { uint a; uint b; }
       uint x;
-      mapping(uint => mapping(uint => S)) data;
+      mapping(uint => mapping(uint => s)) data;
     }
 
 The position of `data[4][9].b` is at `sha3(uint256(9) . sha3(uint256(4) . uint256(1))) + 1`.
@@ -51,9 +51,11 @@ There are some types in Solidity's type system that have no counterpart in the s
         if (useB) f = b;
         return f(x);
       }
+
       function a(uint x) returns (uint z) {
         return x * x;
       }
+
       function b(uint x) returns (uint z) {
         return 2 * x;
       }
@@ -95,6 +97,8 @@ even though the instructions contained a jump in the beginning.
 
 .. index:: ! commandline compiler, compiler;commandline, ! solc, ! linker
 
+.. _commandline-compiler:
+
 ******************************
 Using the Commandline Compiler
 ******************************
@@ -117,7 +121,7 @@ files reside, so things like `import "/etc/passwd";` only work if you add `=/` a
 
 If there are multiple matches due to remappings, the one with the longest common prefix is selected.
 
-If your contracts use [libraries](#libraries), you will notice that the bytecode contains substrings of the form `__LibraryName______`. You can use `solc` as a linker meaning that it will insert the library addresses for you at those points:
+If your contracts use :ref:`libraries <libraries>`, you will notice that the bytecode contains substrings of the form `__LibraryName______`. You can use `solc` as a linker meaning that it will insert the library addresses for you at those points:
 
 Either add `--libraries "Math:0x12345678901234567890 Heap:0xabcdef0123456"` to your command to provide an address for each library or store the string in a file (one library per line) and run `solc` using `--libraries fileName`.
 
@@ -168,7 +172,7 @@ Global Variables
 - `sha3(...) returns (bytes32)`: compute the Ethereum-SHA3 hash of the (tightly packed) arguments
 - `sha256(...) returns (bytes32)`: compute the SHA256 hash of the (tightly packed) arguments
 - `ripemd160(...) returns (bytes20)`: compute RIPEMD of 256 the (tightly packed) arguments
-- `ecrecover(bytes32, uint8, bytes32, bytes32) returns (address)`: recover public key from elliptic curve signature
+- `ecrecover(bytes32, uint8, bytes32, bytes32) returns (address)`: recover address associated with the public key from elliptic curve signature
 - `addmod(uint x, uint y, uint k) returns (uint)`: compute `(x + y) % k` where the addition is performed with arbitrary precision and does not wrap around at `2**256`.
 - `mulmod(uint x, uint y, uint k) returns (uint)`: compute `(x * y) % k` where the multiplication is performed with arbitrary precision and does not wrap around at `2**256`.
 - `this` (current contract's type): the current contract, explicitly convertible to `address`
diff --git a/docs/solidity-by-example.rst b/docs/solidity-by-example.rst
index 59400f3f..12c02eb9 100644
--- a/docs/solidity-by-example.rst
+++ b/docs/solidity-by-example.rst
@@ -15,7 +15,7 @@ a lot of Solidity's features. It implements a voting
 contract. Of course, the main problems of electronic
 voting is how to assign voting rights to the correct
 persons and how to prevent manipulation. We will not
-solve all problems here, but at least we will show 
+solve all problems here, but at least we will show
 how delegated voting can be done so that vote counting
 is **automatic and completely transparent** at the
 same time.
@@ -39,18 +39,17 @@ of votes.
 ::
 
     /// @title Voting with delegation.
-    contract Ballot
-    {
+    contract Ballot {
         // This declares a new complex type which will
         // be used for variables later.
         // It will represent a single voter.
-        struct Voter
-        {
+        struct Voter {
             uint weight; // weight is accumulated by delegation
             bool voted;  // if true, that person already voted
             address delegate; // person delegated to
             uint vote;   // index of the voted proposal
         }
+
         // This is a type for a single proposal.
         struct Proposal
         {
@@ -59,82 +58,92 @@ of votes.
         }
 
         address public chairperson;
+
         // This declares a state variable that
         // stores a `Voter` struct for each possible address.
         mapping(address => Voter) public voters;
+
         // A dynamically-sized array of `Proposal` structs.
         Proposal[] public proposals;
 
         /// Create a new ballot to choose one of `proposalNames`.
-        function Ballot(bytes32[] proposalNames)
-        {
+        function Ballot(bytes32[] proposalNames) {
             chairperson = msg.sender;
             voters[chairperson].weight = 1;
+
             // For each of the provided proposal names,
             // create a new proposal object and add it
             // to the end of the array.
-            for (uint i = 0; i < proposalNames.length; i++)
+            for (uint i = 0; i < proposalNames.length; i++) {
                 // `Proposal({...})` creates a temporary
-                // Proposal object and `proposal.push(...)`
+                // Proposal object and `proposals.push(...)`
                 // appends it to the end of `proposals`.
                 proposals.push(Proposal({
                     name: proposalNames[i],
                     voteCount: 0
                 }));
+            }
         }
 
         // Give `voter` the right to vote on this ballot.
         // May only be called by `chairperson`.
-        function giveRightToVote(address voter)
-        {
-            if (msg.sender != chairperson || voters[voter].voted)
+        function giveRightToVote(address voter) {
+            if (msg.sender != chairperson || voters[voter].voted) {
                 // `throw` terminates and reverts all changes to
                 // the state and to Ether balances. It is often
                 // a good idea to use this if functions are
                 // called incorrectly. But watch out, this
                 // will also consume all provided gas.
                 throw;
+            }
             voters[voter].weight = 1;
         }
 
         /// Delegate your vote to the voter `to`.
-        function delegate(address to)
-        {
+        function delegate(address to) {
             // assigns reference
             Voter sender = voters[msg.sender];
             if (sender.voted)
                 throw;
+
             // Forward the delegation as long as
             // `to` also delegated.
             while (voters[to].delegate != address(0) &&
-                   voters[to].delegate != msg.sender)
-                to = voters[to].delegate;
+                   voters[to].delegate != msg.sender) {
+                       to = voters[to].delegate;
+            }
+
             // We found a loop in the delegation, not allowed.
-            if (to == msg.sender)
+            if (to == msg.sender) {
                 throw;
+            }
+
             // Since `sender` is a reference, this
             // modifies `voters[msg.sender].voted`
             sender.voted = true;
             sender.delegate = to;
             Voter delegate = voters[to];
-            if (delegate.voted)
+            if (delegate.voted) {
                 // If the delegate already voted,
-                // directly add to the number of votes 
+                // directly add to the number of votes
                 proposals[delegate.vote].voteCount += sender.weight;
-            else
+            }
+            else {
                 // If the delegate did not vote yet,
                 // add to her weight.
                 delegate.weight += sender.weight;
+            }
         }
 
         /// Give your vote (including votes delegated to you)
         /// to proposal `proposals[proposal].name`.
-        function vote(uint proposal)
-        {
+        function vote(uint proposal) {
             Voter sender = voters[msg.sender];
-            if (sender.voted) throw;
+            if (sender.voted)
+                throw;
             sender.voted = true;
             sender.vote = proposal;
+
             // If `proposal` is out of the range of the array,
             // this will throw automatically and revert all
             // changes.
@@ -147,10 +156,8 @@ of votes.
                 returns (uint winningProposal)
         {
             uint winningVoteCount = 0;
-            for (uint p = 0; p < proposals.length; p++)
-            {
-                if (proposals[p].voteCount > winningVoteCount)
-                {
+            for (uint p = 0; p < proposals.length; p++) {
+                if (proposals[p].voteCount > winningVoteCount) {
                     winningVoteCount = proposals[p].voteCount;
                     winningProposal = p;
                 }
@@ -223,8 +230,10 @@ activate themselves.
         /// Create a simple auction with `_biddingTime`
         /// seconds bidding time on behalf of the
         /// beneficiary address `_beneficiary`.
-        function SimpleAuction(uint _biddingTime,
-                               address _beneficiary) {
+        function SimpleAuction(
+            uint _biddingTime,
+            address _beneficiary
+        ) {
             beneficiary = _beneficiary;
             auctionStart = now;
             biddingTime = _biddingTime;
@@ -238,16 +247,19 @@ activate themselves.
             // No arguments are necessary, all
             // information is already part of
             // the transaction.
-            if (now > auctionStart + biddingTime)
+            if (now > auctionStart + biddingTime) {
                 // Revert the call if the bidding
                 // period is over.
                 throw;
-            if (msg.value <= highestBid)
+            }
+            if (msg.value <= highestBid) {
                 // If the bid is not higher, send the
                 // money back.
                 throw;
-            if (highestBidder != 0)
+            }
+            if (highestBidder != 0) {
                 highestBidder.send(highestBid);
+            }
             highestBidder = msg.sender;
             highestBid = msg.value;
             HighestBidIncreased(msg.sender, msg.value);
@@ -261,6 +273,7 @@ activate themselves.
             if (ended)
                 throw; // this function has already been called
             AuctionEnded(highestBidder, highestBid);
+
             // We send all the money we have, because some
             // of the refunds might have failed.
             beneficiary.send(this.balance);
@@ -279,7 +292,7 @@ activate themselves.
     }
 
 Blind Auction
-================
+=============
 
 The previous open auction is extended to a blind auction
 in the following. The advantage of a blind auction is
@@ -319,13 +332,12 @@ high or low invalid bids.
 
 ::
 
-    contract BlindAuction
-    {
-        struct Bid
-        {
+    contract BlindAuction {
+        struct Bid {
             bytes32 blindedBid;
             uint deposit;
         }
+
         address public beneficiary;
         uint public auctionStart;
         uint public biddingEnd;
@@ -346,10 +358,11 @@ high or low invalid bids.
         modifier onlyBefore(uint _time) { if (now >= _time) throw; _ }
         modifier onlyAfter(uint _time) { if (now <= _time) throw; _ }
 
-        function BlindAuction(uint _biddingTime,
-                                uint _revealTime,
-                                address _beneficiary)
-        {
+        function BlindAuction(
+            uint _biddingTime,
+            uint _revealTime,
+            address _beneficiary
+        ) {
             beneficiary = _beneficiary;
             auctionStart = now;
             biddingEnd = now + _biddingTime;
@@ -377,29 +390,38 @@ high or low invalid bids.
         /// Reveal your blinded bids. You will get a refund for all
         /// correctly blinded invalid bids and for all bids except for
         /// the totally highest.
-        function reveal(uint[] _values, bool[] _fake,
-                        bytes32[] _secret)
+        function reveal(
+            uint[] _values,
+            bool[] _fake,
+            bytes32[] _secret
+        )
             onlyAfter(biddingEnd)
             onlyBefore(revealEnd)
         {
             uint length = bids[msg.sender].length;
-            if (_values.length != length || _fake.length != length ||
-                        _secret.length != length)
+            if (
+                _values.length != length ||
+                _fake.length != length ||
+                _secret.length != length
+            ) {
                 throw;
+            }
+
             uint refund;
-            for (uint i = 0; i < length; i++)
-            {
+            for (uint i = 0; i < length; i++) {
                 var bid = bids[msg.sender][i];
                 var (value, fake, secret) =
                         (_values[i], _fake[i], _secret[i]);
-                if (bid.blindedBid != sha3(value, fake, secret))
+                if (bid.blindedBid != sha3(value, fake, secret)) {
                     // Bid was not actually revealed.
                     // Do not refund deposit.
                     continue;
+                }
                 refund += bid.deposit;
-                if (!fake && bid.deposit >= value)
+                if (!fake && bid.deposit >= value) {
                     if (placeBid(msg.sender, value))
                         refund -= value;
+                }
                 // Make it impossible for the sender to re-claim
                 // the same deposit.
                 bid.blindedBid = 0;
@@ -413,11 +435,13 @@ high or low invalid bids.
         function placeBid(address bidder, uint value) internal
                 returns (bool success)
         {
-            if (value <= highestBid)
+            if (value <= highestBid) {
                 return false;
-            if (highestBidder != 0)
+            }
+            if (highestBidder != 0) {
                 // Refund the previously highest bidder.
                 highestBidder.send(highestBid);
+            }
             highestBid = value;
             highestBidder = bidder;
             return true;
@@ -428,7 +452,8 @@ high or low invalid bids.
         function auctionEnd()
             onlyAfter(revealEnd)
         {
-            if (ended) throw;
+            if (ended)
+                throw;
             AuctionEnded(highestBidder, highestBid);
             // We send all the money we have, because some
             // of the refunds might have failed.
@@ -436,7 +461,9 @@ high or low invalid bids.
             ended = true;
         }
 
-        function () { throw; }
+        function () {
+            throw;
+        }
     }
 
 .. index:: purchase, remote purchase, escrow
@@ -449,39 +476,39 @@ Safe Remote Purchase
 
 ::
 
-    contract Purchase
-    {
+    contract Purchase {
         uint public value;
         address public seller;
         address public buyer;
         enum State { Created, Locked, Inactive }
         State public state;
-        function Purchase()
-        {
+
+        function Purchase() {
             seller = msg.sender;
             value = msg.value / 2;
             if (2 * value != msg.value) throw;
         }
-        modifier require(bool _condition)
-        {
+
+        modifier require(bool _condition) {
             if (!_condition) throw;
             _
         }
-        modifier onlyBuyer()
-        {
+
+        modifier onlyBuyer() {
             if (msg.sender != buyer) throw;
             _
         }
-        modifier onlySeller()
-        {
+
+        modifier onlySeller() {
             if (msg.sender != seller) throw;
             _
         }
-        modifier inState(State _state)
-        {
+
+        modifier inState(State _state) {
             if (state != _state) throw;
             _
         }
+
         event aborted();
         event purchaseConfirmed();
         event itemReceived();
@@ -497,6 +524,7 @@ Safe Remote Purchase
             seller.send(this.balance);
             state = State.Inactive;
         }
+
         /// Confirm the purchase as buyer.
         /// Transaction has to include `2 * value` ether.
         /// The ether will be locked until confirmReceived
@@ -509,6 +537,7 @@ Safe Remote Purchase
             buyer = msg.sender;
             state = State.Locked;
         }
+
         /// Confirm that you (the buyer) received the item.
         /// This will release the locked ether.
         function confirmReceived()
@@ -520,7 +549,10 @@ Safe Remote Purchase
             seller.send(this.balance);
             state = State.Inactive;
         }
-        function() { throw; }
+
+        function() {
+            throw;
+        }
     }
 
 ********************
diff --git a/docs/structure-of-a-contract.rst b/docs/structure-of-a-contract.rst
index 2e121847..79f78422 100644
--- a/docs/structure-of-a-contract.rst
+++ b/docs/structure-of-a-contract.rst
@@ -21,12 +21,12 @@ State variables are values which are permanently stored in contract storage.
 ::
 
   contract SimpleStorage {
-    uint storedData; // State variable
-    // ...
+      uint storedData; // State variable
+      // ...
   }
 
 See the :ref:`types` section for valid state variable types and
-:ref:`visibility-and-accessors` for possible choices for 
+:ref:`visibility-and-accessors` for possible choices for
 visibility.
 
 .. _structure-functions:
@@ -39,14 +39,14 @@ Functions are the executable units of code within a contract.
 ::
 
   contract SimpleAuction {
-    function bid() { // Function
-      // ...
-    }
+      function bid() { // Function
+          // ...
+      }
   }
 
 :ref:`function-calls` can happen internally or externally
 and have different levels of visibility (:ref:`visibility-and-accessors`)
-towards other contracts. 
+towards other contracts.
 
 .. _structure-function-modifiers:
 
@@ -57,18 +57,18 @@ Function modifiers can be used to amend the semantics of functions in a declarat
 (see :ref:`modifiers` in contracts section).
 
 ::
-  
+
   contract Purchase {
-    address public seller;
-    
-    modifier onlySeller() { // Modifier
-        if (msg.sender != seller) throw;
-        _
-    }
-    
-    function abort() onlySeller { // Modifier usage
-        // ...
-    }
+      address public seller;
+
+      modifier onlySeller() { // Modifier
+          if (msg.sender != seller) throw;
+          _
+      }
+
+      function abort() onlySeller { // Modifier usage
+          // ...
+      }
   }
 
 .. _structure-events:
@@ -80,16 +80,16 @@ Events are convenience interfaces with the EVM logging facilities.
 
 ::
 
-  contract SimpleAuction{
-    event HighestBidIncreased(address bidder, uint amount); // Event
-    
-    function bid() {
-      // ...
-      HighestBidIncreased(msg.sender, msg.value); // Triggering event
-    }
+  contract SimpleAuction {
+      event HighestBidIncreased(address bidder, uint amount); // Event
+
+      function bid() {
+          // ...
+          HighestBidIncreased(msg.sender, msg.value); // Triggering event
+      }
   }
 
-See :ref:`events` in contracts section for information on how events are declared 
+See :ref:`events` in contracts section for information on how events are declared
 and can be used from within a dapp.
 
 .. _structure-structs-types:
@@ -97,18 +97,18 @@ and can be used from within a dapp.
 Structs Types
 =============
 
-Structs are custom defined types that can group several variables (see 
+Structs are custom defined types that can group several variables (see
 :ref:`structs` in types section).
 
 ::
 
   contract Ballot {
-    struct Voter { // Struct
-      uint weight;
-      bool voted;
-      address delegate;
-      uint vote;
-    }
+      struct Voter { // Struct
+          uint weight;
+          bool voted;
+          address delegate;
+          uint vote;
+      }
   }
 
 .. _structure-enum-types:
@@ -116,11 +116,11 @@ Structs are custom defined types that can group several variables (see
 Enum Types
 ==========
 
-Enums can be used to create custom types with a finite set of values (see 
+Enums can be used to create custom types with a finite set of values (see
 :ref:`enums` in types section).
 
 ::
-  
+
   contract Purchase {
-    enum State { Created, Locked, Inactive } // Enum
+      enum State { Created, Locked, Inactive } // Enum
   }
diff --git a/docs/style-guide.rst b/docs/style-guide.rst
index c36efe2c..332b1ba6 100644
--- a/docs/style-guide.rst
+++ b/docs/style-guide.rst
@@ -25,7 +25,7 @@ solidity code.  The goal of this guide is *consistency*.  A quote from python's
 captures this concept well.
 
     A style guide is about consistency. Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is most important.
-    But most importantly: know when to be inconsistent -- sometimes the style guide just doesn't apply. When in doubt, use your best judgment. Look at other examples and decide what looks best. And don't hesitate to ask! 
+    But most importantly: know when to be inconsistent -- sometimes the style guide just doesn't apply. When in doubt, use your best judgment. Look at other examples and decide what looks best. And don't hesitate to ask!
 
 
 ***********
@@ -155,19 +155,27 @@ Whitespace in Expressions
 
 Avoid extraneous whitespace in the following  situations:
 
-* Immediately inside parenthesis, brackets or braces.
+Immediately inside parenthesis, brackets or braces.
 
-Yes: `spam(ham[1], Coin({name: "ham"}));`
+Yes::
+
+    spam(ham[1], Coin({name: "ham"}));
+
+No::
 
-No: `spam( ham[ 1 ], Coin( { name: "ham" } ) );`
+    spam( ham[ 1 ], Coin( { name: "ham" } ) );`
 
-* Immediately before a comma, semicolon:
+Immediately before a comma, semicolon:
 
-Yes: `function spam(uint i, Coin coin);` 
+Yes::
+
+    function spam(uint i, Coin coin);
+
+No::
 
-No: `function spam(uint i , Coin coin) ;`
+    function spam(uint i , Coin coin) ;
 
-* More than one space around an assignment or other operator to align with
+More than one space around an assignment or other operator to align with
   another:
 
 Yes::
@@ -244,7 +252,7 @@ No::
     for (...) {
         ...;}
 
-For control structures who's body contains a single statement, omitting the
+For control structures whose body contains a single statement, omitting the
 braces is ok *if* the statement is contained on a single line.
 
 Yes::
@@ -355,16 +363,16 @@ Yes::
         address c,
         address d,
         address e,
-        address f,
+        address f
     ) {
-        do_something;
+        doSomething();
     }
 
 No::
 
     function thisFunctionHasLotsOfArguments(address a, address b, address c,
         address d, address e, address f) {
-        do_something;
+        doSomething();
     }
 
     function thisFunctionHasLotsOfArguments(address a,
@@ -373,7 +381,7 @@ No::
                                             address d,
                                             address e,
                                             address f) {
-        do_something;
+        doSomething();
     }
 
     function thisFunctionHasLotsOfArguments(
@@ -383,7 +391,7 @@ No::
         address d,
         address e,
         address f) {
-        do_something;
+        doSomething();
     }
 
 If a long function declaration has modifiers, then each modifier should be
@@ -397,7 +405,7 @@ Yes::
         priced
         returns (address)
     {
-        do_something;
+        doSomething();
     }
 
     function thisFunctionNameIsReallyLong(
@@ -410,7 +418,7 @@ Yes::
         priced
         returns (address)
     {
-        do_something;
+        doSomething();
     }
 
 No::
@@ -420,13 +428,13 @@ No::
                                           onlyowner
                                           priced
                                           returns (address) {
-        do_something;
+        doSomething();
     }
 
     function thisFunctionNameIsReallyLong(address x, address y, address z)
         public onlyowner priced returns (address)
     {
-        do_something;
+        doSomething();
     }
 
     function thisFunctionNameIsReallyLong(address x, address y, address z)
@@ -434,10 +442,10 @@ No::
         onlyowner
         priced
         returns (address) {
-        do_something;
+        doSomething();
     }
 
-For constructor functions on inherited contracts who's bases require arguments,
+For constructor functions on inherited contracts whose bases require arguments,
 it is recommended to drop the base constructors onto new lines in the same
 manner as modifiers if the function declaration is long or hard to read.
 
diff --git a/docs/types.rst b/docs/types.rst
index 187f62c1..61c07282 100644
--- a/docs/types.rst
+++ b/docs/types.rst
@@ -28,7 +28,7 @@ Booleans
 
 `bool`: The possible values are constants `true` and `false`.
 
-Operators:  
+Operators:
 
 *  `!` (logical negation)
 *  `&&` (logical conjunction, "and")
@@ -43,25 +43,27 @@ The operators `||` and `&&` apply the common short-circuiting rules. This means
 Integers
 --------
 
-`int` / `uint`: Signed and unsigned integers of various sizes. Keywords `uint8` to `uint256` in steps of `8` (unsigned of 8 up to 256 bits) and `int8` to `int256`. `uint` and `int` are aliases for `uint256` and `int256`, respectively.
+`int` / `uint`: Signed and unsigned integers of various sizes. Keywords `uint8` to `uint256` in steps of `8` (unsigned of 8 up to 256 bits) and `int8` to `int256`. `uint` and `int` are aliases for `uint256` and `int256`, respectively.
 
-Operators:  
+Operators:
 
-* Comparisons: `<=`, `<`, `==`, `!=`, `>=`, `>` (evaluate to `bool`)  
-* Bit operators: `&`, `|`, `^` (bitwise exclusive or), `~` (bitwise negation)  
+* Comparisons: `<=`, `<`, `==`, `!=`, `>=`, `>` (evaluate to `bool`)
+* Bit operators: `&`, `|`, `^` (bitwise exclusive or), `~` (bitwise negation)
 * Arithmetic operators: `+`, `-`, unary `-`, unary `+`, `*`, `/`, `%` (remainder), `**` (exponentiation)
 
 Division always truncates (it just maps to the DIV opcode of the EVM), but it does not truncate if both
-operators are :ref:`literals<integer_literals>` (or literal expressions).
+operators are :ref:`literals<rational_literals>` (or literal expressions).
 
 .. index:: address, balance, send, call, callcode, delegatecall
 
+.. _address:
+
 Address
 -------
 
-`address`: Holds a 20 byte value (size of an Ethereum address). Address types also have members(see [Functions on addresses](#functions-on-addresses)) and serve as base for all contracts.
+`address`: Holds a 20 byte value (size of an Ethereum address). Address types also have members and serve as base for all contracts.
 
-Operators:  
+Operators:
 
 * `<=`, `<`, `==`, `!=`, `>=` and `>`
 
@@ -109,12 +111,12 @@ All three functions `call`, `delegatecall` and `callcode` are very low-level fun
 Fixed-size byte arrays
 ----------------------
 
-`bytes1`, `bytes2`, `bytes3`, ..., `bytes32`. `byte` is an alias for `bytes1`.  
+`bytes1`, `bytes2`, `bytes3`, ..., `bytes32`. `byte` is an alias for `bytes1`.
 
-Operators:  
+Operators:
 
-* Comparisons: `<=`, `<`, `==`, `!=`, `>=`, `>` (evaluate to `bool`)  
-* Bit operators: `&`, `|`, `^` (bitwise exclusive or), `~` (bitwise negation)  
+* Comparisons: `<=`, `<`, `==`, `!=`, `>=`, `>` (evaluate to `bool`)
+* Bit operators: `&`, `|`, `^` (bitwise exclusive or), `~` (bitwise negation)
 * Index access: If `x` is of type `bytesI`, then `x[k]` for `0 <= k < I` returns the `k` th byte (read-only).
 
 Members:
@@ -125,7 +127,7 @@ Dynamically-sized byte array
 ----------------------------
 
 `bytes`:
-    Dynamically-sized byte array, see :ref:`arrays`. Not a value-type!  
+    Dynamically-sized byte array, see :ref:`arrays`. Not a value-type!
 `string`:
     Dynamically-sized UTF8-encoded string, see :ref:`arrays`. Not a value-type!
 
@@ -133,27 +135,68 @@ As a rule of thumb, use `bytes` for arbitrary-length raw byte data and `string`
 for arbitrary-length string (utf-8) data. If you can limit the length to a certain
 number of bytes, always use one of `bytes1` to `bytes32` because they are much cheaper.
 
-.. index:: literal, literal;integer
+.. index:: ! ufixed, ! fixed, ! fixed point number
+
+Fixed Point Numbers
+-------------------
+
+**COMING SOON...**
+
+.. index:: literal, literal;rational
+
+.. _rational_literals:
+
+Rational and Integer Literals
+-----------------------------
 
-.. _integer_literals:
+All number literals retain arbitrary precision until they are converted to a non-literal type (i.e. by
+using them together with a non-literal type). This means that computations do not overflow but also
+divisions do not truncate.
 
-Integer Literals
------------------
+For example, `(2**800 + 1) - 2**800` results in the constant `1` (of type `uint8`)
+although intermediate results would not even fit the machine word size. Furthermore, `.5 * 8` results
+in the integer `4` (although non-integers were used in between).
 
-Integer Literals are arbitrary precision integers until they are used together with a non-literal. In `var x = 1 - 2;`, for example, the value of `1 - 2` is `-1`, which is assigned to `x` and thus `x` receives the type `int8` -- the smallest type that contains `-1`, although the natural types of `1` and `2` are actually `uint8`.    
+If the result is not an integer,
+an appropriate `ufixed` or `fixed` type is used whose number of fractional bits is as large as
+required (approximating the rational number in the worst case).
 
-It is even possible to temporarily exceed the maximum of 256 bits as long as only integer literals are used for the computation: `var x = (0xffffffffffffffffffff * 0xffffffffffffffffffff) * 0;` Here, `x` will have the value `0` and thus the type `uint8`.
+In `var x = 1/4;`, `x` will receive the type `ufixed0x8` while in `var x = 1/3` it will receive
+the type `ufixed0x256` because `1/3` is not finitely representable in binary and will thus be
+approximated.
+
+Any operator that can be applied to integers can also be applied to literal expressions as
+long as the operators are integers. If any of the two is fractional, bit operations are disallowed
+and exponentiation is disallowed if the exponent is fractional (because that might result in
+a non-rational number).
+
+.. note::
+    Most finite decimal fractions like `5.3743` are not finitely representable in binary. The correct type
+    for `5.3743` is `ufixed8x248` because that allows to best approximate the number. If you want to
+    use the number together with types like `ufixed` (i.e. `ufixed128x128`), you have to explicitly
+    specify the desired precision: `x + ufixed(5.3743)`.
 
 .. warning::
-    Divison on integer literals used to truncate in earlier versions, but it will actually convert into a rational number in the future, i.e. `1/2` is not equal to `0`, but to `0.5`.
+    Division on integer literals used to truncate in earlier versions, but it will now convert into a rational number, i.e. `5 / 2` is not equal to `2`, but to `2.5`.
 
+.. note::
+    Literal expressions are converted to a permanent type as soon as they are used with other
+    expressions. Even though we know that the value of the
+    expression assigned to `b` in the following example evaluates to an integer, it still
+    uses fixed point types (and not rational number literals) in between and so the code
+    does not compile
+
+::
+
+    uint128 a = 1;
+    uint128 b = 2.5 + a + 0.5;
 
 .. index:: literal, literal;string, string
 
 String Literals
 ---------------
 
-String Literals are written with double quotes (`"abc"`). As with integer literals, their type can vary, but they are implicitly convertible to `bytes` if they fit, to `bytes` and to `string`.
+String Literals are written with double quotes (`"abc"`). As with integer literals, their type can vary, but they are implicitly convertible to `bytes` if they fit, to `bytes` and to `string`.
 
 .. index:: enum
 
@@ -171,21 +214,21 @@ to and from all integer types but implicit conversion is not allowed.
         enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }
         ActionChoices choice;
         ActionChoices constant defaultChoice = ActionChoices.GoStraight;
-        function setGoStraight()
-        {
+
+        function setGoStraight() {
             choice = ActionChoices.GoStraight;
         }
+
         // Since enum types are not part of the ABI, the signature of "getChoice"
         // will automatically be changed to "getChoice() returns (uint8)"
         // for all matters external to Solidity. The integer type used is just
         // large enough to hold all enum values, i.e. if you have more values,
         // `uint16` will be used and so on.
-        function getChoice() returns (ActionChoices)
-        {
+        function getChoice() returns (ActionChoices) {
             return choice;
         }
-        function getDefaultChoice() returns (uint)
-        {
+
+        function getDefaultChoice() returns (uint) {
             return uint(defaultChoice);
         }
     }
@@ -226,26 +269,28 @@ memory-stored reference type does not create a copy.
 
 ::
 
-    contract c {
-      uint[] x; // the data location of x is storage
-      // the data location of memoryArray is memory
-      function f(uint[] memoryArray) {
-        x = memoryArray; // works, copies the whole array to storage
-        var y = x; // works, assigns a pointer, data location of y is storage
-        y[7]; // fine, returns the 8th element
-        y.length = 2; // fine, modifies x through y
-        delete x; // fine, clears the array, also modifies y
-        // The following does not work; it would need to create a new temporary /
-        // unnamed array in storage, but storage is "statically" allocated:
-        // y = memoryArray;
-        // This does not work either, since it would "reset" the pointer, but there
-        // is no sensible location it could point to.
-        // delete y;
-        g(x); // calls g, handing over a reference to x
-        h(x); // calls h and creates an independent, temporary copy in memory
-      }
-      function g(uint[] storage storageArray) internal {}
-      function h(uint[] memoryArray) {}
+    contract C {
+        uint[] x; // the data location of x is storage
+
+        // the data location of memoryArray is memory
+        function f(uint[] memoryArray) {
+            x = memoryArray; // works, copies the whole array to storage
+            var y = x; // works, assigns a pointer, data location of y is storage
+            y[7]; // fine, returns the 8th element
+            y.length = 2; // fine, modifies x through y
+            delete x; // fine, clears the array, also modifies y
+            // The following does not work; it would need to create a new temporary /
+            // unnamed array in storage, but storage is "statically" allocated:
+            // y = memoryArray;
+            // This does not work either, since it would "reset" the pointer, but there
+            // is no sensible location it could point to.
+            // delete y;
+            g(x); // calls g, handing over a reference to x
+            h(x); // calls h and creates an independent, temporary copy in memory
+        }
+
+        function g(uint[] storage storageArray) internal {}
+        function h(uint[] memoryArray) {}
     }
 
 Summary
@@ -303,12 +348,12 @@ the `.length` member.
 ::
 
     contract C {
-      function f(uint len) {
-        uint[] memory a = new uint[](7);
-        bytes memory b = new bytes(len);
-        // Here we have a.length == 7 and b.length == len
-        a[6] = 8;
-      }
+        function f(uint len) {
+            uint[] memory a = new uint[](7);
+            bytes memory b = new bytes(len);
+            // Here we have a.length == 7 and b.length == len
+            a[6] = 8;
+        }
     }
 
 
@@ -339,51 +384,59 @@ Members
 ::
 
     contract ArrayContract {
-      uint[2**20] m_aLotOfIntegers;
-      // Note that the following is not a pair of arrays but an array of pairs.
-      bool[2][] m_pairsOfFlags;
-      // newPairs is stored in memory - the default for function arguments
-      function setAllFlagPairs(bool[2][] newPairs) {
-        // assignment to a storage array replaces the complete array
-        m_pairsOfFlags = newPairs;
-      }
-      function setFlagPair(uint index, bool flagA, bool flagB) {
-        // access to a non-existing index will throw an exception
-        m_pairsOfFlags[index][0] = flagA;
-        m_pairsOfFlags[index][1] = flagB;
-      }
-      function changeFlagArraySize(uint newSize) {
-        // if the new size is smaller, removed array elements will be cleared
-        m_pairsOfFlags.length = newSize;
-      }
-      function clear() {
-        // these clear the arrays completely
-        delete m_pairsOfFlags;
-        delete m_aLotOfIntegers;
-        // identical effect here
-        m_pairsOfFlags.length = 0;
-      }
-      bytes m_byteData;
-      function byteArrays(bytes data) {
-        // byte arrays ("bytes") are different as they are stored without padding,
-        // but can be treated identical to "uint8[]"
-        m_byteData = data;
-        m_byteData.length += 7;
-        m_byteData[3] = 8;
-        delete m_byteData[2];
-      }
-      function addFlag(bool[2] flag) returns (uint) {
-        return m_pairsOfFlags.push(flag);
-      }
-      function createMemoryArray(uint size) returns (bytes) {
-        // Dynamic memory arrays are created using `new`:
-        uint[2][] memory arrayOfPairs = new uint[2][](size);
-        // Create a dynamic byte array:
-        bytes memory b = new bytes(200);
-        for (uint i = 0; i < b.length; i++)
-          b[i] = byte(i);
-        return b;
-      }
+        uint[2**20] m_aLotOfIntegers;
+        // Note that the following is not a pair of arrays but an array of pairs.
+        bool[2][] m_pairsOfFlags;
+        // newPairs is stored in memory - the default for function arguments
+
+        function setAllFlagPairs(bool[2][] newPairs) {
+            // assignment to a storage array replaces the complete array
+            m_pairsOfFlags = newPairs;
+        }
+
+        function setFlagPair(uint index, bool flagA, bool flagB) {
+            // access to a non-existing index will throw an exception
+            m_pairsOfFlags[index][0] = flagA;
+            m_pairsOfFlags[index][1] = flagB;
+        }
+
+        function changeFlagArraySize(uint newSize) {
+            // if the new size is smaller, removed array elements will be cleared
+            m_pairsOfFlags.length = newSize;
+        }
+
+        function clear() {
+            // these clear the arrays completely
+            delete m_pairsOfFlags;
+            delete m_aLotOfIntegers;
+            // identical effect here
+            m_pairsOfFlags.length = 0;
+        }
+
+        bytes m_byteData;
+
+        function byteArrays(bytes data) {
+            // byte arrays ("bytes") are different as they are stored without padding,
+            // but can be treated identical to "uint8[]"
+            m_byteData = data;
+            m_byteData.length += 7;
+            m_byteData[3] = 8;
+            delete m_byteData[2];
+        }
+
+        function addFlag(bool[2] flag) returns (uint) {
+            return m_pairsOfFlags.push(flag);
+        }
+
+        function createMemoryArray(uint size) returns (bytes) {
+            // Dynamic memory arrays are created using `new`:
+            uint[2][] memory arrayOfPairs = new uint[2][](size);
+            // Create a dynamic byte array:
+            bytes memory b = new bytes(200);
+            for (uint i = 0; i < b.length; i++)
+                b[i] = byte(i);
+            return b;
+        }
     }
 
 
@@ -400,41 +453,46 @@ shown in the following example:
 ::
 
     contract CrowdFunding {
-      // Defines a new type with two fields.
-      struct Funder {
-        address addr;
-        uint amount;
-      }
-      struct Campaign {
-        address beneficiary;
-        uint fundingGoal;
-        uint numFunders;
-        uint amount;
-        mapping (uint => Funder) funders;
-      }
-      uint numCampaigns;
-      mapping (uint => Campaign) campaigns;
-      function newCampaign(address beneficiary, uint goal) returns (uint campaignID) {
-        campaignID = numCampaigns++; // campaignID is return variable
-        // Creates new struct and saves in storage. We leave out the mapping type.
-        campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0);
-      }
-      function contribute(uint campaignID) {
-        Campaign c = campaigns[campaignID];
+        // Defines a new type with two fields.
+        struct Funder {
+            address addr;
+            uint amount;
+        }
+
+        struct Campaign {
+            address beneficiary;
+            uint fundingGoal;
+            uint numFunders;
+            uint amount;
+            mapping (uint => Funder) funders;
+        }
+
+        uint numCampaigns;
+        mapping (uint => Campaign) campaigns;
+
+        function newCampaign(address beneficiary, uint goal) returns (uint campaignID) {
+            campaignID = numCampaigns++; // campaignID is return variable
+            // Creates new struct and saves in storage. We leave out the mapping type.
+            campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0);
+        }
+
+        function contribute(uint campaignID) {
+            Campaign c = campaigns[campaignID];
             // Creates a new temporary memory struct, initialised with the given values
             // and copies it over to storage.
             // Note that you can also use Funder(msg.sender, msg.value) to initialise.
-        c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: msg.value});
-        c.amount += msg.value;
-      }
-      function checkGoalReached(uint campaignID) returns (bool reached) {
-        Campaign c = campaigns[campaignID];
-        if (c.amount < c.fundingGoal)
-          return false;
-        c.beneficiary.send(c.amount);
-        c.amount = 0;
-        return true;
-      }
+            c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: msg.value});
+            c.amount += msg.value;
+        }
+
+        function checkGoalReached(uint campaignID) returns (bool reached) {
+            Campaign c = campaigns[campaignID];
+            if (c.amount < c.fundingGoal)
+                return false;
+            c.beneficiary.send(c.amount);
+            c.amount = 0;
+            return true;
+        }
     }
 
 The contract does not provide the full functionality of a crowdfunding
@@ -495,18 +553,19 @@ It is important to note that `delete a` really behaves like an assignment to `a`
 ::
 
     contract DeleteExample {
-      uint data;
-      uint[] dataArray;
-      function f() {
-        uint x = data;
-        delete x; // sets x to 0, does not affect data
-        delete data; // sets data to 0, does not affect x which still holds a copy
-        uint[] y = dataArray;
-        delete dataArray; // this sets dataArray.length to zero, but as uint[] is a complex object, also
-        // y is affected which is an alias to the storage object
-        // On the other hand: "delete y" is not valid, as assignments to local variables
-        // referencing storage objects can only be made from existing storage objects.
-      }
+        uint data;
+        uint[] dataArray;
+
+        function f() {
+            uint x = data;
+            delete x; // sets x to 0, does not affect data
+            delete data; // sets data to 0, does not affect x which still holds a copy
+            uint[] y = dataArray;
+            delete dataArray; // this sets dataArray.length to zero, but as uint[] is a complex object, also
+            // y is affected which is an alias to the storage object
+            // On the other hand: "delete y" is not valid, as assignments to local variables
+            // referencing storage objects can only be made from existing storage objects.
+        }
     }
 
 .. index:: ! type;conversion, ! cast
diff --git a/docs/units-and-global-variables.rst b/docs/units-and-global-variables.rst
index a4239a29..f1560d25 100644
--- a/docs/units-and-global-variables.rst
+++ b/docs/units-and-global-variables.rst
@@ -35,7 +35,7 @@ These suffixes cannot be applied to variables. If you want to
 interpret some input variable in e.g. days, you can do it in the following way::
 
     function f(uint start, uint daysAfter) {
-      if (now >= start + daysAfter * 1 days) { ... }
+        if (now >= start + daysAfter * 1 days) { ... }
     }
 
 Special Variables and Functions
@@ -94,8 +94,8 @@ Mathematical and Cryptographic Functions
     compute the SHA-256 hash of the (tightly packed) arguments
 `ripemd160(...) returns (bytes20)`:
     compute RIPEMD-160 hash of the (tightly packed) arguments
-`ecrecover(bytes32, uint8, bytes32, bytes32) returns (address)`:
-    recover public key from elliptic curve signature - arguments are (data, v, r, s)
+`ecrecover(bytes32 data, uint8 v, bytes32 r, bytes32 s) returns (address)`:
+    recover the address associated with the public key from elliptic curve signature
 
 In the above, "tightly packed" means that the arguments are concatenated without padding.
 This means that the following are all identical::
@@ -117,9 +117,10 @@ Contract Related
 ----------------
 
 `this` (current contract's type):
-    the current contract, explicitly convertible to `address`
+    the current contract, explicitly convertible to :ref:`address`
+
 `selfdestruct(address)`:
-    destroy the current contract, sending its funds to the given address
+    destroy the current contract, sending its funds to the given :ref:`address`
 
 Furthermore, all functions of the current contract are callable directly including the current function.
 
diff --git a/libevmasm/Instruction.cpp b/libevmasm/Instruction.cpp
index d854dfec..2aaa6f1d 100644
--- a/libevmasm/Instruction.cpp
+++ b/libevmasm/Instruction.cpp
@@ -39,13 +39,13 @@ const std::map<std::string, Instruction> dev::solidity::c_instructions =
 	{ "MOD", Instruction::MOD },
 	{ "SMOD", Instruction::SMOD },
 	{ "EXP", Instruction::EXP },
-	{ "BNOT", Instruction::NOT },
+	{ "NOT", Instruction::NOT },
 	{ "LT", Instruction::LT },
 	{ "GT", Instruction::GT },
 	{ "SLT", Instruction::SLT },
 	{ "SGT", Instruction::SGT },
 	{ "EQ", Instruction::EQ },
-	{ "NOT", Instruction::ISZERO },
+	{ "ISZERO", Instruction::ISZERO },
 	{ "AND", Instruction::AND },
 	{ "OR", Instruction::OR },
 	{ "XOR", Instruction::XOR },
diff --git a/libevmasm/SourceLocation.h b/libevmasm/SourceLocation.h
index b8b57b60..8e22a826 100644
--- a/libevmasm/SourceLocation.h
+++ b/libevmasm/SourceLocation.h
@@ -26,6 +26,7 @@
 #include <string>
 #include <ostream>
 #include <tuple>
+#include <libdevcore/Common.h> // defines noexcept macro for MSVC
 
 namespace dev
 {
@@ -36,24 +37,21 @@ namespace dev
  */
 struct SourceLocation
 {
+	SourceLocation(): start(-1), end(-1) { }
 	SourceLocation(int _start, int _end, std::shared_ptr<std::string const> _sourceName):
 		start(_start), end(_end), sourceName(_sourceName) { }
-	SourceLocation(): start(-1), end(-1) { }
-
-	SourceLocation(SourceLocation const& _other):
+	SourceLocation(SourceLocation&& _other) noexcept:
 		start(_other.start),
 		end(_other.end),
-		sourceName(_other.sourceName)
+		sourceName(std::move(_other.sourceName))
 	{}
-
-	SourceLocation& operator=(SourceLocation const& _other)
+	SourceLocation(SourceLocation const& _other) = default;
+	SourceLocation& operator=(SourceLocation const&) = default;
+	SourceLocation& operator=(SourceLocation&& _other) noexcept
 	{
-		if (&_other == this)
-			return *this;
-
 		start = _other.start;
 		end = _other.end;
-		sourceName = _other.sourceName;
+		sourceName = std::move(_other.sourceName);
 		return *this;
 	}
 
diff --git a/liblll/Parser.cpp b/liblll/Parser.cpp
index df30f389..aa4a4de2 100644
--- a/liblll/Parser.cpp
+++ b/liblll/Parser.cpp
@@ -21,6 +21,10 @@
 
 #include "Parser.h"
 
+#if _MSC_VER
+#pragma warning(disable:4348)
+#endif
+
 #define BOOST_RESULT_OF_USE_DECLTYPE
 #define BOOST_SPIRIT_USE_PHOENIX_V3
 #include <boost/spirit/include/qi.hpp>
diff --git a/libsolidity/analysis/ConstantEvaluator.cpp b/libsolidity/analysis/ConstantEvaluator.cpp
index 6beb655e..bdd8f61e 100644
--- a/libsolidity/analysis/ConstantEvaluator.cpp
+++ b/libsolidity/analysis/ConstantEvaluator.cpp
@@ -31,7 +31,7 @@ using namespace dev::solidity;
 void ConstantEvaluator::endVisit(UnaryOperation const& _operation)
 {
 	TypePointer const& subType = _operation.subExpression().annotation().type;
-	if (!dynamic_cast<IntegerConstantType const*>(subType.get()))
+	if (!dynamic_cast<RationalNumberType const*>(subType.get()))
 		BOOST_THROW_EXCEPTION(_operation.subExpression().createTypeError("Invalid constant expression."));
 	TypePointer t = subType->unaryOperatorResult(_operation.getOperator());
 	_operation.annotation().type = t;
@@ -41,9 +41,9 @@ void ConstantEvaluator::endVisit(BinaryOperation const& _operation)
 {
 	TypePointer const& leftType = _operation.leftExpression().annotation().type;
 	TypePointer const& rightType = _operation.rightExpression().annotation().type;
-	if (!dynamic_cast<IntegerConstantType const*>(leftType.get()))
+	if (!dynamic_cast<RationalNumberType const*>(leftType.get()))
 		BOOST_THROW_EXCEPTION(_operation.leftExpression().createTypeError("Invalid constant expression."));
-	if (!dynamic_cast<IntegerConstantType const*>(rightType.get()))
+	if (!dynamic_cast<RationalNumberType const*>(rightType.get()))
 		BOOST_THROW_EXCEPTION(_operation.rightExpression().createTypeError("Invalid constant expression."));
 	TypePointer commonType = leftType->binaryOperatorResult(_operation.getOperator(), rightType);
 	if (Token::isCompareOp(_operation.getOperator()))
diff --git a/libsolidity/analysis/NameAndTypeResolver.cpp b/libsolidity/analysis/NameAndTypeResolver.cpp
index 5e407383..26d38cfe 100644
--- a/libsolidity/analysis/NameAndTypeResolver.cpp
+++ b/libsolidity/analysis/NameAndTypeResolver.cpp
@@ -296,7 +296,7 @@ void NameAndTypeResolver::linearizeBaseContracts(ContractDefinition& _contract)
 {
 	// order in the lists is from derived to base
 	// list of lists to linearize, the last element is the list of direct bases
-	list<list<ContractDefinition const*>> input(1, {});
+	list<list<ContractDefinition const*>> input(1, list<ContractDefinition const*>{});
 	for (ASTPointer<InheritanceSpecifier> const& baseSpecifier: _contract.baseContracts())
 	{
 		UserDefinedTypeName const& baseName = baseSpecifier->name();
diff --git a/libsolidity/analysis/ReferencesResolver.cpp b/libsolidity/analysis/ReferencesResolver.cpp
index d7542bf3..a7b9e8b8 100644
--- a/libsolidity/analysis/ReferencesResolver.cpp
+++ b/libsolidity/analysis/ReferencesResolver.cpp
@@ -103,10 +103,9 @@ void ReferencesResolver::endVisit(ArrayTypeName const& _typeName)
 	{
 		if (!length->annotation().type)
 			ConstantEvaluator e(*length);
-
-		auto const* lengthType = dynamic_cast<IntegerConstantType const*>(length->annotation().type.get());
-		if (!lengthType)
-			fatalTypeError(length->location(), "Invalid array length.");
+		auto const* lengthType = dynamic_cast<RationalNumberType const*>(length->annotation().type.get());
+		if (!lengthType || lengthType->isFractional())
+			fatalTypeError(length->location(), "Invalid array length, expected integer literal.");
 		else
 			_typeName.annotation().type = make_shared<ArrayType>(DataLocation::Storage, baseType, lengthType->literalValue(nullptr));
 	}
diff --git a/libsolidity/analysis/TypeChecker.cpp b/libsolidity/analysis/TypeChecker.cpp
index bc342b58..5ae0443a 100644
--- a/libsolidity/analysis/TypeChecker.cpp
+++ b/libsolidity/analysis/TypeChecker.cpp
@@ -772,26 +772,51 @@ bool TypeChecker::visit(VariableDeclarationStatement const& _statement)
 		{
 			// Infer type from value.
 			solAssert(!var.typeName(), "");
-			if (
-				valueComponentType->category() == Type::Category::IntegerConstant &&
-				!dynamic_pointer_cast<IntegerConstantType const>(valueComponentType)->integerType()
-			)
-				fatalTypeError(_statement.initialValue()->location(), "Invalid integer constant " + valueComponentType->toString() + ".");
 			var.annotation().type = valueComponentType->mobileType();
+			if (!var.annotation().type)
+			{
+				if (valueComponentType->category() == Type::Category::RationalNumber)
+					fatalTypeError(
+						_statement.initialValue()->location(),
+						"Invalid rational " +
+						valueComponentType->toString() +
+						" (absolute value too large or divison by zero)."
+					);
+				else
+					solAssert(false, "");
+			}
 			var.accept(*this);
 		}
 		else
 		{
 			var.accept(*this);
 			if (!valueComponentType->isImplicitlyConvertibleTo(*var.annotation().type))
-				typeError(
-					_statement.location(),
-					"Type " +
-					valueComponentType->toString() +
-					" is not implicitly convertible to expected type " +
-					var.annotation().type->toString() +
-					"."
-				);
+			{
+				if (
+					valueComponentType->category() == Type::Category::RationalNumber &&
+					dynamic_cast<RationalNumberType const&>(*valueComponentType).isFractional() &&
+					valueComponentType->mobileType()
+				)
+					typeError(
+						_statement.location(),
+						"Type " +
+						valueComponentType->toString() +
+						" is not implicitly convertible to expected type " +
+						var.annotation().type->toString() +
+						". Try converting to type " +
+						valueComponentType->mobileType()->toString() +
+						" or use an explicit conversion." 
+					);
+				else
+					typeError(
+						_statement.location(),
+						"Type " +
+						valueComponentType->toString() +
+						" is not implicitly convertible to expected type " +
+						var.annotation().type->toString() +
+						"."
+					);
+			}
 		}
 	}
 	return false;
@@ -799,9 +824,9 @@ bool TypeChecker::visit(VariableDeclarationStatement const& _statement)
 
 void TypeChecker::endVisit(ExpressionStatement const& _statement)
 {
-	if (type(_statement.expression())->category() == Type::Category::IntegerConstant)
-		if (!dynamic_pointer_cast<IntegerConstantType const>(type(_statement.expression()))->integerType())
-			typeError(_statement.expression().location(), "Invalid integer constant.");
+	if (type(_statement.expression())->category() == Type::Category::RationalNumber)
+		if (!dynamic_cast<RationalNumberType const&>(*type(_statement.expression())).mobileType())
+			typeError(_statement.expression().location(), "Invalid rational number.");
 }
 
 bool TypeChecker::visit(Conditional const& _conditional)
@@ -1106,9 +1131,9 @@ bool TypeChecker::visit(FunctionCall const& _functionCall)
 			auto const& argType = type(*arguments[i]);
 			if (functionType->takesArbitraryParameters())
 			{
-				if (auto t = dynamic_cast<IntegerConstantType const*>(argType.get()))
-					if (!t->integerType())
-						typeError(arguments[i]->location(), "Integer constant too large.");
+				if (auto t = dynamic_cast<RationalNumberType const*>(argType.get()))
+					if (!t->mobileType())
+						typeError(arguments[i]->location(), "Invalid rational number (too large or division by zero).");
 			}
 			else if (!type(*arguments[i])->isImplicitlyConvertibleTo(*parameterTypes[i]))
 				typeError(
@@ -1341,9 +1366,12 @@ bool TypeChecker::visit(IndexAccess const& _access)
 		else
 		{
 			expectType(*index, IntegerType(256));
-			if (auto integerType = dynamic_cast<IntegerConstantType const*>(type(*index).get()))
-				if (!actualType.isDynamicallySized() && actualType.length() <= integerType->literalValue(nullptr))
-					typeError(_access.location(), "Out of bounds array access.");
+			if (auto numberType = dynamic_cast<RationalNumberType const*>(type(*index).get()))
+			{
+				if (!numberType->isFractional()) // error is reported above
+					if (!actualType.isDynamicallySized() && actualType.length() <= numberType->literalValue(nullptr))
+						typeError(_access.location(), "Out of bounds array access.");
+			}
 		}
 		resultType = actualType.baseType();
 		isLValue = actualType.location() != DataLocation::CallData;
@@ -1367,8 +1395,8 @@ bool TypeChecker::visit(IndexAccess const& _access)
 			resultType = make_shared<TypeType>(make_shared<ArrayType>(DataLocation::Memory, typeType.actualType()));
 		else
 		{
-			index->accept(*this);
-			if (auto length = dynamic_cast<IntegerConstantType const*>(type(*index).get()))
+			expectType(*index, IntegerType(256));
+			if (auto length = dynamic_cast<RationalNumberType const*>(type(*index).get()))
 				resultType = make_shared<TypeType>(make_shared<ArrayType>(
 					DataLocation::Memory,
 					typeType.actualType(),
@@ -1387,7 +1415,7 @@ bool TypeChecker::visit(IndexAccess const& _access)
 		else
 		{
 			expectType(*index, IntegerType(256));
-			if (auto integerType = dynamic_cast<IntegerConstantType const*>(type(*index).get()))
+			if (auto integerType = dynamic_cast<RationalNumberType const*>(type(*index).get()))
 				if (bytesType.numBytes() <= integerType->literalValue(nullptr))
 					typeError(_access.location(), "Out of bounds array access.");
 		}
@@ -1492,16 +1520,33 @@ Declaration const& TypeChecker::dereference(UserDefinedTypeName const& _typeName
 void TypeChecker::expectType(Expression const& _expression, Type const& _expectedType)
 {
 	_expression.accept(*this);
-
 	if (!type(_expression)->isImplicitlyConvertibleTo(_expectedType))
-		typeError(
-			_expression.location(),
-			"Type " +
-			type(_expression)->toString() +
-			" is not implicitly convertible to expected type " +
-			_expectedType.toString() +
-			"."
-		);
+	{
+		if (
+			type(_expression)->category() == Type::Category::RationalNumber &&
+			dynamic_pointer_cast<RationalNumberType const>(type(_expression))->isFractional() &&
+			type(_expression)->mobileType()
+		)
+			typeError(
+				_expression.location(),
+				"Type " +
+				type(_expression)->toString() +
+				" is not implicitly convertible to expected type " +
+				_expectedType.toString() +
+				". Try converting to type " +
+				type(_expression)->mobileType()->toString() +
+				" or use an explicit conversion."
+			);
+		else
+			typeError(
+				_expression.location(),
+				"Type " +
+				type(_expression)->toString() +
+				" is not implicitly convertible to expected type " +
+				_expectedType.toString() +
+				"."
+			);
+	}		
 }
 
 void TypeChecker::requireLValue(Expression const& _expression)
diff --git a/libsolidity/ast/Types.cpp b/libsolidity/ast/Types.cpp
index 4dc1eb13..e964d683 100644
--- a/libsolidity/ast/Types.cpp
+++ b/libsolidity/ast/Types.cpp
@@ -122,7 +122,8 @@ TypePointer Type::fromElementaryTypeName(ElementaryTypeNameToken const& _type)
 	);
 
 	Token::Value token = _type.token();
-	unsigned int m = _type.firstNumber();
+	unsigned m = _type.firstNumber();
+	unsigned n = _type.secondNumber();
 
 	switch (token)
 	{
@@ -132,10 +133,18 @@ TypePointer Type::fromElementaryTypeName(ElementaryTypeNameToken const& _type)
 		return make_shared<IntegerType>(m, IntegerType::Modifier::Unsigned);
 	case Token::BytesM:
 		return make_shared<FixedBytesType>(m);
+	case Token::FixedMxN:
+		return make_shared<FixedPointType>(m, n, FixedPointType::Modifier::Signed);
+	case Token::UFixedMxN:
+		return make_shared<FixedPointType>(m, n, FixedPointType::Modifier::Unsigned);
 	case Token::Int:
 		return make_shared<IntegerType>(256, IntegerType::Modifier::Signed);
 	case Token::UInt:
 		return make_shared<IntegerType>(256, IntegerType::Modifier::Unsigned);
+	case Token::Fixed:
+		return make_shared<FixedPointType>(128, 128, FixedPointType::Modifier::Signed);
+	case Token::UFixed:
+		return make_shared<FixedPointType>(128, 128, FixedPointType::Modifier::Unsigned);
 	case Token::Byte:
 		return make_shared<FixedBytesType>(1);
 	case Token::Address:
@@ -171,13 +180,17 @@ TypePointer Type::forLiteral(Literal const& _literal)
 	case Token::FalseLiteral:
 		return make_shared<BoolType>();
 	case Token::Number:
-		if (!IntegerConstantType::isValidLiteral(_literal))
+	{
+		tuple<bool, rational> validLiteral = RationalNumberType::isValidLiteral(_literal);
+		if (get<0>(validLiteral) == true)
+			return make_shared<RationalNumberType>(get<1>(validLiteral));
+		else
 			return TypePointer();
-		return make_shared<IntegerConstantType>(_literal);
+	}
 	case Token::StringLiteral:
 		return make_shared<StringLiteralType>(_literal);
 	default:
-		return shared_ptr<Type>();
+		return TypePointer();
 	}
 }
 
@@ -197,7 +210,7 @@ MemberList const& Type::members(ContractDefinition const* _currentScope) const
 	{
 		MemberList::MemberMap members = nativeMembers(_currentScope);
 		if (_currentScope)
-			members +=  boundFunctions(*this, *_currentScope);
+			members += boundFunctions(*this, *_currentScope);
 		m_members[_currentScope] = unique_ptr<MemberList>(new MemberList(move(members)));
 	}
 	return *m_members[_currentScope];
@@ -220,19 +233,14 @@ MemberList::MemberMap Type::boundFunctions(Type const& _type, ContractDefinition
 			auto const& library = dynamic_cast<ContractDefinition const&>(
 				*ufd->libraryName().annotation().referencedDeclaration
 			);
-			for (auto const& it: library.interfaceFunctions())
+			for (FunctionDefinition const* function: library.definedFunctions())
 			{
-				FunctionType const& funType = *it.second;
-				solAssert(funType.hasDeclaration(), "Tried to bind function without declaration.");
-				if (seenFunctions.count(&funType.declaration()))
+				if (!function->isVisibleInDerivedContracts() || seenFunctions.count(function))
 					continue;
-				seenFunctions.insert(&funType.declaration());
+				seenFunctions.insert(function);
+				FunctionType funType(*function, false);
 				if (auto fun = funType.asMemberFunction(true, true))
-					members.push_back(MemberList::Member(
-						funType.declaration().name(),
-						fun,
-						&funType.declaration()
-					));
+					members.push_back(MemberList::Member(function->name(), fun, function));
 			}
 		}
 	return members;
@@ -251,17 +259,30 @@ IntegerType::IntegerType(int _bits, IntegerType::Modifier _modifier):
 
 bool IntegerType::isImplicitlyConvertibleTo(Type const& _convertTo) const
 {
-	if (_convertTo.category() != category())
-		return false;
-	IntegerType const& convertTo = dynamic_cast<IntegerType const&>(_convertTo);
-	if (convertTo.m_bits < m_bits)
-		return false;
-	if (isAddress())
-		return convertTo.isAddress();
-	else if (isSigned())
-		return convertTo.isSigned();
+	if (_convertTo.category() == category())
+	{
+		IntegerType const& convertTo = dynamic_cast<IntegerType const&>(_convertTo);
+		if (convertTo.m_bits < m_bits)
+			return false;
+		if (isAddress())
+			return convertTo.isAddress();
+		else if (isSigned())
+			return convertTo.isSigned();
+		else
+			return !convertTo.isSigned() || convertTo.m_bits > m_bits;
+	}
+	else if (_convertTo.category() == Category::FixedPoint)
+	{
+		FixedPointType const& convertTo = dynamic_cast<FixedPointType const&>(_convertTo);
+		if (convertTo.integerBits() < m_bits || isAddress())
+			return false;
+		else if (isSigned())
+			return convertTo.isSigned();
+		else
+			return !convertTo.isSigned() || convertTo.integerBits() > m_bits;
+	}
 	else
-		return !convertTo.isSigned() || convertTo.m_bits > m_bits;
+		return false;
 }
 
 bool IntegerType::isExplicitlyConvertibleTo(Type const& _convertTo) const
@@ -269,7 +290,8 @@ bool IntegerType::isExplicitlyConvertibleTo(Type const& _convertTo) const
 	return _convertTo.category() == category() ||
 		_convertTo.category() == Category::Contract ||
 		_convertTo.category() == Category::Enum ||
-		_convertTo.category() == Category::FixedBytes;
+		_convertTo.category() == Category::FixedBytes ||
+		_convertTo.category() == Category::FixedPoint;
 }
 
 TypePointer IntegerType::unaryOperatorResult(Token::Value _operator) const
@@ -307,10 +329,13 @@ string IntegerType::toString(bool) const
 
 TypePointer IntegerType::binaryOperatorResult(Token::Value _operator, TypePointer const& _other) const
 {
-	if (_other->category() != Category::IntegerConstant && _other->category() != category())
+	if (
+		_other->category() != Category::RationalNumber &&
+		_other->category() != Category::FixedPoint &&
+		_other->category() != category()
+	)
 		return TypePointer();
-	auto commonType = dynamic_pointer_cast<IntegerType const>(Type::commonType(shared_from_this(), _other));
-
+	auto commonType = Type::commonType(shared_from_this(), _other); //might be a integer or fixed point
 	if (!commonType)
 		return TypePointer();
 
@@ -320,9 +345,14 @@ TypePointer IntegerType::binaryOperatorResult(Token::Value _operator, TypePointe
 	if (Token::isBooleanOp(_operator))
 		return TypePointer();
 	// Nothing else can be done with addresses
-	if (commonType->isAddress())
-		return TypePointer();
-
+	if (auto intType = dynamic_pointer_cast<IntegerType const>(commonType))
+	{
+		if (intType->isAddress())
+			return TypePointer();
+	}
+	else if (auto fixType = dynamic_pointer_cast<FixedPointType const>(commonType))
+		if (Token::Exp == _operator)
+			return TypePointer();
 	return commonType;
 }
 
@@ -340,143 +370,292 @@ MemberList::MemberMap IntegerType::nativeMembers(ContractDefinition const*) cons
 		return MemberList::MemberMap();
 }
 
-bool IntegerConstantType::isValidLiteral(const Literal& _literal)
+FixedPointType::FixedPointType(int _integerBits, int _fractionalBits, FixedPointType::Modifier _modifier):
+	m_integerBits(_integerBits), m_fractionalBits(_fractionalBits), m_modifier(_modifier)
 {
-	try
+	solAssert(
+		m_integerBits + m_fractionalBits > 0 && 
+		m_integerBits + m_fractionalBits <= 256 && 
+		m_integerBits % 8 == 0 && 
+		m_fractionalBits % 8 == 0,
+		"Invalid bit number(s) for fixed type: " + 
+		dev::toString(_integerBits) + "x" + dev::toString(_fractionalBits)
+	);
+}
+
+bool FixedPointType::isImplicitlyConvertibleTo(Type const& _convertTo) const
+{
+	if (_convertTo.category() == category())
 	{
-		bigint x(_literal.value());
+		FixedPointType const& convertTo = dynamic_cast<FixedPointType const&>(_convertTo);
+		if (convertTo.m_integerBits < m_integerBits || convertTo.m_fractionalBits < m_fractionalBits)
+			return false;
+		else if (isSigned())
+			return convertTo.isSigned();
+		else
+			return !convertTo.isSigned() || (convertTo.m_integerBits > m_integerBits);
 	}
-	catch (...)
-	{
+	return false;
+}
+
+bool FixedPointType::isExplicitlyConvertibleTo(Type const& _convertTo) const
+{
+	return _convertTo.category() == category() ||
+		_convertTo.category() == Category::Integer ||
+		_convertTo.category() == Category::FixedBytes;
+}
+
+TypePointer FixedPointType::unaryOperatorResult(Token::Value _operator) const
+{
+	// "delete" is ok for all fixed types
+	if (_operator == Token::Delete)
+		return make_shared<TupleType>();
+	// for fixed, we allow +, -, ++ and --
+	else if (
+		_operator == Token::Add || 
+		_operator == Token::Sub ||
+		_operator == Token::Inc || 
+		_operator == Token::Dec ||
+		_operator == Token::After
+	)
+		return shared_from_this();
+	else
+		return TypePointer();
+}
+
+bool FixedPointType::operator==(Type const& _other) const
+{
+	if (_other.category() != category())
 		return false;
+	FixedPointType const& other = dynamic_cast<FixedPointType const&>(_other);
+	return other.m_integerBits == m_integerBits && other.m_fractionalBits == m_fractionalBits && other.m_modifier == m_modifier;
+}
+
+string FixedPointType::toString(bool) const
+{
+	string prefix = isSigned() ? "fixed" : "ufixed";
+	return prefix + dev::toString(m_integerBits) + "x" + dev::toString(m_fractionalBits);
+}
+
+TypePointer FixedPointType::binaryOperatorResult(Token::Value _operator, TypePointer const& _other) const
+{
+	if (
+		_other->category() != Category::RationalNumber &&
+		_other->category() != category() &&
+		_other->category() != Category::Integer
+	)
+		return TypePointer();
+	auto commonType = Type::commonType(shared_from_this(), _other); //might be fixed point or integer
+
+	if (!commonType)
+		return TypePointer();
+
+	// All fixed types can be compared
+	if (Token::isCompareOp(_operator))
+		return commonType;
+	if (Token::isBitOp(_operator) || Token::isBooleanOp(_operator))
+		return TypePointer();
+	if (auto fixType = dynamic_pointer_cast<FixedPointType const>(commonType))
+	{
+		if (Token::Exp == _operator)
+			return TypePointer();
 	}
-	return true;
+	else if (auto intType = dynamic_pointer_cast<IntegerType const>(commonType))
+		if (intType->isAddress())
+			return TypePointer();
+	return commonType;
 }
 
-IntegerConstantType::IntegerConstantType(Literal const& _literal)
+tuple<bool, rational> RationalNumberType::isValidLiteral(Literal const& _literal)
 {
-	m_value = bigint(_literal.value());
+	rational x;
+	try
+	{
+		rational numerator;
+		rational denominator(1);
+		
+		auto radixPoint = find(_literal.value().begin(), _literal.value().end(), '.');
+		if (radixPoint != _literal.value().end())
+		{
+			if (
+				!all_of(radixPoint + 1, _literal.value().end(), ::isdigit) || 
+				!all_of(_literal.value().begin(), radixPoint, ::isdigit) 
+			)
+				throw;
+			//Only decimal notation allowed here, leading zeros would switch to octal.
+			auto fractionalBegin = find_if_not(
+				radixPoint + 1, 
+				_literal.value().end(), 
+				[](char const& a) { return a == '0'; }
+			);
 
+			denominator = bigint(string(fractionalBegin, _literal.value().end()));
+			denominator /= boost::multiprecision::pow(
+				bigint(10), 
+				distance(radixPoint + 1, _literal.value().end())
+			);
+			numerator = bigint(string(_literal.value().begin(), radixPoint));
+			x = numerator + denominator;
+		}
+		else
+			x = bigint(_literal.value());
+	}
+	catch (...)
+	{
+		return make_tuple(false, rational(0));
+	}
 	switch (_literal.subDenomination())
 	{
-	case Literal::SubDenomination::Wei:
-	case Literal::SubDenomination::Second:
-	case Literal::SubDenomination::None:
-		break;
-	case Literal::SubDenomination::Szabo:
-		m_value *= bigint("1000000000000");
-		break;
-	case Literal::SubDenomination::Finney:
-		m_value *= bigint("1000000000000000");
-		break;
-	case Literal::SubDenomination::Ether:
-		m_value *= bigint("1000000000000000000");
-		break;
-	case Literal::SubDenomination::Minute:
-		m_value *= bigint("60");
-		break;
-	case Literal::SubDenomination::Hour:
-		m_value *= bigint("3600");
-		break;
-	case Literal::SubDenomination::Day:
-		m_value *= bigint("86400");
-		break;
-	case Literal::SubDenomination::Week:
-		m_value *= bigint("604800");
-		break;
-	case Literal::SubDenomination::Year:
-		m_value *= bigint("31536000");
-		break;
+		case Literal::SubDenomination::None:
+		case Literal::SubDenomination::Wei:
+		case Literal::SubDenomination::Second:
+			break;
+		case Literal::SubDenomination::Szabo:
+			x *= bigint("1000000000000");
+			break;
+		case Literal::SubDenomination::Finney:
+			x *= bigint("1000000000000000");
+			break;
+		case Literal::SubDenomination::Ether:
+			x *= bigint("1000000000000000000");
+			break;
+		case Literal::SubDenomination::Minute:
+			x *= bigint("60");
+			break;
+		case Literal::SubDenomination::Hour:
+			x *= bigint("3600");
+			break;
+		case Literal::SubDenomination::Day:
+			x *= bigint("86400");
+			break;
+		case Literal::SubDenomination::Week:
+			x *= bigint("604800");
+			break;
+		case Literal::SubDenomination::Year:
+			x *= bigint("31536000");
+			break;
 	}
+
+
+	return make_tuple(true, x);
 }
 
-bool IntegerConstantType::isImplicitlyConvertibleTo(Type const& _convertTo) const
+bool RationalNumberType::isImplicitlyConvertibleTo(Type const& _convertTo) const
 {
-	if (auto targetType = dynamic_cast<IntegerType const*>(&_convertTo))
+	if (_convertTo.category() == Category::Integer)
 	{
+		auto targetType = dynamic_cast<IntegerType const*>(&_convertTo);
 		if (m_value == 0)
 			return true;
+		if (isFractional())
+			return false;
 		int forSignBit = (targetType->isSigned() ? 1 : 0);
 		if (m_value > 0)
 		{
-			if (m_value <= (u256(-1) >> (256 - targetType->numBits() + forSignBit)))
+			if (m_value.numerator() <= (u256(-1) >> (256 - targetType->numBits() + forSignBit)))
 				return true;
 		}
-		else if (targetType->isSigned() && -m_value <= (u256(1) << (targetType->numBits() - forSignBit)))
+		else if (targetType->isSigned() && -m_value.numerator() <= (u256(1) << (targetType->numBits() - forSignBit)))
 			return true;
 		return false;
 	}
+	else if (_convertTo.category() == Category::FixedPoint)
+	{
+		if (auto fixed = fixedPointType())
+		{
+			// We disallow implicit conversion if we would have to truncate (fixedPointType()
+			// can return a type that requires truncation).
+			rational value = m_value * (bigint(1) << fixed->fractionalBits());
+			return value.denominator() == 1 && fixed->isImplicitlyConvertibleTo(_convertTo);
+		}
+		return false;
+	}
 	else if (_convertTo.category() == Category::FixedBytes)
 	{
 		FixedBytesType const& fixedBytes = dynamic_cast<FixedBytesType const&>(_convertTo);
-		return fixedBytes.numBytes() * 8 >= integerType()->numBits();
+		if (!isFractional())
+			return fixedBytes.numBytes() * 8 >= integerType()->numBits();
+		else
+			return false;
 	}
-	else
-		return false;
+	return false;
 }
 
-bool IntegerConstantType::isExplicitlyConvertibleTo(Type const& _convertTo) const
+bool RationalNumberType::isExplicitlyConvertibleTo(Type const& _convertTo) const
 {
-	TypePointer intType = integerType();
-	return intType && intType->isExplicitlyConvertibleTo(_convertTo);
+	TypePointer mobType = mobileType();
+	return mobType && mobType->isExplicitlyConvertibleTo(_convertTo);
 }
 
-TypePointer IntegerConstantType::unaryOperatorResult(Token::Value _operator) const
+TypePointer RationalNumberType::unaryOperatorResult(Token::Value _operator) const
 {
-	bigint value;
+	rational value;
 	switch (_operator)
 	{
 	case Token::BitNot:
-		value = ~m_value;
+		if (isFractional())
+			return TypePointer();
+		value = ~m_value.numerator();
 		break;
 	case Token::Add:
-		value = m_value;
+		value = +(m_value);
 		break;
 	case Token::Sub:
-		value = -m_value;
+		value = -(m_value);
 		break;
 	case Token::After:
 		return shared_from_this();
 	default:
 		return TypePointer();
 	}
-	return make_shared<IntegerConstantType>(value);
+	return make_shared<RationalNumberType>(value);
 }
 
-TypePointer IntegerConstantType::binaryOperatorResult(Token::Value _operator, TypePointer const& _other) const
+TypePointer RationalNumberType::binaryOperatorResult(Token::Value _operator, TypePointer const& _other) const
 {
-	if (_other->category() == Category::Integer)
+	if (_other->category() == Category::Integer || _other->category() == Category::FixedPoint)
 	{
-		shared_ptr<IntegerType const> intType = integerType();
-		if (!intType)
+		auto mobile = mobileType();
+		if (!mobile)
 			return TypePointer();
-		return intType->binaryOperatorResult(_operator, _other);
+		return mobile->binaryOperatorResult(_operator, _other);
 	}
 	else if (_other->category() != category())
 		return TypePointer();
 
-	IntegerConstantType const& other = dynamic_cast<IntegerConstantType const&>(*_other);
+	RationalNumberType const& other = dynamic_cast<RationalNumberType const&>(*_other);
 	if (Token::isCompareOp(_operator))
 	{
-		shared_ptr<IntegerType const> thisIntegerType = integerType();
-		shared_ptr<IntegerType const> otherIntegerType = other.integerType();
-		if (!thisIntegerType || !otherIntegerType)
+		// Since we do not have a "BoolConstantType", we have to do the acutal comparison
+		// at runtime and convert to mobile typse first. Such a comparison is not a very common
+		// use-case and will be optimized away.
+		TypePointer thisMobile = mobileType();
+		TypePointer otherMobile = other.mobileType();
+		if (!thisMobile || !otherMobile)
 			return TypePointer();
-		return thisIntegerType->binaryOperatorResult(_operator, otherIntegerType);
+		return thisMobile->binaryOperatorResult(_operator, otherMobile);
 	}
 	else
 	{
-		bigint value;
+		rational value;
+		bool fractional = isFractional() || other.isFractional();
 		switch (_operator)
 		{
+		//bit operations will only be enabled for integers and fixed types that resemble integers
 		case Token::BitOr:
-			value = m_value | other.m_value;
+			if (fractional)
+				return TypePointer();
+			value = m_value.numerator() | other.m_value.numerator();
 			break;
 		case Token::BitXor:
-			value = m_value ^ other.m_value;
+			if (fractional)
+				return TypePointer();
+			value = m_value.numerator() ^ other.m_value.numerator();
 			break;
 		case Token::BitAnd:
-			value = m_value & other.m_value;
+			if (fractional)
+				return TypePointer();
+			value = m_value.numerator() & other.m_value.numerator();
 			break;
 		case Token::Add:
 			value = m_value + other.m_value;
@@ -490,68 +669,104 @@ TypePointer IntegerConstantType::binaryOperatorResult(Token::Value _operator, Ty
 		case Token::Div:
 			if (other.m_value == 0)
 				return TypePointer();
-			value = m_value / other.m_value;
+			else
+				value = m_value / other.m_value;
 			break;
 		case Token::Mod:
 			if (other.m_value == 0)
 				return TypePointer();
-			value = m_value % other.m_value;
-			break;
+			else if (fractional)
+			{
+				rational tempValue = m_value / other.m_value;
+				value = m_value - (tempValue.numerator() / tempValue.denominator()) * other.m_value;
+			}
+			else
+				value = m_value.numerator() % other.m_value.numerator();
+			break;	
 		case Token::Exp:
-			if (other.m_value < 0)
-				return TypePointer();
-			else if (other.m_value > numeric_limits<unsigned int>::max())
+		{
+			using boost::multiprecision::pow;
+			if (other.isFractional())
 				return TypePointer();
+			else if (abs(other.m_value) > numeric_limits<uint32_t>::max())
+				return TypePointer(); // This will need too much memory to represent.
+			uint32_t exponent = abs(other.m_value).numerator().convert_to<uint32_t>();
+			bigint numerator = pow(m_value.numerator(), exponent);
+			bigint denominator = pow(m_value.denominator(), exponent);
+			if (other.m_value >= 0)
+				value = rational(numerator, denominator);
 			else
-				value = boost::multiprecision::pow(m_value, other.m_value.convert_to<unsigned int>());
+				// invert
+				value = rational(denominator, numerator);
 			break;
+		}
 		default:
 			return TypePointer();
 		}
-		return make_shared<IntegerConstantType>(value);
+		return make_shared<RationalNumberType>(value);
 	}
 }
 
-bool IntegerConstantType::operator==(Type const& _other) const
+bool RationalNumberType::operator==(Type const& _other) const
 {
 	if (_other.category() != category())
 		return false;
-	return m_value == dynamic_cast<IntegerConstantType const&>(_other).m_value;
+	RationalNumberType const& other = dynamic_cast<RationalNumberType const&>(_other);
+	return m_value == other.m_value;
 }
 
-string IntegerConstantType::toString(bool) const
+string RationalNumberType::toString(bool) const
 {
-	return "int_const " + m_value.str();
+	if (!isFractional())
+		return "int_const " + m_value.numerator().str();
+	return "rational_const " + m_value.numerator().str() + '/' + m_value.denominator().str();
 }
 
-u256 IntegerConstantType::literalValue(Literal const*) const
+u256 RationalNumberType::literalValue(Literal const*) const
 {
+	// We ignore the literal and hope that the type was correctly determined to represent
+	// its value.
+
 	u256 value;
+	bigint shiftedValue; 
+
+	if (!isFractional())
+		shiftedValue = m_value.numerator();
+	else
+	{
+		auto fixed = fixedPointType();
+		solAssert(!!fixed, "");
+		rational shifted = m_value * (bigint(1) << fixed->fractionalBits());
+		// truncate
+		shiftedValue = shifted.numerator() / shifted.denominator();
+	}
+
 	// we ignore the literal and hope that the type was correctly determined
-	solAssert(m_value <= u256(-1), "Integer constant too large.");
-	solAssert(m_value >= -(bigint(1) << 255), "Integer constant too small.");
+	solAssert(shiftedValue <= u256(-1), "Integer constant too large.");
+	solAssert(shiftedValue >= -(bigint(1) << 255), "Number constant too small.");
 
 	if (m_value >= 0)
-		value = u256(m_value);
+		value = u256(shiftedValue);
 	else
-		value = s2u(s256(m_value));
-
+		value = s2u(s256(shiftedValue));
 	return value;
 }
 
-TypePointer IntegerConstantType::mobileType() const
+TypePointer RationalNumberType::mobileType() const
 {
-	auto intType = integerType();
-	solAssert(!!intType, "mobileType called with invalid integer constant " + toString(false));
-	return intType;
+	if (!isFractional())
+		return integerType();
+	else
+		return fixedPointType();
 }
 
-shared_ptr<IntegerType const> IntegerConstantType::integerType() const
+shared_ptr<IntegerType const> RationalNumberType::integerType() const
 {
-	bigint value = m_value;
+	solAssert(!isFractional(), "integerType() called for fractional number.");
+	bigint value = m_value.numerator();
 	bool negative = (value < 0);
 	if (negative) // convert to positive number of same bit requirements
-		value = ((-value) - 1) << 1;
+		value = ((0 - value) - 1) << 1;
 	if (value > u256(-1))
 		return shared_ptr<IntegerType const>();
 	else
@@ -561,6 +776,58 @@ shared_ptr<IntegerType const> IntegerConstantType::integerType() const
 		);
 }
 
+shared_ptr<FixedPointType const> RationalNumberType::fixedPointType() const
+{
+	bool negative = (m_value < 0);
+	unsigned fractionalBits = 0;
+	rational value = abs(m_value); // We care about the sign later.
+	rational maxValue = negative ? 
+		rational(bigint(1) << 255, 1):
+		rational((bigint(1) << 256) - 1, 1);
+
+	while (value * 0x100 <= maxValue && value.denominator() != 1 && fractionalBits < 256)
+	{
+		value *= 0x100;
+		fractionalBits += 8;
+	}
+	
+	if (value > maxValue)
+		return shared_ptr<FixedPointType const>();
+	// u256(v) is the actual value that will be put on the stack
+	// From here on, very similar to integerType()
+	bigint v = value.numerator() / value.denominator();
+	if (negative)
+		// modify value to satisfy bit requirements for negative numbers:
+		// add one bit for sign and decrement because negative numbers can be larger
+		v = (v - 1) << 1;
+
+	if (v > u256(-1))
+		return shared_ptr<FixedPointType const>();
+
+	unsigned totalBits = bytesRequired(v) * 8;
+	solAssert(totalBits <= 256, "");
+	unsigned integerBits = totalBits >= fractionalBits ? totalBits - fractionalBits : 0;
+	// Special case: Numbers between -1 and 0 have their sign bit in the fractional part.
+	if (negative && abs(m_value) < 1 && totalBits > fractionalBits)
+	{
+		fractionalBits += 8;
+		integerBits = 0;
+	}
+
+	if (integerBits > 256 || fractionalBits > 256 || fractionalBits + integerBits > 256)
+		return shared_ptr<FixedPointType const>();
+	if (integerBits == 0 && fractionalBits == 0)
+	{
+		integerBits = 0;
+		fractionalBits = 8;
+	}
+
+	return make_shared<FixedPointType>(
+		integerBits, fractionalBits,
+		negative ? FixedPointType::Modifier::Signed : FixedPointType::Modifier::Unsigned
+	);
+}
+
 StringLiteralType::StringLiteralType(Literal const& _literal):
 	m_value(_literal.value())
 {
@@ -614,6 +881,7 @@ bool FixedBytesType::isImplicitlyConvertibleTo(Type const& _convertTo) const
 bool FixedBytesType::isExplicitlyConvertibleTo(Type const& _convertTo) const
 {
 	return _convertTo.category() == Category::Integer ||
+		_convertTo.category() == Category::FixedPoint ||
 		_convertTo.category() == Category::Contract ||
 		_convertTo.category() == category();
 }
@@ -655,19 +923,6 @@ bool FixedBytesType::operator==(Type const& _other) const
 	return other.m_bytes == m_bytes;
 }
 
-bool BoolType::isExplicitlyConvertibleTo(Type const& _convertTo) const
-{
-	// conversion to integer is fine, but not to address
-	// this is an example of explicit conversions being not transitive (though implicit should be)
-	if (_convertTo.category() == category())
-	{
-		IntegerType const& convertTo = dynamic_cast<IntegerType const&>(_convertTo);
-		if (!convertTo.isAddress())
-			return true;
-	}
-	return isImplicitlyConvertibleTo(_convertTo);
-}
-
 u256 BoolType::literalValue(Literal const* _literal) const
 {
 	solAssert(_literal, "");
@@ -1052,7 +1307,7 @@ MemberList::MemberMap ContractType::nativeMembers(ContractDefinition const*) con
 					));
 			}
 	}
-	else
+	else if (!m_contract.isLibrary())
 	{
 		for (auto const& it: m_contract.interfaceFunctions())
 			members.push_back(MemberList::Member(
@@ -1282,9 +1537,9 @@ bool EnumType::isExplicitlyConvertibleTo(Type const& _convertTo) const
 	return _convertTo.category() == category() || _convertTo.category() == Category::Integer;
 }
 
-unsigned int EnumType::memberValue(ASTString const& _member) const
+unsigned EnumType::memberValue(ASTString const& _member) const
 {
-	unsigned int index = 0;
+	unsigned index = 0;
 	for (ASTPointer<EnumValue> const& decl: m_enum.members())
 	{
 		if (decl->name() == _member)
@@ -1772,21 +2027,40 @@ FunctionTypePointer FunctionType::asMemberFunction(bool _inLibrary, bool _bound)
 			parameterTypes.push_back(t);
 	}
 
-	// Removes dynamic types.
+	Location location = m_location;
+	if (_inLibrary)
+	{
+		solAssert(!!m_declaration, "Declaration has to be available.");
+		if (!m_declaration->isPublic())
+			location = Location::Internal; // will be inlined
+		else
+			location = Location::DelegateCall;
+	}
+
 	TypePointers returnParameterTypes;
 	vector<string> returnParameterNames;
-	for (size_t i = 0; i < m_returnParameterTypes.size(); ++i)
-		if (!m_returnParameterTypes[i]->isDynamicallySized())
-		{
-			returnParameterTypes.push_back(m_returnParameterTypes[i]);
-			returnParameterNames.push_back(m_returnParameterNames[i]);
-		}
+	if (location == Location::Internal)
+	{
+		returnParameterNames = m_returnParameterNames;
+		returnParameterTypes = m_returnParameterTypes;
+	}
+	else
+	{
+		// Removes dynamic types.
+		for (size_t i = 0; i < m_returnParameterTypes.size(); ++i)
+			if (!m_returnParameterTypes[i]->isDynamicallySized())
+			{
+				returnParameterTypes.push_back(m_returnParameterTypes[i]);
+				returnParameterNames.push_back(m_returnParameterNames[i]);
+			}
+	}
+
 	return make_shared<FunctionType>(
 		parameterTypes,
 		returnParameterTypes,
 		m_parameterNames,
 		returnParameterNames,
-		_inLibrary ? Location::DelegateCall : m_location,
+		location,
 		m_arbitraryParameters,
 		m_declaration,
 		m_gasSet,
@@ -1882,12 +2156,13 @@ MemberList::MemberMap TypeType::nativeMembers(ContractDefinition const* _current
 			isBase = (find(currentBases.begin(), currentBases.end(), &contract) != currentBases.end());
 		}
 		if (contract.isLibrary())
-			for (auto const& it: contract.interfaceFunctions())
-				members.push_back(MemberList::Member(
-					it.second->declaration().name(),
-					it.second->asMemberFunction(true),
-					&it.second->declaration()
-				));
+			for (FunctionDefinition const* function: contract.definedFunctions())
+				if (function->isVisibleInDerivedContracts())
+					members.push_back(MemberList::Member(
+						function->name(),
+						FunctionType(*function).asMemberFunction(true),
+						function
+					));
 		if (isBase)
 		{
 			// We are accessing the type of a base contract, so add all public and protected
diff --git a/libsolidity/ast/Types.h b/libsolidity/ast/Types.h
index d42bb5dd..967e968c 100644
--- a/libsolidity/ast/Types.h
+++ b/libsolidity/ast/Types.h
@@ -26,6 +26,7 @@
 #include <string>
 #include <map>
 #include <boost/noncopyable.hpp>
+#include <boost/rational.hpp>
 #include <libdevcore/Common.h>
 #include <libdevcore/CommonIO.h>
 #include <libsolidity/interface/Exceptions.h>
@@ -43,6 +44,7 @@ class FunctionType; // forward
 using TypePointer = std::shared_ptr<Type const>;
 using FunctionTypePointer = std::shared_ptr<FunctionType const>;
 using TypePointers = std::vector<TypePointer>;
+using rational = boost::rational<dev::bigint>;
 
 
 enum class DataLocation { Storage, CallData, Memory };
@@ -133,7 +135,7 @@ class Type: private boost::noncopyable, public std::enable_shared_from_this<Type
 public:
 	enum class Category
 	{
-		Integer, IntegerConstant, StringLiteral, Bool, Real, Array,
+		Integer, RationalNumber, StringLiteral, Bool, FixedPoint, Array,
 		FixedBytes, Contract, Struct, Function, Enum, Tuple,
 		Mapping, TypeType, Modifier, Magic, Module
 	};
@@ -202,8 +204,9 @@ public:
 	virtual bool isValueType() const { return false; }
 	virtual unsigned sizeOnStack() const { return 1; }
 	/// @returns the mobile (in contrast to static) type corresponding to the given type.
-	/// This returns the corresponding integer type for IntegerConstantTypes and the pointer type
-	/// for storage reference types.
+	/// This returns the corresponding IntegerType or FixedPointType for RationalNumberType
+	/// and the pointer type for storage reference types.
+	/// Might return a null pointer if there is no fitting type.
 	virtual TypePointer mobileType() const { return shared_from_this(); }
 	/// @returns true if this is a non-value type and the data of this type is stored at the
 	/// given location.
@@ -309,20 +312,63 @@ private:
 };
 
 /**
- * Integer constants either literals or computed. Example expressions: 2, 2+10, ~10.
- * There is one distinct type per value.
+ * A fixed point type number (signed, unsigned).
  */
-class IntegerConstantType: public Type
+class FixedPointType: public Type
 {
 public:
-	virtual Category category() const override { return Category::IntegerConstant; }
+	enum class Modifier
+	{
+		Unsigned, Signed
+	};
+	virtual Category category() const override { return Category::FixedPoint; }
 
-	/// @returns true if the literal is a valid integer.
-	static bool isValidLiteral(Literal const& _literal);
+	explicit FixedPointType(int _integerBits, int _fractionalBits, Modifier _modifier = Modifier::Unsigned);
+
+	virtual bool isImplicitlyConvertibleTo(Type const& _convertTo) const override;
+	virtual bool isExplicitlyConvertibleTo(Type const& _convertTo) const override;
+	virtual TypePointer unaryOperatorResult(Token::Value _operator) const override;
+	virtual TypePointer binaryOperatorResult(Token::Value _operator, TypePointer const& _other) const override;
+
+	virtual bool operator==(Type const& _other) const override;
+
+	virtual unsigned calldataEncodedSize(bool _padded = true) const override { return _padded ? 32 : (m_integerBits + m_fractionalBits) / 8; }
+	virtual unsigned storageBytes() const override { return (m_integerBits + m_fractionalBits) / 8; }
+	virtual bool isValueType() const override { return true; }
 
-	explicit IntegerConstantType(Literal const& _literal);
-	explicit IntegerConstantType(bigint _value): m_value(_value) {}
+	virtual std::string toString(bool _short) const override;
+
+	virtual TypePointer encodingType() const override { return shared_from_this(); }
+	virtual TypePointer interfaceType(bool) const override { return shared_from_this(); }
 
+	int numBits() const { return m_integerBits + m_fractionalBits; }
+	int integerBits() const { return m_integerBits; }
+	int fractionalBits() const { return m_fractionalBits; }
+	bool isSigned() const { return m_modifier == Modifier::Signed; }
+
+private:
+	int m_integerBits;
+	int m_fractionalBits;
+	Modifier m_modifier;
+};
+
+/**
+ * Integer and fixed point constants either literals or computed. 
+ * Example expressions: 2, 3.14, 2+10.2, ~10.
+ * There is one distinct type per value.
+ */
+class RationalNumberType: public Type
+{
+public:
+
+	virtual Category category() const override { return Category::RationalNumber; }
+
+	/// @returns true if the literal is a valid integer.
+	static std::tuple<bool, rational> isValidLiteral(Literal const& _literal);
+	
+	explicit RationalNumberType(rational const& _value):
+		m_value(_value)
+	{}
 	virtual bool isImplicitlyConvertibleTo(Type const& _convertTo) const override;
 	virtual bool isExplicitlyConvertibleTo(Type const& _convertTo) const override;
 	virtual TypePointer unaryOperatorResult(Token::Value _operator) const override;
@@ -339,9 +385,15 @@ public:
 
 	/// @returns the smallest integer type that can hold the value or an empty pointer if not possible.
 	std::shared_ptr<IntegerType const> integerType() const;
+	/// @returns the smallest fixed type that can  hold the value or incurs the least precision loss. 
+	/// If the integer part does not fit, returns an empty pointer.
+	std::shared_ptr<FixedPointType const> fixedPointType() const;
+
+	/// @returns true if the value is not an integer.
+	bool isFractional() const { return m_value.denominator() != 1; }
 
 private:
-	bigint m_value;
+	rational m_value;
 };
 
 /**
@@ -418,7 +470,6 @@ class BoolType: public Type
 public:
 	BoolType() {}
 	virtual Category category() const override { return Category::Bool; }
-	virtual bool isExplicitlyConvertibleTo(Type const& _convertTo) const override;
 	virtual TypePointer unaryOperatorResult(Token::Value _operator) const override;
 	virtual TypePointer binaryOperatorResult(Token::Value _operator, TypePointer const& _other) const override;
 
diff --git a/libsolidity/codegen/Compiler.cpp b/libsolidity/codegen/Compiler.cpp
index d4c94297..1ae5dda9 100644
--- a/libsolidity/codegen/Compiler.cpp
+++ b/libsolidity/codegen/Compiler.cpp
@@ -21,51 +21,24 @@
  */
 
 #include <libsolidity/codegen/Compiler.h>
-#include <algorithm>
-#include <boost/range/adaptor/reversed.hpp>
-#include <libevmasm/Instruction.h>
 #include <libevmasm/Assembly.h>
-#include <libevmasm/GasMeter.h>
-#include <libsolidity/inlineasm/AsmCodeGen.h>
-#include <libsolidity/ast/AST.h>
-#include <libsolidity/codegen/ExpressionCompiler.h>
-#include <libsolidity/codegen/CompilerUtils.h>
+#include <libsolidity/codegen/ContractCompiler.h>
+
 using namespace std;
 using namespace dev;
 using namespace dev::solidity;
 
-/**
- * Simple helper class to ensure that the stack height is the same at certain places in the code.
- */
-class StackHeightChecker
-{
-public:
-	StackHeightChecker(CompilerContext const& _context):
-		m_context(_context), stackHeight(m_context.stackHeight()) {}
-	void check() { solAssert(m_context.stackHeight() == stackHeight, "I sense a disturbance in the stack."); }
-private:
-	CompilerContext const& m_context;
-	unsigned stackHeight;
-};
-
 void Compiler::compileContract(
 	ContractDefinition const& _contract,
 	std::map<const ContractDefinition*, eth::Assembly const*> const& _contracts
 )
 {
-	m_context = CompilerContext();
-	{
-		CompilerContext::LocationSetter locationSetterRunTime(m_context, _contract);
-		initializeContext(_contract, _contracts);
-		appendFunctionSelector(_contract);
-		appendFunctionsWithoutCode();
-	}
+	ContractCompiler runtimeCompiler(m_runtimeContext, m_optimize);
+	runtimeCompiler.compileContract(_contract, _contracts);
+
+	ContractCompiler creationCompiler(m_context, m_optimize);
+	m_runtimeSub = creationCompiler.compileConstructor(m_runtimeContext, _contract, _contracts);
 
-	// Swap the runtime context with the creation-time context
-	swap(m_context, m_runtimeContext);
-	CompilerContext::LocationSetter locationSetterCreationTime(m_context, _contract);
-	initializeContext(_contract, _contracts);
-	packIntoContractCreator(_contract, m_runtimeContext);
 	if (m_optimize)
 		m_context.optimise(m_optimizeRuns);
 
@@ -81,21 +54,8 @@ void Compiler::compileClone(
 	map<ContractDefinition const*, eth::Assembly const*> const& _contracts
 )
 {
-	m_context = CompilerContext(); // clear it just in case
-	initializeContext(_contract, _contracts);
-
-	appendInitAndConstructorCode(_contract);
-
-	//@todo determine largest return size of all runtime functions
-	eth::AssemblyItem runtimeSub = m_context.addSubroutine(cloneRuntime());
-	solAssert(runtimeSub.data() < numeric_limits<size_t>::max(), "");
-	m_runtimeSub = size_t(runtimeSub.data());
-
-	// stack contains sub size
-	m_context << Instruction::DUP1 << runtimeSub << u256(0) << Instruction::CODECOPY;
-	m_context << u256(0) << Instruction::RETURN;
-
-	appendFunctionsWithoutCode();
+	ContractCompiler cloneCompiler(m_context, m_optimize);
+	m_runtimeSub = cloneCompiler.compileClone(_contract, _contracts);
 
 	if (m_optimize)
 		m_context.optimise(m_optimizeRuns);
@@ -105,769 +65,3 @@ eth::AssemblyItem Compiler::functionEntryLabel(FunctionDefinition const& _functi
 {
 	return m_runtimeContext.functionEntryLabelIfExists(_function);
 }
-
-void Compiler::initializeContext(
-	ContractDefinition const& _contract,
-	map<ContractDefinition const*, eth::Assembly const*> const& _compiledContracts
-)
-{
-	m_context.setCompiledContracts(_compiledContracts);
-	m_context.setInheritanceHierarchy(_contract.annotation().linearizedBaseContracts);
-	CompilerUtils(m_context).initialiseFreeMemoryPointer();
-	registerStateVariables(_contract);
-	m_context.resetVisitedNodes(&_contract);
-}
-
-void Compiler::appendInitAndConstructorCode(ContractDefinition const& _contract)
-{
-	// Determine the arguments that are used for the base constructors.
-	std::vector<ContractDefinition const*> const& bases = _contract.annotation().linearizedBaseContracts;
-	for (ContractDefinition const* contract: bases)
-	{
-		if (FunctionDefinition const* constructor = contract->constructor())
-			for (auto const& modifier: constructor->modifiers())
-			{
-				auto baseContract = dynamic_cast<ContractDefinition const*>(
-					modifier->name()->annotation().referencedDeclaration);
-				if (baseContract)
-					if (m_baseArguments.count(baseContract->constructor()) == 0)
-						m_baseArguments[baseContract->constructor()] = &modifier->arguments();
-			}
-
-		for (ASTPointer<InheritanceSpecifier> const& base: contract->baseContracts())
-		{
-			ContractDefinition const* baseContract = dynamic_cast<ContractDefinition const*>(
-				base->name().annotation().referencedDeclaration
-			);
-			solAssert(baseContract, "");
-
-			if (m_baseArguments.count(baseContract->constructor()) == 0)
-				m_baseArguments[baseContract->constructor()] = &base->arguments();
-		}
-	}
-	// Initialization of state variables in base-to-derived order.
-	for (ContractDefinition const* contract: boost::adaptors::reverse(bases))
-		initializeStateVariables(*contract);
-
-	if (FunctionDefinition const* constructor = _contract.constructor())
-		appendConstructor(*constructor);
-	else if (auto c = m_context.nextConstructor(_contract))
-		appendBaseConstructor(*c);
-}
-
-void Compiler::packIntoContractCreator(ContractDefinition const& _contract, CompilerContext const& _runtimeContext)
-{
-	appendInitAndConstructorCode(_contract);
-
-	eth::AssemblyItem runtimeSub = m_context.addSubroutine(_runtimeContext.assembly());
-	solAssert(runtimeSub.data() < numeric_limits<size_t>::max(), "");
-	m_runtimeSub = size_t(runtimeSub.data());
-
-	// stack contains sub size
-	m_context << Instruction::DUP1 << runtimeSub << u256(0) << Instruction::CODECOPY;
-	m_context << u256(0) << Instruction::RETURN;
-
-	// note that we have to include the functions again because of absolute jump labels
-	appendFunctionsWithoutCode();
-}
-
-void Compiler::appendBaseConstructor(FunctionDefinition const& _constructor)
-{
-	CompilerContext::LocationSetter locationSetter(m_context, _constructor);
-	FunctionType constructorType(_constructor);
-	if (!constructorType.parameterTypes().empty())
-	{
-		solAssert(m_baseArguments.count(&_constructor), "");
-		std::vector<ASTPointer<Expression>> const* arguments = m_baseArguments[&_constructor];
-		solAssert(arguments, "");
-		for (unsigned i = 0; i < arguments->size(); ++i)
-			compileExpression(*(arguments->at(i)), constructorType.parameterTypes()[i]);
-	}
-	_constructor.accept(*this);
-}
-
-void Compiler::appendConstructor(FunctionDefinition const& _constructor)
-{
-	CompilerContext::LocationSetter locationSetter(m_context, _constructor);
-	// copy constructor arguments from code to memory and then to stack, they are supplied after the actual program
-	if (!_constructor.parameters().empty())
-	{
-		unsigned argumentSize = 0;
-		for (ASTPointer<VariableDeclaration> const& var: _constructor.parameters())
-			if (var->annotation().type->isDynamicallySized())
-			{
-				argumentSize = 0;
-				break;
-			}
-			else
-				argumentSize += var->annotation().type->calldataEncodedSize();
-
-		CompilerUtils(m_context).fetchFreeMemoryPointer();
-		if (argumentSize == 0)
-		{
-			// argument size is dynamic, use CODESIZE to determine it
-			m_context.appendProgramSize(); // program itself
-			// CODESIZE is program plus manually added arguments
-			m_context << Instruction::CODESIZE << Instruction::SUB;
-		}
-		else
-			m_context << u256(argumentSize);
-		// stack: <memptr> <argument size>
-		m_context << Instruction::DUP1;
-		m_context.appendProgramSize();
-		m_context << Instruction::DUP4 << Instruction::CODECOPY;
-		m_context << Instruction::DUP2 << Instruction::ADD;
-		CompilerUtils(m_context).storeFreeMemoryPointer();
-		// stack: <memptr>
-		appendCalldataUnpacker(FunctionType(_constructor).parameterTypes(), true);
-	}
-	_constructor.accept(*this);
-}
-
-void Compiler::appendFunctionSelector(ContractDefinition const& _contract)
-{
-	map<FixedHash<4>, FunctionTypePointer> interfaceFunctions = _contract.interfaceFunctions();
-	map<FixedHash<4>, const eth::AssemblyItem> callDataUnpackerEntryPoints;
-
-	FunctionDefinition const* fallback = _contract.fallbackFunction();
-	eth::AssemblyItem notFound = m_context.newTag();
-	// shortcut messages without data if we have many functions in order to be able to receive
-	// ether with constant gas
-	if (interfaceFunctions.size() > 5 || fallback)
-	{
-		m_context << Instruction::CALLDATASIZE << Instruction::ISZERO;
-		m_context.appendConditionalJumpTo(notFound);
-	}
-
-	// retrieve the function signature hash from the calldata
-	if (!interfaceFunctions.empty())
-		CompilerUtils(m_context).loadFromMemory(0, IntegerType(CompilerUtils::dataStartOffset * 8), true);
-
-	// stack now is: 1 0 <funhash>
-	for (auto const& it: interfaceFunctions)
-	{
-		callDataUnpackerEntryPoints.insert(std::make_pair(it.first, m_context.newTag()));
-		m_context << dupInstruction(1) << u256(FixedHash<4>::Arith(it.first)) << Instruction::EQ;
-		m_context.appendConditionalJumpTo(callDataUnpackerEntryPoints.at(it.first));
-	}
-	m_context.appendJumpTo(notFound);
-
-	m_context << notFound;
-	if (fallback)
-	{
-		eth::AssemblyItem returnTag = m_context.pushNewTag();
-		fallback->accept(*this);
-		m_context << returnTag;
-		appendReturnValuePacker(FunctionType(*fallback).returnParameterTypes(), _contract.isLibrary());
-	}
-	else if (_contract.isLibrary())
-		// Reject invalid library calls and ether sent to a library.
-		m_context.appendJumpTo(m_context.errorTag());
-	else
-		m_context << Instruction::STOP; // function not found
-
-	for (auto const& it: interfaceFunctions)
-	{
-		FunctionTypePointer const& functionType = it.second;
-		solAssert(functionType->hasDeclaration(), "");
-		CompilerContext::LocationSetter locationSetter(m_context, functionType->declaration());
-		m_context << callDataUnpackerEntryPoints.at(it.first);
-		eth::AssemblyItem returnTag = m_context.pushNewTag();
-		m_context << CompilerUtils::dataStartOffset;
-		appendCalldataUnpacker(functionType->parameterTypes());
-		m_context.appendJumpTo(m_context.functionEntryLabel(functionType->declaration()));
-		m_context << returnTag;
-		appendReturnValuePacker(functionType->returnParameterTypes(), _contract.isLibrary());
-	}
-}
-
-void Compiler::appendCalldataUnpacker(TypePointers const& _typeParameters, bool _fromMemory)
-{
-	// We do not check the calldata size, everything is zero-padded
-
-	//@todo this does not yet support nested dynamic arrays
-
-	// Retain the offset pointer as base_offset, the point from which the data offsets are computed.
-	m_context << Instruction::DUP1;
-	for (TypePointer const& parameterType: _typeParameters)
-	{
-		// stack: v1 v2 ... v(k-1) base_offset current_offset
-		TypePointer type = parameterType->decodingType();
-		if (type->category() == Type::Category::Array)
-		{
-			auto const& arrayType = dynamic_cast<ArrayType const&>(*type);
-			solAssert(!arrayType.baseType()->isDynamicallySized(), "Nested arrays not yet implemented.");
-			if (_fromMemory)
-			{
-				solAssert(
-					arrayType.baseType()->isValueType(),
-					"Nested memory arrays not yet implemented here."
-				);
-				// @todo If base type is an array or struct, it is still calldata-style encoded, so
-				// we would have to convert it like below.
-				solAssert(arrayType.location() == DataLocation::Memory, "");
-				if (arrayType.isDynamicallySized())
-				{
-					// compute data pointer
-					m_context << Instruction::DUP1 << Instruction::MLOAD;
-					m_context << Instruction::DUP3 << Instruction::ADD;
-					m_context << Instruction::SWAP2 << Instruction::SWAP1;
-					m_context << u256(0x20) << Instruction::ADD;
-				}
-				else
-				{
-					m_context << Instruction::SWAP1 << Instruction::DUP2;
-					m_context << u256(arrayType.calldataEncodedSize(true)) << Instruction::ADD;
-				}
-			}
-			else
-			{
-				// first load from calldata and potentially convert to memory if arrayType is memory
-				TypePointer calldataType = arrayType.copyForLocation(DataLocation::CallData, false);
-				if (calldataType->isDynamicallySized())
-				{
-					// put on stack: data_pointer length
-					CompilerUtils(m_context).loadFromMemoryDynamic(IntegerType(256), !_fromMemory);
-					// stack: base_offset data_offset next_pointer
-					m_context << Instruction::SWAP1 << Instruction::DUP3 << Instruction::ADD;
-					// stack: base_offset next_pointer data_pointer
-					// retrieve length
-					CompilerUtils(m_context).loadFromMemoryDynamic(IntegerType(256), !_fromMemory, true);
-					// stack: base_offset next_pointer length data_pointer
-					m_context << Instruction::SWAP2;
-					// stack: base_offset data_pointer length next_pointer
-				}
-				else
-				{
-					// leave the pointer on the stack
-					m_context << Instruction::DUP1;
-					m_context << u256(calldataType->calldataEncodedSize()) << Instruction::ADD;
-				}
-				if (arrayType.location() == DataLocation::Memory)
-				{
-					// stack: base_offset calldata_ref [length] next_calldata
-					// copy to memory
-					// move calldata type up again
-					CompilerUtils(m_context).moveIntoStack(calldataType->sizeOnStack());
-					CompilerUtils(m_context).convertType(*calldataType, arrayType);
-					// fetch next pointer again
-					CompilerUtils(m_context).moveToStackTop(arrayType.sizeOnStack());
-				}
-				// move base_offset up
-				CompilerUtils(m_context).moveToStackTop(1 + arrayType.sizeOnStack());
-				m_context << Instruction::SWAP1;
-			}
-		}
-		else
-		{
-			solAssert(!type->isDynamicallySized(), "Unknown dynamically sized type: " + type->toString());
-			CompilerUtils(m_context).loadFromMemoryDynamic(*type, !_fromMemory, true);
-			CompilerUtils(m_context).moveToStackTop(1 + type->sizeOnStack());
-			m_context << Instruction::SWAP1;
-		}
-		// stack: v1 v2 ... v(k-1) v(k) base_offset mem_offset
-	}
-	m_context << Instruction::POP << Instruction::POP;
-}
-
-void Compiler::appendReturnValuePacker(TypePointers const& _typeParameters, bool _isLibrary)
-{
-	CompilerUtils utils(m_context);
-	if (_typeParameters.empty())
-		m_context << Instruction::STOP;
-	else
-	{
-		utils.fetchFreeMemoryPointer();
-		//@todo optimization: if we return a single memory array, there should be enough space before
-		// its data to add the needed parts and we avoid a memory copy.
-		utils.encodeToMemory(_typeParameters, _typeParameters, true, false, _isLibrary);
-		utils.toSizeAfterFreeMemoryPointer();
-		m_context << Instruction::RETURN;
-	}
-}
-
-void Compiler::registerStateVariables(ContractDefinition const& _contract)
-{
-	for (auto const& var: ContractType(_contract).stateVariables())
-		m_context.addStateVariable(*get<0>(var), get<1>(var), get<2>(var));
-}
-
-void Compiler::initializeStateVariables(ContractDefinition const& _contract)
-{
-	for (VariableDeclaration const* variable: _contract.stateVariables())
-		if (variable->value() && !variable->isConstant())
-			ExpressionCompiler(m_context, m_optimize).appendStateVariableInitialization(*variable);
-}
-
-bool Compiler::visit(VariableDeclaration const& _variableDeclaration)
-{
-	solAssert(_variableDeclaration.isStateVariable(), "Compiler visit to non-state variable declaration.");
-	CompilerContext::LocationSetter locationSetter(m_context, _variableDeclaration);
-
-	m_context.startFunction(_variableDeclaration);
-	m_breakTags.clear();
-	m_continueTags.clear();
-
-	if (_variableDeclaration.isConstant())
-		ExpressionCompiler(m_context, m_optimize).appendConstStateVariableAccessor(_variableDeclaration);
-	else
-		ExpressionCompiler(m_context, m_optimize).appendStateVariableAccessor(_variableDeclaration);
-
-	return false;
-}
-
-bool Compiler::visit(FunctionDefinition const& _function)
-{
-	CompilerContext::LocationSetter locationSetter(m_context, _function);
-
-	m_context.startFunction(_function);
-
-	// stack upon entry: [return address] [arg0] [arg1] ... [argn]
-	// reserve additional slots: [retarg0] ... [retargm] [localvar0] ... [localvarp]
-
-	unsigned parametersSize = CompilerUtils::sizeOnStack(_function.parameters());
-	if (!_function.isConstructor())
-		// adding 1 for return address.
-		m_context.adjustStackOffset(parametersSize + 1);
-	for (ASTPointer<VariableDeclaration const> const& variable: _function.parameters())
-	{
-		m_context.addVariable(*variable, parametersSize);
-		parametersSize -= variable->annotation().type->sizeOnStack();
-	}
-
-	for (ASTPointer<VariableDeclaration const> const& variable: _function.returnParameters())
-		appendStackVariableInitialisation(*variable);
-	for (VariableDeclaration const* localVariable: _function.localVariables())
-		appendStackVariableInitialisation(*localVariable);
-
-	if (_function.isConstructor())
-		if (auto c = m_context.nextConstructor(dynamic_cast<ContractDefinition const&>(*_function.scope())))
-			appendBaseConstructor(*c);
-
-	m_returnTag = m_context.newTag();
-	m_breakTags.clear();
-	m_continueTags.clear();
-	m_stackCleanupForReturn = 0;
-	m_currentFunction = &_function;
-	m_modifierDepth = 0;
-
-	appendModifierOrFunctionCode();
-
-	m_context << m_returnTag;
-
-	// Now we need to re-shuffle the stack. For this we keep a record of the stack layout
-	// that shows the target positions of the elements, where "-1" denotes that this element needs
-	// to be removed from the stack.
-	// Note that the fact that the return arguments are of increasing index is vital for this
-	// algorithm to work.
-
-	unsigned const c_argumentsSize = CompilerUtils::sizeOnStack(_function.parameters());
-	unsigned const c_returnValuesSize = CompilerUtils::sizeOnStack(_function.returnParameters());
-	unsigned const c_localVariablesSize = CompilerUtils::sizeOnStack(_function.localVariables());
-
-	vector<int> stackLayout;
-	stackLayout.push_back(c_returnValuesSize); // target of return address
-	stackLayout += vector<int>(c_argumentsSize, -1); // discard all arguments
-	for (unsigned i = 0; i < c_returnValuesSize; ++i)
-		stackLayout.push_back(i);
-	stackLayout += vector<int>(c_localVariablesSize, -1);
-
-	solAssert(stackLayout.size() <= 17, "Stack too deep, try removing local variables.");
-	while (stackLayout.back() != int(stackLayout.size() - 1))
-		if (stackLayout.back() < 0)
-		{
-			m_context << Instruction::POP;
-			stackLayout.pop_back();
-		}
-		else
-		{
-			m_context << swapInstruction(stackLayout.size() - stackLayout.back() - 1);
-			swap(stackLayout[stackLayout.back()], stackLayout.back());
-		}
-	//@todo assert that everything is in place now
-
-	for (ASTPointer<VariableDeclaration const> const& variable: _function.parameters() + _function.returnParameters())
-		m_context.removeVariable(*variable);
-	for (VariableDeclaration const* localVariable: _function.localVariables())
-		m_context.removeVariable(*localVariable);
-
-	m_context.adjustStackOffset(-(int)c_returnValuesSize);
-
-	if (!_function.isConstructor())
-		m_context.appendJump(eth::AssemblyItem::JumpType::OutOfFunction);
-	return false;
-}
-
-bool Compiler::visit(InlineAssembly const& _inlineAssembly)
-{
-	ErrorList errors;
-	assembly::CodeGenerator codeGen(_inlineAssembly.operations(), errors);
-	int startStackHeight = m_context.stackHeight();
-	m_context.appendInlineAssembly(codeGen.assemble(
-		[&](assembly::Identifier const& _identifier, eth::Assembly& _assembly, assembly::CodeGenerator::IdentifierContext _context) {
-			auto ref = _inlineAssembly.annotation().externalReferences.find(&_identifier);
-			if (ref == _inlineAssembly.annotation().externalReferences.end())
-				return false;
-			Declaration const* decl = ref->second;
-			solAssert(!!decl, "");
-			if (_context == assembly::CodeGenerator::IdentifierContext::RValue)
-			{
-				solAssert(!!decl->type(), "Type of declaration required but not yet determined.");
-				if (/*FunctionDefinition const* functionDef = */dynamic_cast<FunctionDefinition const*>(decl))
-				{
-					solAssert(false, "Referencing local functions in inline assembly not yet implemented.");
-					// This does not work directly, because the label does not exist in _assembly
-					// (it is a fresh assembly object).
-					// _assembly.append(m_context.virtualFunctionEntryLabel(*functionDef).pushTag());
-				}
-				else if (auto variable = dynamic_cast<VariableDeclaration const*>(decl))
-				{
-					solAssert(!variable->isConstant(), "");
-					if (m_context.isLocalVariable(variable))
-					{
-						int stackDiff = _assembly.deposit() + startStackHeight - m_context.baseStackOffsetOfVariable(*variable);
-						if (stackDiff < 1 || stackDiff > 16)
-							BOOST_THROW_EXCEPTION(
-								CompilerError() <<
-								errinfo_comment("Stack too deep, try removing local variables.")
-							);
-						for (unsigned i = 0; i < variable->type()->sizeOnStack(); ++i)
-							_assembly.append(dupInstruction(stackDiff));
-					}
-					else
-					{
-						solAssert(m_context.isStateVariable(variable), "Invalid variable type.");
-						auto const& location = m_context.storageLocationOfVariable(*variable);
-						if (!variable->type()->isValueType())
-						{
-							solAssert(location.second == 0, "Intra-slot offest assumed to be zero.");
-							_assembly.append(location.first);
-						}
-						else
-						{
-							_assembly.append(location.first);
-							_assembly.append(u256(location.second));
-						}
-					}
-				}
-				else if (auto contract = dynamic_cast<ContractDefinition const*>(decl))
-				{
-					solAssert(contract->isLibrary(), "");
-					_assembly.appendLibraryAddress(contract->name());
-				}
-				else
-					solAssert(false, "Invalid declaration type.");
-			} else {
-				// lvalue context
-				auto variable = dynamic_cast<VariableDeclaration const*>(decl);
-				solAssert(
-					!!variable || !m_context.isLocalVariable(variable),
-					"Can only assign to stack variables in inline assembly."
-				);
-				unsigned size = variable->type()->sizeOnStack();
-				int stackDiff = _assembly.deposit() + startStackHeight - m_context.baseStackOffsetOfVariable(*variable) - size;
-				if (stackDiff > 16 || stackDiff < 1)
-					BOOST_THROW_EXCEPTION(
-						CompilerError() <<
-						errinfo_comment("Stack too deep, try removing local variables.")
-					);
-				for (unsigned i = 0; i < size; ++i) {
-					_assembly.append(swapInstruction(stackDiff));
-					_assembly.append(Instruction::POP);
-				}
-			}
-			return true;
-		}
-	));
-	solAssert(errors.empty(), "Code generation for inline assembly with errors requested.");
-	return false;
-}
-
-bool Compiler::visit(IfStatement const& _ifStatement)
-{
-	StackHeightChecker checker(m_context);
-	CompilerContext::LocationSetter locationSetter(m_context, _ifStatement);
-	compileExpression(_ifStatement.condition());
-	m_context << Instruction::ISZERO;
-	eth::AssemblyItem falseTag = m_context.appendConditionalJump();
-	eth::AssemblyItem endTag = falseTag;
-	_ifStatement.trueStatement().accept(*this);
-	if (_ifStatement.falseStatement())
-	{
-		endTag = m_context.appendJumpToNew();
-		m_context << falseTag;
-		_ifStatement.falseStatement()->accept(*this);
-	}
-	m_context << endTag;
-
-	checker.check();
-	return false;
-}
-
-bool Compiler::visit(WhileStatement const& _whileStatement)
-{
-	StackHeightChecker checker(m_context);
-	CompilerContext::LocationSetter locationSetter(m_context, _whileStatement);
-	eth::AssemblyItem loopStart = m_context.newTag();
-	eth::AssemblyItem loopEnd = m_context.newTag();
-	m_continueTags.push_back(loopStart);
-	m_breakTags.push_back(loopEnd);
-
-	m_context << loopStart;
-	compileExpression(_whileStatement.condition());
-	m_context << Instruction::ISZERO;
-	m_context.appendConditionalJumpTo(loopEnd);
-
-	_whileStatement.body().accept(*this);
-
-	m_context.appendJumpTo(loopStart);
-	m_context << loopEnd;
-
-	m_continueTags.pop_back();
-	m_breakTags.pop_back();
-
-	checker.check();
-	return false;
-}
-
-bool Compiler::visit(ForStatement const& _forStatement)
-{
-	StackHeightChecker checker(m_context);
-	CompilerContext::LocationSetter locationSetter(m_context, _forStatement);
-	eth::AssemblyItem loopStart = m_context.newTag();
-	eth::AssemblyItem loopEnd = m_context.newTag();
-	eth::AssemblyItem loopNext = m_context.newTag();
-	m_continueTags.push_back(loopNext);
-	m_breakTags.push_back(loopEnd);
-
-	if (_forStatement.initializationExpression())
-		_forStatement.initializationExpression()->accept(*this);
-
-	m_context << loopStart;
-
-	// if there is no terminating condition in for, default is to always be true
-	if (_forStatement.condition())
-	{
-		compileExpression(*_forStatement.condition());
-		m_context << Instruction::ISZERO;
-		m_context.appendConditionalJumpTo(loopEnd);
-	}
-
-	_forStatement.body().accept(*this);
-
-	m_context << loopNext;
-
-	// for's loop expression if existing
-	if (_forStatement.loopExpression())
-		_forStatement.loopExpression()->accept(*this);
-
-	m_context.appendJumpTo(loopStart);
-	m_context << loopEnd;
-
-	m_continueTags.pop_back();
-	m_breakTags.pop_back();
-
-	checker.check();
-	return false;
-}
-
-bool Compiler::visit(Continue const& _continueStatement)
-{
-	CompilerContext::LocationSetter locationSetter(m_context, _continueStatement);
-	if (!m_continueTags.empty())
-		m_context.appendJumpTo(m_continueTags.back());
-	return false;
-}
-
-bool Compiler::visit(Break const& _breakStatement)
-{
-	CompilerContext::LocationSetter locationSetter(m_context, _breakStatement);
-	if (!m_breakTags.empty())
-		m_context.appendJumpTo(m_breakTags.back());
-	return false;
-}
-
-bool Compiler::visit(Return const& _return)
-{
-	CompilerContext::LocationSetter locationSetter(m_context, _return);
-	if (Expression const* expression = _return.expression())
-	{
-		solAssert(_return.annotation().functionReturnParameters, "Invalid return parameters pointer.");
-		vector<ASTPointer<VariableDeclaration>> const& returnParameters =
-			_return.annotation().functionReturnParameters->parameters();
-		TypePointers types;
-		for (auto const& retVariable: returnParameters)
-			types.push_back(retVariable->annotation().type);
-
-		TypePointer expectedType;
-		if (expression->annotation().type->category() == Type::Category::Tuple || types.size() != 1)
-			expectedType = make_shared<TupleType>(types);
-		else
-			expectedType = types.front();
-		compileExpression(*expression, expectedType);
-
-		for (auto const& retVariable: boost::adaptors::reverse(returnParameters))
-			CompilerUtils(m_context).moveToStackVariable(*retVariable);
-	}
-	for (unsigned i = 0; i < m_stackCleanupForReturn; ++i)
-		m_context << Instruction::POP;
-	m_context.appendJumpTo(m_returnTag);
-	m_context.adjustStackOffset(m_stackCleanupForReturn);
-	return false;
-}
-
-bool Compiler::visit(Throw const& _throw)
-{
-	CompilerContext::LocationSetter locationSetter(m_context, _throw);
-	m_context.appendJumpTo(m_context.errorTag());
-	return false;
-}
-
-bool Compiler::visit(VariableDeclarationStatement const& _variableDeclarationStatement)
-{
-	StackHeightChecker checker(m_context);
-	CompilerContext::LocationSetter locationSetter(m_context, _variableDeclarationStatement);
-	if (Expression const* expression = _variableDeclarationStatement.initialValue())
-	{
-		CompilerUtils utils(m_context);
-		compileExpression(*expression);
-		TypePointers valueTypes;
-		if (auto tupleType = dynamic_cast<TupleType const*>(expression->annotation().type.get()))
-			valueTypes = tupleType->components();
-		else
-			valueTypes = TypePointers{expression->annotation().type};
-		auto const& assignments = _variableDeclarationStatement.annotation().assignments;
-		solAssert(assignments.size() == valueTypes.size(), "");
-		for (size_t i = 0; i < assignments.size(); ++i)
-		{
-			size_t j = assignments.size() - i - 1;
-			solAssert(!!valueTypes[j], "");
-			VariableDeclaration const* varDecl = assignments[j];
-			if (!varDecl)
-				utils.popStackElement(*valueTypes[j]);
-			else
-			{
-				utils.convertType(*valueTypes[j], *varDecl->annotation().type);
-				utils.moveToStackVariable(*varDecl);
-			}
-		}
-	}
-	checker.check();
-	return false;
-}
-
-bool Compiler::visit(ExpressionStatement const& _expressionStatement)
-{
-	StackHeightChecker checker(m_context);
-	CompilerContext::LocationSetter locationSetter(m_context, _expressionStatement);
-	Expression const& expression = _expressionStatement.expression();
-	compileExpression(expression);
-	CompilerUtils(m_context).popStackElement(*expression.annotation().type);
-	checker.check();
-	return false;
-}
-
-bool Compiler::visit(PlaceholderStatement const& _placeholderStatement)
-{
-	StackHeightChecker checker(m_context);
-	CompilerContext::LocationSetter locationSetter(m_context, _placeholderStatement);
-	++m_modifierDepth;
-	appendModifierOrFunctionCode();
-	--m_modifierDepth;
-	checker.check();
-	return true;
-}
-
-void Compiler::appendFunctionsWithoutCode()
-{
-	set<Declaration const*> functions = m_context.functionsWithoutCode();
-	while (!functions.empty())
-	{
-		for (Declaration const* function: functions)
-		{
-			m_context.setStackOffset(0);
-			function->accept(*this);
-		}
-		functions = m_context.functionsWithoutCode();
-	}
-}
-
-void Compiler::appendModifierOrFunctionCode()
-{
-	solAssert(m_currentFunction, "");
-	if (m_modifierDepth >= m_currentFunction->modifiers().size())
-		m_currentFunction->body().accept(*this);
-	else
-	{
-		ASTPointer<ModifierInvocation> const& modifierInvocation = m_currentFunction->modifiers()[m_modifierDepth];
-
-		// constructor call should be excluded
-		if (dynamic_cast<ContractDefinition const*>(modifierInvocation->name()->annotation().referencedDeclaration))
-		{
-			++m_modifierDepth;
-			appendModifierOrFunctionCode();
-			--m_modifierDepth;
-			return;
-		}
-
-		ModifierDefinition const& modifier = m_context.functionModifier(modifierInvocation->name()->name());
-		CompilerContext::LocationSetter locationSetter(m_context, modifier);
-		solAssert(modifier.parameters().size() == modifierInvocation->arguments().size(), "");
-		for (unsigned i = 0; i < modifier.parameters().size(); ++i)
-		{
-			m_context.addVariable(*modifier.parameters()[i]);
-			compileExpression(
-				*modifierInvocation->arguments()[i],
-				modifier.parameters()[i]->annotation().type
-			);
-		}
-		for (VariableDeclaration const* localVariable: modifier.localVariables())
-			appendStackVariableInitialisation(*localVariable);
-
-		unsigned const c_stackSurplus = CompilerUtils::sizeOnStack(modifier.parameters()) +
-										CompilerUtils::sizeOnStack(modifier.localVariables());
-		m_stackCleanupForReturn += c_stackSurplus;
-
-		modifier.body().accept(*this);
-
-		for (unsigned i = 0; i < c_stackSurplus; ++i)
-			m_context << Instruction::POP;
-		m_stackCleanupForReturn -= c_stackSurplus;
-	}
-}
-
-void Compiler::appendStackVariableInitialisation(VariableDeclaration const& _variable)
-{
-	CompilerContext::LocationSetter location(m_context, _variable);
-	m_context.addVariable(_variable);
-	CompilerUtils(m_context).pushZeroValue(*_variable.annotation().type);
-}
-
-void Compiler::compileExpression(Expression const& _expression, TypePointer const& _targetType)
-{
-	ExpressionCompiler expressionCompiler(m_context, m_optimize);
-	expressionCompiler.compile(_expression);
-	if (_targetType)
-		CompilerUtils(m_context).convertType(*_expression.annotation().type, *_targetType);
-}
-
-eth::Assembly Compiler::cloneRuntime()
-{
-	eth::Assembly a;
-	a << Instruction::CALLDATASIZE;
-	a << u256(0) << Instruction::DUP1 << Instruction::CALLDATACOPY;
-	//@todo adjust for larger return values, make this dynamic.
-	a << u256(0x20) << u256(0) << Instruction::CALLDATASIZE;
-	a << u256(0);
-	// this is the address which has to be substituted by the linker.
-	//@todo implement as special "marker" AssemblyItem.
-	a << u256("0xcafecafecafecafecafecafecafecafecafecafe");
-	a << u256(eth::GasCosts::callGas + 10) << Instruction::GAS << Instruction::SUB;
-	a << Instruction::DELEGATECALL;
-	//Propagate error condition (if DELEGATECALL pushes 0 on stack).
-	a << Instruction::ISZERO;
-	a.appendJumpI(a.errorTag());
-	//@todo adjust for larger return values, make this dynamic.
-	a << u256(0x20) << u256(0) << Instruction::RETURN;
-	return a;
-}
diff --git a/libsolidity/codegen/Compiler.h b/libsolidity/codegen/Compiler.h
index 68ad904a..fccb68a9 100644
--- a/libsolidity/codegen/Compiler.h
+++ b/libsolidity/codegen/Compiler.h
@@ -24,20 +24,18 @@
 
 #include <ostream>
 #include <functional>
-#include <libsolidity/ast/ASTVisitor.h>
 #include <libsolidity/codegen/CompilerContext.h>
 #include <libevmasm/Assembly.h>
 
 namespace dev {
 namespace solidity {
 
-class Compiler: private ASTConstVisitor
+class Compiler
 {
 public:
 	explicit Compiler(bool _optimize = false, unsigned _runs = 200):
 		m_optimize(_optimize),
-		m_optimizeRuns(_runs),
-		m_returnTag(m_context.newTag())
+		m_optimizeRuns(_runs)
 	{ }
 
 	void compileContract(
@@ -69,69 +67,11 @@ public:
 	eth::AssemblyItem functionEntryLabel(FunctionDefinition const& _function) const;
 
 private:
-	/// Registers the non-function objects inside the contract with the context and stores the basic
-	/// information about the contract like the AST annotations.
-	void initializeContext(
-		ContractDefinition const& _contract,
-		std::map<ContractDefinition const*, eth::Assembly const*> const& _compiledContracts
-	);
-	/// Adds the code that is run at creation time. Should be run after exchanging the run-time context
-	/// with a new and initialized context. Adds the constructor code.
-	void packIntoContractCreator(ContractDefinition const& _contract, CompilerContext const& _runtimeContext);
-	/// Appends state variable initialisation and constructor code.
-	void appendInitAndConstructorCode(ContractDefinition const& _contract);
-	void appendBaseConstructor(FunctionDefinition const& _constructor);
-	void appendConstructor(FunctionDefinition const& _constructor);
-	void appendFunctionSelector(ContractDefinition const& _contract);
-	/// Creates code that unpacks the arguments for the given function represented by a vector of TypePointers.
-	/// From memory if @a _fromMemory is true, otherwise from call data.
-	/// Expects source offset on the stack, which is removed.
-	void appendCalldataUnpacker(TypePointers const& _typeParameters, bool _fromMemory = false);
-	void appendReturnValuePacker(TypePointers const& _typeParameters, bool _isLibrary);
-
-	void registerStateVariables(ContractDefinition const& _contract);
-	void initializeStateVariables(ContractDefinition const& _contract);
-
-	virtual bool visit(VariableDeclaration const& _variableDeclaration) override;
-	virtual bool visit(FunctionDefinition const& _function) override;
-	virtual bool visit(InlineAssembly const& _inlineAssembly) override;
-	virtual bool visit(IfStatement const& _ifStatement) override;
-	virtual bool visit(WhileStatement const& _whileStatement) override;
-	virtual bool visit(ForStatement const& _forStatement) override;
-	virtual bool visit(Continue const& _continue) override;
-	virtual bool visit(Break const& _break) override;
-	virtual bool visit(Return const& _return) override;
-	virtual bool visit(Throw const& _throw) override;
-	virtual bool visit(VariableDeclarationStatement const& _variableDeclarationStatement) override;
-	virtual bool visit(ExpressionStatement const& _expressionStatement) override;
-	virtual bool visit(PlaceholderStatement const&) override;
-
-	/// Repeatedly visits all function which are referenced but which are not compiled yet.
-	void appendFunctionsWithoutCode();
-
-	/// Appends one layer of function modifier code of the current function, or the function
-	/// body itself if the last modifier was reached.
-	void appendModifierOrFunctionCode();
-
-	void appendStackVariableInitialisation(VariableDeclaration const& _variable);
-	void compileExpression(Expression const& _expression, TypePointer const& _targetType = TypePointer());
-
-	/// @returns the runtime assembly for clone contracts.
-	static eth::Assembly cloneRuntime();
-
 	bool const m_optimize;
 	unsigned const m_optimizeRuns;
 	CompilerContext m_context;
-	size_t m_runtimeSub = size_t(-1); ///< Identifier of the runtime sub-assembly
+	size_t m_runtimeSub = size_t(-1); ///< Identifier of the runtime sub-assembly, if present.
 	CompilerContext m_runtimeContext;
-	std::vector<eth::AssemblyItem> m_breakTags; ///< tag to jump to for a "break" statement
-	std::vector<eth::AssemblyItem> m_continueTags; ///< tag to jump to for a "continue" statement
-	eth::AssemblyItem m_returnTag; ///< tag to jump to for a "return" statement
-	unsigned m_modifierDepth = 0;
-	FunctionDefinition const* m_currentFunction = nullptr;
-	unsigned m_stackCleanupForReturn = 0; ///< this number of stack elements need to be removed before jump to m_returnTag
-	// arguments for base constructors, filled in derived-to-base order
-	std::map<FunctionDefinition const*, std::vector<ASTPointer<Expression>> const*> m_baseArguments;
 };
 
 }
diff --git a/libsolidity/codegen/CompilerContext.cpp b/libsolidity/codegen/CompilerContext.cpp
index 7810288e..c1dc8dfb 100644
--- a/libsolidity/codegen/CompilerContext.cpp
+++ b/libsolidity/codegen/CompilerContext.cpp
@@ -50,7 +50,7 @@ void CompilerContext::addStateVariable(
 
 void CompilerContext::startFunction(Declaration const& _function)
 {
-	m_functionsWithCode.insert(&_function);
+	m_functionCompilationQueue.startFunction(_function);
 	*this << functionEntryLabel(_function);
 }
 
@@ -81,25 +81,22 @@ bool CompilerContext::isLocalVariable(Declaration const* _declaration) const
 
 eth::AssemblyItem CompilerContext::functionEntryLabel(Declaration const& _declaration)
 {
-	auto res = m_functionEntryLabels.find(&_declaration);
-	if (res == m_functionEntryLabels.end())
-	{
-		eth::AssemblyItem tag(m_asm.newTag());
-		m_functionEntryLabels.insert(make_pair(&_declaration, tag));
-		return tag.tag();
-	}
-	else
-		return res->second.tag();
+	return m_functionCompilationQueue.entryLabel(_declaration, *this);
 }
 
 eth::AssemblyItem CompilerContext::functionEntryLabelIfExists(Declaration const& _declaration) const
 {
-	auto res = m_functionEntryLabels.find(&_declaration);
-	return res == m_functionEntryLabels.end() ? eth::AssemblyItem(eth::UndefinedItem) : res->second.tag();
+	return m_functionCompilationQueue.entryLabelIfExists(_declaration);
 }
 
 eth::AssemblyItem CompilerContext::virtualFunctionEntryLabel(FunctionDefinition const& _function)
 {
+	// Libraries do not allow inheritance and their functions can be inlined, so we should not
+	// search the inheritance hierarchy (which will be the wrong one in case the function
+	// is inlined).
+	if (auto scope = dynamic_cast<ContractDefinition const*>(_function.scope()))
+		if (scope->isLibrary())
+			return functionEntryLabel(_function);
 	solAssert(!m_inheritanceHierarchy.empty(), "No inheritance hierarchy set.");
 	return virtualFunctionEntryLabel(_function, m_inheritanceHierarchy.begin());
 }
@@ -120,13 +117,9 @@ FunctionDefinition const* CompilerContext::nextConstructor(ContractDefinition co
 	return nullptr;
 }
 
-set<Declaration const*> CompilerContext::functionsWithoutCode()
+Declaration const* CompilerContext::nextFunctionToCompile() const
 {
-	set<Declaration const*> functions;
-	for (auto const& it: m_functionEntryLabels)
-		if (m_functionsWithCode.count(it.first) == 0)
-			functions.insert(it.first);
-	return functions;
+	return m_functionCompilationQueue.nextFunctionToCompile();
 }
 
 ModifierDefinition const& CompilerContext::functionModifier(string const& _name) const
@@ -219,5 +212,48 @@ void CompilerContext::updateSourceLocation()
 	m_asm.setSourceLocation(m_visitedNodes.empty() ? SourceLocation() : m_visitedNodes.top()->location());
 }
 
+eth::AssemblyItem CompilerContext::FunctionCompilationQueue::entryLabel(
+	Declaration const& _declaration,
+	CompilerContext& _context
+)
+{
+	auto res = m_entryLabels.find(&_declaration);
+	if (res == m_entryLabels.end())
+	{
+		eth::AssemblyItem tag(_context.newTag());
+		m_entryLabels.insert(make_pair(&_declaration, tag));
+		m_functionsToCompile.push(&_declaration);
+		return tag.tag();
+	}
+	else
+		return res->second.tag();
+
+}
+
+eth::AssemblyItem CompilerContext::FunctionCompilationQueue::entryLabelIfExists(Declaration const& _declaration) const
+{
+	auto res = m_entryLabels.find(&_declaration);
+	return res == m_entryLabels.end() ? eth::AssemblyItem(eth::UndefinedItem) : res->second.tag();
+}
+
+Declaration const* CompilerContext::FunctionCompilationQueue::nextFunctionToCompile() const
+{
+	while (!m_functionsToCompile.empty())
+	{
+		if (m_alreadyCompiledFunctions.count(m_functionsToCompile.front()))
+			m_functionsToCompile.pop();
+		else
+			return m_functionsToCompile.front();
+	}
+	return nullptr;
+}
+
+void CompilerContext::FunctionCompilationQueue::startFunction(Declaration const& _function)
+{
+	if (!m_functionsToCompile.empty() && m_functionsToCompile.front() == &_function)
+		m_functionsToCompile.pop();
+	m_alreadyCompiledFunctions.insert(&_function);
+}
+
 }
 }
diff --git a/libsolidity/codegen/CompilerContext.h b/libsolidity/codegen/CompilerContext.h
index 9368dbcf..a56335ce 100644
--- a/libsolidity/codegen/CompilerContext.h
+++ b/libsolidity/codegen/CompilerContext.h
@@ -24,6 +24,7 @@
 
 #include <ostream>
 #include <stack>
+#include <queue>
 #include <utility>
 #include <libevmasm/Instruction.h>
 #include <libevmasm/Assembly.h>
@@ -72,8 +73,11 @@ public:
 	eth::AssemblyItem superFunctionEntryLabel(FunctionDefinition const& _function, ContractDefinition const& _base);
 	FunctionDefinition const* nextConstructor(ContractDefinition const& _contract) const;
 
-	/// @returns the set of functions for which we still need to generate code
-	std::set<Declaration const*> functionsWithoutCode();
+	/// @returns the next function in the queue of functions that are still to be compiled
+	/// (i.e. that were referenced during compilation but where we did not yet generate code for).
+	/// Returns nullptr if the queue is empty. Does not remove the function from the queue,
+	/// that will only be done by startFunction below.
+	Declaration const* nextFunctionToCompile() const;
 	/// Resets function specific members, inserts the function entry label and marks the function
 	/// as "having code".
 	void startFunction(Declaration const& _function);
@@ -109,8 +113,6 @@ public:
 	/// Adds a subroutine to the code (in the data section) and pushes its size (via a tag)
 	/// on the stack. @returns the assembly item corresponding to the pushed subroutine, i.e. its offset.
 	eth::AssemblyItem addSubroutine(eth::Assembly const& _assembly) { return m_asm.appendSubSize(_assembly); }
-	/// Appends the given code (used by inline assembly) ignoring any stack height changes.
-	void appendInlineAssembly(eth::Assembly const& _assembly) { int deposit = m_asm.deposit(); m_asm.append(_assembly); m_asm.setDeposit(deposit); }
 	/// Pushes the size of the final program
 	void appendProgramSize() { return m_asm.appendProgramSize(); }
 	/// Adds data to the data section, pushes a reference to the stack
@@ -136,6 +138,10 @@ public:
 	void optimise(unsigned _runs = 200) { m_asm.optimise(true, true, _runs); }
 
 	eth::Assembly const& assembly() const { return m_asm; }
+	/// @returns non-const reference to the underlying assembly. Should be avoided in favour of
+	/// wrappers in this class.
+	eth::Assembly& nonConstAssembly() { return m_asm; }
+
 	/// @arg _sourceCodes is the map of input files to source code strings
 	/// @arg _inJsonFormat shows whether the out should be in Json format
 	Json::Value streamAssembly(std::ostream& _stream, StringMap const& _sourceCodes = StringMap(), bool _inJsonFormat = false) const
@@ -168,6 +174,38 @@ private:
 	/// Updates source location set in the assembly.
 	void updateSourceLocation();
 
+	/**
+	 * Helper class that manages function labels and ensures that referenced functions are
+	 * compiled in a specific order.
+	 */
+	struct FunctionCompilationQueue
+	{
+		/// @returns the entry label of the given function and creates it if it does not exist yet.
+		/// @param _context compiler context used to create a new tag if needed
+		eth::AssemblyItem entryLabel(Declaration const& _declaration, CompilerContext& _context);
+		/// @returns the entry label of the given function. Might return an AssemblyItem of type
+		/// UndefinedItem if it does not exist yet.
+		eth::AssemblyItem entryLabelIfExists(Declaration const& _declaration) const;
+
+		/// @returns the next function in the queue of functions that are still to be compiled
+		/// (i.e. that were referenced during compilation but where we did not yet generate code for).
+		/// Returns nullptr if the queue is empty. Does not remove the function from the queue,
+		/// that will only be done by startFunction below.
+		Declaration const* nextFunctionToCompile() const;
+		/// Informs the queue that we are about to compile the given function, i.e. removes
+		/// the function from the queue of functions to compile.
+		void startFunction(const Declaration &_function);
+
+		/// Labels pointing to the entry points of functions.
+		std::map<Declaration const*, eth::AssemblyItem> m_entryLabels;
+		/// Set of functions for which we did not yet generate code.
+		std::set<Declaration const*> m_alreadyCompiledFunctions;
+		/// Queue of functions that still need to be compiled (important to be a queue to maintain
+		/// determinism even in the presence of a non-deterministic allocator).
+		/// Mutable because we will throw out some functions earlier than needed.
+		mutable std::queue<Declaration const*> m_functionsToCompile;
+	} m_functionCompilationQueue;
+
 	eth::Assembly m_asm;
 	/// Magic global variables like msg, tx or this, distinguished by type.
 	std::set<Declaration const*> m_magicGlobals;
@@ -177,10 +215,6 @@ private:
 	std::map<Declaration const*, std::pair<u256, unsigned>> m_stateVariables;
 	/// Offsets of local variables on the stack (relative to stack base).
 	std::map<Declaration const*, unsigned> m_localVariables;
-	/// Labels pointing to the entry points of functions.
-	std::map<Declaration const*, eth::AssemblyItem> m_functionEntryLabels;
-	/// Set of functions for which we did not yet generate code.
-	std::set<Declaration const*> m_functionsWithCode;
 	/// List of current inheritance hierarchy from derived to base.
 	std::vector<ContractDefinition const*> m_inheritanceHierarchy;
 	/// Stack of current visited AST nodes, used for location attachment
diff --git a/libsolidity/codegen/CompilerUtils.cpp b/libsolidity/codegen/CompilerUtils.cpp
index 36ed480e..efb9b10a 100644
--- a/libsolidity/codegen/CompilerUtils.cpp
+++ b/libsolidity/codegen/CompilerUtils.cpp
@@ -323,18 +323,17 @@ void CompilerUtils::convertType(Type const& _typeOnStack, Type const& _targetTyp
 		}
 		else
 		{
-			// clear lower-order bytes for conversion to shorter bytes - we always clean
+			// clear for conversion to longer bytes
 			solAssert(targetTypeCategory == Type::Category::FixedBytes, "Invalid type conversion requested.");
 			FixedBytesType const& targetType = dynamic_cast<FixedBytesType const&>(_targetType);
-			if (targetType.numBytes() < typeOnStack.numBytes())
+			if (targetType.numBytes() > typeOnStack.numBytes() || _cleanupNeeded)
 			{
-				if (targetType.numBytes() == 0)
-					m_context << Instruction::DUP1 << Instruction::XOR;
+				if (typeOnStack.numBytes() == 0)
+					m_context << Instruction::POP << u256(0);
 				else
 				{
-					m_context << (u256(1) << (256 - targetType.numBytes() * 8));
-					m_context << Instruction::DUP1 << Instruction::SWAP2;
-					m_context << Instruction::DIV << Instruction::MUL;
+					m_context << ((u256(1) << (256 - typeOnStack.numBytes() * 8)) - 1);
+					m_context << Instruction::NOT << Instruction::AND;
 				}
 			}
 		}
@@ -343,12 +342,14 @@ void CompilerUtils::convertType(Type const& _typeOnStack, Type const& _targetTyp
 	case Type::Category::Enum:
 		solAssert(targetTypeCategory == Type::Category::Integer || targetTypeCategory == Type::Category::Enum, "");
 		break;
+	case Type::Category::FixedPoint:
+		solAssert(false, "Not yet implemented - FixedPointType.");
 	case Type::Category::Integer:
 	case Type::Category::Contract:
-	case Type::Category::IntegerConstant:
+	case Type::Category::RationalNumber:
 		if (targetTypeCategory == Type::Category::FixedBytes)
 		{
-			solAssert(stackTypeCategory == Type::Category::Integer || stackTypeCategory == Type::Category::IntegerConstant,
+			solAssert(stackTypeCategory == Type::Category::Integer || stackTypeCategory == Type::Category::RationalNumber,
 				"Invalid conversion to FixedBytesType requested.");
 			// conversion from bytes to string. no need to clean the high bit
 			// only to shift left because of opposite alignment
@@ -361,17 +362,33 @@ void CompilerUtils::convertType(Type const& _typeOnStack, Type const& _targetTyp
 		else if (targetTypeCategory == Type::Category::Enum)
 			// just clean
 			convertType(_typeOnStack, *_typeOnStack.mobileType(), true);
+		else if (targetTypeCategory == Type::Category::FixedPoint)
+		{
+			solAssert(
+				stackTypeCategory == Type::Category::Integer || 
+				stackTypeCategory == Type::Category::RationalNumber ||
+				stackTypeCategory == Type::Category::FixedPoint,
+				"Invalid conversion to FixedMxNType requested."
+			);
+			//shift all integer bits onto the left side of the fixed type
+			FixedPointType const& targetFixedPointType = dynamic_cast<FixedPointType const&>(_targetType);
+			if (auto typeOnStack = dynamic_cast<IntegerType const*>(&_typeOnStack))
+				if (targetFixedPointType.integerBits() > typeOnStack->numBits())
+					cleanHigherOrderBits(*typeOnStack);
+			solAssert(false, "Not yet implemented - FixedPointType.");
+		}
 		else
 		{
 			solAssert(targetTypeCategory == Type::Category::Integer || targetTypeCategory == Type::Category::Contract, "");
 			IntegerType addressType(0, IntegerType::Modifier::Address);
 			IntegerType const& targetType = targetTypeCategory == Type::Category::Integer
 				? dynamic_cast<IntegerType const&>(_targetType) : addressType;
-			if (stackTypeCategory == Type::Category::IntegerConstant)
+			if (stackTypeCategory == Type::Category::RationalNumber)
 			{
-				IntegerConstantType const& constType = dynamic_cast<IntegerConstantType const&>(_typeOnStack);
+				RationalNumberType const& constType = dynamic_cast<RationalNumberType const&>(_typeOnStack);
 				// We know that the stack is clean, we only have to clean for a narrowing conversion
 				// where cleanup is forced.
+				solAssert(!constType.isFractional(), "Not yet implemented - FixedPointType.");
 				if (targetType.numBits() < constType.integerType()->numBits() && _cleanupNeeded)
 					cleanHigherOrderBits(targetType);
 			}
@@ -619,6 +636,10 @@ void CompilerUtils::convertType(Type const& _typeOnStack, Type const& _targetTyp
 		}
 		break;
 	}
+	case Type::Category::Bool:
+		solAssert(_targetType == _typeOnStack, "Invalid conversion for bool.");
+		if (_cleanupNeeded)
+			m_context << Instruction::ISZERO << Instruction::ISZERO;
 	default:
 		// All other types should not be convertible to non-equal types.
 		solAssert(_typeOnStack == _targetType, "Invalid type conversion requested.");
diff --git a/libsolidity/codegen/ContractCompiler.cpp b/libsolidity/codegen/ContractCompiler.cpp
new file mode 100644
index 00000000..3623046e
--- /dev/null
+++ b/libsolidity/codegen/ContractCompiler.cpp
@@ -0,0 +1,853 @@
+/*
+	This file is part of cpp-ethereum.
+
+	cpp-ethereum is free software: you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
+
+	cpp-ethereum is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.
+*/
+/**
+ * @author Christian <c@ethdev.com>
+ * @date 2014
+ * Solidity compiler.
+ */
+
+#include <libsolidity/codegen/ContractCompiler.h>
+#include <algorithm>
+#include <boost/range/adaptor/reversed.hpp>
+#include <libevmasm/Instruction.h>
+#include <libevmasm/Assembly.h>
+#include <libevmasm/GasMeter.h>
+#include <libsolidity/inlineasm/AsmCodeGen.h>
+#include <libsolidity/ast/AST.h>
+#include <libsolidity/codegen/ExpressionCompiler.h>
+#include <libsolidity/codegen/CompilerUtils.h>
+using namespace std;
+using namespace dev;
+using namespace dev::solidity;
+
+/**
+ * Simple helper class to ensure that the stack height is the same at certain places in the code.
+ */
+class StackHeightChecker
+{
+public:
+	StackHeightChecker(CompilerContext const& _context):
+		m_context(_context), stackHeight(m_context.stackHeight()) {}
+	void check() { solAssert(m_context.stackHeight() == stackHeight, "I sense a disturbance in the stack."); }
+private:
+	CompilerContext const& m_context;
+	unsigned stackHeight;
+};
+
+void ContractCompiler::compileContract(
+	ContractDefinition const& _contract,
+	std::map<const ContractDefinition*, eth::Assembly const*> const& _contracts
+)
+{
+	CompilerContext::LocationSetter locationSetter(m_context, _contract);
+	initializeContext(_contract, _contracts);
+	appendFunctionSelector(_contract);
+	appendMissingFunctions();
+}
+
+size_t ContractCompiler::compileConstructor(
+	CompilerContext const& _runtimeContext,
+	ContractDefinition const& _contract,
+	std::map<const ContractDefinition*, eth::Assembly const*> const& _contracts
+)
+{
+	CompilerContext::LocationSetter locationSetter(m_context, _contract);
+	initializeContext(_contract, _contracts);
+	return packIntoContractCreator(_contract, _runtimeContext);
+}
+
+size_t ContractCompiler::compileClone(
+	ContractDefinition const& _contract,
+	map<ContractDefinition const*, eth::Assembly const*> const& _contracts
+)
+{
+	initializeContext(_contract, _contracts);
+
+	appendInitAndConstructorCode(_contract);
+
+	//@todo determine largest return size of all runtime functions
+	eth::AssemblyItem runtimeSub = m_context.addSubroutine(cloneRuntime());
+
+	// stack contains sub size
+	m_context << Instruction::DUP1 << runtimeSub << u256(0) << Instruction::CODECOPY;
+	m_context << u256(0) << Instruction::RETURN;
+
+	appendMissingFunctions();
+
+	solAssert(runtimeSub.data() < numeric_limits<size_t>::max(), "");
+	return size_t(runtimeSub.data());
+}
+
+void ContractCompiler::initializeContext(
+	ContractDefinition const& _contract,
+	map<ContractDefinition const*, eth::Assembly const*> const& _compiledContracts
+)
+{
+	m_context.setCompiledContracts(_compiledContracts);
+	m_context.setInheritanceHierarchy(_contract.annotation().linearizedBaseContracts);
+	CompilerUtils(m_context).initialiseFreeMemoryPointer();
+	registerStateVariables(_contract);
+	m_context.resetVisitedNodes(&_contract);
+}
+
+void ContractCompiler::appendInitAndConstructorCode(ContractDefinition const& _contract)
+{
+	// Determine the arguments that are used for the base constructors.
+	std::vector<ContractDefinition const*> const& bases = _contract.annotation().linearizedBaseContracts;
+	for (ContractDefinition const* contract: bases)
+	{
+		if (FunctionDefinition const* constructor = contract->constructor())
+			for (auto const& modifier: constructor->modifiers())
+			{
+				auto baseContract = dynamic_cast<ContractDefinition const*>(
+					modifier->name()->annotation().referencedDeclaration);
+				if (baseContract)
+					if (m_baseArguments.count(baseContract->constructor()) == 0)
+						m_baseArguments[baseContract->constructor()] = &modifier->arguments();
+			}
+
+		for (ASTPointer<InheritanceSpecifier> const& base: contract->baseContracts())
+		{
+			ContractDefinition const* baseContract = dynamic_cast<ContractDefinition const*>(
+				base->name().annotation().referencedDeclaration
+			);
+			solAssert(baseContract, "");
+
+			if (m_baseArguments.count(baseContract->constructor()) == 0)
+				m_baseArguments[baseContract->constructor()] = &base->arguments();
+		}
+	}
+	// Initialization of state variables in base-to-derived order.
+	for (ContractDefinition const* contract: boost::adaptors::reverse(bases))
+		initializeStateVariables(*contract);
+
+	if (FunctionDefinition const* constructor = _contract.constructor())
+		appendConstructor(*constructor);
+	else if (auto c = m_context.nextConstructor(_contract))
+		appendBaseConstructor(*c);
+}
+
+size_t ContractCompiler::packIntoContractCreator(ContractDefinition const& _contract, CompilerContext const& _runtimeContext)
+{
+	appendInitAndConstructorCode(_contract);
+
+	eth::AssemblyItem runtimeSub = m_context.addSubroutine(_runtimeContext.assembly());
+
+	// stack contains sub size
+	m_context << Instruction::DUP1 << runtimeSub << u256(0) << Instruction::CODECOPY;
+	m_context << u256(0) << Instruction::RETURN;
+
+	// note that we have to include the functions again because of absolute jump labels
+	appendMissingFunctions();
+
+	solAssert(runtimeSub.data() < numeric_limits<size_t>::max(), "");
+	return size_t(runtimeSub.data());
+}
+
+void ContractCompiler::appendBaseConstructor(FunctionDefinition const& _constructor)
+{
+	CompilerContext::LocationSetter locationSetter(m_context, _constructor);
+	FunctionType constructorType(_constructor);
+	if (!constructorType.parameterTypes().empty())
+	{
+		solAssert(m_baseArguments.count(&_constructor), "");
+		std::vector<ASTPointer<Expression>> const* arguments = m_baseArguments[&_constructor];
+		solAssert(arguments, "");
+		for (unsigned i = 0; i < arguments->size(); ++i)
+			compileExpression(*(arguments->at(i)), constructorType.parameterTypes()[i]);
+	}
+	_constructor.accept(*this);
+}
+
+void ContractCompiler::appendConstructor(FunctionDefinition const& _constructor)
+{
+	CompilerContext::LocationSetter locationSetter(m_context, _constructor);
+	// copy constructor arguments from code to memory and then to stack, they are supplied after the actual program
+	if (!_constructor.parameters().empty())
+	{
+		unsigned argumentSize = 0;
+		for (ASTPointer<VariableDeclaration> const& var: _constructor.parameters())
+			if (var->annotation().type->isDynamicallySized())
+			{
+				argumentSize = 0;
+				break;
+			}
+			else
+				argumentSize += var->annotation().type->calldataEncodedSize();
+
+		CompilerUtils(m_context).fetchFreeMemoryPointer();
+		if (argumentSize == 0)
+		{
+			// argument size is dynamic, use CODESIZE to determine it
+			m_context.appendProgramSize(); // program itself
+			// CODESIZE is program plus manually added arguments
+			m_context << Instruction::CODESIZE << Instruction::SUB;
+		}
+		else
+			m_context << u256(argumentSize);
+		// stack: <memptr> <argument size>
+		m_context << Instruction::DUP1;
+		m_context.appendProgramSize();
+		m_context << Instruction::DUP4 << Instruction::CODECOPY;
+		m_context << Instruction::DUP2 << Instruction::ADD;
+		CompilerUtils(m_context).storeFreeMemoryPointer();
+		// stack: <memptr>
+		appendCalldataUnpacker(FunctionType(_constructor).parameterTypes(), true);
+	}
+	_constructor.accept(*this);
+}
+
+void ContractCompiler::appendFunctionSelector(ContractDefinition const& _contract)
+{
+	map<FixedHash<4>, FunctionTypePointer> interfaceFunctions = _contract.interfaceFunctions();
+	map<FixedHash<4>, const eth::AssemblyItem> callDataUnpackerEntryPoints;
+
+	FunctionDefinition const* fallback = _contract.fallbackFunction();
+	eth::AssemblyItem notFound = m_context.newTag();
+	// shortcut messages without data if we have many functions in order to be able to receive
+	// ether with constant gas
+	if (interfaceFunctions.size() > 5 || fallback)
+	{
+		m_context << Instruction::CALLDATASIZE << Instruction::ISZERO;
+		m_context.appendConditionalJumpTo(notFound);
+	}
+
+	// retrieve the function signature hash from the calldata
+	if (!interfaceFunctions.empty())
+		CompilerUtils(m_context).loadFromMemory(0, IntegerType(CompilerUtils::dataStartOffset * 8), true);
+
+	// stack now is: 1 0 <funhash>
+	for (auto const& it: interfaceFunctions)
+	{
+		callDataUnpackerEntryPoints.insert(std::make_pair(it.first, m_context.newTag()));
+		m_context << dupInstruction(1) << u256(FixedHash<4>::Arith(it.first)) << Instruction::EQ;
+		m_context.appendConditionalJumpTo(callDataUnpackerEntryPoints.at(it.first));
+	}
+	m_context.appendJumpTo(notFound);
+
+	m_context << notFound;
+	if (fallback)
+	{
+		eth::AssemblyItem returnTag = m_context.pushNewTag();
+		fallback->accept(*this);
+		m_context << returnTag;
+		appendReturnValuePacker(FunctionType(*fallback).returnParameterTypes(), _contract.isLibrary());
+	}
+	else if (_contract.isLibrary())
+		// Reject invalid library calls and ether sent to a library.
+		m_context.appendJumpTo(m_context.errorTag());
+	else
+		m_context << Instruction::STOP; // function not found
+
+	for (auto const& it: interfaceFunctions)
+	{
+		FunctionTypePointer const& functionType = it.second;
+		solAssert(functionType->hasDeclaration(), "");
+		CompilerContext::LocationSetter locationSetter(m_context, functionType->declaration());
+		m_context << callDataUnpackerEntryPoints.at(it.first);
+		eth::AssemblyItem returnTag = m_context.pushNewTag();
+		m_context << CompilerUtils::dataStartOffset;
+		appendCalldataUnpacker(functionType->parameterTypes());
+		m_context.appendJumpTo(m_context.functionEntryLabel(functionType->declaration()));
+		m_context << returnTag;
+		appendReturnValuePacker(functionType->returnParameterTypes(), _contract.isLibrary());
+	}
+}
+
+void ContractCompiler::appendCalldataUnpacker(TypePointers const& _typeParameters, bool _fromMemory)
+{
+	// We do not check the calldata size, everything is zero-padded
+
+	//@todo this does not yet support nested dynamic arrays
+
+	// Retain the offset pointer as base_offset, the point from which the data offsets are computed.
+	m_context << Instruction::DUP1;
+	for (TypePointer const& parameterType: _typeParameters)
+	{
+		// stack: v1 v2 ... v(k-1) base_offset current_offset
+		TypePointer type = parameterType->decodingType();
+		if (type->category() == Type::Category::Array)
+		{
+			auto const& arrayType = dynamic_cast<ArrayType const&>(*type);
+			solAssert(!arrayType.baseType()->isDynamicallySized(), "Nested arrays not yet implemented.");
+			if (_fromMemory)
+			{
+				solAssert(
+					arrayType.baseType()->isValueType(),
+					"Nested memory arrays not yet implemented here."
+				);
+				// @todo If base type is an array or struct, it is still calldata-style encoded, so
+				// we would have to convert it like below.
+				solAssert(arrayType.location() == DataLocation::Memory, "");
+				if (arrayType.isDynamicallySized())
+				{
+					// compute data pointer
+					m_context << Instruction::DUP1 << Instruction::MLOAD;
+					m_context << Instruction::DUP3 << Instruction::ADD;
+					m_context << Instruction::SWAP2 << Instruction::SWAP1;
+					m_context << u256(0x20) << Instruction::ADD;
+				}
+				else
+				{
+					m_context << Instruction::SWAP1 << Instruction::DUP2;
+					m_context << u256(arrayType.calldataEncodedSize(true)) << Instruction::ADD;
+				}
+			}
+			else
+			{
+				// first load from calldata and potentially convert to memory if arrayType is memory
+				TypePointer calldataType = arrayType.copyForLocation(DataLocation::CallData, false);
+				if (calldataType->isDynamicallySized())
+				{
+					// put on stack: data_pointer length
+					CompilerUtils(m_context).loadFromMemoryDynamic(IntegerType(256), !_fromMemory);
+					// stack: base_offset data_offset next_pointer
+					m_context << Instruction::SWAP1 << Instruction::DUP3 << Instruction::ADD;
+					// stack: base_offset next_pointer data_pointer
+					// retrieve length
+					CompilerUtils(m_context).loadFromMemoryDynamic(IntegerType(256), !_fromMemory, true);
+					// stack: base_offset next_pointer length data_pointer
+					m_context << Instruction::SWAP2;
+					// stack: base_offset data_pointer length next_pointer
+				}
+				else
+				{
+					// leave the pointer on the stack
+					m_context << Instruction::DUP1;
+					m_context << u256(calldataType->calldataEncodedSize()) << Instruction::ADD;
+				}
+				if (arrayType.location() == DataLocation::Memory)
+				{
+					// stack: base_offset calldata_ref [length] next_calldata
+					// copy to memory
+					// move calldata type up again
+					CompilerUtils(m_context).moveIntoStack(calldataType->sizeOnStack());
+					CompilerUtils(m_context).convertType(*calldataType, arrayType);
+					// fetch next pointer again
+					CompilerUtils(m_context).moveToStackTop(arrayType.sizeOnStack());
+				}
+				// move base_offset up
+				CompilerUtils(m_context).moveToStackTop(1 + arrayType.sizeOnStack());
+				m_context << Instruction::SWAP1;
+			}
+		}
+		else
+		{
+			solAssert(!type->isDynamicallySized(), "Unknown dynamically sized type: " + type->toString());
+			CompilerUtils(m_context).loadFromMemoryDynamic(*type, !_fromMemory, true);
+			CompilerUtils(m_context).moveToStackTop(1 + type->sizeOnStack());
+			m_context << Instruction::SWAP1;
+		}
+		// stack: v1 v2 ... v(k-1) v(k) base_offset mem_offset
+	}
+	m_context << Instruction::POP << Instruction::POP;
+}
+
+void ContractCompiler::appendReturnValuePacker(TypePointers const& _typeParameters, bool _isLibrary)
+{
+	CompilerUtils utils(m_context);
+	if (_typeParameters.empty())
+		m_context << Instruction::STOP;
+	else
+	{
+		utils.fetchFreeMemoryPointer();
+		//@todo optimization: if we return a single memory array, there should be enough space before
+		// its data to add the needed parts and we avoid a memory copy.
+		utils.encodeToMemory(_typeParameters, _typeParameters, true, false, _isLibrary);
+		utils.toSizeAfterFreeMemoryPointer();
+		m_context << Instruction::RETURN;
+	}
+}
+
+void ContractCompiler::registerStateVariables(ContractDefinition const& _contract)
+{
+	for (auto const& var: ContractType(_contract).stateVariables())
+		m_context.addStateVariable(*get<0>(var), get<1>(var), get<2>(var));
+}
+
+void ContractCompiler::initializeStateVariables(ContractDefinition const& _contract)
+{
+	for (VariableDeclaration const* variable: _contract.stateVariables())
+		if (variable->value() && !variable->isConstant())
+			ExpressionCompiler(m_context, m_optimise).appendStateVariableInitialization(*variable);
+}
+
+bool ContractCompiler::visit(VariableDeclaration const& _variableDeclaration)
+{
+	solAssert(_variableDeclaration.isStateVariable(), "Compiler visit to non-state variable declaration.");
+	CompilerContext::LocationSetter locationSetter(m_context, _variableDeclaration);
+
+	m_context.startFunction(_variableDeclaration);
+	m_breakTags.clear();
+	m_continueTags.clear();
+
+	if (_variableDeclaration.isConstant())
+		ExpressionCompiler(m_context, m_optimise).appendConstStateVariableAccessor(_variableDeclaration);
+	else
+		ExpressionCompiler(m_context, m_optimise).appendStateVariableAccessor(_variableDeclaration);
+
+	return false;
+}
+
+bool ContractCompiler::visit(FunctionDefinition const& _function)
+{
+	CompilerContext::LocationSetter locationSetter(m_context, _function);
+
+	m_context.startFunction(_function);
+
+	// stack upon entry: [return address] [arg0] [arg1] ... [argn]
+	// reserve additional slots: [retarg0] ... [retargm] [localvar0] ... [localvarp]
+
+	unsigned parametersSize = CompilerUtils::sizeOnStack(_function.parameters());
+	if (!_function.isConstructor())
+		// adding 1 for return address.
+		m_context.adjustStackOffset(parametersSize + 1);
+	for (ASTPointer<VariableDeclaration const> const& variable: _function.parameters())
+	{
+		m_context.addVariable(*variable, parametersSize);
+		parametersSize -= variable->annotation().type->sizeOnStack();
+	}
+
+	for (ASTPointer<VariableDeclaration const> const& variable: _function.returnParameters())
+		appendStackVariableInitialisation(*variable);
+	for (VariableDeclaration const* localVariable: _function.localVariables())
+		appendStackVariableInitialisation(*localVariable);
+
+	if (_function.isConstructor())
+		if (auto c = m_context.nextConstructor(dynamic_cast<ContractDefinition const&>(*_function.scope())))
+			appendBaseConstructor(*c);
+
+	m_returnTag = m_context.newTag();
+	m_breakTags.clear();
+	m_continueTags.clear();
+	m_stackCleanupForReturn = 0;
+	m_currentFunction = &_function;
+	m_modifierDepth = 0;
+
+	appendModifierOrFunctionCode();
+
+	m_context << m_returnTag;
+
+	// Now we need to re-shuffle the stack. For this we keep a record of the stack layout
+	// that shows the target positions of the elements, where "-1" denotes that this element needs
+	// to be removed from the stack.
+	// Note that the fact that the return arguments are of increasing index is vital for this
+	// algorithm to work.
+
+	unsigned const c_argumentsSize = CompilerUtils::sizeOnStack(_function.parameters());
+	unsigned const c_returnValuesSize = CompilerUtils::sizeOnStack(_function.returnParameters());
+	unsigned const c_localVariablesSize = CompilerUtils::sizeOnStack(_function.localVariables());
+
+	vector<int> stackLayout;
+	stackLayout.push_back(c_returnValuesSize); // target of return address
+	stackLayout += vector<int>(c_argumentsSize, -1); // discard all arguments
+	for (unsigned i = 0; i < c_returnValuesSize; ++i)
+		stackLayout.push_back(i);
+	stackLayout += vector<int>(c_localVariablesSize, -1);
+
+	solAssert(stackLayout.size() <= 17, "Stack too deep, try removing local variables.");
+	while (stackLayout.back() != int(stackLayout.size() - 1))
+		if (stackLayout.back() < 0)
+		{
+			m_context << Instruction::POP;
+			stackLayout.pop_back();
+		}
+		else
+		{
+			m_context << swapInstruction(stackLayout.size() - stackLayout.back() - 1);
+			swap(stackLayout[stackLayout.back()], stackLayout.back());
+		}
+	//@todo assert that everything is in place now
+
+	for (ASTPointer<VariableDeclaration const> const& variable: _function.parameters() + _function.returnParameters())
+		m_context.removeVariable(*variable);
+	for (VariableDeclaration const* localVariable: _function.localVariables())
+		m_context.removeVariable(*localVariable);
+
+	m_context.adjustStackOffset(-(int)c_returnValuesSize);
+
+	if (!_function.isConstructor())
+		m_context.appendJump(eth::AssemblyItem::JumpType::OutOfFunction);
+	return false;
+}
+
+bool ContractCompiler::visit(InlineAssembly const& _inlineAssembly)
+{
+	ErrorList errors;
+	assembly::CodeGenerator codeGen(_inlineAssembly.operations(), errors);
+	unsigned startStackHeight = m_context.stackHeight();
+	codeGen.assemble(
+		m_context.nonConstAssembly(),
+		[&](assembly::Identifier const& _identifier, eth::Assembly& _assembly, assembly::CodeGenerator::IdentifierContext _context) {
+			auto ref = _inlineAssembly.annotation().externalReferences.find(&_identifier);
+			if (ref == _inlineAssembly.annotation().externalReferences.end())
+				return false;
+			Declaration const* decl = ref->second;
+			solAssert(!!decl, "");
+			if (_context == assembly::CodeGenerator::IdentifierContext::RValue)
+			{
+				solAssert(!!decl->type(), "Type of declaration required but not yet determined.");
+				if (FunctionDefinition const* functionDef = dynamic_cast<FunctionDefinition const*>(decl))
+					_assembly.append(m_context.virtualFunctionEntryLabel(*functionDef).pushTag());
+				else if (auto variable = dynamic_cast<VariableDeclaration const*>(decl))
+				{
+					solAssert(!variable->isConstant(), "");
+					if (m_context.isLocalVariable(variable))
+					{
+						int stackDiff = _assembly.deposit() - m_context.baseStackOffsetOfVariable(*variable);
+						if (stackDiff < 1 || stackDiff > 16)
+							BOOST_THROW_EXCEPTION(
+								CompilerError() <<
+								errinfo_comment("Stack too deep, try removing local variables.")
+							);
+						for (unsigned i = 0; i < variable->type()->sizeOnStack(); ++i)
+							_assembly.append(dupInstruction(stackDiff));
+					}
+					else
+					{
+						solAssert(m_context.isStateVariable(variable), "Invalid variable type.");
+						auto const& location = m_context.storageLocationOfVariable(*variable);
+						if (!variable->type()->isValueType())
+						{
+							solAssert(location.second == 0, "Intra-slot offest assumed to be zero.");
+							_assembly.append(location.first);
+						}
+						else
+						{
+							_assembly.append(location.first);
+							_assembly.append(u256(location.second));
+						}
+					}
+				}
+				else if (auto contract = dynamic_cast<ContractDefinition const*>(decl))
+				{
+					solAssert(contract->isLibrary(), "");
+					_assembly.appendLibraryAddress(contract->name());
+				}
+				else
+					solAssert(false, "Invalid declaration type.");
+			} else {
+				// lvalue context
+				auto variable = dynamic_cast<VariableDeclaration const*>(decl);
+				solAssert(
+					!!variable || !m_context.isLocalVariable(variable),
+					"Can only assign to stack variables in inline assembly."
+				);
+				unsigned size = variable->type()->sizeOnStack();
+				int stackDiff = _assembly.deposit() - m_context.baseStackOffsetOfVariable(*variable) - size;
+				if (stackDiff > 16 || stackDiff < 1)
+					BOOST_THROW_EXCEPTION(
+						CompilerError() <<
+						errinfo_comment("Stack too deep, try removing local variables.")
+					);
+				for (unsigned i = 0; i < size; ++i) {
+					_assembly.append(swapInstruction(stackDiff));
+					_assembly.append(Instruction::POP);
+				}
+			}
+			return true;
+		}
+	);
+	solAssert(errors.empty(), "Code generation for inline assembly with errors requested.");
+	m_context.setStackOffset(startStackHeight);
+	return false;
+}
+
+bool ContractCompiler::visit(IfStatement const& _ifStatement)
+{
+	StackHeightChecker checker(m_context);
+	CompilerContext::LocationSetter locationSetter(m_context, _ifStatement);
+	compileExpression(_ifStatement.condition());
+	m_context << Instruction::ISZERO;
+	eth::AssemblyItem falseTag = m_context.appendConditionalJump();
+	eth::AssemblyItem endTag = falseTag;
+	_ifStatement.trueStatement().accept(*this);
+	if (_ifStatement.falseStatement())
+	{
+		endTag = m_context.appendJumpToNew();
+		m_context << falseTag;
+		_ifStatement.falseStatement()->accept(*this);
+	}
+	m_context << endTag;
+
+	checker.check();
+	return false;
+}
+
+bool ContractCompiler::visit(WhileStatement const& _whileStatement)
+{
+	StackHeightChecker checker(m_context);
+	CompilerContext::LocationSetter locationSetter(m_context, _whileStatement);
+	eth::AssemblyItem loopStart = m_context.newTag();
+	eth::AssemblyItem loopEnd = m_context.newTag();
+	m_continueTags.push_back(loopStart);
+	m_breakTags.push_back(loopEnd);
+
+	m_context << loopStart;
+	compileExpression(_whileStatement.condition());
+	m_context << Instruction::ISZERO;
+	m_context.appendConditionalJumpTo(loopEnd);
+
+	_whileStatement.body().accept(*this);
+
+	m_context.appendJumpTo(loopStart);
+	m_context << loopEnd;
+
+	m_continueTags.pop_back();
+	m_breakTags.pop_back();
+
+	checker.check();
+	return false;
+}
+
+bool ContractCompiler::visit(ForStatement const& _forStatement)
+{
+	StackHeightChecker checker(m_context);
+	CompilerContext::LocationSetter locationSetter(m_context, _forStatement);
+	eth::AssemblyItem loopStart = m_context.newTag();
+	eth::AssemblyItem loopEnd = m_context.newTag();
+	eth::AssemblyItem loopNext = m_context.newTag();
+	m_continueTags.push_back(loopNext);
+	m_breakTags.push_back(loopEnd);
+
+	if (_forStatement.initializationExpression())
+		_forStatement.initializationExpression()->accept(*this);
+
+	m_context << loopStart;
+
+	// if there is no terminating condition in for, default is to always be true
+	if (_forStatement.condition())
+	{
+		compileExpression(*_forStatement.condition());
+		m_context << Instruction::ISZERO;
+		m_context.appendConditionalJumpTo(loopEnd);
+	}
+
+	_forStatement.body().accept(*this);
+
+	m_context << loopNext;
+
+	// for's loop expression if existing
+	if (_forStatement.loopExpression())
+		_forStatement.loopExpression()->accept(*this);
+
+	m_context.appendJumpTo(loopStart);
+	m_context << loopEnd;
+
+	m_continueTags.pop_back();
+	m_breakTags.pop_back();
+
+	checker.check();
+	return false;
+}
+
+bool ContractCompiler::visit(Continue const& _continueStatement)
+{
+	CompilerContext::LocationSetter locationSetter(m_context, _continueStatement);
+	if (!m_continueTags.empty())
+		m_context.appendJumpTo(m_continueTags.back());
+	return false;
+}
+
+bool ContractCompiler::visit(Break const& _breakStatement)
+{
+	CompilerContext::LocationSetter locationSetter(m_context, _breakStatement);
+	if (!m_breakTags.empty())
+		m_context.appendJumpTo(m_breakTags.back());
+	return false;
+}
+
+bool ContractCompiler::visit(Return const& _return)
+{
+	CompilerContext::LocationSetter locationSetter(m_context, _return);
+	if (Expression const* expression = _return.expression())
+	{
+		solAssert(_return.annotation().functionReturnParameters, "Invalid return parameters pointer.");
+		vector<ASTPointer<VariableDeclaration>> const& returnParameters =
+			_return.annotation().functionReturnParameters->parameters();
+		TypePointers types;
+		for (auto const& retVariable: returnParameters)
+			types.push_back(retVariable->annotation().type);
+
+		TypePointer expectedType;
+		if (expression->annotation().type->category() == Type::Category::Tuple || types.size() != 1)
+			expectedType = make_shared<TupleType>(types);
+		else
+			expectedType = types.front();
+		compileExpression(*expression, expectedType);
+
+		for (auto const& retVariable: boost::adaptors::reverse(returnParameters))
+			CompilerUtils(m_context).moveToStackVariable(*retVariable);
+	}
+	for (unsigned i = 0; i < m_stackCleanupForReturn; ++i)
+		m_context << Instruction::POP;
+	m_context.appendJumpTo(m_returnTag);
+	m_context.adjustStackOffset(m_stackCleanupForReturn);
+	return false;
+}
+
+bool ContractCompiler::visit(Throw const& _throw)
+{
+	CompilerContext::LocationSetter locationSetter(m_context, _throw);
+	m_context.appendJumpTo(m_context.errorTag());
+	return false;
+}
+
+bool ContractCompiler::visit(VariableDeclarationStatement const& _variableDeclarationStatement)
+{
+	StackHeightChecker checker(m_context);
+	CompilerContext::LocationSetter locationSetter(m_context, _variableDeclarationStatement);
+	if (Expression const* expression = _variableDeclarationStatement.initialValue())
+	{
+		CompilerUtils utils(m_context);
+		compileExpression(*expression);
+		TypePointers valueTypes;
+		if (auto tupleType = dynamic_cast<TupleType const*>(expression->annotation().type.get()))
+			valueTypes = tupleType->components();
+		else
+			valueTypes = TypePointers{expression->annotation().type};
+		auto const& assignments = _variableDeclarationStatement.annotation().assignments;
+		solAssert(assignments.size() == valueTypes.size(), "");
+		for (size_t i = 0; i < assignments.size(); ++i)
+		{
+			size_t j = assignments.size() - i - 1;
+			solAssert(!!valueTypes[j], "");
+			VariableDeclaration const* varDecl = assignments[j];
+			if (!varDecl)
+				utils.popStackElement(*valueTypes[j]);
+			else
+			{
+				utils.convertType(*valueTypes[j], *varDecl->annotation().type);
+				utils.moveToStackVariable(*varDecl);
+			}
+		}
+	}
+	checker.check();
+	return false;
+}
+
+bool ContractCompiler::visit(ExpressionStatement const& _expressionStatement)
+{
+	StackHeightChecker checker(m_context);
+	CompilerContext::LocationSetter locationSetter(m_context, _expressionStatement);
+	Expression const& expression = _expressionStatement.expression();
+	compileExpression(expression);
+	CompilerUtils(m_context).popStackElement(*expression.annotation().type);
+	checker.check();
+	return false;
+}
+
+bool ContractCompiler::visit(PlaceholderStatement const& _placeholderStatement)
+{
+	StackHeightChecker checker(m_context);
+	CompilerContext::LocationSetter locationSetter(m_context, _placeholderStatement);
+	++m_modifierDepth;
+	appendModifierOrFunctionCode();
+	--m_modifierDepth;
+	checker.check();
+	return true;
+}
+
+void ContractCompiler::appendMissingFunctions()
+{
+	while (Declaration const* function = m_context.nextFunctionToCompile())
+	{
+		m_context.setStackOffset(0);
+		function->accept(*this);
+		solAssert(m_context.nextFunctionToCompile() != function, "Compiled the wrong function?");
+	}
+}
+
+void ContractCompiler::appendModifierOrFunctionCode()
+{
+	solAssert(m_currentFunction, "");
+	if (m_modifierDepth >= m_currentFunction->modifiers().size())
+		m_currentFunction->body().accept(*this);
+	else
+	{
+		ASTPointer<ModifierInvocation> const& modifierInvocation = m_currentFunction->modifiers()[m_modifierDepth];
+
+		// constructor call should be excluded
+		if (dynamic_cast<ContractDefinition const*>(modifierInvocation->name()->annotation().referencedDeclaration))
+		{
+			++m_modifierDepth;
+			appendModifierOrFunctionCode();
+			--m_modifierDepth;
+			return;
+		}
+
+		ModifierDefinition const& modifier = m_context.functionModifier(modifierInvocation->name()->name());
+		CompilerContext::LocationSetter locationSetter(m_context, modifier);
+		solAssert(modifier.parameters().size() == modifierInvocation->arguments().size(), "");
+		for (unsigned i = 0; i < modifier.parameters().size(); ++i)
+		{
+			m_context.addVariable(*modifier.parameters()[i]);
+			compileExpression(
+				*modifierInvocation->arguments()[i],
+				modifier.parameters()[i]->annotation().type
+			);
+		}
+		for (VariableDeclaration const* localVariable: modifier.localVariables())
+			appendStackVariableInitialisation(*localVariable);
+
+		unsigned const c_stackSurplus = CompilerUtils::sizeOnStack(modifier.parameters()) +
+										CompilerUtils::sizeOnStack(modifier.localVariables());
+		m_stackCleanupForReturn += c_stackSurplus;
+
+		modifier.body().accept(*this);
+
+		for (unsigned i = 0; i < c_stackSurplus; ++i)
+			m_context << Instruction::POP;
+		m_stackCleanupForReturn -= c_stackSurplus;
+	}
+}
+
+void ContractCompiler::appendStackVariableInitialisation(VariableDeclaration const& _variable)
+{
+	CompilerContext::LocationSetter location(m_context, _variable);
+	m_context.addVariable(_variable);
+	CompilerUtils(m_context).pushZeroValue(*_variable.annotation().type);
+}
+
+void ContractCompiler::compileExpression(Expression const& _expression, TypePointer const& _targetType)
+{
+	ExpressionCompiler expressionCompiler(m_context, m_optimise);
+	expressionCompiler.compile(_expression);
+	if (_targetType)
+		CompilerUtils(m_context).convertType(*_expression.annotation().type, *_targetType);
+}
+
+eth::Assembly ContractCompiler::cloneRuntime()
+{
+	eth::Assembly a;
+	a << Instruction::CALLDATASIZE;
+	a << u256(0) << Instruction::DUP1 << Instruction::CALLDATACOPY;
+	//@todo adjust for larger return values, make this dynamic.
+	a << u256(0x20) << u256(0) << Instruction::CALLDATASIZE;
+	a << u256(0);
+	// this is the address which has to be substituted by the linker.
+	//@todo implement as special "marker" AssemblyItem.
+	a << u256("0xcafecafecafecafecafecafecafecafecafecafe");
+	a << u256(eth::GasCosts::callGas + 10) << Instruction::GAS << Instruction::SUB;
+	a << Instruction::DELEGATECALL;
+	//Propagate error condition (if DELEGATECALL pushes 0 on stack).
+	a << Instruction::ISZERO;
+	a.appendJumpI(a.errorTag());
+	//@todo adjust for larger return values, make this dynamic.
+	a << u256(0x20) << u256(0) << Instruction::RETURN;
+	return a;
+}
diff --git a/libsolidity/codegen/ContractCompiler.h b/libsolidity/codegen/ContractCompiler.h
new file mode 100644
index 00000000..d1517e88
--- /dev/null
+++ b/libsolidity/codegen/ContractCompiler.h
@@ -0,0 +1,134 @@
+/*
+	This file is part of cpp-ethereum.
+
+	cpp-ethereum is free software: you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
+
+	cpp-ethereum is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.
+*/
+/**
+ * @author Christian <c@ethdev.com>
+ * @date 2014
+ * Code generator for contracts.
+ */
+
+#pragma once
+
+#include <ostream>
+#include <functional>
+#include <libsolidity/ast/ASTVisitor.h>
+#include <libsolidity/codegen/CompilerContext.h>
+#include <libevmasm/Assembly.h>
+
+namespace dev {
+namespace solidity {
+
+/**
+ * Code generator at the contract level. Can be used to generate code for exactly one contract
+ * either either in "runtime mode" or "creation mode".
+ */
+class ContractCompiler: private ASTConstVisitor
+{
+public:
+	explicit ContractCompiler(CompilerContext& _context, bool _optimise):
+		m_optimise(_optimise),
+		m_context(_context),
+		m_returnTag(eth::Tag, u256(-1))
+	{
+		m_context = CompilerContext();
+		m_returnTag = m_context.newTag();
+	}
+
+	void compileContract(
+		ContractDefinition const& _contract,
+		std::map<ContractDefinition const*, eth::Assembly const*> const& _contracts
+	);
+	/// Compiles the constructor part of the contract.
+	/// @returns the identifier of the runtime sub-assembly.
+	size_t compileConstructor(
+		CompilerContext const& _runtimeContext,
+		ContractDefinition const& _contract,
+		std::map<ContractDefinition const*, eth::Assembly const*> const& _contracts
+	);
+	/// Compiles a contract that uses DELEGATECALL to call into a pre-deployed version of the given
+	/// contract at runtime, but contains the full creation-time code.
+	/// @returns the identifier of the runtime sub-assembly.
+	size_t compileClone(
+		ContractDefinition const& _contract,
+		std::map<ContractDefinition const*, eth::Assembly const*> const& _contracts
+	);
+
+private:
+	/// Registers the non-function objects inside the contract with the context and stores the basic
+	/// information about the contract like the AST annotations.
+	void initializeContext(
+		ContractDefinition const& _contract,
+		std::map<ContractDefinition const*, eth::Assembly const*> const& _compiledContracts
+	);
+	/// Adds the code that is run at creation time. Should be run after exchanging the run-time context
+	/// with a new and initialized context. Adds the constructor code.
+	/// @returns the identifier of the runtime sub assembly
+	size_t packIntoContractCreator(ContractDefinition const& _contract, CompilerContext const& _runtimeContext);
+	/// Appends state variable initialisation and constructor code.
+	void appendInitAndConstructorCode(ContractDefinition const& _contract);
+	void appendBaseConstructor(FunctionDefinition const& _constructor);
+	void appendConstructor(FunctionDefinition const& _constructor);
+	void appendFunctionSelector(ContractDefinition const& _contract);
+	/// Creates code that unpacks the arguments for the given function represented by a vector of TypePointers.
+	/// From memory if @a _fromMemory is true, otherwise from call data.
+	/// Expects source offset on the stack, which is removed.
+	void appendCalldataUnpacker(TypePointers const& _typeParameters, bool _fromMemory = false);
+	void appendReturnValuePacker(TypePointers const& _typeParameters, bool _isLibrary);
+
+	void registerStateVariables(ContractDefinition const& _contract);
+	void initializeStateVariables(ContractDefinition const& _contract);
+
+	virtual bool visit(VariableDeclaration const& _variableDeclaration) override;
+	virtual bool visit(FunctionDefinition const& _function) override;
+	virtual bool visit(InlineAssembly const& _inlineAssembly) override;
+	virtual bool visit(IfStatement const& _ifStatement) override;
+	virtual bool visit(WhileStatement const& _whileStatement) override;
+	virtual bool visit(ForStatement const& _forStatement) override;
+	virtual bool visit(Continue const& _continue) override;
+	virtual bool visit(Break const& _break) override;
+	virtual bool visit(Return const& _return) override;
+	virtual bool visit(Throw const& _throw) override;
+	virtual bool visit(VariableDeclarationStatement const& _variableDeclarationStatement) override;
+	virtual bool visit(ExpressionStatement const& _expressionStatement) override;
+	virtual bool visit(PlaceholderStatement const&) override;
+
+	/// Repeatedly visits all function which are referenced but which are not compiled yet.
+	void appendMissingFunctions();
+
+	/// Appends one layer of function modifier code of the current function, or the function
+	/// body itself if the last modifier was reached.
+	void appendModifierOrFunctionCode();
+
+	void appendStackVariableInitialisation(VariableDeclaration const& _variable);
+	void compileExpression(Expression const& _expression, TypePointer const& _targetType = TypePointer());
+
+	/// @returns the runtime assembly for clone contracts.
+	static eth::Assembly cloneRuntime();
+
+	bool const m_optimise;
+	CompilerContext& m_context;
+	std::vector<eth::AssemblyItem> m_breakTags; ///< tag to jump to for a "break" statement
+	std::vector<eth::AssemblyItem> m_continueTags; ///< tag to jump to for a "continue" statement
+	eth::AssemblyItem m_returnTag; ///< tag to jump to for a "return" statement
+	unsigned m_modifierDepth = 0;
+	FunctionDefinition const* m_currentFunction = nullptr;
+	unsigned m_stackCleanupForReturn = 0; ///< this number of stack elements need to be removed before jump to m_returnTag
+	// arguments for base constructors, filled in derived-to-base order
+	std::map<FunctionDefinition const*, std::vector<ASTPointer<Expression>> const*> m_baseArguments;
+};
+
+}
+}
diff --git a/libsolidity/codegen/ExpressionCompiler.cpp b/libsolidity/codegen/ExpressionCompiler.cpp
index d1cbc8ed..16677093 100644
--- a/libsolidity/codegen/ExpressionCompiler.cpp
+++ b/libsolidity/codegen/ExpressionCompiler.cpp
@@ -281,11 +281,7 @@ bool ExpressionCompiler::visit(TupleExpression const& _tuple)
 bool ExpressionCompiler::visit(UnaryOperation const& _unaryOperation)
 {
 	CompilerContext::LocationSetter locationSetter(m_context, _unaryOperation);
-	//@todo type checking and creating code for an operator should be in the same place:
-	// the operator should know how to convert itself and to which types it applies, so
-	// put this code together with "Type::acceptsBinary/UnaryOperator" into a class that
-	// represents the operator
-	if (_unaryOperation.annotation().type->category() == Type::Category::IntegerConstant)
+	if (_unaryOperation.annotation().type->category() == Type::Category::RationalNumber)
 	{
 		m_context << _unaryOperation.annotation().type->literalValue(nullptr);
 		return false;
@@ -360,17 +356,20 @@ bool ExpressionCompiler::visit(BinaryOperation const& _binaryOperation)
 
 	if (c_op == Token::And || c_op == Token::Or) // special case: short-circuiting
 		appendAndOrOperatorCode(_binaryOperation);
-	else if (commonType.category() == Type::Category::IntegerConstant)
+	else if (commonType.category() == Type::Category::RationalNumber)
 		m_context << commonType.literalValue(nullptr);
 	else
 	{
-		bool cleanupNeeded = commonType.category() == Type::Category::Integer &&
-			(Token::isCompareOp(c_op) || c_op == Token::Div || c_op == Token::Mod);
+		bool cleanupNeeded = false;
+		if (Token::isCompareOp(c_op))
+			cleanupNeeded = true;
+		if (commonType.category() == Type::Category::Integer && (c_op == Token::Div || c_op == Token::Mod))
+			cleanupNeeded = true;
 
 		// for commutative operators, push the literal as late as possible to allow improved optimization
 		auto isLiteral = [](Expression const& _e)
 		{
-			return dynamic_cast<Literal const*>(&_e) || _e.annotation().type->category() == Type::Category::IntegerConstant;
+			return dynamic_cast<Literal const*>(&_e) || _e.annotation().type->category() == Type::Category::RationalNumber;
 		};
 		bool swap = m_optimize && Token::isCommutativeOp(c_op) && isLiteral(rightExpression) && !isLiteral(leftExpression);
 		if (swap)
@@ -464,8 +463,8 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 	{
 		FunctionType const& function = *functionType;
 		if (function.bound())
-			// Only delegatecall functions can be bound, this might be lifted later.
-			solAssert(function.location() == Location::DelegateCall, "");
+			// Only delegatecall and internal functions can be bound, this might be lifted later.
+			solAssert(function.location() == Location::DelegateCall || function.location() == Location::Internal, "");
 		switch (function.location())
 		{
 		case Location::Internal:
@@ -480,13 +479,21 @@ bool ExpressionCompiler::visit(FunctionCall const& _functionCall)
 				utils().convertType(*arguments[i]->annotation().type, *function.parameterTypes()[i]);
 			}
 			_functionCall.expression().accept(*this);
+			unsigned parameterSize = CompilerUtils::sizeOnStack(function.parameterTypes());
+			if (function.bound())
+			{
+				// stack: arg2, ..., argn, label, arg1
+				unsigned depth = parameterSize + 1;
+				utils().moveIntoStack(depth, function.selfType()->sizeOnStack());
+				parameterSize += function.selfType()->sizeOnStack();
+			}
 
 			m_context.appendJump(eth::AssemblyItem::JumpType::IntoFunction);
 			m_context << returnLabel;
 
 			unsigned returnParametersSize = CompilerUtils::sizeOnStack(function.returnParameterTypes());
 			// callee adds return parameters, but removes arguments and return label
-			m_context.adjustStackOffset(returnParametersSize - CompilerUtils::sizeOnStack(function.parameterTypes()) - 1);
+			m_context.adjustStackOffset(returnParametersSize - parameterSize - 1);
 			break;
 		}
 		case Location::External:
@@ -809,7 +816,7 @@ bool ExpressionCompiler::visit(NewExpression const&)
 	return false;
 }
 
-void ExpressionCompiler::endVisit(MemberAccess const& _memberAccess)
+bool ExpressionCompiler::visit(MemberAccess const& _memberAccess)
 {
 	CompilerContext::LocationSetter locationSetter(m_context, _memberAccess);
 	// Check whether the member is a bound function.
@@ -817,19 +824,68 @@ void ExpressionCompiler::endVisit(MemberAccess const& _memberAccess)
 	if (auto funType = dynamic_cast<FunctionType const*>(_memberAccess.annotation().type.get()))
 		if (funType->bound())
 		{
+			_memberAccess.expression().accept(*this);
 			utils().convertType(
 				*_memberAccess.expression().annotation().type,
 				*funType->selfType(),
 				true
 			);
-			auto contract = dynamic_cast<ContractDefinition const*>(funType->declaration().scope());
-			solAssert(contract && contract->isLibrary(), "");
-			m_context.appendLibraryAddress(contract->name());
-			m_context << funType->externalIdentifier();
-			utils().moveIntoStack(funType->selfType()->sizeOnStack(), 2);
-			return;
+			if (funType->location() == FunctionType::Location::Internal)
+			{
+				m_context << m_context.functionEntryLabel(
+					dynamic_cast<FunctionDefinition const&>(funType->declaration())
+				).pushTag();
+				utils().moveIntoStack(funType->selfType()->sizeOnStack(), 1);
+			}
+			else
+			{
+				solAssert(funType->location() == FunctionType::Location::DelegateCall, "");
+				auto contract = dynamic_cast<ContractDefinition const*>(funType->declaration().scope());
+				solAssert(contract && contract->isLibrary(), "");
+				m_context.appendLibraryAddress(contract->name());
+				m_context << funType->externalIdentifier();
+				utils().moveIntoStack(funType->selfType()->sizeOnStack(), 2);
+			}
+			return false;
 		}
 
+	// Special processing for TypeType because we do not want to visit the library itself
+	// for internal functions.
+	if (TypeType const* type = dynamic_cast<TypeType const*>(_memberAccess.expression().annotation().type.get()))
+	{
+		if (dynamic_cast<ContractType const*>(type->actualType().get()))
+		{
+			if (auto funType = dynamic_cast<FunctionType const*>(_memberAccess.annotation().type.get()))
+			{
+				if (funType->location() != FunctionType::Location::Internal)
+				{
+					_memberAccess.expression().accept(*this);
+					m_context << funType->externalIdentifier();
+				}
+				else
+				{
+					// We do not visit the expression here on purpose, because in the case of an
+					// internal library function call, this would push the library address forcing
+					// us to link against it although we actually do not need it.
+					auto const* function = dynamic_cast<FunctionDefinition const*>(_memberAccess.annotation().referencedDeclaration);
+					solAssert(!!function, "Function not found in member access");
+					m_context << m_context.functionEntryLabel(*function).pushTag();
+				}
+			}
+			else
+				_memberAccess.expression().accept(*this);
+		}
+		else if (auto enumType = dynamic_cast<EnumType const*>(type->actualType().get()))
+		{
+			_memberAccess.expression().accept(*this);
+			m_context << enumType->memberValue(_memberAccess.memberName());
+		}
+		else
+			_memberAccess.expression().accept(*this);
+		return false;
+	}
+
+	_memberAccess.expression().accept(*this);
 	switch (_memberAccess.expression().annotation().type->category())
 	{
 	case Type::Category::Contract:
@@ -948,28 +1004,6 @@ void ExpressionCompiler::endVisit(MemberAccess const& _memberAccess)
 		m_context << type.memberValue(_memberAccess.memberName());
 		break;
 	}
-	case Type::Category::TypeType:
-	{
-		TypeType const& type = dynamic_cast<TypeType const&>(*_memberAccess.expression().annotation().type);
-
-		if (dynamic_cast<ContractType const*>(type.actualType().get()))
-		{
-			if (auto funType = dynamic_cast<FunctionType const*>(_memberAccess.annotation().type.get()))
-			{
-				if (funType->location() != FunctionType::Location::Internal)
-					m_context << funType->externalIdentifier();
-				else
-				{
-					auto const* function = dynamic_cast<FunctionDefinition const*>(_memberAccess.annotation().referencedDeclaration);
-					solAssert(!!function, "Function not found in member access");
-					m_context << m_context.functionEntryLabel(*function).pushTag();
-				}
-			}
-		}
-		else if (auto enumType = dynamic_cast<EnumType const*>(type.actualType().get()))
-			m_context << enumType->memberValue(_memberAccess.memberName());
-		break;
-	}
 	case Type::Category::Array:
 	{
 		auto const& type = dynamic_cast<ArrayType const&>(*_memberAccess.expression().annotation().type);
@@ -1018,6 +1052,7 @@ void ExpressionCompiler::endVisit(MemberAccess const& _memberAccess)
 	default:
 		BOOST_THROW_EXCEPTION(InternalCompilerError() << errinfo_comment("Member access to unknown type."));
 	}
+	return false;
 }
 
 bool ExpressionCompiler::visit(IndexAccess const& _indexAccess)
@@ -1189,7 +1224,7 @@ void ExpressionCompiler::endVisit(Literal const& _literal)
 	
 	switch (type->category())
 	{
-	case Type::Category::IntegerConstant:
+	case Type::Category::RationalNumber:
 	case Type::Category::Bool:
 		m_context << type->literalValue(&_literal);
 		break;
@@ -1270,6 +1305,9 @@ void ExpressionCompiler::appendArithmeticOperatorCode(Token::Value _operator, Ty
 	IntegerType const& type = dynamic_cast<IntegerType const&>(_type);
 	bool const c_isSigned = type.isSigned();
 
+	if (_type.category() == Type::Category::FixedPoint)
+		solAssert(false, "Not yet implemented - FixedPointType.");
+
 	switch (_operator)
 	{
 	case Token::Add:
diff --git a/libsolidity/codegen/ExpressionCompiler.h b/libsolidity/codegen/ExpressionCompiler.h
index f00b24e8..43a92a10 100644
--- a/libsolidity/codegen/ExpressionCompiler.h
+++ b/libsolidity/codegen/ExpressionCompiler.h
@@ -78,7 +78,7 @@ private:
 	virtual bool visit(BinaryOperation const& _binaryOperation) override;
 	virtual bool visit(FunctionCall const& _functionCall) override;
 	virtual bool visit(NewExpression const& _newExpression) override;
-	virtual void endVisit(MemberAccess const& _memberAccess) override;
+	virtual bool visit(MemberAccess const& _memberAccess) override;
 	virtual bool visit(IndexAccess const& _indexAccess) override;
 	virtual void endVisit(Identifier const& _identifier) override;
 	virtual void endVisit(Literal const& _literal) override;
diff --git a/libsolidity/codegen/LValue.cpp b/libsolidity/codegen/LValue.cpp
index fcadd2ff..ea8bc1ba 100644
--- a/libsolidity/codegen/LValue.cpp
+++ b/libsolidity/codegen/LValue.cpp
@@ -179,6 +179,9 @@ void StorageItem::retrieveValue(SourceLocation const&, bool _remove) const
 		m_context
 			<< Instruction::SWAP1 << Instruction::SLOAD << Instruction::SWAP1
 			<< u256(0x100) << Instruction::EXP << Instruction::SWAP1 << Instruction::DIV;
+		if (m_dataType->category() == Type::Category::FixedPoint)
+			// implementation should be very similar to the integer case.
+			solAssert(false, "Not yet implemented - FixedPointType.");
 		if (m_dataType->category() == Type::Category::FixedBytes)
 			m_context << (u256(0x1) << (256 - 8 * m_dataType->storageBytes())) << Instruction::MUL;
 		else if (
@@ -239,6 +242,9 @@ void StorageItem::storeValue(Type const& _sourceType, SourceLocation const& _loc
 					<< Instruction::DUP2
 					<< Instruction::MUL
 					<< Instruction::DIV;
+			else if (m_dataType->category() == Type::Category::FixedPoint)
+				// implementation should be very similar to the integer case.
+				solAssert(false, "Not yet implemented - FixedPointType.");
 			m_context  << Instruction::MUL << Instruction::OR;
 			// stack: value storage_ref updated_value
 			m_context << Instruction::SWAP1 << Instruction::SSTORE;
diff --git a/libsolidity/formal/Why3Translator.cpp b/libsolidity/formal/Why3Translator.cpp
index 24fbab13..c794cb24 100644
--- a/libsolidity/formal/Why3Translator.cpp
+++ b/libsolidity/formal/Why3Translator.cpp
@@ -428,8 +428,11 @@ bool Why3Translator::visit(BinaryOperation const& _binaryOperation)
 	Type const& commonType = *_binaryOperation.annotation().commonType;
 	Token::Value const c_op = _binaryOperation.getOperator();
 
-	if (commonType.category() == Type::Category::IntegerConstant)
+	if (commonType.category() == Type::Category::RationalNumber)
 	{
+		auto const& constantNumber = dynamic_cast<RationalNumberType const&>(commonType);
+		if (constantNumber.isFractional())
+			error(_binaryOperation, "Fractional numbers not supported.");
 		add("(of_int " + toString(commonType.literalValue(nullptr)) + ")");
 		return false;
 	}
@@ -589,9 +592,14 @@ bool Why3Translator::visit(Literal const& _literal)
 		else
 			add("true");
 		break;
-	case Type::Category::IntegerConstant:
+	case Type::Category::RationalNumber:
+	{
+		auto const& constantNumber = dynamic_cast<RationalNumberType const&>(*type);
+		if (constantNumber.isFractional())
+			error(_literal, "Fractional numbers not supported.");
 		add("(of_int " + toString(type->literalValue(&_literal)) + ")");
 		break;
+	}	
 	default:
 		error(_literal, "Not supported.");
 	}
diff --git a/libsolidity/inlineasm/AsmCodeGen.cpp b/libsolidity/inlineasm/AsmCodeGen.cpp
index 5fa04087..53d19b0a 100644
--- a/libsolidity/inlineasm/AsmCodeGen.cpp
+++ b/libsolidity/inlineasm/AsmCodeGen.cpp
@@ -36,7 +36,8 @@ using namespace dev::solidity::assembly;
 
 struct GeneratorState
 {
-	explicit GeneratorState(ErrorList& _errors): errors(_errors) {}
+	GeneratorState(ErrorList& _errors, eth::Assembly& _assembly):
+		errors(_errors), assembly(_assembly) {}
 
 	void addError(Error::Type _type, std::string const& _description, SourceLocation const& _location = SourceLocation())
 	{
@@ -66,10 +67,10 @@ struct GeneratorState
 		return label != labels.end() ? &label->second : nullptr;
 	}
 
-	eth::Assembly assembly;
 	map<string, eth::AssemblyItem> labels;
 	vector<pair<string, int>> variables; ///< name plus stack height
 	ErrorList& errors;
+	eth::Assembly& assembly;
 };
 
 /**
@@ -86,8 +87,12 @@ public:
 	void operator()(Label const& _item)
 	{
 		if (m_state.labels.count(_item.name))
-			//@TODO location and secondary location
-			m_state.addError(Error::Type::DeclarationError, "Label " + _item.name + " declared twice.");
+			//@TODO secondary location
+			m_state.addError(
+				Error::Type::DeclarationError,
+				"Label " + _item.name + " declared twice.",
+				_item.location
+			);
 		m_state.labels.insert(make_pair(_item.name, m_state.assembly.newTag()));
 	}
 	void operator()(assembly::Block const& _block)
@@ -117,34 +122,43 @@ public:
 			m_identifierAccess = [](assembly::Identifier const&, eth::Assembly&, CodeGenerator::IdentifierContext) { return false; };
 	}
 
-	void operator()(dev::solidity::assembly::Instruction const& _instruction)
+	void operator()(assembly::Instruction const& _instruction)
 	{
+		m_state.assembly.setSourceLocation(_instruction.location);
 		m_state.assembly.append(_instruction.instruction);
 	}
 	void operator()(assembly::Literal const& _literal)
 	{
+		m_state.assembly.setSourceLocation(_literal.location);
 		if (_literal.isNumber)
 			m_state.assembly.append(u256(_literal.value));
 		else if (_literal.value.size() > 32)
+		{
 			m_state.addError(
 				Error::Type::TypeError,
 				"String literal too long (" + boost::lexical_cast<string>(_literal.value.size()) + " > 32)"
 			);
+			m_state.assembly.append(u256(0));
+		}
 		else
 			m_state.assembly.append(_literal.value);
 	}
 	void operator()(assembly::Identifier const& _identifier)
 	{
+		m_state.assembly.setSourceLocation(_identifier.location);
 		// First search local variables, then labels, then externals.
 		if (int const* stackHeight = m_state.findVariable(_identifier.name))
 		{
 			int heightDiff = m_state.assembly.deposit() - *stackHeight;
 			if (heightDiff <= 0 || heightDiff > 16)
-				//@TODO location
+			{
 				m_state.addError(
 					Error::Type::TypeError,
-					"Variable inaccessible, too deep inside stack (" + boost::lexical_cast<string>(heightDiff) + ")"
+					"Variable inaccessible, too deep inside stack (" + boost::lexical_cast<string>(heightDiff) + ")",
+					_identifier.location
 				);
+				m_state.assembly.append(u256(0));
+			}
 			else
 				m_state.assembly.append(solidity::dupInstruction(heightDiff));
 			return;
@@ -152,10 +166,14 @@ public:
 		else if (eth::AssemblyItem const* label = m_state.findLabel(_identifier.name))
 			m_state.assembly.append(label->pushTag());
 		else if (!m_identifierAccess(_identifier, m_state.assembly, CodeGenerator::IdentifierContext::RValue))
+		{
 			m_state.addError(
 				Error::Type::DeclarationError,
-				"Identifier \"" + string(_identifier.name) + "\" not found or not unique"
+				"Identifier not found or not unique",
+				_identifier.location
 			);
+			m_state.assembly.append(u256(0));
+		}
 	}
 	void operator()(FunctionalInstruction const& _instr)
 	{
@@ -163,30 +181,33 @@ public:
 		{
 			int height = m_state.assembly.deposit();
 			boost::apply_visitor(*this, *it);
-			expectDeposit(1, height);
+			expectDeposit(1, height, locationOf(*it));
 		}
 		(*this)(_instr.instruction);
 	}
 	void operator()(Label const& _label)
 	{
+		m_state.assembly.setSourceLocation(_label.location);
 		m_state.assembly.append(m_state.labels.at(_label.name));
 	}
 	void operator()(assembly::Assignment const& _assignment)
 	{
-		generateAssignment(_assignment.variableName);
+		m_state.assembly.setSourceLocation(_assignment.location);
+		generateAssignment(_assignment.variableName, _assignment.location);
 	}
 	void operator()(FunctionalAssignment const& _assignment)
 	{
 		int height = m_state.assembly.deposit();
 		boost::apply_visitor(*this, *_assignment.value);
-		expectDeposit(1, height);
-		generateAssignment(_assignment.variableName);
+		expectDeposit(1, height, locationOf(*_assignment.value));
+		m_state.assembly.setSourceLocation(_assignment.location);
+		generateAssignment(_assignment.variableName, _assignment.location);
 	}
 	void operator()(assembly::VariableDeclaration const& _varDecl)
 	{
 		int height = m_state.assembly.deposit();
 		boost::apply_visitor(*this, *_varDecl.value);
-		expectDeposit(1, height);
+		expectDeposit(1, height, locationOf(*_varDecl.value));
 		m_state.variables.push_back(make_pair(_varDecl.name, height));
 	}
 	void operator()(assembly::Block const& _block)
@@ -194,7 +215,8 @@ public:
 		size_t numVariables = m_state.variables.size();
 		std::for_each(_block.statements.begin(), _block.statements.end(), boost::apply_visitor(*this));
 		// pop variables
-		//@TODO check height before and after
+		// we deliberately do not check stack height
+		m_state.assembly.setSourceLocation(_block.location);
 		while (m_state.variables.size() > numVariables)
 		{
 			m_state.assembly.append(solidity::Instruction::POP);
@@ -203,22 +225,20 @@ public:
 	}
 
 private:
-	void generateAssignment(assembly::Identifier const& _variableName)
+	void generateAssignment(assembly::Identifier const& _variableName, SourceLocation const& _location)
 	{
 		if (int const* stackHeight = m_state.findVariable(_variableName.name))
 		{
 			int heightDiff = m_state.assembly.deposit() - *stackHeight - 1;
 			if (heightDiff <= 0 || heightDiff > 16)
-				//@TODO location
 				m_state.addError(
 					Error::Type::TypeError,
-					"Variable inaccessible, too deep inside stack (" + boost::lexical_cast<string>(heightDiff) + ")"
+					"Variable inaccessible, too deep inside stack (" + boost::lexical_cast<string>(heightDiff) + ")",
+					_location
 				);
 			else
-			{
 				m_state.assembly.append(solidity::swapInstruction(heightDiff));
-				m_state.assembly.append(solidity::Instruction::POP);
-			}
+			m_state.assembly.append(solidity::Instruction::POP);
 			return;
 		}
 		else if (!m_identifierAccess(_variableName, m_state.assembly, CodeGenerator::IdentifierContext::LValue))
@@ -228,16 +248,16 @@ private:
 			);
 	}
 
-	void expectDeposit(int _deposit, int _oldHeight)
+	void expectDeposit(int _deposit, int _oldHeight, SourceLocation const& _location)
 	{
 		if (m_state.assembly.deposit() != _oldHeight + 1)
-			//@TODO location
 			m_state.addError(Error::Type::TypeError,
 				"Expected instruction(s) to deposit " +
 				boost::lexical_cast<string>(_deposit) +
 				" item(s) to the stack, but did deposit " +
 				boost::lexical_cast<string>(m_state.assembly.deposit() - _oldHeight) +
-				" item(s)."
+				" item(s).",
+				_location
 			);
 	}
 
@@ -248,7 +268,8 @@ private:
 bool assembly::CodeGenerator::typeCheck(assembly::CodeGenerator::IdentifierAccess const& _identifierAccess)
 {
 	size_t initialErrorLen = m_errors.size();
-	GeneratorState state(m_errors);
+	eth::Assembly assembly;
+	GeneratorState state(m_errors, assembly);
 	(LabelOrganizer(state))(m_parsedData);
 	(CodeTransform(state, _identifierAccess))(m_parsedData);
 	return m_errors.size() == initialErrorLen;
@@ -256,9 +277,17 @@ bool assembly::CodeGenerator::typeCheck(assembly::CodeGenerator::IdentifierAcces
 
 eth::Assembly assembly::CodeGenerator::assemble(assembly::CodeGenerator::IdentifierAccess const& _identifierAccess)
 {
-	GeneratorState state(m_errors);
+	eth::Assembly assembly;
+	GeneratorState state(m_errors, assembly);
+	(LabelOrganizer(state))(m_parsedData);
+	(CodeTransform(state, _identifierAccess))(m_parsedData);
+	return assembly;
+}
+
+void assembly::CodeGenerator::assemble(eth::Assembly& _assembly, assembly::CodeGenerator::IdentifierAccess const& _identifierAccess)
+{
+	GeneratorState state(m_errors, _assembly);
 	(LabelOrganizer(state))(m_parsedData);
 	(CodeTransform(state, _identifierAccess))(m_parsedData);
-	return state.assembly;
 }
 
diff --git a/libsolidity/inlineasm/AsmCodeGen.h b/libsolidity/inlineasm/AsmCodeGen.h
index f749ba50..b1fafe15 100644
--- a/libsolidity/inlineasm/AsmCodeGen.h
+++ b/libsolidity/inlineasm/AsmCodeGen.h
@@ -48,13 +48,15 @@ public:
 	/// If in rvalue context, the function is assumed to append instructions to
 	/// push the value of the identifier onto the stack. On error, the function should return false.
 	using IdentifierAccess = std::function<bool(assembly::Identifier const&, eth::Assembly&, IdentifierContext)>;
-	CodeGenerator( Block const& _parsedData, ErrorList& _errors):
+	CodeGenerator(Block const& _parsedData, ErrorList& _errors):
 		m_parsedData(_parsedData), m_errors(_errors) {}
 	/// Performs type checks and @returns false on error.
 	/// Actually runs the full code generation but discards the result.
 	bool typeCheck(IdentifierAccess const& _identifierAccess = IdentifierAccess());
 	/// Performs code generation and @returns the result.
 	eth::Assembly assemble(IdentifierAccess const& _identifierAccess = IdentifierAccess());
+	/// Performs code generation and appends generated to to _assembly.
+	void assemble(eth::Assembly& _assembly, IdentifierAccess const& _identifierAccess = IdentifierAccess());
 
 private:
 	Block const& m_parsedData;
diff --git a/libsolidity/inlineasm/AsmData.h b/libsolidity/inlineasm/AsmData.h
index 42f0ae31..d6abf67f 100644
--- a/libsolidity/inlineasm/AsmData.h
+++ b/libsolidity/inlineasm/AsmData.h
@@ -24,6 +24,7 @@
 
 #include <boost/variant.hpp>
 #include <libevmasm/Instruction.h>
+#include <libevmasm/SourceLocation.h>
 
 namespace dev
 {
@@ -35,29 +36,43 @@ namespace assembly
 /// What follows are the AST nodes for assembly.
 
 /// Direct EVM instruction (except PUSHi and JUMPDEST)
-struct Instruction { solidity::Instruction instruction; };
+struct Instruction { SourceLocation location; solidity::Instruction instruction; };
 /// Literal number or string (up to 32 bytes)
-struct Literal { bool isNumber; std::string value; };
+struct Literal { SourceLocation location; bool isNumber; std::string value; };
 /// External / internal identifier or label reference
-struct Identifier { std::string name; };
+struct Identifier { SourceLocation location; std::string name; };
 struct FunctionalInstruction;
 /// Jump label ("name:")
-struct Label { std::string name; };
+struct Label { SourceLocation location; std::string name; };
 /// Assignemnt (":= x", moves stack top into x, potentially multiple slots)
-struct Assignment { Identifier variableName; };
+struct Assignment { SourceLocation location; Identifier variableName; };
 struct FunctionalAssignment;
 struct VariableDeclaration;
 struct Block;
 using Statement = boost::variant<Instruction, Literal, Label, Assignment, Identifier, FunctionalAssignment, FunctionalInstruction, VariableDeclaration, Block>;
 /// Functional assignment ("x := mload(20)", expects push-1-expression on the right hand
 /// side and requires x to occupy exactly one stack slot.
-struct FunctionalAssignment { Identifier variableName; std::shared_ptr<Statement> value; };
+struct FunctionalAssignment { SourceLocation location; Identifier variableName; std::shared_ptr<Statement> value; };
 /// Functional instruction, e.g. "mul(mload(20), add(2, x))"
-struct FunctionalInstruction { Instruction instruction; std::vector<Statement> arguments; };
+struct FunctionalInstruction { SourceLocation location; Instruction instruction; std::vector<Statement> arguments; };
 /// Block-scope variable declaration ("let x := mload(20)"), non-hoisted
-struct VariableDeclaration { std::string name; std::shared_ptr<Statement> value; };
+struct VariableDeclaration { SourceLocation location; std::string name; std::shared_ptr<Statement> value; };
 /// Block that creates a scope (frees declared stack variables)
-struct Block { std::vector<Statement> statements; };
+struct Block { SourceLocation location; std::vector<Statement> statements; };
+
+struct LocationExtractor: boost::static_visitor<SourceLocation>
+{
+	template <class T> SourceLocation operator()(T const& _node) const
+	{
+		return _node.location;
+	}
+};
+
+/// Extracts the source location from an inline assembly node.
+template <class T> inline SourceLocation locationOf(T const& _node)
+{
+	return boost::apply_visitor(LocationExtractor(), _node);
+}
 
 }
 }
diff --git a/libsolidity/inlineasm/AsmParser.cpp b/libsolidity/inlineasm/AsmParser.cpp
index 33c8efa0..5c7163ee 100644
--- a/libsolidity/inlineasm/AsmParser.cpp
+++ b/libsolidity/inlineasm/AsmParser.cpp
@@ -35,7 +35,7 @@ shared_ptr<assembly::Block> Parser::parse(std::shared_ptr<Scanner> const& _scann
 	try
 	{
 		m_scanner = _scanner;
-		return make_shared<assembly::Block>(parseBlock());
+		return make_shared<Block>(parseBlock());
 	}
 	catch (FatalError const&)
 	{
@@ -47,10 +47,11 @@ shared_ptr<assembly::Block> Parser::parse(std::shared_ptr<Scanner> const& _scann
 
 assembly::Block Parser::parseBlock()
 {
+	assembly::Block block = createWithLocation<Block>();
 	expectToken(Token::LBrace);
-	Block block;
 	while (m_scanner->currentToken() != Token::RBrace)
 		block.statements.emplace_back(parseStatement());
+	block.location.end = endPosition();
 	m_scanner->next();
 	return block;
 }
@@ -65,11 +66,14 @@ assembly::Statement Parser::parseStatement()
 		return parseBlock();
 	case Token::Assign:
 	{
+		assembly::Assignment assignment = createWithLocation<assembly::Assignment>();
 		m_scanner->next();
 		expectToken(Token::Colon);
-		string name = m_scanner->currentLiteral();
+		assignment.variableName.location = location();
+		assignment.variableName.name = m_scanner->currentLiteral();
+		assignment.location.end = endPosition();
 		expectToken(Token::Identifier);
-		return assembly::Assignment{assembly::Identifier{name}};
+		return assignment;
 	}
 	case Token::Return: // opcode
 	case Token::Byte: // opcode
@@ -84,24 +88,30 @@ assembly::Statement Parser::parseStatement()
 	switch (m_scanner->currentToken())
 	{
 	case Token::LParen:
-		return parseFunctionalInstruction(statement);
+		return parseFunctionalInstruction(std::move(statement));
 	case Token::Colon:
 	{
 		if (statement.type() != typeid(assembly::Identifier))
 			fatalParserError("Label name / variable name must precede \":\".");
-		string const& name = boost::get<assembly::Identifier>(statement).name;
+		assembly::Identifier const& identifier = boost::get<assembly::Identifier>(statement);
 		m_scanner->next();
 		if (m_scanner->currentToken() == Token::Assign)
 		{
 			// functional assignment
+			FunctionalAssignment funAss = createWithLocation<FunctionalAssignment>(identifier.location);
 			m_scanner->next();
-			unique_ptr<Statement> value;
-			value.reset(new Statement(parseExpression()));
-			return FunctionalAssignment{{std::move(name)}, std::move(value)};
+			funAss.variableName = identifier;
+			funAss.value.reset(new Statement(parseExpression()));
+			funAss.location.end = locationOf(*funAss.value).end;
+			return funAss;
 		}
 		else
+		{
 			// label
-			return Label{name};
+			Label label = createWithLocation<Label>(identifier.location);
+			label.name = identifier.name;
+			return label;
+		}
 	}
 	default:
 		break;
@@ -113,7 +123,7 @@ assembly::Statement Parser::parseExpression()
 {
 	Statement operation = parseElementaryOperation(true);
 	if (m_scanner->currentToken() == Token::LParen)
-		return parseFunctionalInstruction(operation);
+		return parseFunctionalInstruction(std::move(operation));
 	else
 		return operation;
 }
@@ -137,8 +147,7 @@ assembly::Statement Parser::parseElementaryOperation(bool _onlySinglePusher)
 			s_instructions[name] = instruction.second;
 		}
 
-	//@TODO track location
-
+	Statement ret;
 	switch (m_scanner->currentToken())
 	{
 	case Token::Identifier:
@@ -162,48 +171,50 @@ assembly::Statement Parser::parseElementaryOperation(bool _onlySinglePusher)
 				if (info.ret != 1)
 					fatalParserError("Instruction " + info.name + " not allowed in this context.");
 			}
-			m_scanner->next();
-			return Instruction{instr};
+			ret = Instruction{location(), instr};
 		}
 		else
-			m_scanner->next();
-			return Identifier{literal};
+			ret = Identifier{location(), literal};
 		break;
 	}
 	case Token::StringLiteral:
 	case Token::Number:
 	{
-		Literal literal{
+		ret = Literal{
+			location(),
 			m_scanner->currentToken() == Token::Number,
 			m_scanner->currentLiteral()
 		};
-		m_scanner->next();
-		return literal;
+		break;
 	}
 	default:
-		break;
+		fatalParserError("Expected elementary inline assembly operation.");
 	}
-	fatalParserError("Expected elementary inline assembly operation.");
-	return {};
+	m_scanner->next();
+	return ret;
 }
 
 assembly::VariableDeclaration Parser::parseVariableDeclaration()
 {
+	VariableDeclaration varDecl = createWithLocation<VariableDeclaration>();
 	expectToken(Token::Let);
-	string name = m_scanner->currentLiteral();
+	varDecl.name = m_scanner->currentLiteral();
 	expectToken(Token::Identifier);
 	expectToken(Token::Colon);
 	expectToken(Token::Assign);
-	unique_ptr<Statement> value;
-	value.reset(new Statement(parseExpression()));
-	return VariableDeclaration{name, std::move(value)};
+	varDecl.value.reset(new Statement(parseExpression()));
+	varDecl.location.end = locationOf(*varDecl.value).end;
+	return varDecl;
 }
 
-FunctionalInstruction Parser::parseFunctionalInstruction(assembly::Statement const& _instruction)
+FunctionalInstruction Parser::parseFunctionalInstruction(assembly::Statement&& _instruction)
 {
 	if (_instruction.type() != typeid(Instruction))
 		fatalParserError("Assembly instruction required in front of \"(\")");
-	solidity::Instruction instr = boost::get<solidity::assembly::Instruction>(_instruction).instruction;
+	FunctionalInstruction ret;
+	ret.instruction = std::move(boost::get<Instruction>(_instruction));
+	ret.location = ret.instruction.location;
+	solidity::Instruction instr = ret.instruction.instruction;
 	InstructionInfo instrInfo = instructionInfo(instr);
 	if (solidity::Instruction::DUP1 <= instr && instr <= solidity::Instruction::DUP16)
 		fatalParserError("DUPi instructions not allowed for functional notation");
@@ -211,14 +222,29 @@ FunctionalInstruction Parser::parseFunctionalInstruction(assembly::Statement con
 		fatalParserError("SWAPi instructions not allowed for functional notation");
 
 	expectToken(Token::LParen);
-	vector<Statement> arguments;
 	unsigned args = unsigned(instrInfo.args);
 	for (unsigned i = 0; i < args; ++i)
 	{
-		arguments.push_back(parseExpression());
+		ret.arguments.emplace_back(parseExpression());
 		if (i != args - 1)
-			expectToken(Token::Comma);
+		{
+			if (m_scanner->currentToken() != Token::Comma)
+				fatalParserError(string(
+					"Expected comma (" +
+					instrInfo.name +
+					" expects " +
+					boost::lexical_cast<string>(args) +
+					" arguments)"
+				));
+			else
+				m_scanner->next();
+		}
 	}
+	ret.location.end = endPosition();
+	if (m_scanner->currentToken() == Token::Comma)
+		fatalParserError(
+			string("Expected ')' (" + instrInfo.name + " expects " + boost::lexical_cast<string>(args) + " arguments)")
+		);
 	expectToken(Token::RParen);
-	return FunctionalInstruction{{instr}, std::move(arguments)};
+	return ret;
 }
diff --git a/libsolidity/inlineasm/AsmParser.h b/libsolidity/inlineasm/AsmParser.h
index b54da941..0a9d51d5 100644
--- a/libsolidity/inlineasm/AsmParser.h
+++ b/libsolidity/inlineasm/AsmParser.h
@@ -44,13 +44,29 @@ public:
 	std::shared_ptr<Block> parse(std::shared_ptr<Scanner> const& _scanner);
 
 protected:
+	/// Creates an inline assembly node with the given source location.
+	template <class T> T createWithLocation(SourceLocation const& _loc = SourceLocation())
+	{
+		T r;
+		r.location = _loc;
+		if (r.location.isEmpty())
+		{
+			r.location.start = position();
+			r.location.end = endPosition();
+		}
+		if (!r.location.sourceName)
+			r.location.sourceName = sourceName();
+		return r;
+	}
+	SourceLocation location() const { return SourceLocation(position(), endPosition(), sourceName()); }
+
 	Block parseBlock();
 	Statement parseStatement();
 	/// Parses a functional expression that has to push exactly one stack element
 	Statement parseExpression();
 	Statement parseElementaryOperation(bool _onlySinglePusher = false);
 	VariableDeclaration parseVariableDeclaration();
-	FunctionalInstruction parseFunctionalInstruction(Statement const& _instruction);
+	FunctionalInstruction parseFunctionalInstruction(Statement&& _instruction);
 };
 
 }
diff --git a/libsolidity/inlineasm/AsmStack.cpp b/libsolidity/inlineasm/AsmStack.cpp
index 22042ada..c891678b 100644
--- a/libsolidity/inlineasm/AsmStack.cpp
+++ b/libsolidity/inlineasm/AsmStack.cpp
@@ -34,14 +34,18 @@ using namespace dev::solidity::assembly;
 
 bool InlineAssemblyStack::parse(const std::shared_ptr<Scanner>& _scanner)
 {
+	m_parserResult = make_shared<Block>();
 	Parser parser(m_errors);
-	m_asmBlock = parser.parse(_scanner);
-	return !!m_asmBlock;
+	auto result = parser.parse(_scanner);
+	if (!result)
+		return false;
+	*m_parserResult = std::move(*result);
+	return true;
 }
 
 eth::Assembly InlineAssemblyStack::assemble()
 {
-	CodeGenerator codeGen(*m_asmBlock, m_errors);
+	CodeGenerator codeGen(*m_parserResult, m_errors);
 	return codeGen.assemble();
 }
 
diff --git a/libsolidity/inlineasm/AsmStack.h b/libsolidity/inlineasm/AsmStack.h
index 73ca9583..8a860e46 100644
--- a/libsolidity/inlineasm/AsmStack.h
+++ b/libsolidity/inlineasm/AsmStack.h
@@ -50,7 +50,7 @@ public:
 	ErrorList const& errors() const { return m_errors; }
 
 private:
-	std::shared_ptr<Block> m_asmBlock;
+	std::shared_ptr<Block> m_parserResult;
 	ErrorList m_errors;
 };
 
diff --git a/libsolidity/parsing/Token.cpp b/libsolidity/parsing/Token.cpp
index c73368e5..0ab97988 100644
--- a/libsolidity/parsing/Token.cpp
+++ b/libsolidity/parsing/Token.cpp
@@ -109,6 +109,7 @@ char const Token::m_tokenType[] =
 {
 	TOKEN_LIST(KT, KK)
 };
+
 int Token::parseSize(string::const_iterator _begin, string::const_iterator _end)
 {
 	try
@@ -121,6 +122,7 @@ int Token::parseSize(string::const_iterator _begin, string::const_iterator _end)
 		return -1;
 	}
 }
+
 tuple<Token::Value, unsigned int, unsigned int> Token::fromIdentifierOrKeyword(string const& _literal)
 {
 	auto positionM = find_if(_literal.begin(), _literal.end(), ::isdigit);
@@ -156,7 +158,7 @@ tuple<Token::Value, unsigned int, unsigned int> Token::fromIdentifierOrKeyword(s
 				int n = parseSize(positionX + 1, _literal.end());
 				if (
 					0 <= m && m <= 256 &&
-					0 <= n && n <= 256 &&
+					8 <= n && n <= 256 &&
 					m + n > 0 &&
 					m + n <= 256 &&
 					m % 8 == 0 &&
@@ -171,6 +173,7 @@ tuple<Token::Value, unsigned int, unsigned int> Token::fromIdentifierOrKeyword(s
 		}
 		return make_tuple(Token::Identifier, 0, 0);
 	}
+
 	return make_tuple(keywordByName(_literal), 0, 0);
 }
 Token::Value Token::keywordByName(string const& _name)
diff --git a/lllc/CMakeLists.txt b/lllc/CMakeLists.txt
index a897e663..5726fbd6 100644
--- a/lllc/CMakeLists.txt
+++ b/lllc/CMakeLists.txt
@@ -4,7 +4,7 @@ set(EXECUTABLE lllc)
 
 file(GLOB HEADERS "*.h")
 include_directories(BEFORE ..)
-add_executable(${EXECUTABLE} ${SRC_LIST} ${HEADERS})
+eth_simple_add_executable(${EXECUTABLE} ${SRC_LIST} ${HEADERS})
 
 eth_use(${EXECUTABLE} REQUIRED Solidity::lll Dev::buildinfo Solidity::evmasm)
 
diff --git a/solc/CMakeLists.txt b/solc/CMakeLists.txt
index 9a914af8..fa7e0bde 100644
--- a/solc/CMakeLists.txt
+++ b/solc/CMakeLists.txt
@@ -6,7 +6,7 @@ include_directories(BEFORE ..)
 set(EXECUTABLE solc)
 
 file(GLOB HEADERS "*.h")
-add_executable(${EXECUTABLE} ${SRC_LIST} ${HEADERS})
+eth_simple_add_executable(${EXECUTABLE} ${SRC_LIST} ${HEADERS})
 
 eth_use(${EXECUTABLE} REQUIRED Solidity::solidity)
 target_link_libraries(${EXECUTABLE} ${Boost_PROGRAM_OPTIONS_LIBRARIES})
diff --git a/solc/CommandLineInterface.cpp b/solc/CommandLineInterface.cpp
index 7f7655f2..21624b3b 100644
--- a/solc/CommandLineInterface.cpp
+++ b/solc/CommandLineInterface.cpp
@@ -22,6 +22,13 @@
  */
 #include "CommandLineInterface.h"
 
+#ifdef _WIN32 // windows
+	#include <io.h>
+	#define isatty _isatty
+	#define fileno _fileno
+#else // unix
+	#include <unistd.h>
+#endif
 #include <string>
 #include <iostream>
 #include <fstream>
@@ -478,7 +485,7 @@ Allowed options)",
 		return false;
 	}
 
-	if (m_args.count("help"))
+	if (m_args.count("help") || (isatty(fileno(stdin)) && _argc == 1))
 	{
 		cout << desc;
 		return false;
@@ -861,7 +868,7 @@ void CommandLineInterface::outputAssembly()
 		cout << endl << "======= " << src.first << " =======" << endl;
 		eth::Assembly assembly = m_assemblyStacks[src.first].assemble();
 		cout << assembly.assemble().toHex() << endl;
-		cout << assembly.out();
+		assembly.stream(cout, "", m_sourceCodes);
 	}
 }
 
diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt
index 28b9972e..9d958b16 100644
--- a/test/CMakeLists.txt
+++ b/test/CMakeLists.txt
@@ -42,7 +42,7 @@ endforeach(file)
 
 file(GLOB HEADERS "*.h")
 set(EXECUTABLE soltest)
-add_executable(${EXECUTABLE} ${SRC_LIST} ${HEADERS})
+eth_simple_add_executable(${EXECUTABLE} ${SRC_LIST} ${HEADERS})
 
 eth_use(${EXECUTABLE} REQUIRED Solidity::solidity Eth::ethereum Eth::ethcore)
 
diff --git a/test/libsolidity/SolidityEndToEndTest.cpp b/test/libsolidity/SolidityEndToEndTest.cpp
index f9d2ab2b..30ae5792 100644
--- a/test/libsolidity/SolidityEndToEndTest.cpp
+++ b/test/libsolidity/SolidityEndToEndTest.cpp
@@ -6595,6 +6595,25 @@ BOOST_AUTO_TEST_CASE(inline_assembly_jumps)
 	BOOST_CHECK(callContractFunction("f()", u256(7)) == encodeArgs(u256(34)));
 }
 
+BOOST_AUTO_TEST_CASE(inline_assembly_function_access)
+{
+	char const* sourceCode = R"(
+		contract C {
+			uint public x;
+			function g(uint y) { x = 2 * y; assembly { stop } }
+			function f(uint _x) {
+				assembly {
+					_x
+					jump(g)
+				}
+			}
+		}
+	)";
+	compileAndRun(sourceCode, 0, "C");
+	BOOST_CHECK(callContractFunction("f(uint256)", u256(5)) == encodeArgs());
+	BOOST_CHECK(callContractFunction("x()") == encodeArgs(u256(10)));
+}
+
 BOOST_AUTO_TEST_CASE(index_access_with_type_conversion)
 {
 	// Test for a bug where higher order bits cleanup was not done for array index access.
@@ -6631,6 +6650,147 @@ BOOST_AUTO_TEST_CASE(delete_on_array_of_structs)
 	// This code interprets x as an array length and thus will go out of gas.
 	// neither of the two should throw due to out-of-bounds access
 	BOOST_CHECK(callContractFunction("f()") == encodeArgs(true));
+
+}
+
+BOOST_AUTO_TEST_CASE(internal_library_function)
+{
+	// tests that internal library functions can be called from outside
+	// and retain the same memory context (i.e. are pulled into the caller's code)
+	char const* sourceCode = R"(
+		library L {
+			function f(uint[] _data) internal {
+				_data[3] = 2;
+			}
+		}
+		contract C {
+			function f() returns (uint) {
+				uint[] memory x = new uint[](7);
+				x[3] = 8;
+				L.f(x);
+				return x[3];
+			}
+		}
+	)";
+	// This has to work without linking, because everything will be inlined.
+	compileAndRun(sourceCode, 0, "C");
+	BOOST_CHECK(callContractFunction("f()") == encodeArgs(u256(2)));
+}
+
+BOOST_AUTO_TEST_CASE(internal_library_function_calling_private)
+{
+	// tests that internal library functions that are called from outside and that
+	// themselves call private functions are still able to (i.e. the private function
+	// also has to be pulled into the caller's code)
+	char const* sourceCode = R"(
+		library L {
+			function g(uint[] _data) private {
+				_data[3] = 2;
+			}
+			function f(uint[] _data) internal {
+				g(_data);
+			}
+		}
+		contract C {
+			function f() returns (uint) {
+				uint[] memory x = new uint[](7);
+				x[3] = 8;
+				L.f(x);
+				return x[3];
+			}
+		}
+	)";
+	// This has to work without linking, because everything will be inlined.
+	compileAndRun(sourceCode, 0, "C");
+	BOOST_CHECK(callContractFunction("f()") == encodeArgs(u256(2)));
+}
+
+BOOST_AUTO_TEST_CASE(internal_library_function_bound)
+{
+	char const* sourceCode = R"(
+		library L {
+			struct S { uint[] data; }
+			function f(S _s) internal {
+				_s.data[3] = 2;
+			}
+		}
+		contract C {
+			using L for L.S;
+			function f() returns (uint) {
+				L.S memory x;
+				x.data = new uint[](7);
+				x.data[3] = 8;
+				x.f();
+				return x.data[3];
+			}
+		}
+	)";
+	// This has to work without linking, because everything will be inlined.
+	compileAndRun(sourceCode, 0, "C");
+	BOOST_CHECK(callContractFunction("f()") == encodeArgs(u256(2)));
+}
+
+BOOST_AUTO_TEST_CASE(internal_library_function_return_var_size)
+{
+	char const* sourceCode = R"(
+		library L {
+			struct S { uint[] data; }
+			function f(S _s) internal returns (uint[]) {
+				_s.data[3] = 2;
+				return _s.data;
+			}
+		}
+		contract C {
+			using L for L.S;
+			function f() returns (uint) {
+				L.S memory x;
+				x.data = new uint[](7);
+				x.data[3] = 8;
+				return x.f()[3];
+			}
+		}
+	)";
+	// This has to work without linking, because everything will be inlined.
+	compileAndRun(sourceCode, 0, "C");
+	BOOST_CHECK(callContractFunction("f()") == encodeArgs(u256(2)));
+}
+
+BOOST_AUTO_TEST_CASE(iszero_bnot_correct)
+{
+	// A long time ago, some opcodes were renamed, which involved the opcodes
+	// "iszero" and "not".
+	char const* sourceCode = R"(
+		contract C {
+			function f() returns (bool) {
+				bytes32 x = 1;
+				assembly { x := not(x) }
+				if (x != ~bytes32(1)) return false;
+				assembly { x := iszero(x) }
+				if (x != bytes32(0)) return false;
+				return true;
+			}
+		}
+	)";
+	compileAndRun(sourceCode, 0, "C");
+	BOOST_CHECK(callContractFunction("f()") == encodeArgs(true));
+}
+
+BOOST_AUTO_TEST_CASE(cleanup_bytes_types)
+{
+	// Checks that bytesXX types are properly cleaned before they are compared.
+	char const* sourceCode = R"(
+		contract C {
+			function f(bytes2 a, uint16 x) returns (uint) {
+				if (a != "ab") return 1;
+				if (x != 0x0102) return 2;
+				if (bytes3(x) != 0x0102) return 3;
+				return 0;
+			}
+		}
+	)";
+	compileAndRun(sourceCode, 0, "C");
+	// We input longer data on purpose.
+	BOOST_CHECK(callContractFunction("f(bytes2,uint16)", string("abc"), u256(0x040102)) == encodeArgs(0));
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/test/libsolidity/SolidityExpressionCompiler.cpp b/test/libsolidity/SolidityExpressionCompiler.cpp
index 398ac24f..967b2907 100644
--- a/test/libsolidity/SolidityExpressionCompiler.cpp
+++ b/test/libsolidity/SolidityExpressionCompiler.cpp
@@ -267,10 +267,10 @@ BOOST_AUTO_TEST_CASE(comparison)
 							 "}\n";
 	bytes code = compileFirstExpression(sourceCode);
 
-	bytes expectation({byte(Instruction::PUSH1), 0x1,
+	bytes expectation({byte(Instruction::PUSH1), 0x1, byte(Instruction::ISZERO), byte(Instruction::ISZERO),
 					   byte(Instruction::PUSH2), 0x11, 0xaa,
 					   byte(Instruction::PUSH2), 0x10, 0xaa,
-					   byte(Instruction::LT),
+					   byte(Instruction::LT), byte(Instruction::ISZERO), byte(Instruction::ISZERO),
 					   byte(Instruction::EQ),
 					   byte(Instruction::ISZERO)});
 	BOOST_CHECK_EQUAL_COLLECTIONS(code.begin(), code.end(), expectation.begin(), expectation.end());
@@ -296,7 +296,8 @@ BOOST_AUTO_TEST_CASE(short_circuiting)
 					   byte(Instruction::EQ),
 					   byte(Instruction::ISZERO), // after this we have 9 != 2
 					   byte(Instruction::JUMPDEST),
-					   byte(Instruction::PUSH1), 0x1,
+					   byte(Instruction::ISZERO), byte(Instruction::ISZERO),
+					   byte(Instruction::PUSH1), 0x1, byte(Instruction::ISZERO), byte(Instruction::ISZERO),
 					   byte(Instruction::EQ),
 					   byte(Instruction::ISZERO)});
 	BOOST_CHECK_EQUAL_COLLECTIONS(code.begin(), code.end(), expectation.begin(), expectation.end());
diff --git a/test/libsolidity/SolidityNameAndTypeResolution.cpp b/test/libsolidity/SolidityNameAndTypeResolution.cpp
index b6e21d0f..52e0bf58 100644
--- a/test/libsolidity/SolidityNameAndTypeResolution.cpp
+++ b/test/libsolidity/SolidityNameAndTypeResolution.cpp
@@ -97,13 +97,20 @@ parseAnalyseAndReturnError(string const& _source, bool _reportWarnings = false)
 				return make_pair(sourceUnit, std::make_shared<Error::Type const>(currentError->type()));
 		}
 	}
+	catch (InternalCompilerError const& _e)
+	{
+		string message("Internal compiler error");
+		if (string const* description = boost::get_error_info<errinfo_comment>(_e))
+			message += ": " + *description;
+		BOOST_FAIL(message);
+	}
 	catch (Error const& _e)
 	{
 		return make_pair(sourceUnit, std::make_shared<Error::Type const>(_e.type()));
 	}
-	catch (Exception const& /*_exception*/)
+	catch (...)
 	{
-		return make_pair(sourceUnit, nullptr);
+		BOOST_FAIL("Unexpected exception.");
 	}
 	return make_pair(sourceUnit, nullptr);
 }
@@ -1330,15 +1337,6 @@ BOOST_AUTO_TEST_CASE(overflow_caused_by_ether_units)
 	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
 }
 
-BOOST_AUTO_TEST_CASE(exp_operator_negative_exponent)
-{
-	char const* sourceCode = R"(
-		contract test {
-			function f() returns(uint d) { return 2 ** -3; }
-		})";
-	BOOST_CHECK(expectError(sourceCode) == Error::Type::TypeError);
-}
-
 BOOST_AUTO_TEST_CASE(exp_operator_exponent_too_big)
 {
 	char const* sourceCode = R"(
@@ -2229,18 +2227,6 @@ BOOST_AUTO_TEST_CASE(literal_strings)
 	BOOST_CHECK(success(text));
 }
 
-BOOST_AUTO_TEST_CASE(invalid_integer_literal_fraction)
-{
-	char const* text = R"(
-		contract Foo {
-			function f() {
-				var x = 1.20;
-			}
-		}
-	)";
-	BOOST_CHECK(expectError(text) == Error::Type::TypeError);
-}
-
 BOOST_AUTO_TEST_CASE(invalid_integer_literal_exp)
 {
 	char const* text = R"(
@@ -2323,12 +2309,11 @@ BOOST_AUTO_TEST_CASE(call_to_library_function)
 {
 	char const* text = R"(
 		library Lib {
-			uint constant public pimil = 3141592;
 			function min(uint x, uint y) returns (uint);
 		}
 		contract Test {
 			function f() {
-				uint t = Lib.min(Lib.pimil(), 7);
+				uint t = Lib.min(12, 7);
 			}
 		}
 	)";
@@ -2793,8 +2778,8 @@ BOOST_AUTO_TEST_CASE(inline_array_declaration_and_passing_implicit_conversion)
 					uint8 x = 7;
 					uint16 y = 8;
 					uint32 z = 9;
-					uint32[3] memory ending = [x, y, z]; 
-					return (ending[1]);                   
+					uint32[3] memory ending = [x, y, z];
+					return (ending[1]);
 				}
 			}
 	)";
@@ -3231,26 +3216,57 @@ BOOST_AUTO_TEST_CASE(int10abc_is_identifier)
 	BOOST_CHECK(success(text));
 }
 
-BOOST_AUTO_TEST_CASE(invalid_fixed_types)
+BOOST_AUTO_TEST_CASE(library_functions_do_not_have_value)
 {
 	char const* text = R"(
+		library L { function l() {} }
 		contract test {
 			function f() {
-				fixed0x7 a = .3;
-				fixed99999999999999999999999999999999999999x7 b = 9.5;
+				L.l.value;
 			}
 		}
 	)";
 	BOOST_CHECK(!success(text));
 }
 
-BOOST_AUTO_TEST_CASE(library_functions_do_not_have_value)
+BOOST_AUTO_TEST_CASE(invalid_fixed_types_0x7_mxn)
+{
+	char const* text = R"(
+		contract test {
+			fixed0x7 a = .3;
+		}
+	)";
+	BOOST_CHECK(!success(text));
+}
+
+BOOST_AUTO_TEST_CASE(invalid_fixed_types_long_invalid_identifier)
+{
+	char const* text = R"(
+		contract test {
+			fixed99999999999999999999999999999999999999x7 b = 9.5;
+		}
+	)";
+	BOOST_CHECK(!success(text));
+}
+
+BOOST_AUTO_TEST_CASE(invalid_fixed_types_7x8_mxn)
+{
+	char const* text = R"(
+		contract test {
+			fixed7x8 c = 3.12345678;
+		}
+	)";
+	BOOST_CHECK(!success(text));
+}
+
+BOOST_AUTO_TEST_CASE(library_instances_cannot_be_used)
 {
 	char const* text = R"(
 		library L { function l() {} }
 		contract test {
 			function f() {
-				L.l.value;
+				L x;
+				x.l();
 			}
 		}
 	)";
@@ -3269,6 +3285,454 @@ BOOST_AUTO_TEST_CASE(invalid_fixed_type_long)
 	BOOST_CHECK(!success(text));
 }
 
+BOOST_AUTO_TEST_CASE(fixed_type_int_conversion)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				uint128 a = 3;
+				int128 b = 4;
+				fixed c = b;
+				ufixed d = a;
+			}
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(fixed_type_rational_int_conversion)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				fixed c = 3;
+				ufixed d = 4;
+			}
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(fixed_type_rational_fraction_conversion)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				fixed a = 4.5;
+				ufixed d = 2.5;
+			}
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(invalid_int_implicit_conversion_from_fixed)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				fixed a = 4.5;
+				int b = a;
+			}
+		}
+	)";
+	BOOST_CHECK(!success(text));
+}
+
+BOOST_AUTO_TEST_CASE(rational_unary_operation)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				ufixed8x16 a = +3.25;
+				fixed8x16 b = -3.25;
+			}
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(leading_zero_rationals_convert)
+{
+	char const* text = R"(
+		contract A {
+			function f() {
+				ufixed0x8 a = 0.5;
+				ufixed0x56 b = 0.0000000000000006661338147750939242541790008544921875;
+				fixed0x8 c = -0.5;
+				fixed0x56 d = -0.0000000000000006661338147750939242541790008544921875;
+			}
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(size_capabilities_of_fixed_point_types)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				ufixed248x8 a = 123456781234567979695948382928485849359686494864095409282048094275023098123.5;
+				ufixed0x256 b = 0.920890746623327805482905058466021565416131529487595827354393978494366605267637829135688384325135165352082715782143655824815685807141335814463015972119819459298455224338812271036061391763384038070334798471324635050876128428143374549108557403087615966796875;
+				ufixed0x256 c = 0.0000000000015198847363997979984922685411315294875958273543939784943666052676464653042434787697605517039455161817147718251801220885263595179331845639229818863564267318422845592626219390573301877339317935702714669975697814319204326238832436501979827880859375;
+				fixed248x8 d = -123456781234567979695948382928485849359686494864095409282048094275023098123.5;
+				fixed0x256 e = -0.93322335481643744342575580035176794825198893968114429702091846411734101080123092162893656820177312738451291806995868682861328125;
+				fixed0x256 g = -0.00011788606643744342575580035176794825198893968114429702091846411734101080123092162893656820177312738451291806995868682861328125;
+			}
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(fixed_type_invalid_implicit_conversion_size)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				ufixed a = 11/4;
+				ufixed248x8 b = a;
+			}
+		}
+	)";
+	BOOST_CHECK(!success(text));
+}
+
+BOOST_AUTO_TEST_CASE(fixed_type_invalid_implicit_conversion_lost_data)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				ufixed0x256 a = 1/3;
+			}
+		}
+	)";
+	BOOST_CHECK(!success(text));
+}
+
+BOOST_AUTO_TEST_CASE(fixed_type_valid_explicit_conversions)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				ufixed0x256 a = ufixed0x256(1/3);
+				ufixed0x248 b = ufixed0x248(1/3);
+				ufixed0x8 c = ufixed0x8(1/3);
+			}
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(invalid_array_declaration_with_rational)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				uint[3.5] a;
+			}
+		}
+	)";
+	BOOST_CHECK(!success(text));
+}
+
+BOOST_AUTO_TEST_CASE(invalid_array_declaration_with_fixed_type)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				uint[fixed(3.5)] a;
+			}
+		}
+	)";
+	BOOST_CHECK(!success(text));
+}
+
+BOOST_AUTO_TEST_CASE(rational_to_bytes_implicit_conversion)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				bytes32 c = 3.2;
+			}
+		}
+	)";
+	BOOST_CHECK(!success(text));
+}
+
+BOOST_AUTO_TEST_CASE(fixed_to_bytes_implicit_conversion)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				fixed a = 3.2;
+				bytes32 c = a;
+			}
+		}
+	)";
+	BOOST_CHECK(!success(text));
+}
+
+BOOST_AUTO_TEST_CASE(mapping_with_fixed_literal)
+{
+	char const* text = R"(
+		contract test {
+			mapping(ufixed8x248 => string) fixedString;
+			function f() {
+				fixedString[0.5] = "Half";
+			}
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(fixed_points_inside_structs)
+{
+	char const* text = R"(
+		contract test {
+			struct myStruct {
+				ufixed a;
+				int b;
+			}
+			myStruct a = myStruct(3.125, 3);
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(inline_array_fixed_types)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				fixed[3] memory a = [fixed(3.5), fixed(-4.25), fixed(967.125)];
+			}
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(inline_array_rationals)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				ufixed8x8[4] memory a = [3.5, 4.125, 2.5, 4.0];
+			}
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(rational_index_access)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				uint[] memory a;
+				a[.5];
+			}
+		}
+	)";
+	BOOST_CHECK(!success(text));
+}
+
+BOOST_AUTO_TEST_CASE(rational_to_fixed_literal_expression)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				ufixed8x8 a = 3.5 * 3;
+				ufixed8x8 b = 4 - 2.5;
+				ufixed8x8 c = 11 / 4;
+				ufixed16x240 d = 599 + 0.21875;
+				ufixed8x248 e = ufixed8x248(35.245 % 12.9);
+				ufixed8x248 f = ufixed8x248(1.2 % 2);
+				fixed g = 2 ** -2;
+			}
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(rational_as_exponent_value)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				fixed g = 2 ** -2.2;
+				ufixed b = 3 ** 2.5;
+				ufixed24x24 b = 2 ** (1/2);
+				fixed40x40 c = 42 ** (-1/4);
+			}
+		}
+	)";
+	BOOST_CHECK(!success(text));
+}
+
+BOOST_AUTO_TEST_CASE(fixed_point_casting_exponents)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				ufixed a = 3 ** ufixed(1.5);
+				ufixed b = 2 ** ufixed(1/2);
+				fixed c = 42 ** fixed(-1/4);
+				fixed d = 16 ** fixed(-0.33);
+			}
+		}
+	)";
+	BOOST_CHECK(!success(text));
+}
+
+BOOST_AUTO_TEST_CASE(var_capable_of_holding_constant_rationals)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				var a = 0.12345678;
+				var b = 12345678.352;
+				var c = 0.00000009;
+			}
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(var_and_rational_with_tuple)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				var (a, b) = (.5, 1/3);
+			}
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(var_handle_divided_integers)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				var x = 1/3;
+			}
+		}
+	)";
+	BOOST_CHECK(success(text));	
+}
+
+BOOST_AUTO_TEST_CASE(rational_bitnot_unary_operation)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				fixed a = ~3.56;
+			}
+		}
+	)";
+	BOOST_CHECK(!success(text));
+}
+
+BOOST_AUTO_TEST_CASE(rational_bitor_binary_operation)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				fixed a = 1.56 | 3;
+			}
+		}
+	)";
+	BOOST_CHECK(!success(text));
+}
+
+BOOST_AUTO_TEST_CASE(rational_bitxor_binary_operation)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				fixed a = 1.56 ^ 3;
+			}
+		}
+	)";
+	BOOST_CHECK(!success(text));
+}
+
+BOOST_AUTO_TEST_CASE(rational_bitand_binary_operation)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				fixed a = 1.56 & 3;
+			}
+		}
+	)";
+	BOOST_CHECK(!success(text));
+}
+
+BOOST_AUTO_TEST_CASE(zero_handling)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				fixed8x8 a = 0;
+				ufixed8x8 b = 0;
+			}
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(missing_bool_conversion)
+{
+	char const* text = R"(
+		contract test {
+			function b(uint a) {
+				bool(a == 1);
+			}
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(integer_and_fixed_interaction)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				ufixed a = uint128(1) + ufixed(2);
+			}
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(signed_rational_modulus)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				fixed a = 0.42578125 % -0.4271087646484375;
+				fixed b = .5 % a;
+				fixed c = a % b;
+			}
+		}
+	)";
+	BOOST_CHECK(success(text));
+}
+
+BOOST_AUTO_TEST_CASE(one_divided_by_three_integer_conversion)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				uint a = 1/3;
+			}
+		}
+	)";
+	BOOST_CHECK(!success(text));
+}
+
 BOOST_AUTO_TEST_SUITE_END()
 
 }
diff --git a/test/libsolidity/SolidityParser.cpp b/test/libsolidity/SolidityParser.cpp
index e43b026c..909d18c9 100644
--- a/test/libsolidity/SolidityParser.cpp
+++ b/test/libsolidity/SolidityParser.cpp
@@ -1177,6 +1177,52 @@ BOOST_AUTO_TEST_CASE(conditional_with_assignment)
 	BOOST_CHECK(successParse(text));
 }
 
+BOOST_AUTO_TEST_CASE(declaring_fixed_and_ufixed_variables)
+{
+	char const* text = R"(
+		contract A {
+			fixed40x40 storeMe;
+			function f(ufixed x, fixed32x32 y) {
+				ufixed8x8 a;
+				fixed b;
+			}
+		}
+	)";
+	BOOST_CHECK(successParse(text));
+}
+
+BOOST_AUTO_TEST_CASE(declaring_fixed_literal_variables)
+{
+	char const* text = R"(
+		contract A {
+			fixed40x40 pi = 3.14;
+		}
+	)";
+	BOOST_CHECK(successParse(text));
+}
+
+BOOST_AUTO_TEST_CASE(no_double_radix_in_fixed_literal)
+{
+	char const* text = R"(
+		contract A {
+			fixed40x40 pi = 3.14.15;
+		}
+	)";
+	BOOST_CHECK(!successParse(text));
+}
+
+BOOST_AUTO_TEST_CASE(invalid_fixed_conversion_leading_zeroes_check)
+{
+	char const* text = R"(
+		contract test {
+			function f() {
+				fixed a = 1.0x2;
+			}
+		}
+	)";
+	BOOST_CHECK(!successParse(text));
+}
+
 BOOST_AUTO_TEST_SUITE_END()
 
 }
